deepseek_prompt,deepseek_contract,deepseek_file_name
"Create a smart contract that builds upon the WETHOmnibridgeRouter contract by adding features for account registration, token wrapping, and relay. The contract should integrate with the Omnibridge and WETH contracts. Include methods for registering and wrapping tokens, as well as functionality for relaying tokens to specific recipients. The contract should emit events upon successful token wrapping and relaying. Consider implementing  error handling and validation checks for user input.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IWETH {
    function deposit() external payable;
    function transfer(address to, uint value) external returns (bool);
    function withdraw(uint) external;
}

interface IOmnibridge {
    function relayTokens(address token, address _receiver, uint256 _value) external;
}

contract WETHOmnibridgeRouter {
    IWETH public immutable weth;
    IOmnibridge public immutable omnibridge;

    event TokenWrapped(address indexed user, uint256 amount);
    event TokenRelayed(address indexed user, address indexed receiver, uint256 amount);

    mapping(address => bool) public registeredAccounts;

    constructor(address _weth, address _omnibridge) {
        weth = IWETH(_weth);
        omnibridge = IOmnibridge(_omnibridge);
    }

    modifier onlyRegistered() {
        require(registeredAccounts[msg.sender], ""Account not registered"");
        _;
    }

    function registerAccount() external {
        registeredAccounts[msg.sender] = true;
    }

    function wrapTokens() external payable onlyRegistered {
        require(msg.value > 0, ""Amount must be greater than 0"");
        weth.deposit{value: msg.value}();
        emit TokenWrapped(msg.sender, msg.value);
    }

    function relayTokens(address token, address receiver, uint256 amount) external onlyRegistered {
        require(amount > 0, ""Amount must be greater than 0"");
        require(receiver != address(0), ""Invalid receiver address"");

        if (token == address(weth)) {
            weth.transfer(address(this), amount);
            weth.withdraw(amount);
        }

        omnibridge.relayTokens(token, receiver, amount);
        emit TokenRelayed(msg.sender, receiver, amount);
    }

    receive() external payable {
        // Allow deposits of ETH
    }
}",contract_1.sol
"Create a smart contract for a BlindAuctionMarketplace that allows users to create auctions with various settings. Include features for users to make offers, fill orders, and withdraw funds. Provide functions for setting auction minimum price limits, required termination periods, and maximum price percentages. The contract should have specific events for auction settlement, withdrawal, and failed transfers. Allow contract owners to update settings and control the salvorSigner and pause state.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract BlindAuctionMarketplace {
    address public owner;
    address public salvorSigner;
    bool public paused;

    struct Auction {
        address seller;
        uint256 minPrice;
        uint256 maxPrice;
        uint256 terminationPeriod;
        bool settled;
        mapping(address => uint256) offers;
    }

    mapping(uint256 => Auction) public auctions;
    uint256 public auctionCount;

    event AuctionCreated(uint256 indexed auctionId, address indexed seller, uint256 minPrice, uint256 maxPrice, uint256 terminationPeriod);
    event OfferMade(uint256 indexed auctionId, address indexed bidder, uint256 amount);
    event AuctionSettled(uint256 indexed auctionId, address indexed winner, uint256 amount);
    event FundsWithdrawn(address indexed user, uint256 amount);
    event TransferFailed(address indexed from, address indexed to, uint256 amount);
    event SettingsUpdated(address indexed newSalvorSigner, bool newPausedState);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    constructor() {
        owner = msg.sender;
        salvorSigner = msg.sender;
        paused = false;
    }

    function createAuction(uint256 _minPrice, uint256 _maxPrice, uint256 _terminationPeriod) external whenNotPaused {
        require(_minPrice < _maxPrice, ""Min price must be less than max price"");
        require(_terminationPeriod > 0, ""Termination period must be greater than 0"");

        uint256 auctionId = ++auctionCount;
        Auction storage auction = auctions[auctionId];
        auction.seller = msg.sender;
        auction.minPrice = _minPrice;
        auction.maxPrice = _maxPrice;
        auction.terminationPeriod = _terminationPeriod;
        auction.settled = false;

        emit AuctionCreated(auctionId, msg.sender, _minPrice, _maxPrice, _terminationPeriod);
    }

    function makeOffer(uint256 _auctionId, uint256 _amount) external payable whenNotPaused {
        Auction storage auction = auctions[_auctionId];
        require(!auction.settled, ""Auction is settled"");
        require(_amount >= auction.minPrice && _amount <= auction.maxPrice, ""Offer out of price range"");

        auction.offers[msg.sender] = _amount;
        emit OfferMade(_auctionId, msg.sender, _amount);
    }

    function settleAuction(uint256 _auctionId) external {
        Auction storage auction = auctions[_auctionId];
        require(!auction.settled, ""Auction is already settled"");
        require(block.timestamp >= auction.terminationPeriod, ""Auction termination period not reached"");

        address winner = address(0);
        uint256 highestOffer = 0;
        for (uint256 i = 0; i < auctionCount; i++) {
            if (auction.offers[address(i)] > highestOffer) {
                highestOffer = auction.offers[address(i)];
                winner = address(i);
            }
        }

        if (winner != address(0)) {
            auction.settled = true;
            (bool success, ) = auction.seller.call{value: highestOffer}("""");
            if (!success) {
                emit TransferFailed(winner, auction.seller, highestOffer);
            } else {
                emit AuctionSettled(_auctionId, winner, highestOffer);
            }
        }
    }

    function withdrawFunds(uint256 _amount) external {
        require(_amount <= address(this).balance, ""Insufficient contract balance"");
        (bool success, ) = msg.sender.call{value: _amount}("""");
        if (!success) {
            emit TransferFailed(address(this), msg.sender, _amount);
        } else {
            emit FundsWithdrawn(msg.sender, _amount);
        }
    }

    function updateSettings(address _newSalvorSigner, bool _newPausedState) external onlyOwner {
        salvorSigner = _newSalvorSigner;
        paused = _newPausedState;
        emit SettingsUpdated(_newSalvorSigner, _newPausedState);
    }

    receive() external payable {}
}",contract_2.sol
"Create a smart contract that allows for basic withdraw and deposit functionality, token transfer/approval, and proportional distribution when new underlying tokens are minted to vault. The contract should include functions that perform the following: set approvers for specific tokens, initialize Lever, set JoeRouter, Aave, and Aave V3 addresses, and have test functions for vanilla Joe swap fork, vanilla JLP in fork, and vanilla JLP in out fork.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Vault {
    address public owner;
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowances;
    address[] public approvers;
    address public joeRouter;
    address public aave;
    address public aaveV3;

    event Deposit(address indexed user, uint256 amount);
    event Withdraw(address indexed user, uint256 amount);
    event Transfer(address indexed from, address indexed to, uint256 amount);
    event Approval(address indexed owner, address indexed spender, uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function deposit() public payable {
        balances[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }

    function withdraw(uint256 amount) public {
        require(balances[msg.sender] >= amount, ""Insufficient balance"");
        balances[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);
        emit Withdraw(msg.sender, amount);
    }

    function transfer(address to, uint256 amount) public {
        require(balances[msg.sender] >= amount, ""Insufficient balance"");
        balances[msg.sender] -= amount;
        balances[to] += amount;
        emit Transfer(msg.sender, to, amount);
    }

    function approve(address spender, uint256 amount) public {
        allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
    }

    function transferFrom(address from, address to, uint256 amount) public {
        require(allowances[from][msg.sender] >= amount, ""Allowance exceeded"");
        require(balances[from] >= amount, ""Insufficient balance"");
        allowances[from][msg.sender] -= amount;
        balances[from] -= amount;
        balances[to] += amount;
        emit Transfer(from, to, amount);
    }

    function setApprovers(address[] memory _approvers) public onlyOwner {
        approvers = _approvers;
    }

    function initializeLever() public onlyOwner {
        // Initialization logic for Lever
    }

    function setJoeRouter(address _joeRouter) public onlyOwner {
        joeRouter = _joeRouter;
    }

    function setAave(address _aave) public onlyOwner {
        aave = _aave;
    }

    function setAaveV3(address _aaveV3) public onlyOwner {
        aaveV3 = _aaveV3;
    }

    function testVanillaJoeSwapFork() public {
        // Test logic for vanilla Joe swap fork
    }

    function testVanillaJLPInFork() public {
        // Test logic for vanilla JLP in fork
    }

    function testVanillaJLPInOutFork() public {
        // Test logic for vanilla JLP in out fork
    }
}",contract_3.sol
"Create a smart contract for managing decentralized autonomous organizations (DAOs) and embedded registries of EVM scripts. The contract should enable the deployment and management of DAOs, as well as the registration and management of EVM script registries. Include event emitters for tracking deployments and implement permission and access control mechanisms for DAOs and registries.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DAOFactory {
    struct DAO {
        address daoAddress;
        string name;
        bool active;
    }

    struct EVMScriptRegistry {
        address registryAddress;
        string description;
        bool active;
    }

    DAO[] public daos;
    EVMScriptRegistry[] public registries;
    mapping(address => bool) public isDAOAdmin;
    mapping(address => bool) public isRegistryAdmin;

    event DAOCreated(address indexed daoAddress, string name);
    event DAOActivated(address indexed daoAddress);
    event DAODeactivated(address indexed daoAddress);
    event EVMScriptRegistryCreated(address indexed registryAddress, string description);
    event EVMScriptRegistryActivated(address indexed registryAddress);
    event EVMScriptRegistryDeactivated(address indexed registryAddress);

    modifier onlyDAOAdmin() {
        require(isDAOAdmin[msg.sender], ""Not a DAO admin"");
        _;
    }

    modifier onlyRegistryAdmin() {
        require(isRegistryAdmin[msg.sender], ""Not a Registry admin"");
        _;
    }

    constructor() {
        isDAOAdmin[msg.sender] = true;
        isRegistryAdmin[msg.sender] = true;
    }

    function createDAO(address _daoAddress, string memory _name) public onlyDAOAdmin {
        daos.push(DAO(_daoAddress, _name, true));
        emit DAOCreated(_daoAddress, _name);
    }

    function activateDAO(address _daoAddress) public onlyDAOAdmin {
        for (uint i = 0; i < daos.length; i++) {
            if (daos[i].daoAddress == _daoAddress) {
                daos[i].active = true;
                emit DAOActivated(_daoAddress);
                break;
            }
        }
    }

    function deactivateDAO(address _daoAddress) public onlyDAOAdmin {
        for (uint i = 0; i < daos.length; i++) {
            if (daos[i].daoAddress == _daoAddress) {
                daos[i].active = false;
                emit DAODeactivated(_daoAddress);
                break;
            }
        }
    }

    function createEVMScriptRegistry(address _registryAddress, string memory _description) public onlyRegistryAdmin {
        registries.push(EVMScriptRegistry(_registryAddress, _description, true));
        emit EVMScriptRegistryCreated(_registryAddress, _description);
    }

    function activateEVMScriptRegistry(address _registryAddress) public onlyRegistryAdmin {
        for (uint i = 0; i < registries.length; i++) {
            if (registries[i].registryAddress == _registryAddress) {
                registries[i].active = true;
                emit EVMScriptRegistryActivated(_registryAddress);
                break;
            }
        }
    }

    function deactivateEVMScriptRegistry(address _registryAddress) public onlyRegistryAdmin {
        for (uint i = 0; i < registries.length; i++) {
            if (registries[i].registryAddress == _registryAddress) {
                registries[i].active = false;
                emit EVMScriptRegistryDeactivated(_registryAddress);
                break;
            }
        }
    }

    function addDAOAdmin(address _admin) public onlyDAOAdmin {
        isDAOAdmin[_admin] = true;
    }

    function removeDAOAdmin(address _admin) public onlyDAOAdmin {
        isDAOAdmin[_admin] = false;
    }

    function addRegistryAdmin(address _admin) public onlyRegistryAdmin {
        isRegistryAdmin[_admin] = true;
    }

    function removeRegistryAdmin(address _admin) public onlyRegistryAdmin {
        isRegistryAdmin[_admin] = false;
    }
}",contract_4.sol
"Create a smart contract that allows for a cryptocurrency crowdsale, mimicking the ARMOR token. This contract should have a constructor that sets the total token supply, allocating 90% for public sale and 10% for the owner. Implement a function to accept Ether, approve token ownership, and transfer tokens. Include decimal precision for the token. Lastly, add features for withdrawing funds and killing the contract.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ArmorTokenCrowdsale {
    string public name = ""Armor Token"";
    string public symbol = ""ARMOR"";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    address public owner;
    uint256 public publicSaleAllocation;
    uint256 public ownerAllocation;
    uint256 public tokensSold;
    bool public isActive = true;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event TokensPurchased(address indexed buyer, uint256 value);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier onlyWhenActive() {
        require(isActive, ""Contract is not active"");
        _;
    }

    constructor(uint256 _totalSupply) {
        totalSupply = _totalSupply;
        publicSaleAllocation = (_totalSupply * 90) / 100;
        ownerAllocation = (_totalSupply * 10) / 100;
        owner = msg.sender;
        balanceOf[owner] = ownerAllocation;
        emit Transfer(address(0), owner, ownerAllocation);
    }

    function buyTokens() public payable onlyWhenActive {
        require(msg.value > 0, ""Ether amount must be greater than 0"");
        uint256 tokensToBuy = msg.value * (publicSaleAllocation / address(this).balance);
        require(tokensSold + tokensToBuy <= publicSaleAllocation, ""Not enough tokens left for sale"");

        balanceOf[msg.sender] += tokensToBuy;
        tokensSold += tokensToBuy;
        emit TokensPurchased(msg.sender, tokensToBuy);
        emit Transfer(address(0), msg.sender, tokensToBuy);
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transfer(address to, uint256 amount) public returns (bool) {
        require(balanceOf[msg.sender] >= amount, ""Not enough balance"");
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        emit Transfer(msg.sender, to, amount);
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) public returns (bool) {
        require(balanceOf[from] >= amount, ""Not enough balance"");
        require(allowance[from][msg.sender] >= amount, ""Not enough allowance"");
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        allowance[from][msg.sender] -= amount;
        emit Transfer(from, to, amount);
        return true;
    }

    function withdrawFunds() public onlyOwner {
        payable(owner).transfer(address(this).balance);
    }

    function killContract() public onlyOwner {
        isActive = false;
        selfdestruct(payable(owner));
    }
}",contract_5.sol
"Design a smart contract that distributes tokens based on a time-vesting model with multiple claimable steps and a TGE event. The contract should allow users to claim tokens based on their proof of ownership and meet specific eligibility criteria. Incorporate a token, Merkle root, and TGE timestamp. Implement functions for checking and claiming tokens, utilizing import statements for OpenZeppelin libraries. Ensure events are triggered for claim, TGE, and step claim. The contract should have mappings for investors, categories, and claim states.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TokenVesting {
    // OpenZeppelin ERC20 contract implementation
    address public owner;
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply;
        balanceOf[msg.sender] = totalSupply;
        owner = msg.sender;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], ""Insufficient balance"");
        require(_value <= allowance[_from][msg.sender], ""Allowance exceeded"");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    // TokenVesting specific code
    bytes32 public merkleRoot;
    uint256 public tgeTimestamp;
    mapping(address => bool) public hasClaimed;
    mapping(address => uint256) public claimedAmount;
    mapping(uint256 => uint256) public stepTimestamps;
    mapping(uint256 => uint256) public stepAmounts;

    event TokensClaimed(address indexed user, uint256 amount);
    event TGEInitialized(uint256 timestamp);
    event StepClaimed(uint256 indexed step, uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    function initializeTGE(uint256 _tgeTimestamp, bytes32 _merkleRoot) public onlyOwner {
        tgeTimestamp = _tgeTimestamp;
        merkleRoot = _merkleRoot;
        emit TGEInitialized(_tgeTimestamp);
    }

    function setStep(uint256 step, uint256 timestamp, uint256 amount) public onlyOwner {
        stepTimestamps[step] = timestamp;
        stepAmounts[step] = amount;
    }

    function claimTokens(address user, uint256 amount, bytes32[] memory proof) public {
        require(!hasClaimed[user], ""Tokens already claimed"");
        require(verifyMerkleProof(user, amount, proof), ""Invalid proof"");

        hasClaimed[user] = true;
        claimedAmount[user] = amount;
        require(transfer(user, amount), ""Transfer failed"");

        emit TokensClaimed(user, amount);
    }

    function verifyMerkleProof(address user, uint256 amount, bytes32[] memory proof) internal view returns (bool) {
        bytes32 leaf = keccak256(abi.encodePacked(user, amount));
        return verify(merkleRoot, leaf, proof);
    }

    function verify(bytes32 root, bytes32 leaf, bytes32[] memory proof) internal pure returns (bool) {
        bytes32 computedHash = leaf;
        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];
            if (computedHash <= proofElement) {
                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));
            } else {
                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));
            }
        }
        return computedHash == root;
    }
}",contract_6.sol
"Create a smart contract that mirrors the behavior of the provided CAdapterTestHelper contract, focusing on simulating a Compound adapter with three adapters (cDAI, cETH, and cUSDC) and integrating with a token handler, divider, and address book. Include functions for setting contributor rewards, retrieving comp speeds, and interacting with the Compound oracle. Emphasize the importance of ensuring correct transfer of funds using SafeTransferLib. Keep an eye on backwards compatibility.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract CAdapterTestHelper {
    address public tokenHandler;
    address public divider;
    address public addressBook;

    mapping(address => uint256) public compSpeeds;
    address public cDAI;
    address public cETH;
    address public cUSDC;
    address public compoundOracle;

    constructor(
        address _tokenHandler,
        address _divider,
        address _addressBook,
        address _cDAI,
        address _cETH,
        address _cUSDC,
        address _compoundOracle
    ) {
        tokenHandler = _tokenHandler;
        divider = _divider;
        addressBook = _addressBook;
        cDAI = _cDAI;
        cETH = _cETH;
        cUSDC = _cUSDC;
        compoundOracle = _compoundOracle;
    }

    function setContributorRewards(address contributor, uint256 amount) external {
        require(msg.sender == addressBook, ""Only AddressBook can set rewards"");
        compSpeeds[contributor] = amount;
    }

    function getCompSpeed(address market) external view returns (uint256) {
        return compSpeeds[market];
    }

    function interactWithCompoundOracle(address asset) external view returns (uint256) {
        // Simulate interaction with Compound Oracle
        // This is a placeholder and should be replaced with actual logic
        return 1; // Placeholder return value
    }

    function safeTransfer(address token, address to, uint256 value) internal {
        // Simulate SafeTransferLib functionality
        // This is a placeholder and should be replaced with actual logic
        // Assuming ERC20 transfer function
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), ""Transfer failed"");
    }
}",contract_7.sol
"Create a smart contract that manages user deposits, calculates dividends, and handles fees. The contract should include functions for depositing, withdrawing, and transferring funds. Implement a mapping to store user information. Develop an event handler for withdrawing funds. Implement a calculation function for dividend distribution and inflation handling.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DepositManager {
    struct User {
        uint256 balance;
        uint256 lastDividendPoint;
    }

    mapping(address => User) public users;
    uint256 public totalSupply;
    uint256 public dividendPerToken;
    uint256 public constant FEE_RATE = 1; // 1% fee
    uint256 public inflationRate = 5; // 5% inflation per year

    event Deposit(address indexed user, uint256 amount);
    event Withdraw(address indexed user, uint256 amount);
    event Transfer(address indexed from, address indexed to, uint256 amount);

    function deposit(uint256 amount) external {
        require(amount > 0, ""Amount must be greater than 0"");
        User storage user = users[msg.sender];
        updateDividend(user);
        user.balance += amount;
        totalSupply += amount;
        emit Deposit(msg.sender, amount);
    }

    function withdraw(uint256 amount) external {
        require(amount > 0, ""Amount must be greater than 0"");
        User storage user = users[msg.sender];
        require(user.balance >= amount, ""Insufficient balance"");
        updateDividend(user);
        user.balance -= amount;
        totalSupply -= amount;
        uint256 fee = (amount * FEE_RATE) / 100;
        uint256 withdrawAmount = amount - fee;
        emit Withdraw(msg.sender, withdrawAmount);
        // Transfer funds to user
        (bool success, ) = msg.sender.call{value: withdrawAmount}("""");
        require(success, ""Transfer failed."");
    }

    function transfer(address to, uint256 amount) external {
        require(amount > 0, ""Amount must be greater than 0"");
        User storage sender = users[msg.sender];
        User storage recipient = users[to];
        require(sender.balance >= amount, ""Insufficient balance"");
        updateDividend(sender);
        updateDividend(recipient);
        sender.balance -= amount;
        recipient.balance += amount;
        emit Transfer(msg.sender, to, amount);
    }

    function updateDividend(User storage user) internal {
        uint256 newDividend = calculateDividend(user);
        user.lastDividendPoint = dividendPerToken;
        if (newDividend > 0) {
            user.balance += newDividend;
        }
    }

    function calculateDividend(User storage user) internal view returns (uint256) {
        uint256 totalDividend = (user.balance * (dividendPerToken - user.lastDividendPoint)) / 1e18;
        return totalDividend;
    }

    function distributeDividends() external {
        uint256 newDividends = (totalSupply * inflationRate) / 100;
        dividendPerToken += (newDividends * 1e18) / totalSupply;
    }
}",contract_8.sol
"Create a Solidity smart contract that manages the unwrapping of GM tokens. The contract should allow users to unwrap GM tokens after a specified interval. Include functions for unwrapping, setting/unsetting a flag for unlocking/unlocking GM token unwrapping, changing the GM token address, managing the user's unwrap timestamp, and calculating the maximum unwrapped amount. Consider implementing reentrancy protection and utilizing OpenZeppelin libraries. The contract should include mapping data structures and interfaces for addressing and uint256 calculations.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GMTokenUnwrapper {
    address public gmTokenAddress;
    bool public unwrapLocked;
    uint256 public unwrapInterval;

    mapping(address => uint256) public lastUnwrapTime;
    mapping(address => uint256) public unwrappedAmount;

    event Unwrapped(address indexed user, uint256 amount);
    event UnwrapLocked(bool status);
    event GMTokenAddressChanged(address newAddress);

    modifier whenUnwrapUnlocked() {
        require(!unwrapLocked, ""Unwrap is locked"");
        _;
    }

    modifier onlyOwner() {
        // Assuming owner is the deployer of the contract
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    address private owner;

    constructor(address _gmTokenAddress, uint256 _unwrapInterval) {
        gmTokenAddress = _gmTokenAddress;
        unwrapInterval = _unwrapInterval;
        owner = msg.sender;
    }

    function setUnwrapLocked(bool _status) external onlyOwner {
        unwrapLocked = _status;
        emit UnwrapLocked(_status);
    }

    function changeGMTokenAddress(address _newAddress) external onlyOwner {
        gmTokenAddress = _newAddress;
        emit GMTokenAddressChanged(_newAddress);
    }

    function unwrap(uint256 amount) external whenUnwrapUnlocked {
        require(canUnwrap(msg.sender), ""Unwrap interval not met"");
        require(amount <= maxUnwrapAmount(msg.sender), ""Exceeds max unwrap amount"");

        // Assuming transferFrom function exists in the GMToken contract
        require(IGMToken(gmTokenAddress).transferFrom(msg.sender, address(this), amount), ""Transfer failed"");

        unwrappedAmount[msg.sender] += amount;
        lastUnwrapTime[msg.sender] = block.timestamp;

        emit Unwrapped(msg.sender, amount);
    }

    function canUnwrap(address user) public view returns (bool) {
        return block.timestamp >= lastUnwrapTime[user] + unwrapInterval;
    }

    function maxUnwrapAmount(address user) public view returns (uint256) {
        // Placeholder logic for maximum unwrap amount calculation
        // This should be replaced with actual logic based on the token's economics
        return IGMToken(gmTokenAddress).balanceOf(user);
    }
}

interface IGMToken {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}",contract_9.sol
"Create a smart contract that safely manages token balances and transfer, implementing ReentrancyGuard and Ownable contracts from OpenZeppelin. Include deposit, withdraw, and balance functions, considering timestamp-based unlocking. Make sure the contract is compatible with Solidity 0.8.0.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SafeTokenManager {
    mapping(address => uint256) private _balances;
    mapping(address => uint256) private _lockTimestamps;
    address private _owner;

    modifier onlyOwner() {
        require(msg.sender == _owner, ""Ownable: caller is not the owner"");
        _;
    }

    modifier nonReentrant() {
        require(_lockTimestamps[msg.sender] <= block.timestamp, ""ReentrancyGuard: reentrant call"");
        _lockTimestamps[msg.sender] = block.timestamp + 1;
        _;
        _lockTimestamps[msg.sender] = block.timestamp;
    }

    constructor() {
        _owner = msg.sender;
    }

    function deposit(uint256 amount) external nonReentrant {
        _balances[msg.sender] += amount;
    }

    function withdraw(uint256 amount) external nonReentrant {
        require(_balances[msg.sender] >= amount, ""SafeTokenManager: insufficient balance"");
        _balances[msg.sender] -= amount;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _owner = newOwner;
    }

    function owner() external view returns (address) {
        return _owner;
    }
}",contract_10.sol
"Create a smart contract that manages collateral and liquidation for options market. The contract should include functionality for sending quote and base collateral, liquidating positions, and settling options. Implement interfaces for OpenZeppelin's ERC20 and interfaces for synthetix adapter, option market, and option token. Include initialization functions for setting up the contract's variables.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface ISynthetixAdapter {
    function getPrice(address asset) external view returns (uint256);
}

interface IOptionMarket {
    function buyOption(address buyer, uint256 optionId, uint256 amount) external returns (bool);
    function sellOption(address seller, uint256 optionId, uint256 amount) external returns (bool);
}

interface IOptionToken {
    function mint(address to, uint256 amount) external returns (bool);
    function burn(address from, uint256 amount) external returns (bool);
}

contract OptionsMarketCollateralManager {
    IERC20 public baseCollateralToken;
    IERC20 public quoteCollateralToken;
    ISynthetixAdapter public synthetixAdapter;
    IOptionMarket public optionMarket;
    IOptionToken public optionToken;

    constructor(
        address _baseCollateralToken,
        address _quoteCollateralToken,
        address _synthetixAdapter,
        address _optionMarket,
        address _optionToken
    ) {
        baseCollateralToken = IERC20(_baseCollateralToken);
        quoteCollateralToken = IERC20(_quoteCollateralToken);
        synthetixAdapter = ISynthetixAdapter(_synthetixAdapter);
        optionMarket = IOptionMarket(_optionMarket);
        optionToken = IOptionToken(_optionToken);
    }

    function sendQuoteCollateral(address recipient, uint256 amount) external {
        require(quoteCollateralToken.transferFrom(msg.sender, recipient, amount), ""Transfer failed"");
    }

    function sendBaseCollateral(address recipient, uint256 amount) external {
        require(baseCollateralToken.transferFrom(msg.sender, recipient, amount), ""Transfer failed"");
    }

    function liquidatePosition(address positionOwner, uint256 optionId, uint256 amount) external {
        uint256 currentPrice = synthetixAdapter.getPrice(address(baseCollateralToken));
        // Logic to determine if liquidation is necessary based on currentPrice and option conditions
        // If liquidation is necessary, proceed with liquidation process
        require(optionToken.burn(positionOwner, amount), ""Burn failed"");
        // Additional logic for handling collateral and notifying the option market
    }

    function settleOption(address optionOwner, uint256 optionId, uint256 amount) external {
        // Logic to settle the option, which might involve transferring collateral back to the owner
        // based on the option's conditions and the current market price
        uint256 currentPrice = synthetixAdapter.getPrice(address(baseCollateralToken));
        // Settlement logic based on currentPrice and option conditions
        require(optionToken.burn(optionOwner, amount), ""Burn failed"");
        // Additional logic for handling collateral and notifying the option market
    }
}",contract_11.sol
Develop a smart contract that verifies the existence or non-existence of a key-value pair in a Merkle tree. The contract should include functions to validate the commitment root and leaf node of the Merkle tree. Implement a way to check against a specification to ensure the internal consistency of the Merkle tree. Your solution should handle common error cases and provide clear documentation of the contract's functionality.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MerkleTreeVerifier {
    bytes32 public commitmentRoot;

    // Event to log validation results
    event ValidationResult(bool isValid, string message);

    // Constructor to set the commitment root
    constructor(bytes32 _commitmentRoot) {
        commitmentRoot = _commitmentRoot;
    }

    // Function to validate the Merkle proof
    function validateMerkleProof(
        bytes32[] memory proof,
        bytes32 leaf,
        uint256 index
    ) public view returns (bool) {
        bytes32 computedHash = leaf;

        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];

            if (index % 2 == 0) {
                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));
            } else {
                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));
            }

            index = index / 2;
        }

        return computedHash == commitmentRoot;
    }

    // Function to check the existence or non-existence of a key-value pair
    function checkKeyValuePair(
        bytes32[] memory proof,
        bytes32 key,
        bytes32 value
    ) public {
        bytes32 leaf = keccak256(abi.encodePacked(key, value));
        bool isValid = validateMerkleProof(proof, leaf, 0); // Assuming index is 0 for simplicity

        if (isValid) {
            emit ValidationResult(true, ""Key-Value pair exists in the Merkle tree."");
        } else {
            emit ValidationResult(false, ""Key-Value pair does not exist in the Merkle tree."");
        }
    }

    // Function to ensure internal consistency of the Merkle tree
    function ensureConsistency(
        bytes32[] memory proof,
        bytes32 leaf,
        uint256 index
    ) public view returns (bool) {
        return validateMerkleProof(proof, leaf, index);
    }
}",contract_12.sol
"Create a Solidity smart contract that integrates with the MasterChef and Uniswap protocols to manage rewards and LP tokens. The contract should have functions for harvesting rewards, depositing, and preview depositing. Handle address variables for the reward token, unirouter, and masterchef. Calculate LP token amounts and total assets accurately. Implement error handling as needed.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

interface IMasterChef {
    function deposit(uint256 _pid, uint256 _amount) external;
    function withdraw(uint256 _pid, uint256 _amount) external;
    function userInfo(uint256 _pid, address _user) external view returns (uint256, uint256);
    function pendingReward(uint256 _pid, address _user) external view returns (uint256);
}

interface IUniswapV2Router02 {
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
}

contract RewardManager {
    address public rewardToken;
    address public unirouter;
    address public masterchef;
    uint256 public pid;

    constructor(address _rewardToken, address _unirouter, address _masterchef, uint256 _pid) {
        rewardToken = _rewardToken;
        unirouter = _unirouter;
        masterchef = _masterchef;
        pid = _pid;
    }

    function harvestRewards() external {
        IMasterChef(masterchef).withdraw(pid, 0);
        uint256 rewardBalance = IERC20(rewardToken).balanceOf(address(this));
        require(rewardBalance > 0, ""No rewards to harvest"");
        IERC20(rewardToken).transfer(msg.sender, rewardBalance);
    }

    function deposit(uint256 amount) external {
        IERC20(rewardToken).transferFrom(msg.sender, address(this), amount);
        IERC20(rewardToken).approve(masterchef, amount);
        IMasterChef(masterchef).deposit(pid, amount);
    }

    function previewDeposit(uint256 amount) external view returns (uint256) {
        (uint256 lpTokenAmount, ) = IMasterChef(masterchef).userInfo(pid, msg.sender);
        return lpTokenAmount + amount;
    }

    function totalAssets() external view returns (uint256) {
        (uint256 lpTokenAmount, ) = IMasterChef(masterchef).userInfo(pid, msg.sender);
        return lpTokenAmount;
    }
}",contract_13.sol
Develop a smart contract for Random APE NFTs that enables minting and burning of tokens. Utilize OpenZeppelin's ERC-721 and ERC-721Burnable contracts. Require the MINTER_ROLE for minting. Implement a constructor that initializes the contract and grants the DEFAULT_ADMIN_ROLE and MINTER_ROLE to the contract deployer. Include a function for minting a new token and provide a way to burn tokens. Consider implementing a base URI function to set the prefix for IPFS links. The contract should also support the EIP-165 interface.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

abstract contract IERC165 {
    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool);
}

interface IERC721 is IERC165 {
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function balanceOf(address owner) external view returns (uint256 balance);
    function ownerOf(uint256 tokenId) external view returns (address owner);
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    function transferFrom(address from, address to, uint256 tokenId) external;
    function approve(address to, uint256 tokenId) external;
    function getApproved(uint256 tokenId) external view returns (address operator);
    function setApprovalForAll(address operator, bool _approved) external;
    function isApprovedForAll(address owner, address operator) external view returns (bool);
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
}

interface IERC721Metadata is IERC721 {
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function tokenURI(uint256 tokenId) external view returns (string memory);
}

interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}

library Address {
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

library Strings {
    bytes16 private constant _HEX_SYMBOLS = ""0123456789abcdef"";

    function toString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return ""0"";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }

    function toHexString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return ""0x00"";
        }
        uint256 temp = value;
        uint256 length = 0;
        while (temp != 0) {
            length++;
            temp >>= 8;
        }
        return toHexString(value, length);
    }

    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = ""0"";
        buffer[1] = ""x"";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _HEX_SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, ""Strings: hex length insufficient"");
        return string(buffer);
    }
}

abstract contract ERC165 is IERC165 {
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}

contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {
    using Address for address;
    using Strings for uint256;

    string private _name;
    string private _symbol;
    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return
            interfaceId == type(IERC721).interfaceId ||
            interfaceId == type(IERC721Metadata).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    function balanceOf(address owner) public view virtual override returns (uint256) {
        require(owner != address(0), ""ERC721: balance query for the zero address"");
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) public view virtual override returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), ""ERC721: owner query for nonexistent token"");
        return owner;
    }

    function name() public view virtual override returns (string memory) {
        return _name;
    }

    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        require(_exists(tokenId), ""ERC721Metadata: URI query for nonexistent token"");

        string memory baseURI = _baseURI();
        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : """";
    }

    function _baseURI() internal view virtual returns (string memory) {
        return """";
    }

    function approve(address to, uint256 tokenId) public virtual override {
        address owner = ERC721.ownerOf(tokenId);
        require(to != owner, ""ERC721: approval to current owner"");

        require(
            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
            ""ERC721: approve caller is not owner nor approved for all""
        );

        _approve(to, tokenId);
    }

    function getApproved(uint256 tokenId) public view virtual override returns (address) {
        require(_exists(tokenId), ""ERC721: approved query for nonexistent token"");

        return _tokenApprovals[tokenId];
    }

    function setApprovalForAll(address operator, bool approved) public virtual override {
        require(operator != _msgSender(), ""ERC721: approve to caller"");

        _operatorApprovals[_msgSender()][operator] = approved;
        emit ApprovalForAll(_msgSender(), operator, approved);
    }

    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        require(_isApprovedOrOwner(_msgSender(), tokenId), ""ERC721: transfer caller is not owner nor approved"");

        _transfer(from, to, tokenId);
    }

    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        safeTransferFrom(from, to, tokenId, """");
    }

    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) public virtual override {
        require(_isApprovedOrOwner(_msgSender(), tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _safeTransfer(from, to, tokenId, _data);
    }

    function _safeTransfer(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) internal virtual {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _exists(uint256 tokenId) internal view virtual returns (bool) {
        return _owners[tokenId] != address(0);
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");
        address owner = ERC721.ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    function _safeMint(address to, uint256 tokenId) internal virtual {
        _safeMint(to, tokenId, """");
    }

    function _safeMint(
        address to,
        uint256 tokenId,
        bytes memory _data
    ) internal virtual {
        _mint(to, tokenId);
        require(
            _checkOnERC721Received(address(0), to, tokenId, _data),
            ""ERC721: transfer to non ERC721Receiver implementer""
        );
    }

    function _mint(address to, uint256 tokenId) internal virtual {
        require(to != address(0), ""ERC721: mint to the zero address"");
        require(!_exists(tokenId), ""ERC721: token already minted"");

        _beforeTokenTransfer(address(0), to, tokenId);

        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(address(0), to, tokenId);
    }

    function _burn(uint256 tokenId) internal virtual {
        address owner = ERC721.ownerOf(tokenId);

        _beforeTokenTransfer(owner, address(0), tokenId);

        _approve(address(0), tokenId);

        _balances[owner] -= 1;
        delete _owners[tokenId];

        emit Transfer(owner, address(0), tokenId);
    }

    function _transfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual {
        require(ERC721.ownerOf(tokenId) == from, ""ERC721: transfer of token that is not own"");
        require(to != address(0), ""ERC721: transfer to the zero address"");

        _beforeTokenTransfer(from, to, tokenId);

        _approve(address(0), tokenId);

        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(from, to, tokenId);
    }

    function _approve(address to, uint256 tokenId) internal virtual {
        _tokenApprovals[tokenId] = to;
        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);
    }

    function _checkOnERC721Received(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) private returns (bool) {
        if (to.isContract()) {
            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
                return retval == IERC721Receiver.onERC721Received.selector;
            } catch (bytes memory reason) {
                if (reason.length == 0) {
                    revert(""ERC721: transfer to non ERC721Receiver implementer"");
                } else {
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        } else {
            return true;
        }
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual {}
}

abstract contract ERC721Burnable is Context, ERC721 {
    function burn(uint256 tokenId) public virtual {
        require(_isApprovedOrOwner(_msgSender(), tokenId), ""ERC721Burnable: caller is not owner nor approved"");
        _burn(tokenId);
    }
}

abstract contract AccessControl is Context {
    struct RoleData {
        mapping(address => bool) members;
        bytes32 adminRole;
    }

    mapping(bytes32 => RoleData) private _roles;

    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    function hasRole(bytes32 role, address account) public view returns (bool) {
        return _roles[role].members[account];
    }

    function getRoleAdmin(bytes32 role) public view returns (bytes32) {
        return _roles[role].adminRole;
    }

    function grantRole(bytes32 role, address account) public virtual {
        require(hasRole(getRoleAdmin(role), _msgSender()), ""AccessControl: sender must be an admin to grant"");

        _grantRole(role, account);
    }

    function revokeRole(bytes32 role, address account) public virtual {
        require(hasRole(getRoleAdmin(role), _msgSender()), ""AccessControl: sender must be an admin to revoke"");

        _revokeRole(role, account);
    }

    function renounceRole(bytes32 role, address account) public virtual {
        require(account == _msgSender(), ""AccessControl: can only renounce roles for self"");

        _revokeRole(role, account);
    }

    function _setupRole(bytes32 role, address account) internal virtual {
        _grantRole(role, account);
    }

    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
        _roles[role].adminRole = adminRole;
    }

    function _grantRole(bytes32 role, address account) private {
        if (!hasRole(role, account)) {
            _roles[role].members[account] = true;
            emit RoleGranted(role, account, _msgSender());
        }
    }

    function _revokeRole(bytes32 role, address account) private {
        if (hasRole(role, account)) {
            _roles[role].members[account] = false;
            emit RoleRevoked(role, account, _msgSender());
        }
    }
}

contract RandomAPENFT is ERC721, ERC721Burnable, AccessControl {
    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");
    string private _baseTokenURI;

    constructor() ERC721(""RandomAPENFT"", ""RAPENFT"") {
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setupRole(MINTER_ROLE, _msgSender());
    }

    function mint(address to, uint256 tokenId) public {
        require(hasRole(MINTER_ROLE, _msgSender()), ""RandomAPENFT: must have minter role to mint"");
        _safeMint(to, tokenId);
    }

    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }

    function setBaseURI(string memory baseURI) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), ""RandomAPENFT: must have admin role to set base URI"");
        _baseTokenURI = baseURI;
    }

    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, AccessControl) returns (bool) {
        return super.supportsInterface(interfaceId);
    }
}",contract_14.sol
"Create a smart contract for a KaijuKingz NFT collection. The contract should allow for fusion of Kaijus, revealing revealed Kaijus, and changing their names and bios. Consider implementing burn mechanics for fusion and updates. Be mindful of gas efficiency and EIP-1167 compliance.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract KaijuKingzNFT {
    address public owner;
    uint256 public totalSupply;
    string public baseURI;

    struct Kaiju {
        string name;
        string bio;
        bool isRevealed;
    }

    mapping(uint256 => Kaiju) public kaijus;
    mapping(uint256 => address) public kaijuToOwner;
    mapping(address => uint256) public ownerKaijuCount;

    event KaijuCreated(uint256 indexed kaijuId, string name, string bio, address indexed owner);
    event KaijuRevealed(uint256 indexed kaijuId);
    event KaijuNameChanged(uint256 indexed kaijuId, string newName);
    event KaijuBioChanged(uint256 indexed kaijuId, string newBio);
    event KaijuFused(uint256 indexed kaijuId1, uint256 indexed kaijuId2, uint256 newKaijuId);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier onlyKaijuOwner(uint256 kaijuId) {
        require(kaijuToOwner[kaijuId] == msg.sender, ""Not the owner of this Kaiju"");
        _;
    }

    constructor(string memory _baseURI) {
        owner = msg.sender;
        baseURI = _baseURI;
    }

    function createKaiju(string memory _name, string memory _bio) external {
        totalSupply++;
        uint256 kaijuId = totalSupply;
        kaijus[kaijuId] = Kaiju(_name, _bio, false);
        kaijuToOwner[kaijuId] = msg.sender;
        ownerKaijuCount[msg.sender]++;
        emit KaijuCreated(kaijuId, _name, _bio, msg.sender);
    }

    function revealKaiju(uint256 kaijuId) external onlyKaijuOwner(kaijuId) {
        kaijus[kaijuId].isRevealed = true;
        emit KaijuRevealed(kaijuId);
    }

    function changeKaijuName(uint256 kaijuId, string memory newName) external onlyKaijuOwner(kaijuId) {
        kaijus[kaijuId].name = newName;
        emit KaijuNameChanged(kaijuId, newName);
    }

    function changeKaijuBio(uint256 kaijuId, string memory newBio) external onlyKaijuOwner(kaijuId) {
        kaijus[kaijuId].bio = newBio;
        emit KaijuBioChanged(kaijuId, newBio);
    }

    function fuseKaijus(uint256 kaijuId1, uint256 kaijuId2) external onlyKaijuOwner(kaijuId1) onlyKaijuOwner(kaijuId2) {
        require(kaijuId1 != kaijuId2, ""Cannot fuse the same Kaiju"");
        require(kaijus[kaijuId1].isRevealed && kaijus[kaijuId2].isRevealed, ""Both Kaijus must be revealed"");

        // Burn the original Kaijus
        delete kaijus[kaijuId1];
        delete kaijus[kaijuId2];
        ownerKaijuCount[msg.sender] -= 2;

        // Create a new Kaiju
        totalSupply++;
        uint256 newKaijuId = totalSupply;
        kaijus[newKaijuId] = Kaiju(""Fusion Kaiju"", ""A powerful fusion of two Kaijus"", false);
        kaijuToOwner[newKaijuId] = msg.sender;
        ownerKaijuCount[msg.sender]++;

        emit KaijuFused(kaijuId1, kaijuId2, newKaijuId);
    }

    function setBaseURI(string memory _newBaseURI) external onlyOwner {
        baseURI = _newBaseURI;
    }
}",contract_15.sol
"Design a contract that allows for the pause and resumption of transfer operations. The contract should allow users to set an address as pausable, check if an address is pausable, and transfer tokens. The transfer function should fail if the transfer is paused. The contract should also include a function to get the current pause status.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract PausableToken {
    mapping(address => bool) public pausableAddresses;
    bool public isPaused;
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier whenNotPaused() {
        require(!isPaused, ""Contract is paused"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setPausableAddress(address _address, bool _isPausable) external onlyOwner {
        pausableAddresses[_address] = _isPausable;
    }

    function checkPausableAddress(address _address) external view returns (bool) {
        return pausableAddresses[_address];
    }

    function pause() external onlyOwner {
        isPaused = true;
    }

    function resume() external onlyOwner {
        isPaused = false;
    }

    function getPauseStatus() external view returns (bool) {
        return isPaused;
    }

    function transfer(address _to, uint256 _amount) external whenNotPaused {
        require(!pausableAddresses[msg.sender], ""Sender address is pausable"");
        // Assuming there's a balance check and update logic here for simplicity
        // require(balanceOf[msg.sender] >= _amount, ""Not enough balance"");
        // balanceOf[msg.sender] -= _amount;
        // balanceOf[_to] += _amount;
        // Emit Transfer event
    }
}",contract_16.sol
"Design a smart contract to manage insurance products with a focus on security matrices, capital pools, and premium pools. The contract should include functions for setup and initialization, pausing and unpausing, and secure authorizations. Implement logic for cover purchase, cancellation, and status updates. Use best practices for code organization, naming conventions, and error handling.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract InsuranceManager {
    address public owner;
    bool public paused;
    uint256 public totalCapital;
    uint256 public totalPremiums;

    struct InsuranceProduct {
        bool active;
        uint256 premium;
        uint256 coverageAmount;
        uint256 expiration;
    }

    mapping(address => InsuranceProduct) public policies;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    event PolicyPurchased(address indexed policyHolder, uint256 premium, uint256 coverageAmount, uint256 expiration);
    event PolicyCancelled(address indexed policyHolder);
    event ContractPaused(address indexed pauser);
    event ContractUnpaused(address indexed unpauser);

    constructor() {
        owner = msg.sender;
        paused = false;
    }

    function pause() external onlyOwner {
        paused = true;
        emit ContractPaused(msg.sender);
    }

    function unpause() external onlyOwner {
        paused = false;
        emit ContractUnpaused(msg.sender);
    }

    function purchaseCoverage(uint256 _premium, uint256 _coverageAmount, uint256 _duration) external payable whenNotPaused {
        require(msg.value == _premium, ""Incorrect premium amount"");
        require(_coverageAmount > 0, ""Coverage amount must be greater than zero"");
        require(_duration > 0, ""Duration must be greater than zero"");

        InsuranceProduct memory newPolicy = InsuranceProduct({
            active: true,
            premium: _premium,
            coverageAmount: _coverageAmount,
            expiration: block.timestamp + _duration
        });

        policies[msg.sender] = newPolicy;
        totalPremiums += _premium;
        totalCapital += _coverageAmount;

        emit PolicyPurchased(msg.sender, _premium, _coverageAmount, newPolicy.expiration);
    }

    function cancelCoverage() external whenNotPaused {
        InsuranceProduct storage policy = policies[msg.sender];
        require(policy.active, ""No active policy found"");

        policy.active = false;
        totalPremiums -= policy.premium;
        totalCapital -= policy.coverageAmount;

        (bool success, ) = msg.sender.call{value: policy.premium}("""");
        require(success, ""Transfer failed"");

        emit PolicyCancelled(msg.sender);
    }

    function getPolicyStatus(address _policyHolder) external view returns (bool, uint256, uint256, uint256) {
        InsuranceProduct storage policy = policies[_policyHolder];
        return (policy.active, policy.premium, policy.coverageAmount, policy.expiration);
    }
}",contract_17.sol
"Create a smart contract that integrates a role-based access control system for a decentralized application. The contract should include functions for verifying user memberships, granting and revoking permissions, and getting the administration role. Ensure the contract emits events for role changes and implements a mechanism for setting admin roles. Focus on the high-level structure and functionality of the contract.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract RoleBasedAccessControl {
    struct Role {
        mapping(address => bool) members;
        bytes32 adminRole;
    }

    mapping(bytes32 => Role) private roles;

    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
    event AdminRoleSet(bytes32 indexed role, bytes32 indexed adminRole, address indexed sender);

    modifier onlyRoleAdmin(bytes32 role) {
        require(isAdmin(role, msg.sender), ""Must be admin"");
        _;
    }

    function isAdmin(bytes32 role, address account) public view returns (bool) {
        return roles[role].members[account];
    }

    function hasRole(bytes32 role, address account) public view returns (bool) {
        return roles[role].members[account];
    }

    function getAdminRole(bytes32 role) public view returns (bytes32) {
        return roles[role].adminRole;
    }

    function setAdminRole(bytes32 role, bytes32 adminRole) public onlyRoleAdmin(role) {
        roles[role].adminRole = adminRole;
        emit AdminRoleSet(role, adminRole, msg.sender);
    }

    function grantRole(bytes32 role, address account) public onlyRoleAdmin(role) {
        roles[role].members[account] = true;
        emit RoleGranted(role, account, msg.sender);
    }

    function revokeRole(bytes32 role, address account) public onlyRoleAdmin(role) {
        roles[role].members[account] = false;
        emit RoleRevoked(role, account, msg.sender);
    }
}",contract_18.sol
"Create a smart contract that allows for ownership transfer, paused state management, and payment withdrawal. The contract should inherit from OpenZeppelin's contracts and provide clear documentation for its functions. The contract should allow the owner to renounce ownership, transfer ownership to another address, and change the paused state. The owner should be able to withdraw payments to a payee address, and the withdrawn value should be deducted from the balance of the contract.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of ""user permissions"".
 */
contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(_owner == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

/**
 * @title Pausable
 * @dev The Pausable contract allows the owner to pause and unpause the contract.
 */
contract Pausable is Ownable {
    bool private _paused;

    event Paused(address account);
    event Unpaused(address account);

    constructor() {
        _paused = false;
    }

    /**
     * @dev Returns true if the contract is paused, and false otherwise.
     */
    function paused() public view returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
        require(!_paused, ""Pausable: paused"");
        _;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is paused.
     */
    modifier whenPaused() {
        require(_paused, ""Pausable: not paused"");
        _;
    }

    /**
     * @dev Called by the owner to pause, triggers stopped state.
     */
    function pause() public onlyOwner whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    /**
     * @dev Called by the owner to unpause, returns to normal state.
     */
    function unpause() public onlyOwner whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}

/**
 * @title PaymentWithdrawable
 * @dev The PaymentWithdrawable contract allows the owner to withdraw payments to a payee address.
 */
contract PaymentWithdrawable is Ownable {
    mapping(address => uint256) private _balances;

    event PaymentWithdrawn(address indexed payee, uint256 amount);

    /**
     * @dev Withdraws the specified amount of wei to the payee address.
     * Can only be called by the owner.
     */
    function withdraw(address payable payee, uint256 amount) public onlyOwner {
        require(payee != address(0), ""PaymentWithdrawable: payee is the zero address"");
        require(_balances[payee] >= amount, ""PaymentWithdrawable: insufficient balance"");

        _balances[payee] -= amount;
        (bool success, ) = payee.call{value: amount}("""");
        require(success, ""PaymentWithdrawable: withdraw failed"");

        emit PaymentWithdrawn(payee, amount);
    }

    /**
     * @dev Fallback function to receive payments.
     */
    receive() external payable {
        _balances[msg.sender] += msg.value;
    }
}

/**
 * @title FullContract
 * @dev The FullContract combines Ownable, Pausable, and PaymentWithdrawable functionalities.
 */
contract FullContract is Ownable, Pausable, PaymentWithdrawable {
    // This contract inherits from Ownable, Pausable, and PaymentWithdrawable,
    // providing ownership transfer, paused state management, and payment withdrawal capabilities.
}",contract_19.sol
"Create a smart contract that allows for the management of tokens, enables the addition and removal of liquidity, and manages token swapping, admin fees, and LP earnings. Focus on implementing these functions in a logical and efficient manner.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TokenSwap {
    string public name = ""TokenSwap"";
    address public admin;
    uint256 public totalLiquidity;
    uint256 public adminFee;

    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event AddLiquidity(address indexed provider, uint256 amount);
    event RemoveLiquidity(address indexed provider, uint256 amount);
    event Swap(address indexed user, uint256 amountIn, uint256 amountOut);

    constructor() {
        admin = msg.sender;
    }

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Not the admin"");
        _;
    }

    function addLiquidity(uint256 amount) external onlyAdmin {
        require(amount > 0, ""Amount must be greater than 0"");
        balances[msg.sender] += amount;
        totalLiquidity += amount;
        emit AddLiquidity(msg.sender, amount);
    }

    function removeLiquidity(uint256 amount) external onlyAdmin {
        require(amount > 0, ""Amount must be greater than 0"");
        require(balances[msg.sender] >= amount, ""Insufficient balance"");
        balances[msg.sender] -= amount;
        totalLiquidity -= amount;
        emit RemoveLiquidity(msg.sender, amount);
    }

    function swap(uint256 amountIn, uint256 amountOut) external {
        require(amountIn > 0 && amountOut > 0, ""Amounts must be greater than 0"");
        require(balances[msg.sender] >= amountIn, ""Insufficient balance"");

        uint256 fee = (amountIn * adminFee) / 10000;
        uint256 amountInAfterFee = amountIn - fee;

        balances[msg.sender] -= amountIn;
        balances[msg.sender] += amountOut;
        adminFee += fee;

        emit Swap(msg.sender, amountIn, amountOut);
    }

    function setAdminFee(uint256 newFee) external onlyAdmin {
        require(newFee >= 0, ""Fee must be non-negative"");
        adminFee = newFee;
    }

    function transfer(address to, uint256 value) external returns (bool) {
        require(balances[msg.sender] >= value, ""Insufficient balance"");
        balances[msg.sender] -= value;
        balances[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) external returns (bool) {
        allowances[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) external returns (bool) {
        require(balances[from] >= value, ""Insufficient balance"");
        require(allowances[from][msg.sender] >= value, ""Allowance too low"");
        balances[from] -= value;
        balances[to] += value;
        allowances[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }
}",contract_20.sol
Create a smart contract that accurately calculates logarithmic values for specific input values. Utilize the provided table of constants and implement a function that takes an unsigned integer as input and returns the corresponding logarithmic value. Ensure that the implementation seamlessly integrates with the existing code and utilizes safe arithmetic operations. Include relevant documentation comments and provide examples of how to use the contract.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract LogarithmCalculator {
    // Constants for logarithm calculation
    uint256 private constant LOG_E_2 = 69314718055994530941723212145817656807550013436025525412068000949339362196969; // ln(2) * 2^256 / 10^18
    uint256 private constant LOG_E_10 = 23025850929940456840179914546843642076011014886287729760333279009675726096773; // ln(10) * 2^256 / 10^18

    /**
     * @dev Calculates the natural logarithm of a given unsigned integer.
     * @param x The unsigned integer input value.
     * @return The natural logarithm of the input value.
     */
    function ln(uint256 x) public pure returns (int256) {
        require(x > 0, ""Input must be greater than zero"");

        if (x == 1) {
            return 0;
        }

        int256 res = 0;
        uint256 y = x;

        while (y > 1) {
            res += int256(LOG_E_2);
            y >>= 1;
        }

        return res / 10**18;
    }

    /**
     * @dev Calculates the base 10 logarithm of a given unsigned integer.
     * @param x The unsigned integer input value.
     * @return The base 10 logarithm of the input value.
     */
    function log10(uint256 x) public pure returns (int256) {
        require(x > 0, ""Input must be greater than zero"");

        if (x == 1) {
            return 0;
        }

        int256 res = 0;
        uint256 y = x;

        while (y > 1) {
            res += int256(LOG_E_10);
            y /= 10;
        }

        return res / 10**18;
    }
}

/*
Example usage:

1. Deploy the LogarithmCalculator contract.
2. Call the ln function with an unsigned integer input to get the natural logarithm.
3. Call the log10 function with an unsigned integer input to get the base 10 logarithm.

Note: The results are scaled by 10^18 to maintain precision. Divide by 10^18 to get the actual logarithm value.
*/",contract_21.sol
"Create a smart contract that allows for token minting and burning, with approval and allowance management. The contract should include functions for getting the token name, symbol, decimal precision, total supply, and balance. Implement a system for transferring tokens between addresses, with allowance management for approving and revoking spending limits. Ensure the contract has a clear and consistent interface for users.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    string private _name;
    string private _symbol;
    uint8 private _decimals;
    uint256 private _totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory name_, string memory symbol_, uint8 decimals_, uint256 initialSupply) {
        _name = name_;
        _symbol = symbol_;
        _decimals = decimals_;
        _totalSupply = initialSupply * 10 ** uint256(decimals_);
        _balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        require(_balances[msg.sender] >= amount, ""Token: transfer amount exceeds balance"");
        _balances[msg.sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        require(_balances[sender] >= amount, ""Token: transfer amount exceeds balance"");
        require(_allowances[sender][msg.sender] >= amount, ""Token: transfer amount exceeds allowance"");
        _balances[sender] -= amount;
        _balances[recipient] += amount;
        _allowances[sender][msg.sender] -= amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }

    function mint(address account, uint256 amount) public {
        require(account != address(0), ""Token: mint to the zero address"");
        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function burn(address account, uint256 amount) public {
        require(_balances[account] >= amount, ""Token: burn amount exceeds balance"");
        _totalSupply -= amount;
        _balances[account] -= amount;
        emit Transfer(account, address(0), amount);
    }
}",contract_22.sol
Create a smart contract for managing lending and withdrawing tokens. The contract should have separate functions for depositing and withdrawing tokens. Implement a mechanism to prevent reentrancy attacks. Utilize Openzeppelin's libraries for proxy and clone contracts. Include interfaces for lending and admin facets. Ensure the contract follows best practices for coding and security.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract LendingContract {
    address public owner;
    mapping(address => uint256) public balances;
    bool internal locked;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier noReentrancy() {
        require(!locked, ""Reentrant call"");
        locked = true;
        _;
        locked = false;
    }

    constructor() {
        owner = msg.sender;
    }

    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw(uint256 amount) public noReentrancy {
        require(balances[msg.sender] >= amount, ""Insufficient balance"");
        balances[msg.sender] -= amount;
        (bool success, ) = msg.sender.call{value: amount}("""");
        require(success, ""Transfer failed"");
    }

    function getBalance(address account) public view returns (uint256) {
        return balances[account];
    }

    function transferOwnership(address newOwner) public onlyOwner {
        owner = newOwner;
    }
}

interface ILendingFacet {
    function deposit() external payable;
    function withdraw(uint256 amount) external;
}

interface IAdminFacet {
    function transferOwnership(address newOwner) external;
}

// Note: OpenZeppelin's libraries for proxy and clone contracts are not included here as per the instruction to not use import statements.
// However, their functionality would typically be integrated into a full implementation to handle proxy and clone logic securely.",contract_23.sol
"Create a smart contract that provides functionality similar to OpenZeppelin's Pausable and Ownable contracts. The contract should include functions to Pause/Unpause the contract, TransferOwnership, and RenounceOwnership. Implement all necessary variables and modifiers. Provide a general overview of how the contract's functionality works.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract PausableOwnable {
    address private _owner;
    bool private _paused;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event Paused(address account);
    event Unpaused(address account);

    modifier onlyOwner() {
        require(owner() == msg.sender, ""PausableOwnable: caller is not the owner"");
        _;
    }

    modifier whenNotPaused() {
        require(!_paused, ""PausableOwnable: paused"");
        _;
    }

    modifier whenPaused() {
        require(_paused, ""PausableOwnable: not paused"");
        _;
    }

    constructor() {
        _transferOwnership(msg.sender);
        _paused = false;
    }

    function owner() public view returns (address) {
        return _owner;
    }

    function paused() public view returns (bool) {
        return _paused;
    }

    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""PausableOwnable: new owner is the zero address"");
        _transferOwnership(newOwner);
    }

    function pause() public onlyOwner whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    function unpause() public onlyOwner whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }

    function _transferOwnership(address newOwner) internal {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

/*
Overview:
- The contract PausableOwnable combines the functionalities of Ownable and Pausable contracts.
- It allows the contract owner to pause and unpause the contract, transfer ownership, and renounce ownership.
- The contract uses modifiers to restrict certain functions to the owner only and to enforce paused/unpaused states.
- Events are emitted for important state changes such as ownership transfer, pausing, and unpausing.
- The constructor initializes the contract with the deployer as the owner and the contract in an unpaused state.
*/",contract_24.sol
Create a smart contract that allows for token burning and upgrading. The contract should inherit from the StandardToken contract and include functions to modify the total supply and balance of addresses. It should also include functions to approve and add allowance for specific spenders. The contract should emit events to track these actions. Focus on implementing the necessary logic for token burning and upgrading without overcomplicating the contract with unnecessary features.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract StandardToken {
    mapping(address => uint256) internal _balances;
    mapping(address => mapping(address => uint256)) internal _allowances;
    uint256 internal _totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public virtual returns (bool) {
        require(_balances[msg.sender] >= amount, ""ST: transfer amount exceeds balance"");
        _balances[msg.sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view virtual returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public virtual returns (bool) {
        _allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool) {
        require(_allowances[sender][msg.sender] >= amount, ""ST: transfer amount exceeds allowance"");
        require(_balances[sender] >= amount, ""ST: transfer amount exceeds balance"");
        _allowances[sender][msg.sender] -= amount;
        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }
}

contract BurnableUpgradeableToken is StandardToken {
    event Burn(address indexed burner, uint256 value);
    event Upgrade(address indexed upgrader, uint256 value);

    function burn(uint256 _value) public {
        require(_balances[msg.sender] >= _value, ""BUT: burn amount exceeds balance"");
        _balances[msg.sender] -= _value;
        _totalSupply -= _value;
        emit Burn(msg.sender, _value);
        emit Transfer(msg.sender, address(0), _value);
    }

    function upgrade(uint256 _value) public {
        _totalSupply += _value;
        _balances[msg.sender] += _value;
        emit Upgrade(msg.sender, _value);
        emit Transfer(address(0), msg.sender, _value);
    }
}",contract_25.sol
Create a smart contract that restricts access to certain functions based on the operator's role. The contract should have an `operator` variable and an `operator` function that returns the current operator. Implement a function to transfer the operator role to a new address and another function to check if a user is the current operator. The contract should also have events for operator changes and notifications for certain actions.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract OperatorRole {
    address private _operator;

    event OperatorTransferred(address indexed previousOperator, address indexed newOperator);
    event ActionNotification(string message);

    modifier onlyOperator() {
        require(isOperator(msg.sender), ""Caller is not the operator"");
        _;
    }

    constructor() {
        _operator = msg.sender;
        emit OperatorTransferred(address(0), _operator);
    }

    function operator() public view returns (address) {
        return _operator;
    }

    function isOperator(address account) public view returns (bool) {
        return account == _operator;
    }

    function transferOperator(address newOperator) public onlyOperator {
        require(newOperator != address(0), ""New operator is the zero address"");
        emit OperatorTransferred(_operator, newOperator);
        _operator = newOperator;
    }

    function performAction() public onlyOperator {
        emit ActionNotification(""Action performed by operator"");
    }
}",contract_26.sol
"Create a smart contract that builds upon the OpenZeppelin Context contract and integrates ERC20 token management functionality. The contract should enable token transfer, approval, and balance verification. Implement SafeMath for arithmetic operations and Address library for low-level function calls. Focus on maintainable and readable code structure.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, ""SafeMath: modulo by zero"");
        return a % b;
    }
}

library Address {
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, ""Address: insufficient balance"");
        (bool success, ) = recipient.call{ value: amount }("""");
        require(success, ""Address: unable to send value, recipient may have reverted"");
    }

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
      return functionCall(target, data, ""Address: low-level call failed"");
    }

    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, ""Address: low-level call with value failed"");
    }

    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, ""Address: insufficient balance for call"");
        require(isContract(target), ""Address: call to non-contract"");
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            if (returndata.length > 0) {
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

contract ERC20 is Context {
    using SafeMath for uint256;
    using Address for address;

    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    constructor (string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
        _decimals = 18;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, ""ERC20: transfer amount exceeds allowance""));
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, ""ERC20: decreased allowance below zero""));
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _balances[sender] = _balances[sender].sub(amount, ""ERC20: transfer amount exceeds balance"");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) internal {
        require(account != address(0), ""ERC20: burn from the zero address"");

        _balances[account] = _balances[account].sub(amount, ""ERC20: burn amount exceeds balance"");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}",contract_27.sol
"Create a smart contract that builds upon the EtherCartel example code. The new contract should allow users to collect and sell drugs, buy drugs, and manage their kilos. The contract should also include a function to seed the market with a specified number of drugs. The contract should handle funds transferred and include logic to calculate revenue shares and referral rewards.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DrugMarket {
    struct User {
        uint kilos;
        uint revenue;
        address referrer;
    }

    mapping(address => User) public users;
    uint public totalKilos;
    uint public drugPrice = 1 ether; // Price per kilo
    uint public referralRewardPercentage = 5; // 5% referral reward

    event DrugsCollected(address indexed user, uint kilos);
    event DrugsSold(address indexed user, uint kilos, uint revenue);
    event DrugsBought(address indexed user, uint kilos, uint cost);
    event MarketSeeded(uint kilos);

    function collectDrugs(uint kilos) external {
        User storage user = users[msg.sender];
        user.kilos += kilos;
        totalKilos += kilos;
        emit DrugsCollected(msg.sender, kilos);
    }

    function sellDrugs(uint kilos) external {
        User storage user = users[msg.sender];
        require(user.kilos >= kilos, ""Not enough kilos to sell"");

        uint revenue = kilos * drugPrice;
        user.kilos -= kilos;
        user.revenue += revenue;
        totalKilos -= kilos;

        if (user.referrer != address(0)) {
            uint referralReward = (revenue * referralRewardPercentage) / 100;
            users[user.referrer].revenue += referralReward;
            revenue -= referralReward;
        }

        payable(msg.sender).transfer(revenue);
        emit DrugsSold(msg.sender, kilos, revenue);
    }

    function buyDrugs(uint kilos, address referrer) external payable {
        uint cost = kilos * drugPrice;
        require(msg.value >= cost, ""Insufficient payment"");

        User storage user = users[msg.sender];
        user.kilos += kilos;
        totalKilos += kilos;

        if (referrer != address(0) && referrer != msg.sender) {
            users[referrer].referrer = referrer;
        }

        if (msg.value > cost) {
            payable(msg.sender).transfer(msg.value - cost);
        }

        emit DrugsBought(msg.sender, kilos, cost);
    }

    function seedMarket(uint kilos) external {
        totalKilos += kilos;
        emit MarketSeeded(kilos);
    }

    receive() external payable {
        // Accept Ether transfers
    }
}",contract_28.sol
"Create a timelock smart contract that enables scheduling of transactions at a specific delay. The contract should include features for setting an admin, pending admin, and delay. Implement methods for queuing and canceling transactions, as well as functions for administering the admin and pending admin roles. The contract should restrict access to specific functions, ensuring that only authorized users can initiate actions.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Timelock {
    address public admin;
    address public pendingAdmin;
    uint public delay;
    mapping(bytes32 => bool) public queuedTransactions;

    event NewAdmin(address indexed newAdmin);
    event NewPendingAdmin(address indexed newPendingAdmin);
    event NewDelay(uint indexed newDelay);
    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);
    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);
    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Timelock: caller is not the admin"");
        _;
    }

    constructor(uint _delay) {
        require(_delay > 0, ""Timelock: delay must be greater than 0"");
        admin = msg.sender;
        delay = _delay;
    }

    function setDelay(uint _delay) public onlyAdmin {
        require(_delay > 0, ""Timelock: delay must be greater than 0"");
        delay = _delay;
        emit NewDelay(_delay);
    }

    function acceptAdmin() public {
        require(msg.sender == pendingAdmin, ""Timelock: caller is not the pending admin"");
        admin = msg.sender;
        pendingAdmin = address(0);
        emit NewAdmin(admin);
    }

    function setPendingAdmin(address newPendingAdmin) public onlyAdmin {
        pendingAdmin = newPendingAdmin;
        emit NewPendingAdmin(newPendingAdmin);
    }

    function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public onlyAdmin returns (bytes32) {
        require(eta >= block.timestamp + delay, ""Timelock: eta is before delay"");
        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));
        queuedTransactions[txHash] = true;
        emit QueueTransaction(txHash, target, value, signature, data, eta);
        return txHash;
    }

    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public onlyAdmin {
        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));
        queuedTransactions[txHash] = false;
        emit CancelTransaction(txHash, target, value, signature, data, eta);
    }

    function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable onlyAdmin returns (bytes memory) {
        require(block.timestamp >= eta, ""Timelock: transaction is before eta"");
        require(block.timestamp <= eta + delay, ""Timelock: transaction is after eta + delay"");
        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));
        require(queuedTransactions[txHash], ""Timelock: transaction is not queued"");
        queuedTransactions[txHash] = false;

        bytes memory callData;
        if (bytes(signature).length == 0) {
            callData = data;
        } else {
            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);
        }

        (bool success, bytes memory returnData) = target.call{value: value}(callData);
        require(success, ""Timelock: transaction execution reverted"");

        emit ExecuteTransaction(txHash, target, value, signature, data, eta);
        return returnData;
    }
}",contract_29.sol
"Develop a smart contract that implements an ERC20 token with an owner. The contract should have a name and symbol, and have the ability to transfer tokens. Include a functionality to approve and increase allowance for other accounts. Implement token transfer, approval, and disapproval logic. The contract should be inheritable from OpenZeppelin's ERC20 and Ownable contracts.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20 {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    uint256 private _totalSupply;
    string private _name;
    string private _symbol;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public pure returns (uint8) {
        return 18;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) public returns (bool) {
        _transfer(msg.sender, to, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) public returns (bool) {
        _spendAllowance(from, msg.sender, amount);
        _transfer(from, to, amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        uint256 currentAllowance = _allowances[msg.sender][spender];
        require(currentAllowance >= subtractedValue, ""ERC20: decreased allowance below zero"");
        unchecked {
            _approve(msg.sender, spender, currentAllowance - subtractedValue);
        }
        return true;
    }

    function _transfer(address from, address to, uint256 amount) internal {
        require(from != address(0), ""ERC20: transfer from the zero address"");
        require(to != address(0), ""ERC20: transfer to the zero address"");

        uint256 fromBalance = _balances[from];
        require(fromBalance >= amount, ""ERC20: transfer amount exceeds balance"");
        unchecked {
            _balances[from] = fromBalance - amount;
        }
        _balances[to] += amount;

        emit Transfer(from, to, amount);
    }

    function _mint(address account, uint256 amount) internal {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) internal {
        require(account != address(0), ""ERC20: burn from the zero address"");

        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, ""ERC20: burn amount exceeds balance"");
        unchecked {
            _balances[account] = accountBalance - amount;
        }
        _totalSupply -= amount;

        emit Transfer(account, address(0), amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _spendAllowance(address owner, address spender, uint256 amount) internal {
        uint256 currentAllowance = allowance(owner, spender);
        if (currentAllowance != type(uint256).max) {
            require(currentAllowance >= amount, ""ERC20: insufficient allowance"");
            unchecked {
                _approve(owner, spender, currentAllowance - amount);
            }
        }
    }
}

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _transferOwnership(msg.sender);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract MyToken is ERC20, Ownable {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}

    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }

    function burn(address account, uint256 amount) public onlyOwner {
        _burn(account, amount);
    }
}",contract_30.sol
"Develop a smart contract that enables the creation, transfer, and management of digital assets. The contract should implement the IERC721 interface and support functions for retrieving the balance of assets, retrieving the owner of an asset, approving and transferring assets, and retrieving the approved operator for an asset. The contract should also provide metadata about the assets, including the name, symbol, and token URI. Finally, the contract should emit events to track changes in asset ownership and approval.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC721 {
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function balanceOf(address owner) external view returns (uint256 balance);
    function ownerOf(uint256 tokenId) external view returns (address owner);
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    function transferFrom(address from, address to, uint256 tokenId) external;
    function approve(address to, uint256 tokenId) external;
    function getApproved(uint256 tokenId) external view returns (address operator);
    function setApprovalForAll(address operator, bool _approved) external;
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}

contract DigitalAsset is IERC721 {
    string public name;
    string public symbol;
    uint256 private _tokenIdCounter;

    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;
    mapping(uint256 => string) private _tokenURIs;

    constructor(string memory _name, string memory _symbol) {
        name = _name;
        symbol = _symbol;
    }

    function balanceOf(address owner) public view override returns (uint256) {
        require(owner != address(0), ""ERC721: balance query for the zero address"");
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) public view override returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), ""ERC721: owner query for nonexistent token"");
        return owner;
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) public override {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _safeTransfer(from, to, tokenId);
    }

    function transferFrom(address from, address to, uint256 tokenId) public override {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _transfer(from, to, tokenId);
    }

    function approve(address to, uint256 tokenId) public override {
        address owner = ownerOf(tokenId);
        require(to != owner, ""ERC721: approval to current owner"");
        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), ""ERC721: approve caller is not owner nor approved for all"");
        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    function getApproved(uint256 tokenId) public view override returns (address) {
        require(_exists(tokenId), ""ERC721: approved query for nonexistent token"");
        return _tokenApprovals[tokenId];
    }

    function setApprovalForAll(address operator, bool approved) public override {
        require(operator != msg.sender, ""ERC721: approve to caller"");
        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function isApprovedForAll(address owner, address operator) public view override returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function _safeTransfer(address from, address to, uint256 tokenId) internal {
        _transfer(from, to, tokenId);
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        require(ownerOf(tokenId) == from, ""ERC721: transfer of token that is not own"");
        require(to != address(0), ""ERC721: transfer to the zero address"");

        _beforeTokenTransfer(from, to, tokenId);

        _approve(address(0), tokenId);

        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(from, to, tokenId);
    }

    function _approve(address to, uint256 tokenId) internal {
        _tokenApprovals[tokenId] = to;
        emit Approval(ownerOf(tokenId), to, tokenId);
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return _owners[tokenId] != address(0);
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal {}

    function tokenURI(uint256 tokenId) public view returns (string memory) {
        require(_exists(tokenId), ""ERC721Metadata: URI query for nonexistent token"");
        return _tokenURIs[tokenId];
    }

    function _setTokenURI(uint256 tokenId, string memory uri) internal {
        require(_exists(tokenId), ""ERC721Metadata: URI set of nonexistent token"");
        _tokenURIs[tokenId] = uri;
    }

    function createAsset(address to, string memory uri) public returns (uint256) {
        uint256 tokenId = _tokenIdCounter++;
        _mint(to, tokenId);
        _setTokenURI(tokenId, uri);
        return tokenId;
    }

    function _mint(address to, uint256 tokenId) internal {
        require(to != address(0), ""ERC721: mint to the zero address"");
        require(!_exists(tokenId), ""ERC721: token already minted"");

        _beforeTokenTransfer(address(0), to, tokenId);

        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(address(0), to, tokenId);
    }
}",contract_31.sol
"Create a smart contract that allows for ownership transfer and token permissioned transfer. The contract should inherit from OpenZeppelin's owned base contract, with functions for transferring ownership and permitting token transfers. The contract should include logic for checking both ownership and permit permissions. Utilize the SafeERC20 library for ensuring safe token transfers.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _transferOwnership(msg.sender);
    }

    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

library SafeERC20 {
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        bytes memory returndata = address(token).functionCall(data, ""SafeERC20: low-level call failed"");
        if (returndata.length > 0) {
            require(abi.decode(returndata, (bool)), ""SafeERC20: ERC20 operation did not succeed"");
        }
    }
}

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}

library Address {
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, ""Address: insufficient balance for call"");
        require(isContract(target), ""Address: call to non-contract"");

        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            if (returndata.length > 0) {
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

contract TokenTransfer is Ownable {
    using SafeERC20 for IERC20;

    mapping(address => bool) public permitTransfer;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event PermitTransferUpdated(address indexed account, bool permitted);

    function updatePermitTransfer(address account, bool permitted) external onlyOwner {
        permitTransfer[account] = permitted;
        emit PermitTransferUpdated(account, permitted);
    }

    function transferWithPermit(IERC20 token, address to, uint256 value) external {
        require(permitTransfer[msg.sender], ""TokenTransfer: caller does not have permit to transfer"");
        token.safeTransfer(to, value);
    }

    function transferFromWithPermit(IERC20 token, address from, address to, uint256 value) external {
        require(permitTransfer[from], ""TokenTransfer: 'from' address does not have permit to transfer"");
        token.safeTransferFrom(from, to, value);
    }
}",contract_32.sol
"Create a smart contract that demonstrates inheritance and function visibility. The contract should have a base contract (Base) that defines private, internal, and public functions. The child contract should override internal functions and call them. Ensure that private functions are inaccessible outside the contract. The contract should also include public and internal state variables. Write test functions to demonstrate the functionality of each type of function.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Base {
    uint public publicVar;
    uint internal internalVar;

    function publicFunction() public {
        privateFunction();
        internalFunction();
    }

    function privateFunction() private {
        // Private function logic
    }

    function internalFunction() internal virtual {
        // Internal function logic
    }
}

contract Child is Base {
    function overrideInternalFunction() public {
        internalFunction();
    }

    function internalFunction() internal virtual override {
        // Override internal function logic
    }

    function testVisibility() public {
        publicFunction(); // Call public function from Base
        overrideInternalFunction(); // Call overridden internal function
        // privateFunction(); // This line would cause an error if uncommented, as private functions are inaccessible outside the contract
    }
}",contract_33.sol
"Create a smart contract that manages buy, sell, transfer, and game fees, with the ability to set and retrieve these fees. The contract should use a counter to track revisions and emit events when fees are updated. It should also enforce limits on total fees for buy, sell, and transfer operations.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract FeeManager {
    struct Fees {
        uint256 buyFee;
        uint256 sellFee;
        uint256 transferFee;
        uint256 gameFee;
    }

    Fees public currentFees;
    uint256 public revisionCounter;

    event FeesUpdated(uint256 buyFee, uint256 sellFee, uint256 transferFee, uint256 gameFee, uint256 revision);

    constructor(uint256 _buyFee, uint256 _sellFee, uint256 _transferFee, uint256 _gameFee) {
        require(_buyFee + _sellFee + _transferFee + _gameFee <= 10000, ""Total fees exceed 100%"");
        currentFees = Fees(_buyFee, _sellFee, _transferFee, _gameFee);
        revisionCounter = 1;
        emit FeesUpdated(_buyFee, _sellFee, _transferFee, _gameFee, revisionCounter);
    }

    function setFees(uint256 _buyFee, uint256 _sellFee, uint256 _transferFee, uint256 _gameFee) external {
        require(_buyFee + _sellFee + _transferFee + _gameFee <= 10000, ""Total fees exceed 100%"");
        currentFees = Fees(_buyFee, _sellFee, _transferFee, _gameFee);
        revisionCounter++;
        emit FeesUpdated(_buyFee, _sellFee, _transferFee, _gameFee, revisionCounter);
    }

    function getFees() external view returns (uint256, uint256, uint256, uint256) {
        return (currentFees.buyFee, currentFees.sellFee, currentFees.transferFee, currentFees.gameFee);
    }
}",contract_34.sol
"Create a smart contract that represents an ERC20 token. The contract should manage token balances and allow for the transfer of tokens. Users should be able to query the balance of their account and approve or disapprove specific amounts for spending. Implement event listeners for token transfers and approvals. Consider implementing features for token creation, naming, and tracking of supply.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }
}",contract_35.sol
"Develop a smart contract that mimics the behavior of the IPancakePair interface. This contract should be able to handle token minting, burning, swapping, and syncing. Ensure the contract accurately manages the token reserves and pricing information. Include basic input validation and error handling.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract PancakePair {
    address public token0;
    address public token1;

    uint112 private reserve0;
    uint112 private reserve1;
    uint32 private blockTimestampLast;

    uint public price0CumulativeLast;
    uint public price1CumulativeLast;

    event Mint(address indexed sender, uint amount0, uint amount1);
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    constructor(address _token0, address _token1) {
        token0 = _token0;
        token1 = _token1;
    }

    function mint(address to) external returns (uint liquidity) {
        uint balance0 = IERC20(token0).balanceOf(address(this));
        uint balance1 = IERC20(token1).balanceOf(address(this));
        uint amount0 = balance0 - reserve0;
        uint amount1 = balance1 - reserve1;

        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
        if (_totalSupply == 0) {
            liquidity = Math.sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY;
            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens
        } else {
            liquidity = Math.min(amount0 * _totalSupply / reserve0, amount1 * _totalSupply / reserve1);
        }
        require(liquidity > 0, 'Pancake: INSUFFICIENT_LIQUIDITY_MINTED');
        _mint(to, liquidity);

        _update(balance0, balance1, reserve0, reserve1);
        emit Mint(msg.sender, amount0, amount1);
    }

    function burn(address to) external returns (uint amount0, uint amount1) {
        uint balance0 = IERC20(token0).balanceOf(address(this));
        uint balance1 = IERC20(token1).balanceOf(address(this));
        uint liquidity = balanceOf[address(this)];

        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
        amount0 = liquidity * balance0 / _totalSupply; // using balances ensures pro-rata distribution
        amount1 = liquidity * balance1 / _totalSupply; // using balances ensures pro-rata distribution
        require(amount0 > 0 && amount1 > 0, 'Pancake: INSUFFICIENT_LIQUIDITY_BURNED');
        _burn(address(this), liquidity);
        IERC20(token0).transfer(to, amount0);
        IERC20(token1).transfer(to, amount1);

        balance0 = IERC20(token0).balanceOf(address(this));
        balance1 = IERC20(token1).balanceOf(address(this));

        _update(balance0, balance1, reserve0, reserve1);
        emit Burn(msg.sender, amount0, amount1, to);
    }

    function swap(uint amount0Out, uint amount1Out, address to) external {
        require(amount0Out > 0 || amount1Out > 0, 'Pancake: INSUFFICIENT_OUTPUT_AMOUNT');
        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'Pancake: INSUFFICIENT_LIQUIDITY');

        uint balance0;
        uint balance1;
        { // scope for _token{0,1}, avoids stack too deep errors
        address _token0 = token0;
        address _token1 = token1;
        require(to != _token0 && to != _token1, 'Pancake: INVALID_TO');
        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens
        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens
        balance0 = IERC20(_token0).balanceOf(address(this));
        balance1 = IERC20(_token1).balanceOf(address(this));
        }
        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;
        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;
        require(amount0In > 0 || amount1In > 0, 'Pancake: INSUFFICIENT_INPUT_AMOUNT');
        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors
        uint balance0Adjusted = balance0 * 1000 - amount0In * 3;
        uint balance1Adjusted = balance1 * 1000 - amount1In * 3;
        require(balance0Adjusted * balance1Adjusted >= uint(_reserve0) * uint(_reserve1) * 1000000, 'Pancake: K');
        }

        _update(balance0, balance1, _reserve0, _reserve1);
        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
    }

    function sync() external {
        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);
    }

    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {
        _reserve0 = reserve0;
        _reserve1 = reserve1;
        _blockTimestampLast = blockTimestampLast;
    }

    function _safeTransfer(address token, address to, uint value) private {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'Pancake: TRANSFER_FAILED');
    }

    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {
        require(balance0 <= type(uint112).max && balance1 <= type(uint112).max, 'Pancake: OVERFLOW');
        uint32 blockTimestamp = uint32(block.timestamp % 2**32);
        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired
        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {
            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;
            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;
        }
        reserve0 = uint112(balance0);
        reserve1 = uint112(balance1);
        blockTimestampLast = blockTimestamp;
        emit Sync(reserve0, reserve1);
    }

    // ERC20 related functions and variables
    string public constant name = 'Pancake LPs';
    string public constant symbol = 'Cake-LP';
    uint8 public constant decimals = 18;
    uint public totalSupply;
    mapping(address => uint) public balanceOf;
    mapping(address => mapping(address => uint)) public allowance;

    bytes32 public DOMAIN_SEPARATOR;
    // keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");
    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
    mapping(address => uint) public nonces;

    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    constructor() {
        uint chainId;
        assembly {
            chainId := chainid()
        }
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),
                keccak256(bytes(name)),
                keccak256(bytes('1')),
                chainId,
                address(this)
            )
        );
    }

    function _mint(address to, uint value) internal {
        totalSupply += value;
        balanceOf[to] += value;
        emit Transfer(address(0), to, value);
    }

    function _burn(address from, uint value) internal {
        balanceOf[from] -= value;
        totalSupply -= value;
        emit Transfer(from, address(0), value);
    }

    function _approve(address owner, address spender, uint value) private {
        allowance[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    function _transfer(address from, address to, uint value) private {
        balanceOf[from] -= value;
        balanceOf[to] += value;
        emit Transfer(from, to, value);
    }

    function approve(address spender, uint value) external returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    function transfer(address to, uint value) external returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    function transferFrom(address from, address to, uint value) external returns (bool) {
        if (allowance[from][msg.sender] != type(uint).max) {
            allowance[from][msg.sender] -= value;
        }
        _transfer(from, to, value);
        return true;
    }

    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {
        require(deadline >= block.timestamp, 'Pancake: EXPIRED');
        bytes32 digest = keccak256(
            abi.encodePacked(
                '\x19\x01',
                DOMAIN_SEPARATOR,
                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))
            )
        );
        address recoveredAddress = ecrecover(digest, v, r, s);
        require(recoveredAddress != address(0) && recoveredAddress == owner, 'Pancake: INVALID_SIGNATURE');
        _approve(owner, spender, value);
    }
}

interface IERC20 {
    function totalSupply() external view returns (uint);
    function balanceOf(address account) external view returns (uint);
    function transfer(address recipient, uint amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint);
    function approve(address spender, uint amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);
}

library Math {
    function min(uint x, uint y) internal pure returns (uint z) {
        z = x < y ? x : y;
    }

    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)
    function sqrt(uint y) internal pure returns (uint z) {
        if (y > 3) {
            z = y;
            uint x = y / 2 + 1;
            while (x < z) {
                z = x;
                x = (y / x + x) / 2;
            }
        } else if (y != 0) {
            z = 1;
        }
    }
}

library UQ112x112 {
    uint224 constant Q112 = 2**112;

    // encode a uint112 as a UQ112x112
    function encode(uint112 y) internal pure returns (uint224 z) {
        z = uint224(y) * Q112; // never overflows
    }

    // divide a UQ112x112 by a uint112, returning a UQ112x112
    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {
        z = x / uint224(y);
    }
}",contract_36.sol
"Create a smart contract that allows users to transfer a token, check their balance, and approve token transfers. The contract should utilize the IERC20 interface and inherit from OpenZeppelin's Context contract. The implementation should include SafeMath library functions for arithmetic operations and Address library functions for sending values and making function calls. Consider potential reentrancy attacks and optimize for gas efficiency.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }
}

library Address {
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, ""Address: insufficient balance"");
        (bool success, ) = recipient.call{ value: amount }("""");
        require(success, ""Address: unable to send value, recipient may have reverted"");
    }

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
      return functionCall(target, data, ""Address: low-level call failed"");
    }

    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, ""Address: low-level call with value failed"");
    }

    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, ""Address: insufficient balance for call"");
        require(isContract(target), ""Address: call to non-contract"");
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            if (returndata.length > 0) {
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

contract ERC20 is Context, IERC20 {
    using SafeMath for uint256;
    using Address for address;

    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    constructor (string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
        _decimals = 18;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, ""ERC20: transfer amount exceeds allowance""));
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, ""ERC20: decreased allowance below zero""));
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _beforeTokenTransfer(sender, recipient, amount);

        _balances[sender] = _balances[sender].sub(amount, ""ERC20: transfer amount exceeds balance"");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: burn from the zero address"");

        _beforeTokenTransfer(account, address(0), amount);

        _balances[account] = _balances[account].sub(amount, ""ERC20: burn amount exceeds balance"");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }
}",contract_37.sol
"Create a smart contract that follows the ERC721 standard. The contract should have functions to retrieve the balance of an owner, check if a token exists, approve an operator, and transfer a token. The contract should also have a mapping to store the owner of each token. The contract should use the SafeMath library for arithmetic operations and the AddressUtils library for address utilities. The contract should have a modifier to check if the sender is the owner of the token.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC721 {
    using SafeMath for uint256;
    using AddressUtils for address;

    mapping (uint256 => address) private _tokenOwner;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (uint256 => address) private _tokenApprovals;

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    modifier onlyOwnerOf(uint256 _tokenId) {
        require(_tokenOwner[_tokenId] == msg.sender, ""Not the owner of the token"");
        _;
    }

    function balanceOf(address _owner) public view returns (uint256) {
        require(_owner != address(0), ""Owner query for non-existent token"");
        return _ownedTokensCount[_owner];
    }

    function ownerOf(uint256 _tokenId) public view returns (address) {
        address owner = _tokenOwner[_tokenId];
        require(owner != address(0), ""Owner query for non-existent token"");
        return owner;
    }

    function exists(uint256 _tokenId) public view returns (bool) {
        return _tokenOwner[_tokenId] != address(0);
    }

    function approve(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {
        _tokenApprovals[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }

    function transfer(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {
        require(_to != address(0), ""Transfer to the zero address"");
        clearApproval(msg.sender, _tokenId);
        removeTokenFrom(msg.sender, _tokenId);
        addTokenTo(_to, _tokenId);
        emit Transfer(msg.sender, _to, _tokenId);
    }

    function clearApproval(address _owner, uint256 _tokenId) internal {
        require(_tokenOwner[_tokenId] == _owner, ""Not the owner of the token"");
        if (_tokenApprovals[_tokenId] != address(0)) {
            _tokenApprovals[_tokenId] = address(0);
        }
    }

    function removeTokenFrom(address _from, uint256 _tokenId) internal {
        require(_tokenOwner[_tokenId] == _from, ""Not the owner of the token"");
        _ownedTokensCount[_from] = _ownedTokensCount[_from].sub(1);
        _tokenOwner[_tokenId] = address(0);
    }

    function addTokenTo(address _to, uint256 _tokenId) internal {
        require(_tokenOwner[_tokenId] == address(0), ""Token already has an owner"");
        _tokenOwner[_tokenId] = _to;
        _ownedTokensCount[_to] = _ownedTokensCount[_to].add(1);
    }
}

library SafeMath {
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a / b;
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}

library AddressUtils {
    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}",contract_38.sol
Develop a Solidity smart contract that enables a staking warm-up mechanism. The contract should include: (1) Immutable addresses for staking and SOHM; (2) A constructor to initialize these addresses; (3) A retrieve function accessible only to the staking address; (4) This function should distribute specified amounts from SOHM to authorized stakers; and (5) Emit a transfer event for the transferred amount. The contract should adhere to standard best practices and follow proper smart contract development guidelines.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract StakingWarmUp {
    address public immutable stakingAddress;
    address public immutable sohmAddress;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor(address _stakingAddress, address _sohmAddress) {
        require(_stakingAddress != address(0), ""Invalid staking address"");
        require(_sohmAddress != address(0), ""Invalid SOHM address"");
        stakingAddress = _stakingAddress;
        sohmAddress = _sohmAddress;
    }

    modifier onlyStaking() {
        require(msg.sender == stakingAddress, ""Only staking contract can call this function"");
        _;
    }

    function retrieve(address _to, uint256 _amount) external onlyStaking {
        require(_to != address(0), ""Invalid recipient address"");
        require(_amount > 0, ""Amount must be greater than zero"");

        // Assuming SOHM contract has a transfer function
        (bool success, ) = sohmAddress.call(abi.encodeWithSignature(""transfer(address,uint256)"", _to, _amount));
        require(success, ""Transfer failed"");

        emit Transfer(sohmAddress, _to, _amount);
    }
}",contract_39.sol
"Create a smart contract that outlines a token transfer process, allowing users to approve and withdraw tokens. The contract should include functions for checking token balances, approving transfers, and transferring tokens. Incorporate event emitting for transactions. Implement a basic security measure to prevent unauthorized transactions.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TokenTransfer {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }
}",contract_40.sol
"Create a smart contract for managing ERC721 tokens, including minting, transferring, and burning tokens. The contract should be pauseable and log all token events. Implement logic for handling gas costs and rejecting failed transactions. Include functions for minting and burning tokens, as well as functions for transferring and withdrawing tokens. Utilize relevant inheritances and interfaces from existing ERC721 contracts, ensuring compatibility with other ERC721 token contracts. Provide a clear and organized Solidity code structure for this contract.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC721 {
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    function balanceOf(address owner) public view returns (uint256) {
        require(owner != address(0), ""ERC721: balance query for the zero address"");
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) public view returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), ""ERC721: owner query for nonexistent token"");
        return owner;
    }

    function approve(address to, uint256 tokenId) public {
        address owner = ownerOf(tokenId);
        require(to != owner, ""ERC721: approval to current owner"");
        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), ""ERC721: approve caller is not owner nor approved for all"");
        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    function getApproved(uint256 tokenId) public view returns (address) {
        require(_exists(tokenId), ""ERC721: approved query for nonexistent token"");
        return _tokenApprovals[tokenId];
    }

    function setApprovalForAll(address operator, bool approved) public {
        require(operator != msg.sender, ""ERC721: approve to caller"");
        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function isApprovedForAll(address owner, address operator) public view returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function transferFrom(address from, address to, uint256 tokenId) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _transfer(from, to, tokenId);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) public {
        safeTransferFrom(from, to, tokenId, """");
    }

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _safeTransfer(from, to, tokenId, _data);
    }

    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return _owners[tokenId] != address(0);
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    function _safeMint(address to, uint256 tokenId) internal {
        _safeMint(to, tokenId, """");
    }

    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal {
        _mint(to, tokenId);
        require(_checkOnERC721Received(address(0), to, tokenId, _data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _mint(address to, uint256 tokenId) internal {
        require(to != address(0), ""ERC721: mint to the zero address"");
        require(!_exists(tokenId), ""ERC721: token already minted"");
        _beforeTokenTransfer(address(0), to, tokenId);
        _balances[to] += 1;
        _owners[tokenId] = to;
        emit Transfer(address(0), to, tokenId);
    }

    function _burn(uint256 tokenId) internal {
        address owner = ownerOf(tokenId);
        _beforeTokenTransfer(owner, address(0), tokenId);
        _approve(address(0), tokenId);
        _balances[owner] -= 1;
        delete _owners[tokenId];
        emit Transfer(owner, address(0), tokenId);
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        require(ownerOf(tokenId) == from, ""ERC721: transfer of token that is not own"");
        require(to != address(0), ""ERC721: transfer to the zero address"");
        _beforeTokenTransfer(from, to, tokenId);
        _approve(address(0), tokenId);
        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;
        emit Transfer(from, to, tokenId);
    }

    function _approve(address to, uint256 tokenId) internal {
        _tokenApprovals[tokenId] = to;
        emit Approval(ownerOf(tokenId), to, tokenId);
    }

    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) internal returns (bool) {
        if (to.code.length > 0) {
            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data) returns (bytes4 retval) {
                return retval == IERC721Receiver.onERC721Received.selector;
            } catch (bytes memory reason) {
                if (reason.length == 0) {
                    revert(""ERC721: transfer to non ERC721Receiver implementer"");
                } else {
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        } else {
            return true;
        }
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual {}
}

interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}

contract Pausable {
    event Paused(address account);
    event Unpaused(address account);

    bool private _paused;

    constructor() {
        _paused = false;
    }

    function paused() public view returns (bool) {
        return _paused;
    }

    modifier whenNotPaused() {
        require(!_paused, ""Pausable: paused"");
        _;
    }

    modifier whenPaused() {
        require(_paused, ""Pausable: not paused"");
        _;
    }

    function _pause() internal whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    function _unpause() internal whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}

contract ERC721Token is ERC721, Pausable {
    string private _name;
    string private _symbol;
    uint256 private _tokenIdCounter;

    event TokenMinted(address indexed to, uint256 indexed tokenId);
    event TokenBurned(uint256 indexed tokenId);
    event TokenTransferred(address indexed from, address indexed to, uint256 indexed tokenId);

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
        _tokenIdCounter = 0;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function pause() public {
        _pause();
    }

    function unpause() public {
        _unpause();
    }

    function mintToken(address to) public whenNotPaused returns (uint256) {
        _tokenIdCounter++;
        uint256 newTokenId = _tokenIdCounter;
        _safeMint(to, newTokenId);
        emit TokenMinted(to, newTokenId);
        return newTokenId;
    }

    function burnToken(uint256 tokenId) public whenNotPaused {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: caller is not owner nor approved"");
        _burn(tokenId);
        emit TokenBurned(tokenId);
    }

    function transferToken(address from, address to, uint256 tokenId) public whenNotPaused {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _transfer(from, to, tokenId);
        emit TokenTransferred(from, to, tokenId);
    }

    function withdrawTokens(address to, uint256 tokenId) public whenNotPaused {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: caller is not owner nor approved"");
        _transfer(ownerOf(tokenId), to, tokenId);
        emit TokenTransferred(ownerOf(tokenId), to, tokenId);
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override whenNotPaused {
        super._beforeTokenTransfer(from, to, tokenId);
    }
}",contract_41.sol
"Create a Solidity smart contract for a NonStopTRX system that allows users to register, update weekly referral counts, and enter the cycle pool. The contract should have modifiers for the contract owner and owner. Define private functions for registering users, updating weekly referrals, and entering the cycle pool. Implement the logic for these functions using the provided contract code as a reference. Focus on implementing the necessary data structures and variables to store user information and track weekly referrals.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract NonStopTRX {
    address public owner;

    struct User {
        bool registered;
        uint256 weeklyReferrals;
        bool inCyclePool;
    }

    mapping(address => User) public users;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function registerUser(address _user) private {
        require(!users[_user].registered, ""User already registered"");
        users[_user].registered = true;
    }

    function updateWeeklyReferrals(address _user, uint256 _referrals) private {
        require(users[_user].registered, ""User not registered"");
        users[_user].weeklyReferrals = _referrals;
    }

    function enterCyclePool(address _user) private {
        require(users[_user].registered, ""User not registered"");
        require(!users[_user].inCyclePool, ""User already in cycle pool"");
        users[_user].inCyclePool = true;
    }

    function publicRegisterUser() external {
        registerUser(msg.sender);
    }

    function publicUpdateWeeklyReferrals(uint256 _referrals) external {
        updateWeeklyReferrals(msg.sender, _referrals);
    }

    function publicEnterCyclePool() external {
        enterCyclePool(msg.sender);
    }
}",contract_42.sol
"Create a smart contract that interacts with various interfaces to enable approval, allowance, and utility methods. The contract should be modular and well-documented. Focus on implementing the key functions and modules outlined in the provided code fragment.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }
}",contract_43.sol
"Develop a smart contract for a derivative investment platform that allows users to invest and withdraw funds. The contract should inherit from ERC20Extended and Ownable. Implement functions for investing, withdrawing, and updating the derivative status. Incorporate modifiers for ownership and access control. Utilize the SafeMath library for arithmetic operations.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Extended {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply;
        balanceOf[msg.sender] = _totalSupply;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }
}

contract Ownable {
    address public owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""Invalid address"");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }
}

contract DerivativeInvestmentPlatform is ERC20Extended, Ownable {
    using SafeMath for uint256;

    bool public derivativeStatus;

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalSupply)
        ERC20Extended(_name, _symbol, _decimals, _totalSupply)
    {
        derivativeStatus = true;
    }

    modifier onlyWhenOpen() {
        require(derivativeStatus, ""Derivative is closed"");
        _;
    }

    function invest() public payable onlyWhenOpen {
        require(msg.value > 0, ""Investment amount must be greater than zero"");
        balanceOf[msg.sender] = balanceOf[msg.sender].add(msg.value);
        totalSupply = totalSupply.add(msg.value);
        emit Transfer(address(0), msg.sender, msg.value);
    }

    function withdraw(uint256 amount) public onlyWhenOpen {
        require(balanceOf[msg.sender] >= amount, ""Insufficient balance"");
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(amount);
        totalSupply = totalSupply.sub(amount);
        payable(msg.sender).transfer(amount);
        emit Transfer(msg.sender, address(0), amount);
    }

    function updateDerivativeStatus(bool _status) public onlyOwner {
        derivativeStatus = _status;
    }
}",contract_44.sol
"Implement a smart contract that allows for the creation and management of token markets. The contract should include features for adding, removing, and modifying tokens, as well as allowing traders to trade tokens. The contract should also include mechanisms for validating transactions and ensuring the integrity of the markets.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TokenMarket {
    struct Token {
        address tokenAddress;
        string symbol;
        uint8 decimals;
        uint256 totalSupply;
    }

    struct Trade {
        address trader;
        address tokenAddress;
        uint256 amount;
        uint256 price;
        bool isBuy;
    }

    mapping(address => Token) public tokens;
    address[] public tokenList;
    mapping(address => mapping(address => uint256)) public balances;
    Trade[] public trades;

    event TokenAdded(address indexed tokenAddress, string symbol, uint8 decimals, uint256 totalSupply);
    event TokenRemoved(address indexed tokenAddress);
    event TradeExecuted(address indexed trader, address indexed tokenAddress, uint256 amount, uint256 price, bool isBuy);

    modifier tokenExists(address _tokenAddress) {
        require(tokens[_tokenAddress].tokenAddress != address(0), ""Token does not exist"");
        _;
    }

    function addToken(address _tokenAddress, string memory _symbol, uint8 _decimals, uint256 _totalSupply) public {
        require(tokens[_tokenAddress].tokenAddress == address(0), ""Token already exists"");
        tokens[_tokenAddress] = Token(_tokenAddress, _symbol, _decimals, _totalSupply);
        tokenList.push(_tokenAddress);
        emit TokenAdded(_tokenAddress, _symbol, _decimals, _totalSupply);
    }

    function removeToken(address _tokenAddress) public tokenExists(_tokenAddress) {
        delete tokens[_tokenAddress];
        for (uint256 i = 0; i < tokenList.length; i++) {
            if (tokenList[i] == _tokenAddress) {
                tokenList[i] = tokenList[tokenList.length - 1];
                tokenList.pop();
                break;
            }
        }
        emit TokenRemoved(_tokenAddress);
    }

    function modifyToken(address _tokenAddress, string memory _symbol, uint8 _decimals, uint256 _totalSupply) public tokenExists(_tokenAddress) {
        tokens[_tokenAddress].symbol = _symbol;
        tokens[_tokenAddress].decimals = _decimals;
        tokens[_tokenAddress].totalSupply = _totalSupply;
    }

    function tradeToken(address _tokenAddress, uint256 _amount, uint256 _price, bool _isBuy) public tokenExists(_tokenAddress) {
        require(_amount > 0, ""Amount must be greater than 0"");
        require(_price > 0, ""Price must be greater than 0"");

        if (_isBuy) {
            require(balances[msg.sender][_tokenAddress] >= _amount * _price, ""Insufficient balance"");
            balances[msg.sender][_tokenAddress] -= _amount * _price;
        } else {
            require(balances[msg.sender][_tokenAddress] >= _amount, ""Insufficient token balance"");
            balances[msg.sender][_tokenAddress] -= _amount;
        }

        trades.push(Trade(msg.sender, _tokenAddress, _amount, _price, _isBuy));
        emit TradeExecuted(msg.sender, _tokenAddress, _amount, _price, _isBuy);
    }

    function deposit(address _tokenAddress, uint256 _amount) public tokenExists(_tokenAddress) {
        require(_amount > 0, ""Amount must be greater than 0"");
        balances[msg.sender][_tokenAddress] += _amount;
    }

    function withdraw(address _tokenAddress, uint256 _amount) public tokenExists(_tokenAddress) {
        require(_amount > 0, ""Amount must be greater than 0"");
        require(balances[msg.sender][_tokenAddress] >= _amount, ""Insufficient balance"");
        balances[msg.sender][_tokenAddress] -= _amount;
    }

    function getTokenList() public view returns (address[] memory) {
        return tokenList;
    }

    function getTrades() public view returns (Trade[] memory) {
        return trades;
    }
}",contract_45.sol
"Create a Yearn V2 Vault smart contract that allows users to deposit and withdraw tokens, obtain the current price per share, and retrieve the underlying token address. The contract should inherit from IERC20 and conform to the OpenZeppelin ERC20 standard.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract YearnV2Vault is IERC20 {
    string public name = ""Yearn V2 Vault"";
    string public symbol = ""YV2"";
    uint8 public decimals = 18;
    uint256 private _totalSupply;
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    address public underlyingToken;
    uint256 public totalUnderlying;
    uint256 public pricePerShare;

    constructor(address _underlyingToken) {
        underlyingToken = _underlyingToken;
        pricePerShare = 1e18; // Initialize price per share to 1 token
    }

    function totalSupply() external view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) external view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) external override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) external view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) external override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    function deposit(uint256 amount) external {
        require(IERC20(underlyingToken).transferFrom(msg.sender, address(this), amount), ""Transfer failed"");
        uint256 shares = (amount * 1e18) / pricePerShare;
        _mint(msg.sender, shares);
        totalUnderlying += amount;
    }

    function withdraw(uint256 shares) external {
        uint256 amount = (shares * pricePerShare) / 1e18;
        require(IERC20(underlyingToken).transfer(msg.sender, amount), ""Transfer failed"");
        _burn(msg.sender, shares);
        totalUnderlying -= amount;
    }

    function getPricePerShare() external view returns (uint256) {
        return pricePerShare;
    }

    function getUnderlyingTokenAddress() external view returns (address) {
        return underlyingToken;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""Transfer from the zero address"");
        require(recipient != address(0), ""Transfer to the zero address"");
        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""Approve from the zero address"");
        require(spender != address(0), ""Approve to the zero address"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _mint(address account, uint256 amount) internal {
        require(account != address(0), ""Mint to the zero address"");
        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) internal {
        require(account != address(0), ""Burn from the zero address"");
        _balances[account] -= amount;
        _totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }
}",contract_46.sol
"Create a contract that allows users to swap tokens, add/remove liquidity, and query reserves. Based on the IUniswapV2Router01 and IUniswapV2Router02 interfaces, implement the necessary functions without getting into the low-level implementation details. Provide general comments explaining the functionality.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TokenSwap {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    // Function to swap tokens
    function swapTokens(address tokenIn, address tokenOut, uint amountIn, uint amountOutMin, address to) external {
        // Implementation of token swap logic would go here
        // This is a placeholder for the actual swap functionality
    }

    // Function to add liquidity
    function addLiquidity(address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to) external {
        // Implementation of adding liquidity logic would go here
        // This is a placeholder for the actual liquidity addition functionality
    }

    // Function to remove liquidity
    function removeLiquidity(address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to) external {
        // Implementation of removing liquidity logic would go here
        // This is a placeholder for the actual liquidity removal functionality
    }

    // Function to query reserves
    function getReserves(address tokenA, address tokenB) external view returns (uint reserveA, uint reserveB) {
        // Implementation of querying reserves logic would go here
        // This is a placeholder for the actual reserves query functionality
    }
}",contract_47.sol
"Create a smart contract that allows users to stake tokens and earn rewards. The contract should have the ability to mint new tokens, track user balances, and distribute rewards. The contract should also be able to handle multiple external tokens and store and track user rewards for each token. The contract should also have functions to get the last time rewards were distributed, get the reward rate, and get the reward for a specific duration.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract StakingRewards {
    struct User {
        uint256 balance;
        uint256 reward;
        uint256 lastUpdateTime;
    }

    struct Token {
        uint256 totalStaked;
        uint256 rewardRate;
        uint256 lastRewardTime;
    }

    mapping(address => User) public users;
    mapping(address => Token) public tokens;
    address[] public tokenList;

    function stake(address token, uint256 amount) external {
        require(amount > 0, ""Amount must be greater than 0"");
        User storage user = users[msg.sender];
        Token storage tokenInfo = tokens[token];

        updateReward(msg.sender, token);
        user.balance += amount;
        tokenInfo.totalStaked += amount;
    }

    function withdraw(address token, uint256 amount) external {
        require(amount > 0, ""Amount must be greater than 0"");
        User storage user = users[msg.sender];
        Token storage tokenInfo = tokens[token];

        require(user.balance >= amount, ""Insufficient balance"");
        updateReward(msg.sender, token);
        user.balance -= amount;
        tokenInfo.totalStaked -= amount;
    }

    function claimReward(address token) external {
        User storage user = users[msg.sender];
        Token storage tokenInfo = tokens[token];

        updateReward(msg.sender, token);
        uint256 reward = user.reward;
        user.reward = 0;
        // Transfer reward to user (assuming internal minting or transfer mechanism)
    }

    function updateReward(address userAddress, address token) internal {
        User storage user = users[userAddress];
        Token storage tokenInfo = tokens[token];

        if (user.balance > 0) {
            uint256 timeSinceLastUpdate = block.timestamp - user.lastUpdateTime;
            uint256 reward = (user.balance * tokenInfo.rewardRate * timeSinceLastUpdate) / 1e18;
            user.reward += reward;
        }
        user.lastUpdateTime = block.timestamp;
        tokenInfo.lastRewardTime = block.timestamp;
    }

    function getLastRewardTime(address token) external view returns (uint256) {
        return tokens[token].lastRewardTime;
    }

    function getRewardRate(address token) external view returns (uint256) {
        return tokens[token].rewardRate;
    }

    function getRewardForDuration(address token, uint256 duration) external view returns (uint256) {
        Token storage tokenInfo = tokens[token];
        return (tokenInfo.totalStaked * tokenInfo.rewardRate * duration) / 1e18;
    }

    function addToken(address token, uint256 rewardRate) external {
        Token storage tokenInfo = tokens[token];
        require(tokenInfo.rewardRate == 0, ""Token already added"");

        tokenInfo.rewardRate = rewardRate;
        tokenList.push(token);
    }

    function mint(address to, uint256 amount) external {
        // Mint new tokens (assuming internal minting mechanism)
    }
}",contract_48.sol
"Create a basic ERC20 token contract that allows users to mint, burn, and transfer tokens. Implement the necessary functions, including totalSupply, balanceOf, transfer, approve, and transferFrom. Also, consider adding other relevant functions such as increaseAllowance, decreaseAllowance, _transfer, and any other necessary methods","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 private _totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        _totalSupply = initialSupply * 10 ** uint256(decimals);
        _balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);
        return true;
    }

    function mint(address account, uint256 amount) public {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function burn(uint256 amount) public {
        _burn(msg.sender, amount);
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");
        require(_balances[sender] >= amount, ""ERC20: transfer amount exceeds balance"");

        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _burn(address account, uint256 amount) internal {
        require(account != address(0), ""ERC20: burn from the zero address"");
        require(_balances[account] >= amount, ""ERC20: burn amount exceeds balance"");

        _balances[account] -= amount;
        _totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }
}",contract_49.sol
"Create a smart contract that allows for token transfers and includes basic functionality, utilizing the IERC20 interface and SafeMath library. Implement a balance retrieval function and include event triggers for transfer and approval operations.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }
}

contract MyToken is IERC20 {
    using SafeMath for uint256;

    string public constant name = ""MyToken"";
    string public constant symbol = ""MTK"";
    uint8 public constant decimals = 18;

    mapping(address => uint256) balances;
    mapping(address => mapping (address => uint256)) allowed;
    uint256 totalSupply_;

    constructor(uint256 total) {
        totalSupply_ = total;
        balances[msg.sender] = totalSupply_;
    }

    function totalSupply() public override view returns (uint256) {
        return totalSupply_;
    }

    function increaseTotalSupply(uint newTokensAmount) public {
        totalSupply_ += newTokensAmount;
        balances[msg.sender] += newTokensAmount;
    }

    function balanceOf(address tokenOwner) public override view returns (uint256 balance) {
        return balances[tokenOwner];
    }

    function transfer(address receiver, uint256 numTokens) public override returns (bool) {
        require(numTokens <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(numTokens);
        balances[receiver] = balances[receiver].add(numTokens);
        emit Transfer(msg.sender, receiver, numTokens);
        return true;
    }

    function approve(address delegate, uint256 numTokens) public override returns (bool) {
        allowed[msg.sender][delegate] = numTokens;
        emit Approval(msg.sender, delegate, numTokens);
        return true;
    }

    function allowance(address owner, address delegate) public override view returns (uint256) {
        return allowed[owner][delegate];
    }

    function transferFrom(address owner, address buyer, uint256 numTokens) public override returns (bool) {
        require(numTokens <= balances[owner]);
        require(numTokens <= allowed[owner][msg.sender]);

        balances[owner] = balances[owner].sub(numTokens);
        allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);
        balances[buyer] = balances[buyer].add(numTokens);
        emit Transfer(owner, buyer, numTokens);
        return true;
    }
}",contract_50.sol
"Create a smart contract that allows single ownership and transferable management. The contract should have a specific default owner and implement a function to obtain the current owner. Further, it should provide the capability to transfer ownership to a new address, pushing ownership to a new address, and pulling ownership to the new address from the owner. Finally, ensure that only the current owner can execute certain actions.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;
    address private _newOwner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(msg.sender == _owner, ""Ownable: caller is not the owner"");
        _;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _newOwner = newOwner;
    }

    function acceptOwnership() public {
        require(msg.sender == _newOwner, ""Ownable: caller is not the new owner"");
        emit OwnershipTransferred(_owner, _newOwner);
        _owner = _newOwner;
        _newOwner = address(0);
    }
}",contract_51.sol
"Create a smart contract that allows for staging and committing delayed protocol parameters, leveraging the Aave LendingPool. Implement functions for delaying parameter updates and commit logic, ensuring timestamp validation and access control. Consider integrating the contract with external systems and incorporate best practices for smart contract development.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface ILendingPool {
    function getReserveData(address asset) external view returns (uint256);
    function setReserveData(address asset, uint256 data) external;
}

contract DelayedProtocolParameters {
    struct ParameterProposal {
        address asset;
        uint256 newData;
        uint256 commitTime;
        bool committed;
    }

    ILendingPool public lendingPool;
    address public owner;
    mapping(address => ParameterProposal) public proposals;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the owner"");
        _;
    }

    constructor(address _lendingPoolAddress) {
        lendingPool = ILendingPool(_lendingPoolAddress);
        owner = msg.sender;
    }

    function proposeParameterUpdate(address asset, uint256 newData, uint256 delay) external onlyOwner {
        require(delay > 0, ""Delay must be greater than 0"");
        proposals[asset] = ParameterProposal({
            asset: asset,
            newData: newData,
            commitTime: block.timestamp + delay,
            committed: false
        });
    }

    function commitParameterUpdate(address asset) external onlyOwner {
        ParameterProposal storage proposal = proposals[asset];
        require(proposal.commitTime > 0, ""No proposal for this asset"");
        require(block.timestamp >= proposal.commitTime, ""Commit time not reached"");
        require(!proposal.committed, ""Already committed"");

        lendingPool.setReserveData(asset, proposal.newData);
        proposal.committed = true;
    }

    function getCurrentParameter(address asset) external view returns (uint256) {
        return lendingPool.getReserveData(asset);
    }

    function getProposedParameter(address asset) external view returns (uint256) {
        return proposals[asset].newData;
    }
}",contract_52.sol
"Create a smart contract that interacts with the provided ERC20 token. The contract should allow token transfers and update the allowance for the token owner. Implement a system for adding and removing modules, and enable static calls. Include functions for calculating the total supply of the token and querying the balance of a specific token owner. Focus on functionality and ease of use, ensuring that the contract can handle a large number of token owners. Do not worry about optimization for scalability.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }
}

contract TokenInteraction {
    ERC20Token public token;

    constructor(address tokenAddress) {
        token = ERC20Token(tokenAddress);
    }

    function transferTokens(address to, uint256 value) public {
        require(token.transferFrom(msg.sender, to, value), ""Transfer failed"");
    }

    function approveTokens(address spender, uint256 value) public {
        require(token.approve(spender, value), ""Approval failed"");
    }

    function getTotalSupply() public view returns (uint256) {
        return token.totalSupply();
    }

    function getBalanceOf(address owner) public view returns (uint256) {
        return token.balanceOf(owner);
    }
}

contract ModuleSystem {
    address public owner;
    mapping(address => bool) public modules;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function addModule(address module) public onlyOwner {
        modules[module] = true;
    }

    function removeModule(address module) public onlyOwner {
        modules[module] = false;
    }

    function isModuleActive(address module) public view returns (bool) {
        return modules[module];
    }
}

contract TokenManager is TokenInteraction, ModuleSystem {
    constructor(address tokenAddress) TokenInteraction(tokenAddress) ModuleSystem() {}

    function staticCall(address target, bytes memory data) public view returns (bool, bytes memory) {
        return target.staticcall(data);
    }
}",contract_53.sol
"Create a smart contract that allows for minting, transferring, and burning tokens. The contract should have a way to query the total supply, get the owner, and set a new owner. It should also allow for token allowance and approval. Implement a mapping for tracking token balances and include functions for getting the balance of an address and transferring tokens between accounts.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    address public owner;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        owner = msg.sender;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""New owner is the zero address"");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }

    function mint(address to, uint256 value) public onlyOwner {
        totalSupply += value;
        balanceOf[to] += value;
        emit Transfer(address(0), to, value);
    }

    function burn(uint256 value) public {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        totalSupply -= value;
        balanceOf[msg.sender] -= value;
        emit Transfer(msg.sender, address(0), value);
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance too low"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }
}",contract_54.sol
"Create a smart contract that manages access control for a system. The contract should allow for the modification of public access and call permissions, including support for batch updates. Implement functions for checking access and permission status, and consider incorporating events for notification purposes.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract AccessControl {
    struct Permission {
        bool canCall;
        bool isPublic;
    }

    mapping(address => Permission) private permissions;
    event AccessModified(address indexed user, bool canCall, bool isPublic);
    event BatchAccessModified(address[] users, bool[] canCall, bool[] isPublic);

    modifier onlyWithPermission(address user) {
        require(permissions[user].canCall, ""User does not have call permission"");
        _;
    }

    function modifyAccess(address user, bool canCall, bool isPublic) public onlyWithPermission(msg.sender) {
        permissions[user] = Permission(canCall, isPublic);
        emit AccessModified(user, canCall, isPublic);
    }

    function batchModifyAccess(address[] memory users, bool[] memory canCall, bool[] memory isPublic) public onlyWithPermission(msg.sender) {
        require(users.length == canCall.length && users.length == isPublic.length, ""Input arrays must have the same length"");
        for (uint i = 0; i < users.length; i++) {
            permissions[users[i]] = Permission(canCall[i], isPublic[i]);
        }
        emit BatchAccessModified(users, canCall, isPublic);
    }

    function checkAccess(address user) public view returns (bool canCall, bool isPublic) {
        Permission memory perm = permissions[user];
        return (perm.canCall, perm.isPublic);
    }
}",contract_55.sol
"Design a smart contract to handle the creation and transfer of a Basic Attention Token (BAT). The contract should include functions for creating, transferring, and approving tokens, as well as allowing users to retrieve their token balance. Ensure the contract has logic to prevent token supply from exceeding a set cap. Include modifiers to control the token distribution and refund any remaining funds. The contract should utilize the Solidity programming language and be compatible with the Ethereum blockchain.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract BasicAttentionToken {
    string public name = ""Basic Attention Token"";
    string public symbol = ""BAT"";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    uint256 public cap = 1000000000 * 10 ** uint256(decimals); // 1 billion tokens

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        totalSupply = cap;
        balanceOf[msg.sender] = cap;
        emit Transfer(address(0), msg.sender, cap);
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }

    function increaseCap(uint256 newCap) public {
        require(newCap > cap, ""New cap must be higher than current cap"");
        cap = newCap;
    }

    function refundRemaining(address payable recipient) public {
        require(balanceOf[msg.sender] > 0, ""No balance to refund"");
        uint256 amount = balanceOf[msg.sender];
        balanceOf[msg.sender] = 0;
        recipient.transfer(amount);
    }
}",contract_56.sol
"Create a smart contract that facilitates creating, managing, and withdrawing redirection fees for collections. The contract should allow for setting repositories, routers, and budget managers, as well as chain names, collection creation, and omnichain message receiving. Incorporate ownership management and control for only-owner actions. Define necessary functions and variables within the Solidity contract. Consider compatibility with a blockchain ecosystem.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract FeeManager {
    address public owner;
    mapping(address => bool) public repositories;
    mapping(address => bool) public routers;
    mapping(address => bool) public budgetManagers;
    string[] public chainNames;
    mapping(address => uint256) public collectionFees;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier onlyRepository() {
        require(repositories[msg.sender], ""Not a registered repository"");
        _;
    }

    modifier onlyRouter() {
        require(routers[msg.sender], ""Not a registered router"");
        _;
    }

    modifier onlyBudgetManager() {
        require(budgetManagers[msg.sender], ""Not a registered budget manager"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setRepository(address repo, bool status) external onlyOwner {
        repositories[repo] = status;
    }

    function setRouter(address router, bool status) external onlyOwner {
        routers[router] = status;
    }

    function setBudgetManager(address manager, bool status) external onlyOwner {
        budgetManagers[manager] = status;
    }

    function addChainName(string memory chainName) external onlyOwner {
        chainNames.push(chainName);
    }

    function createCollection(address collection, uint256 fee) external onlyRepository {
        collectionFees[collection] = fee;
    }

    function withdrawFees(address collection, uint256 amount) external onlyBudgetManager {
        require(collectionFees[collection] >= amount, ""Insufficient fees"");
        collectionFees[collection] -= amount;
        payable(msg.sender).transfer(amount);
    }

    function receiveOmnichainMessage(bytes memory message) external onlyRouter {
        // Handle omnichain message
    }

    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0), ""Invalid address"");
        owner = newOwner;
    }

    receive() external payable {
        // Accept ETH for fee deposits
    }
}",contract_57.sol
"Create a Solidity smart contract that enables the deployment and management of ERC721DAOToken, ERC721Timelock, and ERC721Governor contracts, allowing for easy minting, cloning, and initialization of new instances. The contract should provide a basic framework for governance and management of each instance.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}

contract ERC721DAOToken {
    string private _name;
    string private _symbol;
    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function balanceOf(address owner) public view returns (uint256) {
        require(owner != address(0), ""ERC721: balance query for the zero address"");
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) public view returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), ""ERC721: owner query for nonexistent token"");
        return owner;
    }

    function approve(address to, uint256 tokenId) public {
        address owner = ownerOf(tokenId);
        require(to != owner, ""ERC721: approval to current owner"");
        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), ""ERC721: approve caller is not owner nor approved for all"");
        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    function getApproved(uint256 tokenId) public view returns (address) {
        require(_exists(tokenId), ""ERC721: approved query for nonexistent token"");
        return _tokenApprovals[tokenId];
    }

    function setApprovalForAll(address operator, bool approved) public {
        require(operator != msg.sender, ""ERC721: approve to caller"");
        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function isApprovedForAll(address owner, address operator) public view returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function transferFrom(address from, address to, uint256 tokenId) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _transfer(from, to, tokenId);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) public {
        safeTransferFrom(from, to, tokenId, """");
    }

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _safeTransfer(from, to, tokenId, _data);
    }

    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return _owners[tokenId] != address(0);
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    function _safeMint(address to, uint256 tokenId) internal {
        _safeMint(to, tokenId, """");
    }

    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal {
        _mint(to, tokenId);
        require(_checkOnERC721Received(address(0), to, tokenId, _data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _mint(address to, uint256 tokenId) internal {
        require(to != address(0), ""ERC721: mint to the zero address"");
        require(!_exists(tokenId), ""ERC721: token already minted"");
        _beforeTokenTransfer(address(0), to, tokenId);
        _balances[to] += 1;
        _owners[tokenId] = to;
        emit Transfer(address(0), to, tokenId);
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        require(ownerOf(tokenId) == from, ""ERC721: transfer of token that is not own"");
        require(to != address(0), ""ERC721: transfer to the zero address"");
        _beforeTokenTransfer(from, to, tokenId);
        _approve(address(0), tokenId);
        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;
        emit Transfer(from, to, tokenId);
    }

    function _approve(address to, uint256 tokenId) internal {
        _tokenApprovals[tokenId] = to;
        emit Approval(ownerOf(tokenId), to, tokenId);
    }

    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) internal returns (bool) {
        if (to.code.length > 0) {
            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data) returns (bytes4 retval) {
                return retval == IERC721Receiver.onERC721Received.selector;
            } catch (bytes memory reason) {
                if (reason.length == 0) {
                    revert(""ERC721: transfer to non ERC721Receiver implementer"");
                } else {
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        } else {
            return true;
        }
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual {}
}

contract ERC721Timelock {
    address public token;
    uint256 public releaseTime;

    constructor(address token_, uint256 releaseTime_) {
        require(releaseTime_ > block.timestamp, ""ERC721Timelock: release time is before current time"");
        token = token_;
        releaseTime = releaseTime_;
    }

    function withdrawToken(uint256 tokenId) public {
        require(block.timestamp >= releaseTime, ""ERC721Timelock: current time is before release time"");
        ERC721DAOToken(token).safeTransferFrom(address(this), msg.sender, tokenId);
    }
}

contract ERC721Governor {
    ERC721DAOToken public token;
    mapping(uint256 => Proposal) public proposals;
    uint256 public proposalCount;

    struct Proposal {
        address proposer;
        string description;
        uint256 forVotes;
        uint256 againstVotes;
        bool executed;
        mapping(address => bool) voted;
    }

    event ProposalCreated(uint256 id, address proposer, string description);
    event VoteCast(uint256 proposalId, address voter, bool support, uint256 votes);
    event ProposalExecuted(uint256 id);

    constructor(address tokenAddress) {
        token = ERC721DAOToken(tokenAddress);
    }

    function propose(string memory description) public returns (uint256) {
        proposalCount++;
        Proposal storage p = proposals[proposalCount];
        p.proposer = msg.sender;
        p.description = description;
        emit ProposalCreated(proposalCount, msg.sender, description);
        return proposalCount;
    }

    function vote(uint256 proposalId, bool support) public {
        Proposal storage p = proposals[proposalId];
        require(p.proposer != address(0), ""ERC721Governor: proposal does not exist"");
        require(!p.voted[msg.sender], ""ERC721Governor: voter already voted"");
        uint256 balance = token.balanceOf(msg.sender);
        require(balance > 0, ""ERC721Governor: voter has no tokens"");
        p.voted[msg.sender] = true;
        if (support) {
            p.forVotes += balance;
        } else {
            p.againstVotes += balance;
        }
        emit VoteCast(proposalId, msg.sender, support, balance);
    }

    function executeProposal(uint256 proposalId) public {
        Proposal storage p = proposals[proposalId];
        require(p.forVotes > p.againstVotes, ""ERC721Governor: proposal failed"");
        require(!p.executed, ""ERC721Governor: proposal already executed"");
        p.executed = true;
        emit ProposalExecuted(proposalId);
    }
}

contract DAOFactory {
    event TokenCreated(address indexed tokenAddress);
    event TimelockCreated(address indexed timelockAddress);
    event GovernorCreated(address indexed governorAddress);

    function createToken(string memory name, string memory symbol) public returns (address) {
        ERC721DAOToken token = new ERC721DAOToken(name, symbol);
        emit TokenCreated(address(token));
        return address(token);
    }

    function createTimelock(address token, uint256 releaseTime) public returns (address) {
        ERC721Timelock timelock = new ERC721Timelock(token, releaseTime);
        emit TimelockCreated(address(timelock));
        return address(timelock);
    }

    function createGovernor(address token) public returns (address) {
        ERC721Governor governor = new ERC721Governor(token);
        emit GovernorCreated(address(governor));
        return address(governor);
    }
}",contract_58.sol
Create a Solidity smart contract that adapts fees and reserves. The contract should inherit from the FeesAndReservesAdaptor class and override the `feesAndReserves` function to return a FeesAndReserves object. The FeesAndReservesAdaptor class will be imported from the specified location. The contract should be implemented using Solidity version 0.8.16 and include necessary license information.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract FeesAndReservesAdaptor {
    function feesAndReserves() public virtual returns (FeesAndReserves memory) {}
}

struct FeesAndReserves {
    uint256 fee;
    uint256 reserve;
}

contract MyFeesAndReserves is FeesAndReservesAdaptor {
    FeesAndReserves private myFeesAndReserves;

    constructor(uint256 _fee, uint256 _reserve) {
        myFeesAndReserves = FeesAndReserves({
            fee: _fee,
            reserve: _reserve
        });
    }

    function feesAndReserves() public override view returns (FeesAndReserves memory) {
        return myFeesAndReserves;
    }
}",contract_59.sol
"Create a smart contract that enables a betting system for users to participate in. The contract should have functions for depositing funds, placing bets, and withdrawing winnings. Include a system for tracking user balances and betting history. Implement event tracking for deposits, bets, and withdrawals. Make sure to enforce withdrawal and betting limits. Don't forget to provide a clear description of the smart contract's functionality and structure.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract BettingSystem {
    struct User {
        uint balance;
        uint[] betHistory;
    }

    struct Bet {
        address user;
        uint amount;
        bool resolved;
        bool won;
    }

    mapping(address => User) public users;
    Bet[] public bets;
    uint public totalPool;
    uint public withdrawalLimit = 1000; // Example limit
    uint public betLimit = 100; // Example limit

    event Deposit(address indexed user, uint amount);
    event BetPlaced(address indexed user, uint betId, uint amount);
    event Withdrawal(address indexed user, uint amount);

    function deposit() public payable {
        require(msg.value > 0, ""Deposit amount must be greater than zero"");
        users[msg.sender].balance += msg.value;
        totalPool += msg.value;
        emit Deposit(msg.sender, msg.value);
    }

    function placeBet(uint amount) public {
        require(amount > 0 && amount <= betLimit, ""Invalid bet amount"");
        require(users[msg.sender].balance >= amount, ""Insufficient balance"");
        users[msg.sender].balance -= amount;
        totalPool += amount;
        Bet memory newBet = Bet({user: msg.sender, amount: amount, resolved: false, won: false});
        uint betId = bets.length;
        bets.push(newBet);
        users[msg.sender].betHistory.push(betId);
        emit BetPlaced(msg.sender, betId, amount);
    }

    function withdraw(uint amount) public {
        require(amount > 0 && amount <= withdrawalLimit, ""Invalid withdrawal amount"");
        require(users[msg.sender].balance >= amount, ""Insufficient balance"");
        users[msg.sender].balance -= amount;
        totalPool -= amount;
        payable(msg.sender).transfer(amount);
        emit Withdrawal(msg.sender, amount);
    }

    function resolveBet(uint betId, bool won) public {
        require(betId < bets.length, ""Invalid bet ID"");
        Bet storage bet = bets[betId];
        require(!bet.resolved, ""Bet already resolved"");
        bet.resolved = true;
        bet.won = won;
        if (won) {
            users[bet.user].balance += bet.amount * 2; // Example payout
        }
    }

    function getUserBalance(address user) public view returns (uint) {
        return users[user].balance;
    }

    function getUserBetHistory(address user) public view returns (uint[] memory) {
        return users[user].betHistory;
    }
}",contract_60.sol
"Develop a smart contract for the Dai Backstop Syndicate, incorporating functionality for depositing Dai, entering auctions, finalizing auctions, and halting new deposits and auctions. The contract should utilize Solidity's standard libraries and best practices for code organization and readability. Ensure proper event emission and handling for all contract interactions.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DaiBackstopSyndicate {
    address public owner;
    bool public halted;
    uint256 public totalDeposits;

    mapping(address => uint256) public deposits;

    event Deposit(address indexed user, uint256 amount);
    event AuctionEntered(address indexed user, uint256 amount);
    event AuctionFinalized(address indexed user, uint256 amount);
    event Halted(bool status);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier notHalted() {
        require(!halted, ""Contract is halted"");
        _;
    }

    constructor() {
        owner = msg.sender;
        halted = false;
    }

    function deposit(uint256 amount) external notHalted {
        require(amount > 0, ""Amount must be greater than 0"");
        deposits[msg.sender] += amount;
        totalDeposits += amount;
        emit Deposit(msg.sender, amount);
    }

    function enterAuction(uint256 amount) external notHalted {
        require(amount > 0, ""Amount must be greater than 0"");
        require(deposits[msg.sender] >= amount, ""Insufficient balance"");
        deposits[msg.sender] -= amount;
        emit AuctionEntered(msg.sender, amount);
    }

    function finalizeAuction(uint256 amount) external {
        require(amount > 0, ""Amount must be greater than 0"");
        deposits[msg.sender] += amount;
        emit AuctionFinalized(msg.sender, amount);
    }

    function halt(bool status) external onlyOwner {
        halted = status;
        emit Halted(status);
    }
}",contract_61.sol
"Create a smart contract that uses the OpenZeppelin libraries to manage arithmetic operations and a counter variable. The contract should have functions to increment, decrement, and reset the counter. It should also include a mapping to store and retrieve values from an enumerable set. The contract should be structured in a way that is easy to understand and maintain.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Counter {
    uint256 private _counter;

    // EnumerableSet from OpenZeppelin
    struct EnumerableSet {
        uint256[] _values;
        mapping(uint256 => uint256) _indexes;
    }

    EnumerableSet private _set;

    // Events
    event CounterIncremented(uint256 value);
    event CounterDecremented(uint256 value);
    event CounterReset();

    // Constructor
    constructor() {
        _counter = 0;
    }

    // Increment the counter
    function increment() public {
        _counter += 1;
        emit CounterIncremented(_counter);
    }

    // Decrement the counter
    function decrement() public {
        require(_counter > 0, ""Counter: counter underflow"");
        _counter -= 1;
        emit CounterDecremented(_counter);
    }

    // Reset the counter
    function reset() public {
        _counter = 0;
        emit CounterReset();
    }

    // Get the current counter value
    function counter() public view returns (uint256) {
        return _counter;
    }

    // Add a value to the set
    function addToSet(uint256 value) public returns (bool) {
        if (!_set._indexes[value] > 0) {
            _set._values.push(value);
            _set._indexes[value] = _set._values.length;
            return true;
        } else {
            return false;
        }
    }

    // Remove a value from the set
    function removeFromSet(uint256 value) public returns (bool) {
        uint256 valueIndex = _set._indexes[value];
        if (valueIndex > 0) {
            uint256 toDeleteIndex = valueIndex - 1;
            uint256 lastIndex = _set._values.length - 1;
            uint256 lastValue = _set._values[lastIndex];
            _set._values[toDeleteIndex] = lastValue;
            _set._indexes[lastValue] = valueIndex;
            _set._values.pop();
            delete _set._indexes[value];
            return true;
        } else {
            return false;
        }
    }

    // Check if a value is in the set
    function containsInSet(uint256 value) public view returns (bool) {
        return _set._indexes[value] > 0;
    }

    // Get the number of unique values in the set
    function setLength() public view returns (uint256) {
        return _set._values.length;
    }

    // Get the value at a specific index in the set
    function atInSet(uint256 index) public view returns (uint256) {
        require(index < _set._values.length, ""EnumerableSet: index out of bounds"");
        return _set._values[index];
    }
}",contract_62.sol
"Create a Solidity smart contract called 'Gamble' that enables users to make predictions on the outcome of a random event. The contract should have variables to store the maximum bet amount, percentage fee, and bank roll. Write functions to update settings, initialize the bank roll, and place bets. Design a system to determine the winner of a bet and award the winnings.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Gamble {
    address public owner;
    uint256 public maxBetAmount;
    uint256 public percentageFee;
    uint256 public bankRoll;
    bool public bettingActive;

    struct Bet {
        address better;
        uint256 amount;
        uint256 prediction;
        bool resolved;
    }

    Bet[] public bets;

    event BetPlaced(address indexed better, uint256 amount, uint256 prediction);
    event BetResolved(address indexed better, uint256 amount, bool won);
    event SettingsUpdated(uint256 maxBetAmount, uint256 percentageFee);
    event BankRollInitialized(uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
        maxBetAmount = 1 ether; // Example value
        percentageFee = 5; // 5% fee
        bettingActive = false;
    }

    function updateSettings(uint256 _maxBetAmount, uint256 _percentageFee) external onlyOwner {
        maxBetAmount = _maxBetAmount;
        percentageFee = _percentageFee;
        emit SettingsUpdated(maxBetAmount, percentageFee);
    }

    function initializeBankRoll(uint256 _amount) external onlyOwner {
        require(bankRoll == 0, ""Bank roll already initialized"");
        bankRoll = _amount;
        emit BankRollInitialized(_amount);
    }

    function placeBet(uint256 _prediction) external payable {
        require(bettingActive, ""Betting is not active"");
        require(msg.value <= maxBetAmount, ""Bet amount exceeds maximum"");
        require(msg.value > 0, ""Bet amount must be greater than 0"");

        bets.push(Bet({
            better: msg.sender,
            amount: msg.value,
            prediction: _prediction,
            resolved: false
        }));

        emit BetPlaced(msg.sender, msg.value, _prediction);
    }

    function resolveBet(uint256 betIndex, uint256 outcome) external onlyOwner {
        require(betIndex < bets.length, ""Invalid bet index"");
        Bet storage bet = bets[betIndex];
        require(!bet.resolved, ""Bet already resolved"");

        bool won = bet.prediction == outcome;
        if (won) {
            uint256 winnings = bet.amount + (bet.amount * (100 - percentageFee)) / 100;
            require(winnings <= bankRoll, ""Insufficient bank roll to pay winnings"");
            payable(bet.better).transfer(winnings);
            bankRoll -= winnings;
        }

        bet.resolved = true;
        emit BetResolved(bet.better, bet.amount, won);
    }

    function toggleBettingActive() external onlyOwner {
        bettingActive = !bettingActive;
    }

    function withdrawBankRoll(uint256 amount) external onlyOwner {
        require(amount <= bankRoll, ""Insufficient bank roll"");
        bankRoll -= amount;
        payable(owner).transfer(amount);
    }
}",contract_63.sol
"Create a smart contract that interacts with IPriceProvidersAggregator, IPriceProvider, and IAddressProvider. The contract should have methods to retrieve the current price of a token in USD, quote token pairs, and update the address of the IAddressProvider. The implementation should be structured with clear functions and logic, and use modifiers to restrict access to critical functions. Focus on implementing the required functionality without focusing too much on performance or security.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IPriceProvidersAggregator {
    function getPriceProvider(address token) external view returns (IPriceProvider);
}

interface IPriceProvider {
    function getPrice(address token) external view returns (uint256);
    function quote(address tokenIn, address tokenOut, uint256 amountIn) external view returns (uint256 amountOut);
}

interface IAddressProvider {
    function getPriceProvidersAggregator() external view returns (IPriceProvidersAggregator);
    function setPriceProvidersAggregator(IPriceProvidersAggregator newAggregator) external;
}

contract PriceQuoter {
    IAddressProvider public addressProvider;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    address public owner;

    constructor(IAddressProvider _addressProvider) {
        addressProvider = _addressProvider;
        owner = msg.sender;
    }

    function getCurrentPriceInUSD(address token) public view returns (uint256) {
        IPriceProvidersAggregator aggregator = addressProvider.getPriceProvidersAggregator();
        IPriceProvider provider = aggregator.getPriceProvider(token);
        return provider.getPrice(token);
    }

    function quoteTokenPair(address tokenIn, address tokenOut, uint256 amountIn) public view returns (uint256) {
        IPriceProvidersAggregator aggregator = addressProvider.getPriceProvidersAggregator();
        IPriceProvider provider = aggregator.getPriceProvider(tokenIn);
        return provider.quote(tokenIn, tokenOut, amountIn);
    }

    function updateAddressProvider(IAddressProvider newAddressProvider) public onlyOwner {
        addressProvider = newAddressProvider;
    }
}",contract_64.sol
"Create a smart contract that represents a token with the following properties: a limited supply of tokens, the ability to transfer tokens between addresses, and support for approving and allowing of token spend. Implement functions to manage token balances, allow and disallow token transfer, and record transactions. Use Solidity and the SafeMath library to ensure accurate and secure arithmetic operations.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MyToken {
    using SafeMath for uint256;

    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(value);
        balanceOf[to] = balanceOf[to].add(value);
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] = balanceOf[from].sub(value);
        balanceOf[to] = balanceOf[to].add(value);
        allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);
        emit Transfer(from, to, value);
        return true;
    }
}

library SafeMath {
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }
}",contract_65.sol
"Create a smart contract for the PIVOTCHAIN token that allows users to buy and sell tokens, with a fixed total supply, and a specified buy price. Implement functions for users to contribute ether to receive tokens, while keeping track of the creator's balance. Include event logs for transfers and contributions. Make sure to include error checking to prevent token overflows and ensure a fair transfer.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract PIVOTCHAIN {
    string public name = ""PIVOTCHAIN"";
    string public symbol = ""PVT"";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    uint256 public buyPrice;
    address public owner;

    mapping(address => uint256) public balanceOf;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Contribution(address indexed contributor, uint256 value, uint256 tokensReceived);

    constructor(uint256 initialSupply, uint256 _buyPrice) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        buyPrice = _buyPrice;
        owner = msg.sender;
    }

    function buyTokens() public payable {
        require(msg.value > 0, ""Contribution must be greater than 0"");
        uint256 tokensToBuy = msg.value * buyPrice;
        require(tokensToBuy <= balanceOf[owner], ""Not enough tokens available for sale"");
        balanceOf[owner] -= tokensToBuy;
        balanceOf[msg.sender] += tokensToBuy;
        emit Transfer(owner, msg.sender, tokensToBuy);
        emit Contribution(msg.sender, msg.value, tokensToBuy);
    }

    function sellTokens(uint256 tokenAmount) public {
        require(tokenAmount > 0, ""Token amount must be greater than 0"");
        require(balanceOf[msg.sender] >= tokenAmount, ""Insufficient token balance"");
        uint256 etherAmount = tokenAmount / buyPrice;
        require(address(this).balance >= etherAmount, ""Not enough ether in the contract"");
        balanceOf[msg.sender] -= tokenAmount;
        balanceOf[owner] += tokenAmount;
        payable(msg.sender).transfer(etherAmount);
        emit Transfer(msg.sender, owner, tokenAmount);
    }

    function withdrawEther(uint256 amount) public {
        require(msg.sender == owner, ""Only owner can withdraw ether"");
        require(amount <= address(this).balance, ""Insufficient contract balance"");
        payable(owner).transfer(amount);
    }

    receive() external payable {
        buyTokens();
    }
}",contract_66.sol
"Create a smart contract that builds upon the provided Ownable contract and adds features to manage whitelisted addresses, funding managers/operators, and funds unlocker managers/operators. The contract should include functions to add/remove addresses, check role membership, and allow the owner to transfer ownership. Focus on implementing the logic and functions defined in the provided code fragment.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract RoleManager is Ownable {
    mapping(address => bool) private _whitelistedAddresses;
    mapping(address => bool) private _fundingManagers;
    mapping(address => bool) private _fundsUnlockers;

    event AddressAdded(address indexed addr, string role);
    event AddressRemoved(address indexed addr, string role);

    function addWhitelistedAddress(address addr) external onlyOwner {
        _whitelistedAddresses[addr] = true;
        emit AddressAdded(addr, ""whitelisted"");
    }

    function removeWhitelistedAddress(address addr) external onlyOwner {
        _whitelistedAddresses[addr] = false;
        emit AddressRemoved(addr, ""whitelisted"");
    }

    function isWhitelisted(address addr) public view returns (bool) {
        return _whitelistedAddresses[addr];
    }

    function addFundingManager(address addr) external onlyOwner {
        _fundingManagers[addr] = true;
        emit AddressAdded(addr, ""fundingManager"");
    }

    function removeFundingManager(address addr) external onlyOwner {
        _fundingManagers[addr] = false;
        emit AddressRemoved(addr, ""fundingManager"");
    }

    function isFundingManager(address addr) public view returns (bool) {
        return _fundingManagers[addr];
    }

    function addFundsUnlocker(address addr) external onlyOwner {
        _fundsUnlockers[addr] = true;
        emit AddressAdded(addr, ""fundsUnlocker"");
    }

    function removeFundsUnlocker(address addr) external onlyOwner {
        _fundsUnlockers[addr] = false;
        emit AddressRemoved(addr, ""fundsUnlocker"");
    }

    function isFundsUnlocker(address addr) public view returns (bool) {
        return _fundsUnlockers[addr];
    }
}",contract_67.sol
"Create a smart contract that allows users to stake LP tokens in a vault and earn AORI tokens. The contract should retrieve real-time prices from Chainlink. Implement functions for depositing, withdrawing, and claiming AORI tokens. Include a mechanism for whitelisting vaults and oracles. Adhere to the OpenZeppelin ERC20 and ERC4626 standards.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface AggregatorV3Interface {
    function latestRoundData() external view returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    );
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _transferOwnership(_msgSender());
    }

    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), ""Ownable: caller is not the owner"");
    }

    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract ERC20 is Context, IERC20 {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    uint256 private _totalSupply;
    string private _name;
    string private _symbol;

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function name() public view virtual returns (string memory) {
        return _name;
    }

    function symbol() public view virtual returns (string memory) {
        return _symbol;
    }

    function decimals() public view virtual returns (uint8) {
        return 18;
    }

    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        uint256 currentAllowance = _allowances[sender][_msgSender()];
        require(currentAllowance >= amount, ""ERC20: transfer amount exceeds allowance"");
        unchecked {
            _approve(sender, _msgSender(), currentAllowance - amount);
        }
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        uint256 currentAllowance = _allowances[_msgSender()][spender];
        require(currentAllowance >= subtractedValue, ""ERC20: decreased allowance below zero"");
        unchecked {
            _approve(_msgSender(), spender, currentAllowance - subtractedValue);
        }
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");
        uint256 senderBalance = _balances[sender];
        require(senderBalance >= amount, ""ERC20: transfer amount exceeds balance"");
        unchecked {
            _balances[sender] = senderBalance - amount;
        }
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: mint to the zero address"");
        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: burn from the zero address"");
        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, ""ERC20: burn amount exceeds balance"");
        unchecked {
            _balances[account] = accountBalance - amount;
        }
        _totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}

interface IERC4626 is IERC20 {
    function asset() external view returns (address);
    function totalAssets() external view returns (uint256);
    function convertToShares(uint256 assets) external view returns (uint256);
    function convertToAssets(uint256 shares) external view returns (uint256);
    function maxDeposit(address receiver) external view returns (uint256);
    function previewDeposit(uint256 assets) external view returns (uint256);
    function deposit(uint256 assets, address receiver) external returns (uint256);
    function maxMint(address receiver) external view returns (uint256);
    function previewMint(uint256 shares) external view returns (uint256);
    function mint(uint256 shares, address receiver) external returns (uint256);
    function maxWithdraw(address owner) external view returns (uint256);
    function previewWithdraw(uint256 assets) external view returns (uint256);
    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256);
    function maxRedeem(address owner) external view returns (uint256);
    function previewRedeem(uint256 shares) external view returns (uint256);
    function redeem(uint256 shares, address receiver, address owner) external returns (uint256);
}

contract AORIVault is Ownable, ERC20, IERC4626 {
    address public asset;
    address public aoriToken;
    AggregatorV3Interface internal priceFeed;
    mapping(address => bool) public whitelistedVaults;
    mapping(address => bool) public whitelistedOracles;

    constructor(address _asset, address _aoriToken, address _priceFeed) ERC20(""AORIVault"", ""aAORI"") {
        asset = _asset;
        aoriToken = _aoriToken;
        priceFeed = AggregatorV3Interface(_priceFeed);
    }

    function asset() public view override returns (address) {
        return asset;
    }

    function totalAssets() public view override returns (uint256) {
        return IERC20(asset).balanceOf(address(this));
    }

    function convertToShares(uint256 assets) public view override returns (uint256) {
        uint256 supply = totalSupply();
        return supply == 0 ? assets : assets * supply / totalAssets();
    }

    function convertToAssets(uint256 shares) public view override returns (uint256) {
        uint256 supply = totalSupply();
        return supply == 0 ? shares : shares * totalAssets() / supply;
    }

    function maxDeposit(address) public pure override returns (uint256) {
        return type(uint256).max;
    }

    function previewDeposit(uint256 assets) public view override returns (uint256) {
        return convertToShares(assets);
    }

    function deposit(uint256 assets, address receiver) public override returns (uint256) {
        require(assets <= maxDeposit(receiver), ""ERC4626: deposit more than max"");
        uint256 shares = previewDeposit(assets);
        _mint(receiver, shares);
        require(IERC20(asset).transferFrom(_msgSender(), address(this), assets), ""ERC4626: transfer failed"");
        return shares;
    }

    function maxMint(address) public pure override returns (uint256) {
        return type(uint256).max;
    }

    function previewMint(uint256 shares) public view override returns (uint256) {
        uint256 supply = totalSupply();
        return supply == 0 ? shares : shares * totalAssets() / supply;
    }

    function mint(uint256 shares, address receiver) public override returns (uint256) {
        require(shares <= maxMint(receiver), ""ERC4626: mint more than max"");
        uint256 assets = previewMint(shares);
        _mint(receiver, shares);
        require(IERC20(asset).transferFrom(_msgSender(), address(this), assets), ""ERC4626: transfer failed"");
        return assets;
    }

    function maxWithdraw(address owner) public view override returns (uint256) {
        return convertToAssets(balanceOf(owner));
    }

    function previewWithdraw(uint256 assets) public view override returns (uint256) {
        uint256 supply = totalSupply();
        return supply == 0 ? assets : assets * supply / totalAssets();
    }

    function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256) {
        require(assets <= maxWithdraw(owner), ""ERC4626: withdraw more than max"");
        uint256 shares = previewWithdraw(assets);
        _burn(owner, shares);
        require(IERC20(asset).transfer(receiver, assets), ""ERC4626: transfer failed"");
        return shares;
    }

    function maxRedeem(address owner) public view override returns (uint256) {
        return balanceOf(owner);
    }

    function previewRedeem(uint256 shares) public view override returns (uint256) {
        return convertToAssets(shares);
    }

    function redeem(uint256 shares, address receiver, address owner) public override returns (uint256) {
        require(shares <= maxRedeem(owner), ""ERC4626: redeem more than max"");
        uint256 assets = previewRedeem(shares);
        _burn(owner, shares);
        require(IERC20(asset).transfer(receiver, assets), ""ERC4626: transfer failed"");
        return assets;
    }

    function claimAORITokens() public {
        uint256 shares = balanceOf(_msgSender());
        uint256 aoriTokens = shares * 10**18 / 10**18; // Placeholder for actual calculation
        require(IERC20(aoriToken).transfer(_msgSender(), aoriTokens), ""AORIVault: AORI transfer failed"");
    }

    function addWhitelistedVault(address vault) public onlyOwner {
        whitelistedVaults[vault] = true;
    }

    function removeWhitelistedVault(address vault) public onlyOwner {
        whitelistedVaults[vault] = false;
    }

    function addWhitelistedOracle(address oracle) public onlyOwner {
        whitelistedOracles[oracle] = true;
    }

    function removeWhitelistedOracle(address oracle) public onlyOwner {
        whitelistedOracles[oracle] = false;
    }

    function getLatestPrice() public view returns (int) {
        (
            ,
            int price,
            ,
            ,
        ) = priceFeed.latestRoundData();
        return price;
    }
}",contract_68.sol
"Develop a Solidity smart contract that provides a diamond cut facet. The contract should enable users to add, replace, or remove functions from facets and execute functions with delegatecall. Consider the technical aspects of implementing this functionality, such as function selectors and facet addresses.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DiamondCutFacet {
    struct FacetCut {
        address facetAddress;
        FacetCutAction action;
        bytes4[] functionSelectors;
    }

    enum FacetCutAction {
        Add,
        Replace,
        Remove
    }

    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);

    // Function to add, replace, or remove functions from facets
    function diamondCut(
        FacetCut[] memory _diamondCut,
        address _init,
        bytes memory _calldata
    ) external {
        for (uint256 i = 0; i < _diamondCut.length; i++) {
            FacetCut memory cut = _diamondCut[i];
            if (cut.action == FacetCutAction.Add) {
                addFunctions(cut.facetAddress, cut.functionSelectors);
            } else if (cut.action == FacetCutAction.Replace) {
                replaceFunctions(cut.facetAddress, cut.functionSelectors);
            } else if (cut.action == FacetCutAction.Remove) {
                removeFunctions(cut.facetAddress, cut.functionSelectors);
            }
        }
        emit DiamondCut(_diamondCut, _init, _calldata);
        initializeDiamondCut(_init, _calldata);
    }

    // Internal function to add functions to a facet
    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {
        require(_functionSelectors.length > 0, ""LibDiamond: No selectors in facet to cut"");
        for (uint256 i = 0; i < _functionSelectors.length; i++) {
            bytes4 selector = _functionSelectors[i];
            addFunction(selector, _facetAddress);
        }
    }

    // Internal function to replace functions in a facet
    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {
        require(_functionSelectors.length > 0, ""LibDiamond: No selectors in facet to cut"");
        for (uint256 i = 0; i < _functionSelectors.length; i++) {
            bytes4 selector = _functionSelectors[i];
            replaceFunction(selector, _facetAddress);
        }
    }

    // Internal function to remove functions from a facet
    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {
        require(_functionSelectors.length > 0, ""LibDiamond: No selectors in facet to cut"");
        for (uint256 i = 0; i < _functionSelectors.length; i++) {
            bytes4 selector = _functionSelectors[i];
            removeFunction(selector);
        }
    }

    // Internal function to add a single function to a facet
    function addFunction(bytes4 _selector, address _facetAddress) internal {
        // Implementation for adding a function
    }

    // Internal function to replace a single function in a facet
    function replaceFunction(bytes4 _selector, address _facetAddress) internal {
        // Implementation for replacing a function
    }

    // Internal function to remove a single function from a facet
    function removeFunction(bytes4 _selector) internal {
        // Implementation for removing a function
    }

    // Internal function to initialize the diamond cut
    function initializeDiamondCut(address _init, bytes memory _calldata) internal {
        if (_init == address(0)) {
            require(_calldata.length == 0, ""LibDiamond: _init is address(0) but_calldata is not empty"");
        } else {
            require(_calldata.length > 0, ""LibDiamond: _calldata is empty but _init is not address(0)"");
            if (_init != address(this)) {
                enforceHasContractCode(_init, ""LibDiamond: _init address has no code"");
            }
            (bool success, bytes memory error) = _init.delegatecall(_calldata);
            if (!success) {
                if (error.length > 0) {
                    // bubble up the error
                    revert(string(error));
                } else {
                    revert(""LibDiamond: _init function reverted"");
                }
            }
        }
    }

    // Internal function to enforce that the contract has code
    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {
        uint256 contractSize;
        assembly {
            contractSize := extcodesize(_contract)
        }
        require(contractSize > 0, _errorMessage);
    }
}",contract_69.sol
"Write a Solidity smart contract that allows for token transfers between users, implements approval and allowance functions for spending tokens, and includes emission of events for successful transfers and approvals. The contract should be an extension of the StandardToken contract and have variables for the total supply, balance, and approved addresses. Token transfers and approvals should be implemented.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract StandardToken {
    mapping(address => uint256) internal _balances;
    mapping(address => mapping(address => uint256)) internal _allowances;
    uint256 internal _totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract MyToken is StandardToken {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;

    constructor(uint256 initialSupply) {
        _totalSupply = initialSupply * 10 ** uint256(decimals);
        _balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        require(_balances[msg.sender] >= amount, ""Transfer amount exceeds balance"");
        _balances[msg.sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        require(_balances[sender] >= amount, ""Transfer amount exceeds balance"");
        require(_allowances[sender][msg.sender] >= amount, ""Transfer amount exceeds allowance"");
        _balances[sender] -= amount;
        _balances[recipient] += amount;
        _allowances[sender][msg.sender] -= amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }
}",contract_70.sol
"Create a smart contract that manages token allocation and distribution. The contract should enable users to mint and burn tokens, as well as claim rewards from the community fund and dev fund. The contract should also have a vesting period for token distribution and a reward rate calculation. The contract should include a function for setting the treasury fund and dev fund, as well as a function to distribute farming incentives. Ensure that the contract includes the necessary logic for token distribution and implementation of the OpenZeppelin contracts.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TokenManagement {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    address public owner;
    address public treasuryFund;
    address public devFund;
    uint256 public vestingPeriod;
    uint256 public rewardRate;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Mint(address indexed to, uint256 value);
    event Burn(address indexed from, uint256 value);
    event RewardClaimed(address indexed user, uint256 value);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor(uint256 initialSupply, uint256 _vestingPeriod, uint256 _rewardRate) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        owner = msg.sender;
        vestingPeriod = _vestingPeriod;
        rewardRate = _rewardRate;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance too low"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }

    function mint(address to, uint256 value) public onlyOwner returns (bool success) {
        totalSupply += value;
        balanceOf[to] += value;
        emit Mint(to, value);
        emit Transfer(address(0), to, value);
        return true;
    }

    function burn(uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        totalSupply -= value;
        balanceOf[msg.sender] -= value;
        emit Burn(msg.sender, value);
        emit Transfer(msg.sender, address(0), value);
        return true;
    }

    function setTreasuryFund(address _treasuryFund) public onlyOwner {
        treasuryFund = _treasuryFund;
    }

    function setDevFund(address _devFund) public onlyOwner {
        devFund = _devFund;
    }

    function claimReward(address user, uint256 value) public returns (bool success) {
        require(balanceOf[treasuryFund] >= value, ""Insufficient treasury fund balance"");
        balanceOf[treasuryFund] -= value;
        balanceOf[user] += value;
        emit RewardClaimed(user, value);
        emit Transfer(treasuryFund, user, value);
        return true;
    }

    function distributeFarmingIncentives(address to, uint256 value) public onlyOwner returns (bool success) {
        require(balanceOf[devFund] >= value, ""Insufficient dev fund balance"");
        balanceOf[devFund] -= value;
        balanceOf[to] += value;
        emit Transfer(devFund, to, value);
        return true;
    }
}",contract_71.sol
Create a smart contract that enables the control and management of ownership. The contract should allow for the transfer of ownership to a new address and renounce ownership. It should also set the initial owner. Use the provided code fragment as a reference and implement the necessary functions and logic for ownership management.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    modifier onlyOwner() {
        require(msg.sender == _owner, ""Ownable: caller is not the owner"");
        _;
    }

    function owner() public view returns (address) {
        return _owner;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }

    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }
}",contract_72.sol
"Create a smart contract that follows the IERC20 token standard. It should include functions for total supply, balance checking, sending tokens, approving transfers, and handling transfer requests. Utilize the SafeMath and Address libraries to ensure accurate calculations and efficient interaction. Focus on a clean and readable code structure.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20 {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    mapping(address => uint256) private balances;
    mapping(address => mapping(address => uint256)) private allowed;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply;
        balances[msg.sender] = _totalSupply;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0), ""Invalid address"");
        require(balances[msg.sender] >= _value, ""Insufficient balance"");
        balances[msg.sender] = balances[msg.sender] - _value;
        balances[_to] = balances[_to] + _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        require(_spender != address(0), ""Invalid address"");
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_from != address(0) && _to != address(0), ""Invalid address"");
        require(balances[_from] >= _value, ""Insufficient balance"");
        require(allowed[_from][msg.sender] >= _value, ""Allowance too low"");
        balances[_from] = balances[_from] - _value;
        balances[_to] = balances[_to] + _value;
        allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }
}

library Address {
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}",contract_73.sol
"Create a smart contract that represents a standard token with custom details. The contract should include functions for transferring tokens, approving token spending, and checking balances. It should also handle token approvals and have a total supply of tokens. Make sure to include event triggers for token transfer and approval events.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract StandardToken {
    string public name = ""StandardToken"";
    string public symbol = ""STK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private balances;
    mapping(address => mapping(address => uint256)) private allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 _initialSupply) {
        totalSupply = _initialSupply * 10 ** uint256(decimals);
        balances[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value, ""Insufficient balance"");
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowances[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balances[_from], ""Insufficient balance"");
        require(_value <= allowances[_from][msg.sender], ""Allowance too low"");
        balances[_from] -= _value;
        balances[_to] += _value;
        allowances[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowances[_owner][_spender];
    }
}",contract_74.sol
"Create a Solidity smart contract that allows users to manage factories and instances. The contract should provide functions for registering new factories and instances, retrieving factory and instance information, and retrieving paginated lists of factories and instances. The contract should also handle factory and instance retirement. Note: You can refer to the provided iRegistry interface for guidance on the required functions and their functionality.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract FactoryManager {
    struct Factory {
        address owner;
        string name;
        bool isActive;
    }

    struct Instance {
        address factoryAddress;
        address instanceAddress;
        string name;
        bool isActive;
    }

    Factory[] public factories;
    mapping(address => Instance[]) public instances;
    mapping(address => bool) public factoryExists;
    mapping(address => mapping(address => bool)) public instanceExists;

    event FactoryRegistered(address indexed owner, address indexed factoryAddress, string name);
    event InstanceRegistered(address indexed factoryAddress, address indexed instanceAddress, string name);
    event FactoryRetired(address indexed factoryAddress);
    event InstanceRetired(address indexed instanceAddress);

    function registerFactory(address _factoryAddress, string memory _name) public {
        require(!factoryExists[_factoryAddress], ""Factory already registered"");
        factories.push(Factory({owner: msg.sender, name: _name, isActive: true}));
        factoryExists[_factoryAddress] = true;
        emit FactoryRegistered(msg.sender, _factoryAddress, _name);
    }

    function registerInstance(address _factoryAddress, address _instanceAddress, string memory _name) public {
        require(factoryExists[_factoryAddress], ""Factory not registered"");
        require(!instanceExists[_factoryAddress][_instanceAddress], ""Instance already registered"");
        instances[_factoryAddress].push(Instance({factoryAddress: _factoryAddress, instanceAddress: _instanceAddress, name: _name, isActive: true}));
        instanceExists[_factoryAddress][_instanceAddress] = true;
        emit InstanceRegistered(_factoryAddress, _instanceAddress, _name);
    }

    function retireFactory(address _factoryAddress) public {
        require(factoryExists[_factoryAddress], ""Factory not registered"");
        for (uint i = 0; i < factories.length; i++) {
            if (factories[i].owner == msg.sender && factories[i].isActive) {
                factories[i].isActive = false;
                emit FactoryRetired(_factoryAddress);
                break;
            }
        }
    }

    function retireInstance(address _factoryAddress, address _instanceAddress) public {
        require(instanceExists[_factoryAddress][_instanceAddress], ""Instance not registered"");
        for (uint i = 0; i < instances[_factoryAddress].length; i++) {
            if (instances[_factoryAddress][i].instanceAddress == _instanceAddress && instances[_factoryAddress][i].isActive) {
                instances[_factoryAddress][i].isActive = false;
                emit InstanceRetired(_instanceAddress);
                break;
            }
        }
    }

    function getFactories(uint _start, uint _count) public view returns (Factory[] memory) {
        uint end = _start + _count;
        if (end > factories.length) {
            end = factories.length;
        }
        Factory[] memory result = new Factory[](end - _start);
        for (uint i = _start; i < end; i++) {
            result[i - _start] = factories[i];
        }
        return result;
    }

    function getInstances(address _factoryAddress, uint _start, uint _count) public view returns (Instance[] memory) {
        uint end = _start + _count;
        if (end > instances[_factoryAddress].length) {
            end = instances[_factoryAddress].length;
        }
        Instance[] memory result = new Instance[](end - _start);
        for (uint i = _start; i < end; i++) {
            result[i - _start] = instances[_factoryAddress][i];
        }
        return result;
    }
}",contract_75.sol
Create a smart contract that builds upon OpenZeppelin's Ownable contract and adds a function to calculate the total value of a given asset. Use the provided formula to ensure accurate calculations. The contract should only allow the owner to transfer ownership and access specific functions. Implement smart contract best practices and include relevant error handling and debugging mechanisms.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function owner() public view returns (address) {
        return _owner;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract AssetValueCalculator is Ownable {
    struct Asset {
        uint256 quantity;
        uint256 price;
    }

    mapping(address => Asset) public assets;

    event AssetAdded(address indexed assetOwner, uint256 quantity, uint256 price);
    event AssetUpdated(address indexed assetOwner, uint256 quantity, uint256 price);

    function addAsset(uint256 _quantity, uint256 _price) external onlyOwner {
        require(_quantity > 0, ""Quantity must be greater than zero"");
        require(_price > 0, ""Price must be greater than zero"");

        assets[msg.sender] = Asset(_quantity, _price);
        emit AssetAdded(msg.sender, _quantity, _price);
    }

    function updateAsset(uint256 _quantity, uint256 _price) external onlyOwner {
        require(_quantity > 0, ""Quantity must be greater than zero"");
        require(_price > 0, ""Price must be greater than zero"");
        require(assets[msg.sender].quantity > 0, ""Asset does not exist"");

        assets[msg.sender] = Asset(_quantity, _price);
        emit AssetUpdated(msg.sender, _quantity, _price);
    }

    function calculateTotalValue(address _assetOwner) public view onlyOwner returns (uint256) {
        Asset memory asset = assets[_assetOwner];
        require(asset.quantity > 0, ""Asset does not exist"");

        return asset.quantity * asset.price;
    }
}",contract_76.sol
"Create a smart contract that builds upon the provided Solidity code fragment. Incorporate the necessary functions and interfaces (IBEP20, IDEXFactory) to manage BEP20 tokens and create trading pairs with IDEX. Implement authorization mechanisms to restrict specific functionality to authorized addresses. Focus on developing a robust and secure smart contract that meets the requirements of the provided code fragment.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IBEP20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface IDEXFactory {
    function createPair(address tokenA, address tokenB) external returns (address pair);
}

contract Token is IBEP20 {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 private _totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    mapping(address => bool) private _authorized;

    address public owner;
    IDEXFactory public dexFactory;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier onlyAuthorized() {
        require(_authorized[msg.sender], ""Not authorized"");
        _;
    }

    constructor(uint256 initialSupply, address factoryAddress) {
        _totalSupply = initialSupply * 10 ** uint256(decimals);
        _balances[msg.sender] = _totalSupply;
        owner = msg.sender;
        dexFactory = IDEXFactory(factoryAddress);
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function totalSupply() external view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) external view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) external override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) external view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) external override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    function authorize(address account) external onlyOwner {
        _authorized[account] = true;
    }

    function deauthorize(address account) external onlyOwner {
        _authorized[account] = false;
    }

    function createTradingPair(address tokenB) external onlyAuthorized returns (address) {
        return dexFactory.createPair(address(this), tokenB);
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""Transfer from the zero address"");
        require(recipient != address(0), ""Transfer to the zero address"");
        require(_balances[sender] >= amount, ""Transfer amount exceeds balance"");

        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""Approve from the zero address"");
        require(spender != address(0), ""Approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}",contract_77.sol
"Develop a smart contract that allows for wallet address balance increases, utilizes a specific function to perform the transfer, and includes error handling for insufficient balance and invalid target addresses. The contract should be structured to utilize OpenZeppelin's Initializable contract and AddressUpgradeable library. Implement a user-friendly interface for sending the specified amount to the target address.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Initializable {
    bool private _initialized;
    bool private _initializing;

    modifier initializer() {
        require(!_initialized, ""Initializable: contract is already initialized"");
        _;
    }

    modifier initializer() {
        bool isTopLevelCall = !_initializing;
        require(
            isTopLevelCall && !_initialized,
            ""Initializable: contract is already initialized""
        );
        _initialized = true;
        if (isTopLevelCall) {
            _initializing = true;
        }
        _;
        if (isTopLevelCall) {
            _initializing = false;
        }
    }
}

library AddressUpgradeable {
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }
}

contract WalletBalance is Initializable {
    mapping(address => uint256) private balances;

    function initialize() public initializer {
        // Initialization code
    }

    function increaseBalance(address wallet, uint256 amount) external {
        require(wallet != address(0), ""Invalid wallet address"");
        balances[wallet] += amount;
    }

    function transfer(address to, uint256 amount) external {
        require(to != address(0), ""Invalid target address"");
        require(balances[msg.sender] >= amount, ""Insufficient balance"");

        balances[msg.sender] -= amount;
        balances[to] += amount;
    }

    function getBalance(address wallet) external view returns (uint256) {
        return balances[wallet];
    }
}",contract_78.sol
"Create a smart contract that manages a digital currency, allowing users to transfer funds and approve addresses to spend tokens. The contract should keep track of token balances and support operations such as transferring funds, approving other addresses, and retrieving the remaining allowance.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DigitalCurrency {
    string public name = ""MyDigitalCurrency"";
    string public symbol = ""MDC"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance too low"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }

    function getAllowance(address owner, address spender) public view returns (uint256 remaining) {
        return allowance[owner][spender];
    }
}",contract_79.sol
"Create a smart contract that allows users to stake, update, and claim rewards for a specific token. The contract should enable users to create pools with varying allocation points and manage staking and unstaking of tokens. Implement functions for creating, updating, and maintaining pools, as well as handling staking, unstaking, emergency unstaking, claiming, and tier obtaining. Utilize the OpenZeppelin library for Ownable and Pausable features. Ensure that the contract tracks the total allocation points and service balance. Include event logs for each action.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract StakingRewards is Ownable, Pausable {
    struct PoolInfo {
        IERC20 token;
        uint256 allocationPoints;
        uint256 lastRewardBlock;
        uint256 accRewardPerShare;
    }

    struct UserInfo {
        uint256 amount;
        uint256 rewardDebt;
    }

    IERC20 public rewardToken;
    uint256 public rewardPerBlock;
    uint256 public totalAllocationPoints;
    uint256 public startBlock;

    PoolInfo[] public poolInfo;
    mapping(uint256 => mapping(address => UserInfo)) public userInfo;

    event PoolCreated(uint256 indexed pid, uint256 allocationPoints);
    event PoolUpdated(uint256 indexed pid, uint256 allocationPoints);
    event Staked(address indexed user, uint256 indexed pid, uint256 amount);
    event Unstaked(address indexed user, uint256 indexed pid, uint256 amount);
    event EmergencyUnstaked(address indexed user, uint256 indexed pid, uint256 amount);
    event RewardClaimed(address indexed user, uint256 indexed pid, uint256 amount);

    constructor(IERC20 _rewardToken, uint256 _rewardPerBlock, uint256 _startBlock) {
        rewardToken = _rewardToken;
        rewardPerBlock = _rewardPerBlock;
        startBlock = _startBlock;
    }

    function createPool(IERC20 _token, uint256 _allocationPoints) external onlyOwner {
        totalAllocationPoints += _allocationPoints;
        poolInfo.push(PoolInfo({
            token: _token,
            allocationPoints: _allocationPoints,
            lastRewardBlock: block.number > startBlock ? block.number : startBlock,
            accRewardPerShare: 0
        }));
        emit PoolCreated(poolInfo.length - 1, _allocationPoints);
    }

    function updatePool(uint256 _pid, uint256 _allocationPoints) external onlyOwner {
        PoolInfo storage pool = poolInfo[_pid];
        totalAllocationPoints = totalAllocationPoints - pool.allocationPoints + _allocationPoints;
        pool.allocationPoints = _allocationPoints;
        emit PoolUpdated(_pid, _allocationPoints);
    }

    function stake(uint256 _pid, uint256 _amount) external whenNotPaused {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        updatePoolRewards(_pid);
        if (user.amount > 0) {
            uint256 pending = user.amount * pool.accRewardPerShare / 1e12 - user.rewardDebt;
            if (pending > 0) {
                safeRewardTransfer(msg.sender, pending);
            }
        }
        if (_amount > 0) {
            pool.token.transferFrom(msg.sender, address(this), _amount);
            user.amount += _amount;
        }
        user.rewardDebt = user.amount * pool.accRewardPerShare / 1e12;
        emit Staked(msg.sender, _pid, _amount);
    }

    function unstake(uint256 _pid, uint256 _amount) external {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        require(user.amount >= _amount, ""unstake: not good"");
        updatePoolRewards(_pid);
        uint256 pending = user.amount * pool.accRewardPerShare / 1e12 - user.rewardDebt;
        if (pending > 0) {
            safeRewardTransfer(msg.sender, pending);
        }
        if (_amount > 0) {
            user.amount -= _amount;
            pool.token.transfer(msg.sender, _amount);
        }
        user.rewardDebt = user.amount * pool.accRewardPerShare / 1e12;
        emit Unstaked(msg.sender, _pid, _amount);
    }

    function emergencyUnstake(uint256 _pid, uint256 _amount) external {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        require(user.amount >= _amount, ""emergencyUnstake: not good"");
        user.amount -= _amount;
        pool.token.transfer(msg.sender, _amount);
        emit EmergencyUnstaked(msg.sender, _pid, _amount);
    }

    function claimReward(uint256 _pid) external {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        updatePoolRewards(_pid);
        uint256 pending = user.amount * pool.accRewardPerShare / 1e12 - user.rewardDebt;
        if (pending > 0) {
            safeRewardTransfer(msg.sender, pending);
            emit RewardClaimed(msg.sender, _pid, pending);
        }
        user.rewardDebt = user.amount * pool.accRewardPerShare / 1e12;
    }

    function updatePoolRewards(uint256 _pid) internal {
        PoolInfo storage pool = poolInfo[_pid];
        if (block.number <= pool.lastRewardBlock) {
            return;
        }
        uint256 tokenSupply = pool.token.balanceOf(address(this));
        if (tokenSupply == 0) {
            pool.lastRewardBlock = block.number;
            return;
        }
        uint256 multiplier = block.number - pool.lastRewardBlock;
        uint256 reward = multiplier * rewardPerBlock * pool.allocationPoints / totalAllocationPoints;
        pool.accRewardPerShare += reward * 1e12 / tokenSupply;
        pool.lastRewardBlock = block.number;
    }

    function safeRewardTransfer(address _to, uint256 _amount) internal {
        uint256 rewardBal = rewardToken.balanceOf(address(this));
        if (_amount > rewardBal) {
            rewardToken.transfer(_to, rewardBal);
        } else {
            rewardToken.transfer(_to, _amount);
        }
    }

    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }
}

abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _transferOwnership(msg.sender);
    }

    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

abstract contract Pausable is Ownable {
    event Paused(address account);
    event Unpaused(address account);

    bool private _paused;

    constructor() {
        _paused = false;
    }

    modifier whenNotPaused() {
        require(!paused(), ""Pausable: paused"");
        _;
    }

    modifier whenPaused() {
        require(paused(), ""Pausable: not paused"");
        _;
    }

    function paused() public view virtual returns (bool) {
        return _paused;
    }

    function _pause() internal virtual whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    function _unpause() internal virtual whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}",contract_80.sol
"Create a smart contract that implements a tax office with the ability to set tax tiers and enable or disable tax exclusions for certain addresses. The contract should also store addresses for pumpkin, wftm, and uniRouter. Include a function to set tax tiers via TWAP and ensure only authorized operators can perform this action. Utilize the SafeMath library for mathematical operations.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, ""SafeMath: modulo by zero"");
        return a % b;
    }
}

contract TaxOffice {
    using SafeMath for uint256;

    address public pumpkin;
    address public wftm;
    address public uniRouter;
    address public operator;

    struct TaxTier {
        uint256 lowerLimit;
        uint256 upperLimit;
        uint256 taxRate;
    }

    TaxTier[] public taxTiers;
    mapping(address => bool) public taxExclusions;

    modifier onlyOperator() {
        require(msg.sender == operator, ""Not the operator"");
        _;
    }

    constructor(address _pumpkin, address _wftm, address _uniRouter) {
        pumpkin = _pumpkin;
        wftm = _wftm;
        uniRouter = _uniRouter;
        operator = msg.sender;
    }

    function setTaxTiers(uint256[] memory lowerLimits, uint256[] memory upperLimits, uint256[] memory taxRates) external onlyOperator {
        require(lowerLimits.length == upperLimits.length && lowerLimits.length == taxRates.length, ""Array lengths mismatch"");
        for (uint256 i = 0; i < taxTiers.length; i++) {
            taxTiers.pop();
        }
        for (uint256 i = 0; i < lowerLimits.length; i++) {
            taxTiers.push(TaxTier({
                lowerLimit: lowerLimits[i],
                upperLimit: upperLimits[i],
                taxRate: taxRates[i]
            }));
        }
    }

    function enableTaxExclusion(address excludedAddress) external onlyOperator {
        taxExclusions[excludedAddress] = true;
    }

    function disableTaxExclusion(address excludedAddress) external onlyOperator {
        taxExclusions[excludedAddress] = false;
    }

    function setOperator(address newOperator) external onlyOperator {
        operator = newOperator;
    }

    function getTaxRate(uint256 amount) public view returns (uint256) {
        for (uint256 i = 0; i < taxTiers.length; i++) {
            if (amount >= taxTiers[i].lowerLimit && amount <= taxTiers[i].upperLimit) {
                return taxTiers[i].taxRate;
            }
        }
        return 0; // Default tax rate if no tier matches
    }
}",contract_81.sol
"Create a smart contract that follows the ERC-20 token standard, with functions for managing token supply, balances, and transfers. The contract should include a mechanism for setting a fee recipient and distributing transfer fees. Additionally, provide functions for approving and managing token allowance for spending and transferring. Note: ensure the contract uses safe arithmetic operations and follows best practices for secure coding.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    address public feeRecipient;
    uint256 public transferFeePercentage;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event FeeRecipientSet(address indexed newFeeRecipient);
    event TransferFeePercentageSet(uint256 newTransferFeePercentage);

    constructor(uint256 initialSupply, address _feeRecipient, uint256 _transferFeePercentage) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        feeRecipient = _feeRecipient;
        transferFeePercentage = _transferFeePercentage;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");

        uint256 fee = (value * transferFeePercentage) / 100;
        uint256 transferAmount = value - fee;

        balanceOf[msg.sender] -= value;
        balanceOf[to] += transferAmount;
        balanceOf[feeRecipient] += fee;

        emit Transfer(msg.sender, to, transferAmount);
        emit Transfer(msg.sender, feeRecipient, fee);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");

        uint256 fee = (value * transferFeePercentage) / 100;
        uint256 transferAmount = value - fee;

        balanceOf[from] -= value;
        balanceOf[to] += transferAmount;
        balanceOf[feeRecipient] += fee;

        allowance[from][msg.sender] -= value;

        emit Transfer(from, to, transferAmount);
        emit Transfer(from, feeRecipient, fee);
        return true;
    }

    function setFeeRecipient(address newFeeRecipient) public {
        require(msg.sender == feeRecipient, ""Only fee recipient can set new fee recipient"");
        feeRecipient = newFeeRecipient;
        emit FeeRecipientSet(newFeeRecipient);
    }

    function setTransferFeePercentage(uint256 newTransferFeePercentage) public {
        require(msg.sender == feeRecipient, ""Only fee recipient can set transfer fee percentage"");
        transferFeePercentage = newTransferFeePercentage;
        emit TransferFeePercentageSet(newTransferFeePercentage);
    }
}",contract_82.sol
"Create a smart contract that enables the transfer of tokens, approval of allowance, and transfer of ETH. The contract should include functions for safe transfer from, safe transfer, safe approve, and safe transfer ETH. Implement basic error handling and logging. Ensure the contract's functionality is structured and readable.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TokenTransfer {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    uint256 private _totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event TransferETH(address indexed from, address indexed to, uint256 value);

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function safeTransfer(address to, uint256 value) public returns (bool) {
        require(to != address(0), ""Transfer to the zero address"");
        require(_balances[msg.sender] >= value, ""Insufficient balance"");

        _balances[msg.sender] -= value;
        _balances[to] += value;

        emit Transfer(msg.sender, to, value);
        return true;
    }

    function safeTransferFrom(address from, address to, uint256 value) public returns (bool) {
        require(to != address(0), ""Transfer to the zero address"");
        require(_balances[from] >= value, ""Insufficient balance"");
        require(_allowances[from][msg.sender] >= value, ""Allowance too low"");

        _balances[from] -= value;
        _balances[to] += value;
        _allowances[from][msg.sender] -= value;

        emit Transfer(from, to, value);
        return true;
    }

    function safeApprove(address spender, uint256 value) public returns (bool) {
        require(spender != address(0), ""Approve to the zero address"");

        _allowances[msg.sender][spender] = value;

        emit Approval(msg.sender, spender, value);
        return true;
    }

    function safeTransferETH(address payable to, uint256 value) public payable returns (bool) {
        require(to != address(0), ""Transfer to the zero address"");
        require(address(this).balance >= value, ""Insufficient ETH balance"");

        (bool success, ) = to.call{value: value}("""");
        require(success, ""ETH transfer failed"");

        emit TransferETH(msg.sender, to, value);
        return true;
    }

    function mint(address account, uint256 amount) public {
        require(account != address(0), ""Mint to the zero address"");

        _totalSupply += amount;
        _balances[account] += amount;

        emit Transfer(address(0), account, amount);
    }

    function burn(address account, uint256 amount) public {
        require(account != address(0), ""Burn from the zero address"");
        require(_balances[account] >= amount, ""Insufficient balance"");

        _totalSupply -= amount;
        _balances[account] -= amount;

        emit Transfer(account, address(0), amount);
    }
}",contract_83.sol
"Develop a smart contract that controls access to specific roles within a decentralized application. The contract should include functionality for creating and managing roles, assigning roles to accounts, and revoking roles. It should also include a mechanism to enforce role-based access control. Provide functions for retrieving role admins and checking role membership. Implement string library functions for address and hexadecimal conversions. Focus on ensuring the contract meets the requirements outlined in the IAccessControl interface.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract AccessControl {
    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    struct RoleData {
        mapping(address => bool) members;
        bytes32 adminRole;
    }

    mapping(bytes32 => RoleData) private _roles;

    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    function hasRole(bytes32 role, address account) public view returns (bool) {
        return _roles[role].members[account];
    }

    function getRoleAdmin(bytes32 role) public view returns (bytes32) {
        return _roles[role].adminRole;
    }

    function grantRole(bytes32 role, address account) public {
        require(hasRole(_roles[role].adminRole, msg.sender), ""AccessControl: sender must be an admin to grant"");
        _grantRole(role, account);
    }

    function revokeRole(bytes32 role, address account) public {
        require(hasRole(_roles[role].adminRole, msg.sender), ""AccessControl: sender must be an admin to revoke"");
        _revokeRole(role, account);
    }

    function renounceRole(bytes32 role, address account) public {
        require(account == msg.sender, ""AccessControl: can only renounce roles for self"");
        _revokeRole(role, account);
    }

    function _setupRole(bytes32 role, address account) internal {
        _grantRole(role, account);
    }

    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {
        bytes32 previousAdminRole = _roles[role].adminRole;
        _roles[role].adminRole = adminRole;
        emit RoleAdminChanged(role, previousAdminRole, adminRole);
    }

    function _grantRole(bytes32 role, address account) private {
        if (!hasRole(role, account)) {
            _roles[role].members[account] = true;
            emit RoleGranted(role, account, msg.sender);
        }
    }

    function _revokeRole(bytes32 role, address account) private {
        if (hasRole(role, account)) {
            _roles[role].members[account] = false;
            emit RoleRevoked(role, account, msg.sender);
        }
    }

    function toString(address account) public pure returns (string memory) {
        return toString(abi.encodePacked(account));
    }

    function toString(bytes memory data) public pure returns (string memory) {
        bytes memory alphabet = ""0123456789abcdef"";

        bytes memory str = new bytes(2 + data.length * 2);
        str[0] = ""0"";
        str[1] = ""x"";
        for (uint i = 0; i < data.length; i++) {
            str[2 + i * 2] = alphabet[uint(uint8(data[i] >> 4))];
            str[3 + i * 2] = alphabet[uint(uint8(data[i] & 0x0f))];
        }
        return string(str);
    }
}",contract_84.sol
"Create a Solidity contract that allows for the minting of tokens. The contract should have functions for presale and public minting, and include variables for maximum supply, public and presale prices, and allowed mint limits. The contract should also have functions for withdrawing funds and setting the merkle root. Implement a constructor that initializes the contract name and symbol.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TokenMinting {
    string public name;
    string public symbol;
    uint256 public totalSupply;
    uint256 public maxSupply;
    uint256 public publicPrice;
    uint256 public presalePrice;
    uint256 public publicMintLimit;
    uint256 public presaleMintLimit;
    bytes32 public merkleRoot;
    address public owner;

    mapping(address => uint256) public balanceOf;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor(string memory _name, string memory _symbol, uint256 _maxSupply, uint256 _publicPrice, uint256 _presalePrice, uint256 _publicMintLimit, uint256 _presaleMintLimit) {
        name = _name;
        symbol = _symbol;
        maxSupply = _maxSupply;
        publicPrice = _publicPrice;
        presalePrice = _presalePrice;
        publicMintLimit = _publicMintLimit;
        presaleMintLimit = _presaleMintLimit;
        owner = msg.sender;
    }

    function mintPublic(uint256 amount) public payable {
        require(totalSupply + amount <= maxSupply, ""Exceeds max supply"");
        require(amount <= publicMintLimit, ""Exceeds public mint limit"");
        require(msg.value >= publicPrice * amount, ""Insufficient funds"");

        totalSupply += amount;
        balanceOf[msg.sender] += amount;
    }

    function mintPresale(uint256 amount, bytes32[] calldata merkleProof) public payable {
        require(totalSupply + amount <= maxSupply, ""Exceeds max supply"");
        require(amount <= presaleMintLimit, ""Exceeds presale mint limit"");
        require(msg.value >= presalePrice * amount, ""Insufficient funds"");
        require(verify(merkleProof, merkleRoot, keccak256(abi.encodePacked(msg.sender))), ""Invalid proof"");

        totalSupply += amount;
        balanceOf[msg.sender] += amount;
    }

    function setMerkleRoot(bytes32 _merkleRoot) public onlyOwner {
        merkleRoot = _merkleRoot;
    }

    function withdrawFunds() public onlyOwner {
        payable(owner).transfer(address(this).balance);
    }

    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {
        bytes32 computedHash = leaf;

        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];

            if (computedHash <= proofElement) {
                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));
            } else {
                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));
            }
        }

        return computedHash == root;
    }
}",contract_85.sol
"Create a smart contract that allows for minting of a new token, with specific name, symbol, and decimals. The contract should also enable token transfer, allow for approval and increase/decrease approval, and implement burn functionality. Ownership is also important, ensuring that only the owner can transfer tokens.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MyToken {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    address public owner;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Burn(address indexed from, uint256 value);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _initialSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _initialSupply * (10 ** uint256(_decimals));
        balanceOf[msg.sender] = totalSupply;
        owner = msg.sender;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], ""Insufficient balance"");
        require(_value <= allowance[_from][msg.sender], ""Allowance too low"");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    function increaseApproval(address _spender, uint256 _addedValue) public returns (bool success) {
        allowance[msg.sender][_spender] += _addedValue;
        emit Approval(msg.sender, _spender, allowance[msg.sender][_spender]);
        return true;
    }

    function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool success) {
        uint256 oldValue = allowance[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
            allowance[msg.sender][_spender] = 0;
        } else {
            allowance[msg.sender][_spender] = oldValue - _subtractedValue;
        }
        emit Approval(msg.sender, _spender, allowance[msg.sender][_spender]);
        return true;
    }

    function burn(uint256 _value) public onlyOwner returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        totalSupply -= _value;
        emit Burn(msg.sender, _value);
        emit Transfer(msg.sender, address(0), _value);
        return true;
    }
}",contract_86.sol
"Create a smart contract that implements a revenue sharing model for a multi-level marketing organization. The contract should allow investors to deposit funds, make investments, and withdraw funds. It should also track deposits and withdrawals, and calculate daily income and commission distributions. The contract should include variables for storing investor information and investment records, and has internal functions for processing deposits and withdrawals. Externally, allow users to deposit and withdraw funds. Include modifiers for restricting access to certain functions based on user roles.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract RevenueSharing {
    struct Investor {
        uint256 totalInvestment;
        uint256 lastWithdrawal;
        uint256 pendingIncome;
        address referrer;
    }

    mapping(address => Investor) public investors;
    mapping(address => bool) public isInvestor;
    address public owner;
    uint256 public totalInvestments;
    uint256 public dailyIncomeRate = 1; // 1% daily income rate

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier onlyInvestor() {
        require(isInvestor[msg.sender], ""Not an investor"");
        _;
    }

    event Deposit(address indexed investor, uint256 amount);
    event Withdrawal(address indexed investor, uint256 amount);
    event Investment(address indexed investor, uint256 amount);

    constructor() {
        owner = msg.sender;
    }

    function deposit() external payable {
        require(msg.value > 0, ""Deposit amount must be greater than 0"");
        if (!isInvestor[msg.sender]) {
            investors[msg.sender] = Investor({
                totalInvestment: msg.value,
                lastWithdrawal: block.timestamp,
                pendingIncome: 0,
                referrer: address(0)
            });
            isInvestor[msg.sender] = true;
        } else {
            investors[msg.sender].totalInvestment += msg.value;
        }
        totalInvestments += msg.value;
        emit Deposit(msg.sender, msg.value);
    }

    function invest(address _referrer) external payable onlyInvestor {
        require(msg.value > 0, ""Investment amount must be greater than 0"");
        investors[msg.sender].totalInvestment += msg.value;
        investors[msg.sender].referrer = _referrer;
        totalInvestments += msg.value;
        emit Investment(msg.sender, msg.value);
    }

    function withdraw(uint256 amount) external onlyInvestor {
        require(amount > 0, ""Withdrawal amount must be greater than 0"");
        updatePendingIncome(msg.sender);
        require(investors[msg.sender].pendingIncome >= amount, ""Insufficient balance"");
        investors[msg.sender].pendingIncome -= amount;
        investors[msg.sender].lastWithdrawal = block.timestamp;
        payable(msg.sender).transfer(amount);
        emit Withdrawal(msg.sender, amount);
    }

    function updatePendingIncome(address investor) internal {
        uint256 daysSinceLastWithdrawal = (block.timestamp - investors[investor].lastWithdrawal) / 1 days;
        if (daysSinceLastWithdrawal > 0) {
            uint256 dailyIncome = (investors[investor].totalInvestment * dailyIncomeRate) / 100;
            investors[investor].pendingIncome += dailyIncome * daysSinceLastWithdrawal;
        }
    }

    function setDailyIncomeRate(uint256 rate) external onlyOwner {
        dailyIncomeRate = rate;
    }

    function getPendingIncome(address investor) external view returns (uint256) {
        uint256 daysSinceLastWithdrawal = (block.timestamp - investors[investor].lastWithdrawal) / 1 days;
        uint256 dailyIncome = (investors[investor].totalInvestment * dailyIncomeRate) / 100;
        return investors[investor].pendingIncome + (dailyIncome * daysSinceLastWithdrawal);
    }
}",contract_87.sol
"Create a smart contract that supports asset transfer between addresses. The contract should allow for basic operations like withdraw, balance check, and allowance setting. Include event emitters for key actions like transfer, approve, and transferFrom. Implement necessary error handling for arithmetic operations.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract AssetTransfer {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    uint256 private _totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) public returns (bool) {
        _transfer(msg.sender, to, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) public returns (bool) {
        _spendAllowance(from, msg.sender, amount);
        _transfer(from, to, amount);
        return true;
    }

    function _transfer(address from, address to, uint256 amount) internal {
        require(from != address(0), ""Transfer from the zero address"");
        require(to != address(0), ""Transfer to the zero address"");

        uint256 fromBalance = _balances[from];
        require(fromBalance >= amount, ""Transfer amount exceeds balance"");
        unchecked {
            _balances[from] = fromBalance - amount;
        }
        _balances[to] += amount;

        emit Transfer(from, to, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""Approve from the zero address"");
        require(spender != address(0), ""Approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _spendAllowance(address owner, address spender, uint256 amount) internal {
        uint256 currentAllowance = allowance(owner, spender);
        if (currentAllowance != type(uint256).max) {
            require(currentAllowance >= amount, ""Insufficient allowance"");
            unchecked {
                _approve(owner, spender, currentAllowance - amount);
            }
        }
    }

    function _mint(address account, uint256 amount) internal {
        require(account != address(0), ""Mint to the zero address"");

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) internal {
        require(account != address(0), ""Burn from the zero address"");

        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, ""Burn amount exceeds balance"");
        unchecked {
            _balances[account] = accountBalance - amount;
        }
        _totalSupply -= amount;

        emit Transfer(account, address(0), amount);
    }
}",contract_88.sol
"Create a smart contract that manages vaults, allowing users to deposit, borrow, and repay tokens. functions should get asset and debt information, as well as calculate equity. Implement getter functions for current asset value and equity. Utilize ReentrancyGuard, Pausable, and AccessControl for added security. Familiarize yourself with the OpenZeppelin libraries and explore their usage.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract VaultManager is ReentrancyGuard, Pausable, AccessControl {
    bytes32 public constant PAUSER_ROLE = keccak256(""PAUSER_ROLE"");
    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");

    struct Vault {
        uint256 assetValue;
        uint256 debtValue;
    }

    mapping(address => Vault) public vaults;
    IERC20 public token;

    event Deposited(address indexed user, uint256 amount);
    event Borrowed(address indexed user, uint256 amount);
    event Repaid(address indexed user, uint256 amount);

    constructor(address _token) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(PAUSER_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
        token = IERC20(_token);
    }

    modifier onlyAdmin() {
        require(hasRole(ADMIN_ROLE, msg.sender), ""VaultManager: must have admin role to perform this action"");
        _;
    }

    function deposit(uint256 amount) external nonReentrant whenNotPaused {
        require(token.transferFrom(msg.sender, address(this), amount), ""VaultManager: token transfer failed"");
        vaults[msg.sender].assetValue += amount;
        emit Deposited(msg.sender, amount);
    }

    function borrow(uint256 amount) external nonReentrant whenNotPaused {
        require(vaults[msg.sender].assetValue >= amount, ""VaultManager: insufficient asset value"");
        vaults[msg.sender].assetValue -= amount;
        vaults[msg.sender].debtValue += amount;
        require(token.transfer(msg.sender, amount), ""VaultManager: token transfer failed"");
        emit Borrowed(msg.sender, amount);
    }

    function repay(uint256 amount) external nonReentrant whenNotPaused {
        require(token.transferFrom(msg.sender, address(this), amount), ""VaultManager: token transfer failed"");
        vaults[msg.sender].debtValue -= amount;
        emit Repaid(msg.sender, amount);
    }

    function getAssetValue(address user) external view returns (uint256) {
        return vaults[user].assetValue;
    }

    function getDebtValue(address user) external view returns (uint256) {
        return vaults[user].debtValue;
    }

    function calculateEquity(address user) external view returns (uint256) {
        return vaults[user].assetValue - vaults[user].debtValue;
    }

    function pause() external onlyAdmin {
        _pause();
    }

    function unpause() external onlyAdmin {
        _unpause();
    }
}

abstract contract ReentrancyGuard {
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;
    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    modifier nonReentrant() {
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");
        _status = _ENTERED;
        _;
        _status = _NOT_ENTERED;
    }
}

abstract contract Pausable is Context {
    event Paused(address account);
    event Unpaused(address account);

    bool private _paused;

    constructor() {
        _paused = false;
    }

    modifier whenNotPaused() {
        require(!_paused, ""Pausable: paused"");
        _;
    }

    modifier whenPaused() {
        require(_paused, ""Pausable: not paused"");
        _;
    }

    function _pause() internal virtual whenNotPaused {
        _paused = true;
        emit Paused(_msgSender());
    }

    function _unpause() internal virtual whenPaused {
        _paused = false;
        emit Unpaused(_msgSender());
    }
}

abstract contract AccessControl is Context {
    struct RoleData {
        mapping(address => bool) members;
        bytes32 adminRole;
    }

    mapping(bytes32 => RoleData) private _roles;

    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    function hasRole(bytes32 role, address account) public view returns (bool) {
        return _roles[role].members[account];
    }

    function _setupRole(bytes32 role, address account) internal {
        _grantRole(role, account);
    }

    function _grantRole(bytes32 role, address account) private {
        if (!hasRole(role, account)) {
            _roles[role].members[account] = true;
            emit RoleGranted(role, account, _msgSender());
        }
    }

    function _revokeRole(bytes32 role, address account) private {
        if (hasRole(role, account)) {
            _roles[role].members[account] = false;
            emit RoleRevoked(role, account, _msgSender());
        }
    }
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}",contract_89.sol
"Create a smart contract that builds upon the SafeMath library and incorporates authorization mechanisms using the Auth contract. The contract should interact with IDEXFactory and IDEXRouter interfaces for integration with decentralized exchanges. Provide high-level descriptions for each function, focusing on the desired functionality and technical implementation.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }
}

contract Auth {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(_owner == msg.sender, ""Auth: caller is not the owner"");
        _;
    }

    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""Auth: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

interface IDEXFactory {
    function createPair(address tokenA, address tokenB) external returns (address pair);
}

interface IDEXRouter {
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);

    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
}

contract DEXIntegration is SafeMath, Auth {
    IDEXFactory public factory;
    IDEXRouter public router;

    constructor(address _factory, address _router) {
        factory = IDEXFactory(_factory);
        router = IDEXRouter(_router);
    }

    // Creates a pair with the given tokens
    function createPair(address tokenA, address tokenB) external onlyOwner returns (address pair) {
        pair = factory.createPair(tokenA, tokenB);
    }

    // Adds liquidity to the given token pair
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external onlyOwner returns (uint amountA, uint amountB, uint liquidity) {
        return router.addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin, to, deadline);
    }

    // Swaps exact tokens for tokens
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external onlyOwner returns (uint[] memory amounts) {
        return router.swapExactTokensForTokens(amountIn, amountOutMin, path, to, deadline);
    }
}",contract_90.sol
"Create a smart contract for the F4Kings game, inheriting from F3Devents. The contract should track game settings, admin and shareCom addresses, and game statistics. Implement events for player registration, buying/reloading, withdrawing, and affiliate payouts. Include features for air drops, round timers, and affiliate payments. Focus on readability and maintainability.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract F3Devents {
    event PlayerRegistered(address indexed player);
    event PlayerBought(address indexed player, uint256 amount);
    event PlayerReloaded(address indexed player, uint256 amount);
    event PlayerWithdrew(address indexed player, uint256 amount);
    event AffiliatePaid(address indexed affiliate, uint256 amount);
}

contract F4Kings is F3Devents {
    address public admin;
    address public shareCom;
    uint256 public gameStartTime;
    uint256 public roundDuration;
    uint256 public totalPlayers;
    uint256 public totalBought;
    uint256 public totalWithdrawn;
    uint256 public totalAffiliatePaid;

    struct Player {
        bool isRegistered;
        uint256 balance;
        address affiliate;
    }

    mapping(address => Player) public players;

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Not the admin"");
        _;
    }

    constructor(address _shareCom, uint256 _roundDuration) {
        admin = msg.sender;
        shareCom = _shareCom;
        roundDuration = _roundDuration;
        gameStartTime = block.timestamp;
    }

    function registerPlayer(address _affiliate) external {
        require(!players[msg.sender].isRegistered, ""Player already registered"");
        players[msg.sender] = Player({isRegistered: true, balance: 0, affiliate: _affiliate});
        totalPlayers++;
        emit PlayerRegistered(msg.sender);
    }

    function buy(uint256 amount) external payable {
        require(players[msg.sender].isRegistered, ""Player not registered"");
        require(msg.value == amount, ""Incorrect amount sent"");
        players[msg.sender].balance += amount;
        totalBought += amount;
        emit PlayerBought(msg.sender, amount);
    }

    function reload(uint256 amount) external payable {
        require(players[msg.sender].isRegistered, ""Player not registered"");
        require(msg.value == amount, ""Incorrect amount sent"");
        players[msg.sender].balance += amount;
        emit PlayerReloaded(msg.sender, amount);
    }

    function withdraw(uint256 amount) external {
        require(players[msg.sender].isRegistered, ""Player not registered"");
        require(players[msg.sender].balance >= amount, ""Insufficient balance"");
        players[msg.sender].balance -= amount;
        totalWithdrawn += amount;
        payable(msg.sender).transfer(amount);
        emit PlayerWithdrew(msg.sender, amount);
    }

    function payAffiliate(address affiliate, uint256 amount) external onlyAdmin {
        require(players[affiliate].isRegistered, ""Affiliate not registered"");
        require(players[affiliate].balance >= amount, ""Insufficient affiliate balance"");
        players[affiliate].balance -= amount;
        totalAffiliatePaid += amount;
        payable(affiliate).transfer(amount);
        emit AffiliatePaid(affiliate, amount);
    }

    function airDrop(address[] memory recipients, uint256[] memory amounts) external onlyAdmin {
        require(recipients.length == amounts.length, ""Mismatched arrays"");
        for (uint256 i = 0; i < recipients.length; i++) {
            require(players[recipients[i]].isRegistered, ""Recipient not registered"");
            players[recipients[i]].balance += amounts[i];
        }
    }

    function setRoundDuration(uint256 _roundDuration) external onlyAdmin {
        roundDuration = _roundDuration;
    }

    function setShareCom(address _shareCom) external onlyAdmin {
        shareCom = _shareCom;
    }
}",contract_91.sol
"Create a smart contract that enables the issuance, transfer, and management of certifications. The contract should include functions for tracking the total supply of certifications, getting the balance of certifications held by an entity, transferring certifications, and approving or rejecting certification transfers. The contract should also include events for tracking certification transfers and approvals.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract CertificationManagement {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event CertificationIssued(address indexed to, uint256 value);
    event CertificationTransferred(address indexed from, address indexed to, uint256 value);
    event ApprovalGranted(address indexed owner, address indexed spender, uint256 value);
    event ApprovalRejected(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _initialSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _initialSupply * (10 ** uint256(decimals));
        balanceOf[msg.sender] = totalSupply;
        emit CertificationIssued(msg.sender, totalSupply);
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        emit CertificationTransferred(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        emit ApprovalGranted(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], ""Insufficient balance"");
        require(_value <= allowance[_from][msg.sender], ""Allowance too low"");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        emit CertificationTransferred(_from, _to, _value);
        return true;
    }

    function rejectApproval(address _spender) public returns (bool success) {
        allowance[msg.sender][_spender] = 0;
        emit Approval(msg.sender, _spender, 0);
        emit ApprovalRejected(msg.sender, _spender, 0);
        return true;
    }
}",contract_92.sol
"Create a smart contract using Solidity that represents a Talentum token. The token should have a name, symbol, and total supply. Implement functions for transferring tokens, approving transfers, and allow-listed transfers. The contract should also include features for writers to write in the Holy Bible, readers to read the Holy Bible, and administrators to set writers and country codes. Include a donation mechanic with different price tiers based on the donate step.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TalentumToken {
    string public name = ""Talentum Token"";
    string public symbol = ""TTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    mapping(address => bool) public writers;
    mapping(address => string) public countryCodes;

    address public owner;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event WriterSet(address indexed writer, bool status);
    event CountryCodeSet(address indexed user, string code);
    event Donation(address indexed donor, uint256 amount, uint256 step);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier onlyWriter() {
        require(writers[msg.sender], ""Not a writer"");
        _;
    }

    constructor(uint256 _initialSupply) {
        owner = msg.sender;
        mint(owner, _initialSupply);
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], ""Insufficient balance"");
        require(_value <= allowance[_from][msg.sender], ""Allowance too low"");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    function mint(address _to, uint256 _value) public onlyOwner {
        totalSupply += _value;
        balanceOf[_to] += _value;
        emit Transfer(address(0), _to, _value);
    }

    function setWriter(address _writer, bool _status) public onlyOwner {
        writers[_writer] = _status;
        emit WriterSet(_writer, _status);
    }

    function setCountryCode(address _user, string memory _code) public onlyOwner {
        countryCodes[_user] = _code;
        emit CountryCodeSet(_user, _code);
    }

    function donate(uint256 _step) public payable {
        require(_step > 0, ""Invalid step"");
        uint256 amount;
        if (_step == 1) {
            amount = 0.1 ether;
        } else if (_step == 2) {
            amount = 1 ether;
        } else if (_step == 3) {
            amount = 10 ether;
        } else {
            revert(""Invalid donation step"");
        }
        require(msg.value >= amount, ""Insufficient donation amount"");
        // Handle the donation, e.g., transfer to a donation wallet
        emit Donation(msg.sender, msg.value, _step);
    }
}",contract_93.sol
"Create a smart contract that allows for locking and unlocking of gold, with a cache contract to manage the locked gold and a separate contract for managing the gold, implementing basic token-like functionality with supply, balance, and allowance tracking.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GoldToken {
    string public name = ""GoldToken"";
    string public symbol = ""GLD"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance too low"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }
}

contract GoldLock {
    GoldToken public goldToken;

    struct Lock {
        uint256 amount;
        uint256 unlockTime;
        bool claimed;
    }

    mapping(address => Lock[]) public locks;

    event GoldLocked(address indexed owner, uint256 amount, uint256 unlockTime);
    event GoldUnlocked(address indexed owner, uint256 amount);

    constructor(address _goldToken) {
        goldToken = GoldToken(_goldToken);
    }

    function lockGold(uint256 amount, uint256 unlockTime) public {
        require(goldToken.transferFrom(msg.sender, address(this), amount), ""Transfer failed"");
        locks[msg.sender].push(Lock({amount: amount, unlockTime: unlockTime, claimed: false}));
        emit GoldLocked(msg.sender, amount, unlockTime);
    }

    function unlockGold(uint256 lockIndex) public {
        Lock storage lock = locks[msg.sender][lockIndex];
        require(!lock.claimed, ""Already claimed"");
        require(block.timestamp >= lock.unlockTime, ""Unlock time not reached"");
        lock.claimed = true;
        require(goldToken.transfer(msg.sender, lock.amount), ""Transfer failed"");
        emit GoldUnlocked(msg.sender, lock.amount);
    }
}",contract_94.sol
"Create a smart contract that enables the delegation of function calls to another contract. The contract should have the ability to set various variables, including uint256 values and addresses, using a delegatecall mechanism. Implement functions for setting the num and value variables, and utilize encoding and encoding signatures to ensure proper delegation and validation.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DelegateContract {
    address public implementation;
    uint256 public num;
    address public value;

    event ImplementationSet(address indexed newImplementation);
    event NumSet(uint256 newNum);
    event ValueSet(address newValue);

    modifier onlyImplementation() {
        require(msg.sender == implementation, ""Caller is not the implementation"");
        _;
    }

    function setImplementation(address _newImplementation) external {
        implementation = _newImplementation;
        emit ImplementationSet(_newImplementation);
    }

    function delegateSetNum(uint256 _newNum) external onlyImplementation {
        num = _newNum;
        emit NumSet(_newNum);
    }

    function delegateSetValue(address _newValue) external onlyImplementation {
        value = _newValue;
        emit ValueSet(_newValue);
    }
}

contract ProxyContract {
    address public implementation;
    uint256 public num;
    address public value;

    function setImplementation(address _newImplementation) external {
        implementation = _newImplementation;
    }

    function setNum(uint256 _newNum) external {
        (bool success, ) = implementation.delegatecall(
            abi.encodeWithSignature(""delegateSetNum(uint256)"", _newNum)
        );
        require(success, ""Delegate call failed"");
    }

    function setValue(address _newValue) external {
        (bool success, ) = implementation.delegatecall(
            abi.encodeWithSignature(""delegateSetValue(address)"", _newValue)
        );
        require(success, ""Delegate call failed"");
    }
}",contract_95.sol
"Create a smart contract that enables users to deposit and withdraw funds, with specific minimums and return rates. Design a system for deposit returns and product purchases. Implement functions for user registration, deposit, investment, and withdrawal. Incorporate modifiers for authorized access and log events for auditing purposes.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract FinancialPlatform {
    struct User {
        uint balance;
        bool isRegistered;
    }

    mapping(address => User) public users;
    address public owner;
    uint public constant MIN_DEPOSIT = 100; // Minimum deposit amount
    uint public constant RETURN_RATE = 5; // 5% return rate

    event UserRegistered(address indexed user);
    event DepositMade(address indexed user, uint amount);
    event InvestmentReturn(address indexed user, uint amount);
    event WithdrawalMade(address indexed user, uint amount);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier onlyRegistered() {
        require(users[msg.sender].isRegistered, ""User not registered"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function register() external {
        require(!users[msg.sender].isRegistered, ""Already registered"");
        users[msg.sender] = User({balance: 0, isRegistered: true});
        emit UserRegistered(msg.sender);
    }

    function deposit() external payable onlyRegistered {
        require(msg.value >= MIN_DEPOSIT, ""Deposit amount too low"");
        users[msg.sender].balance += msg.value;
        emit DepositMade(msg.sender, msg.value);
    }

    function invest() external onlyRegistered {
        uint investmentAmount = users[msg.sender].balance * RETURN_RATE / 100;
        users[msg.sender].balance += investmentAmount;
        emit InvestmentReturn(msg.sender, investmentAmount);
    }

    function withdraw(uint amount) external onlyRegistered {
        require(amount <= users[msg.sender].balance, ""Insufficient balance"");
        users[msg.sender].balance -= amount;
        payable(msg.sender).transfer(amount);
        emit WithdrawalMade(msg.sender, amount);
    }

    function getBalance() external view onlyRegistered returns (uint) {
        return users[msg.sender].balance;
    }
}",contract_96.sol
"Create a smart contract that handles rewards distribution for suppliers, borrowers, and transactors. The contract should have variables indicating whether it's a rewards distributor and a flywheel. Implement functions for pre-supplier, pre-borrower, and pre-transfer actions to accrue rewards. Add a function to retrieve accrued rewards and another to add new markets for rewards accrual. The contract should allow for reading the current state of markets. Provide a clear and understandable implementation.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract RewardsDistribution {
    bool public isRewardsDistributor;
    bool public isFlywheel;

    struct Market {
        bool isActive;
        uint256 rewardsAccrued;
    }

    mapping(address => Market) public markets;
    mapping(address => uint256) public supplierRewards;
    mapping(address => uint256) public borrowerRewards;
    mapping(address => uint256) public transactorRewards;

    event MarketAdded(address market);
    event RewardsAccrued(address indexed user, uint256 amount);

    constructor(bool _isRewardsDistributor, bool _isFlywheel) {
        isRewardsDistributor = _isRewardsDistributor;
        isFlywheel = _isFlywheel;
    }

    function addMarket(address market) external {
        require(!markets[market].isActive, ""Market already added"");
        markets[market] = Market({isActive: true, rewardsAccrued: 0});
        emit MarketAdded(market);
    }

    function preSupplierAction(address supplier, uint256 amount) external {
        require(markets[msg.sender].isActive, ""Market not active"");
        supplierRewards[supplier] += amount;
        markets[msg.sender].rewardsAccrued += amount;
        emit RewardsAccrued(supplier, amount);
    }

    function preBorrowerAction(address borrower, uint256 amount) external {
        require(markets[msg.sender].isActive, ""Market not active"");
        borrowerRewards[borrower] += amount;
        markets[msg.sender].rewardsAccrued += amount;
        emit RewardsAccrued(borrower, amount);
    }

    function preTransferAction(address transactor, uint256 amount) external {
        require(markets[msg.sender].isActive, ""Market not active"");
        transactorRewards[transactor] += amount;
        markets[msg.sender].rewardsAccrued += amount;
        emit RewardsAccrued(transactor, amount);
    }

    function getAccruedRewards(address user) external view returns (uint256) {
        return supplierRewards[user] + borrowerRewards[user] + transactorRewards[user];
    }

    function getMarketState(address market) external view returns (bool, uint256) {
        return (markets[market].isActive, markets[market].rewardsAccrued);
    }
}",contract_97.sol
Create a smart contract to manage the Declaration of Decentralization (DoD). The contract should store the DoD text and allow signing by designated parties. Implement validation logic to ensure only authorized parties can modify the contract state. Incorporate a constructor to initialize the debot's address and the DoD text.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DeclarationOfDecentralization {
    address public owner;
    address public debotAddress;
    string public declarationText;
    mapping(address => bool) public signers;
    address[] public signatures;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can perform this action"");
        _;
    }

    modifier onlyAuthorized() {
        require(msg.sender == owner || msg.sender == debotAddress, ""Not authorized to modify the contract"");
        _;
    }

    constructor(address _debotAddress, string memory _declarationText) {
        owner = msg.sender;
        debotAddress = _debotAddress;
        declarationText = _declarationText;
    }

    function updateDeclaration(string memory _newDeclarationText) public onlyAuthorized {
        declarationText = _newDeclarationText;
    }

    function addSigner(address _signer) public onlyOwner {
        signers[_signer] = true;
    }

    function removeSigner(address _signer) public onlyOwner {
        signers[_signer] = false;
    }

    function signDeclaration() public {
        require(signers[msg.sender], ""Not authorized to sign the declaration"");
        signatures.push(msg.sender);
    }

    function getSignatures() public view returns (address[] memory) {
        return signatures;
    }
}",contract_98.sol
"Create a smart contract that allows for basic ownership management. The contract should have a way to initialize the owner and register feature functions, as well as a function to transfer ownership and a function to migrate the contract. Make sure to include error handling in case of unexpected inputs. The contract should also include a way to retrieve the current owner.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract OwnershipManager {
    address private _owner;
    bool private _initialized;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    modifier onlyOwner() {
        require(msg.sender == _owner, ""OwnershipManager: caller is not the owner"");
        _;
    }

    function initializeOwner(address initialOwner) public {
        require(!_initialized, ""OwnershipManager: already initialized"");
        require(initialOwner != address(0), ""OwnershipManager: initial owner is the zero address"");
        _owner = initialOwner;
        _initialized = true;
        emit OwnershipTransferred(address(0), initialOwner);
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""OwnershipManager: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }

    function getOwner() public view returns (address) {
        return _owner;
    }

    function migrateContract(address newContract) public onlyOwner {
        require(newContract != address(0), ""OwnershipManager: new contract is the zero address"");
        // Logic to migrate contract state can be added here
        // This is a placeholder function for demonstration purposes
    }
}",contract_99.sol
"Develop a Solidity smart contract that replicates the functionality of the Electrocoin token. This contract should include key functions like `distr`, `transfer`, and `approve`, while adhering to the ERC20 standard. The contract should also incorporate necessary modifiers and events. Pay attention to the logical flow and technical aspects, ensuring that the contract is structured correctly and follows best practices in Smart Contract development.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Electrocoin {
    string public name = ""Electrocoin"";
    string public symbol = ""ELC"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function distr(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        return distr(_to, _value);
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], ""Insufficient balance"");
        require(_value <= allowance[_from][msg.sender], ""Allowance too low"");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }
}",contract_100.sol
"Create a smart contract that manages a fungible token. Implement the following functionality: allow users to transfer tokens, set token allowances, and burn tokens. Include functionality for the owner to mint new tokens. Provide a high-level overview of how the contract should be structured and involve the reader in the development process.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract FungibleToken {
    string public name = ""MyFungibleToken"";
    string public symbol = ""MFT"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    address public owner;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Burn(address indexed from, uint256 value);
    event Mint(address indexed to, uint256 value);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor(uint256 initialSupply) {
        owner = msg.sender;
        mint(owner, initialSupply);
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance too low"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }

    function burn(uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        totalSupply -= value;
        emit Burn(msg.sender, value);
        return true;
    }

    function mint(address to, uint256 value) public onlyOwner returns (bool success) {
        balanceOf[to] += value;
        totalSupply += value;
        emit Mint(to, value);
        return true;
    }
}",contract_101.sol
Design a smart contract for managing ownership of a target. The contract should inherit from a parent contract (PRBProxyPlugin) and implement a specific interface (TargetChangeOwner). The contract should provide two functions: one to change the owner of the target and another to retrieve the current owner. The implementation should be suitable for a real-world use case and include necessary functions and variables.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract PRBProxyPlugin {
    // Placeholder for the parent contract's logic
}

interface TargetChangeOwner {
    function changeOwner(address newOwner) external;
    function getCurrentOwner() external view returns (address);
}

contract TargetOwnerManager is PRBProxyPlugin, TargetChangeOwner {
    address private _targetOwner;

    event OwnerChanged(address indexed previousOwner, address indexed newOwner);

    constructor(address initialOwner) {
        require(initialOwner != address(0), ""Initial owner cannot be zero address"");
        _targetOwner = initialOwner;
    }

    function changeOwner(address newOwner) external override {
        require(newOwner != address(0), ""New owner cannot be zero address"");
        require(msg.sender == _targetOwner, ""Only current owner can change the owner"");
        emit OwnerChanged(_targetOwner, newOwner);
        _targetOwner = newOwner;
    }

    function getCurrentOwner() external view override returns (address) {
        return _targetOwner;
    }
}",contract_102.sol
"Create a smart contract for the Median protocol that supports various cryptocurrency exchange rates. The contract should be structured to manage multiple currency pairs (e.g. ETH/USD, BAT/USD, etc.) with a single function for recovering the signer's address from a signed message. Focus on implementing the necessary functions and variables to achieve this functionality.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MedianProtocol {
    struct CurrencyPair {
        uint256 rate;
        uint256 lastUpdated;
    }

    mapping(bytes32 => CurrencyPair) public currencyPairs;
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function updateRate(bytes32 _currencyPair, uint256 _rate) external onlyOwner {
        currencyPairs[_currencyPair].rate = _rate;
        currencyPairs[_currencyPair].lastUpdated = block.timestamp;
    }

    function getRate(bytes32 _currencyPair) external view returns (uint256) {
        return currencyPairs[_currencyPair].rate;
    }

    function recoverSigner(bytes32 message, bytes memory sig) public pure returns (address) {
        require(sig.length == 65, ""Invalid signature length"");

        bytes32 r;
        bytes32 s;
        uint8 v;

        assembly {
            r := mload(add(sig, 32))
            s := mload(add(sig, 64))
            v := byte(0, mload(add(sig, 96)))
        }

        if (v < 27) {
            v += 27;
        }

        require(v == 27 || v == 28, ""Invalid signature recovery id"");

        return ecrecover(message, v, r, s);
    }
}",contract_103.sol
"Create a smart contract for an ERC20 token with the following requirements: manage token balances, approve transfers, and burn tokens. The contract should include functions for token transfer, approval, and transfer from. Additionally, consider implementing private modifier onlySuper and public view functions for token total supply, unLock time, and burn amount.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    uint256 public unLockTime;
    uint256 public burnAmount;
    address private superAdmin;

    mapping(address => uint256) private balances;
    mapping(address => mapping(address => uint256)) private allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Burn(address indexed burner, uint256 value);

    modifier onlySuper() {
        require(msg.sender == superAdmin, ""Not super admin"");
        _;
    }

    constructor(uint256 initialSupply, uint256 _unLockTime) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balances[msg.sender] = totalSupply;
        unLockTime = _unLockTime;
        superAdmin = msg.sender;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        require(balances[msg.sender] >= amount, ""Insufficient balance"");
        balances[msg.sender] -= amount;
        balances[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        require(balances[sender] >= amount, ""Insufficient balance"");
        require(allowances[sender][msg.sender] >= amount, ""Allowance too low"");
        balances[sender] -= amount;
        balances[recipient] += amount;
        allowances[sender][msg.sender] -= amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }

    function burn(uint256 _value) public onlySuper {
        require(balances[msg.sender] >= _value, ""Burn amount exceeds balance"");
        balances[msg.sender] -= _value;
        totalSupply -= _value;
        burnAmount += _value;
        emit Burn(msg.sender, _value);
        emit Transfer(msg.sender, address(0), _value);
    }

    function getUnLockTime() public view returns (uint256) {
        return unLockTime;
    }

    function getBurnAmount() public view returns (uint256) {
        return burnAmount;
    }
}",contract_104.sol
"Create a smart contract that restricts access to certain functions based on specific roles. The contract should have four roles: DAO_ADMIN, OPERATOR, CALLER, and CALLEE. Each role should have specific privileges, such as DAO_ADMIN being able to set up initial administrators. The contract should include modifier functions for each role to control access to specific functions. Use Solidity 0.8.10 and include necessary import statements.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract RoleBasedAccessControl {
    // Role definitions
    bytes32 public constant DAO_ADMIN = keccak256(""DAO_ADMIN"");
    bytes32 public constant OPERATOR = keccak256(""OPERATOR"");
    bytes32 public constant CALLER = keccak256(""CALLER"");
    bytes32 public constant CALLEE = keccak256(""CALLEE"");

    // Mapping from role to account to boolean (true if account has role)
    mapping(bytes32 => mapping(address => bool)) private _roles;

    // Events
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    // Modifiers
    modifier onlyRole(bytes32 role) {
        require(_roles[role][msg.sender], ""RoleBasedAccessControl: sender does not have the required role"");
        _;
    }

    // Constructor
    constructor() {
        _grantRole(DAO_ADMIN, msg.sender);
    }

    // Role management functions
    function grantRole(bytes32 role, address account) external onlyRole(DAO_ADMIN) {
        _grantRole(role, account);
    }

    function revokeRole(bytes32 role, address account) external onlyRole(DAO_ADMIN) {
        _revokeRole(role, account);
    }

    function hasRole(bytes32 role, address account) public view returns (bool) {
        return _roles[role][account];
    }

    // Internal role management functions
    function _grantRole(bytes32 role, address account) internal {
        if (!hasRole(role, account)) {
            _roles[role][account] = true;
            emit RoleGranted(role, account, msg.sender);
        }
    }

    function _revokeRole(bytes32 role, address account) internal {
        if (hasRole(role, account)) {
            _roles[role][account] = false;
            emit RoleRevoked(role, account, msg.sender);
        }
    }

    // Example functions with role-based access control
    function daoAdminFunction() external onlyRole(DAO_ADMIN) {
        // Functionality for DAO_ADMIN
    }

    function operatorFunction() external onlyRole(OPERATOR) {
        // Functionality for OPERATOR
    }

    function callerFunction() external onlyRole(CALLER) {
        // Functionality for CALLER
    }

    function calleeFunction() external onlyRole(CALLEE) {
        // Functionality for CALLEE
    }
}",contract_105.sol
"Create a smart contract that allows users to stake and unstake tokens. The contract should keep track of total staked amounts and provide functions for staking, unstaking, and retrieving the total staked amount. Implement arithmetic operations securely using the SafeMath library. Consider the event-driven nature of the provided code snippets, such as the transfer events from IERC20. Ensure the contract is scalable and maintainable.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract StakingContract {
    using SafeMath for uint256;

    IERC20 public token;
    uint256 public totalStaked;
    mapping(address => uint256) public stakedBalances;

    event Staked(address indexed user, uint256 amount);
    event Unstaked(address indexed user, uint256 amount);

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function stake(uint256 _amount) external {
        require(_amount > 0, ""Amount must be greater than zero"");
        require(token.transferFrom(msg.sender, address(this), _amount), ""Transfer failed"");

        stakedBalances[msg.sender] = stakedBalances[msg.sender].add(_amount);
        totalStaked = totalStaked.add(_amount);

        emit Staked(msg.sender, _amount);
    }

    function unstake(uint256 _amount) external {
        require(_amount > 0, ""Amount must be greater than zero"");
        require(stakedBalances[msg.sender] >= _amount, ""Insufficient staked balance"");

        stakedBalances[msg.sender] = stakedBalances[msg.sender].sub(_amount);
        totalStaked = totalStaked.sub(_amount);

        require(token.transfer(msg.sender, _amount), ""Transfer failed"");

        emit Unstaked(msg.sender, _amount);
    }

    function getTotalStaked() external view returns (uint256) {
        return totalStaked;
    }
}

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }
}",contract_106.sol
"Develop a smart contract that follows the IERC721 standard for managing unique digital assets. The contract should include functions for transferring ownership, approving operators, and querying token balances. Implement methods for setting and retrieving token metadata, such as token names and symbols. Include support for ERC721Receiver events and consider adding features for token burning, conversion, or renaming. Structure the contract with clear and readable code, and include basic documentation for the contract's variables, functions, and events.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}

contract ERC721 {
    string private _name;
    string private _symbol;
    uint256 private _tokenIdCounter;

    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function balanceOf(address owner) public view returns (uint256) {
        require(owner != address(0), ""ERC721: balance query for the zero address"");
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) public view returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), ""ERC721: owner query for nonexistent token"");
        return owner;
    }

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _safeTransfer(from, to, tokenId, data);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) public {
        safeTransferFrom(from, to, tokenId, """");
    }

    function transferFrom(address from, address to, uint256 tokenId) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _transfer(from, to, tokenId);
    }

    function approve(address to, uint256 tokenId) public {
        address owner = ownerOf(tokenId);
        require(to != owner, ""ERC721: approval to current owner"");
        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), ""ERC721: approve caller is not owner nor approved for all"");
        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    function getApproved(uint256 tokenId) public view returns (address) {
        require(_exists(tokenId), ""ERC721: approved query for nonexistent token"");
        return _tokenApprovals[tokenId];
    }

    function setApprovalForAll(address operator, bool approved) public {
        require(operator != msg.sender, ""ERC721: approve to caller"");
        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function isApprovedForAll(address owner, address operator) public view returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return _owners[tokenId] != address(0);
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    function _safeMint(address to, uint256 tokenId) internal {
        _safeMint(to, tokenId, """");
    }

    function _safeMint(address to, uint256 tokenId, bytes memory data) internal {
        _mint(to, tokenId);
        require(_checkOnERC721Received(address(0), to, tokenId, data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _mint(address to, uint256 tokenId) internal {
        require(to != address(0), ""ERC721: mint to the zero address"");
        require(!_exists(tokenId), ""ERC721: token already minted"");
        _balances[to] += 1;
        _owners[tokenId] = to;
        emit Transfer(address(0), to, tokenId);
    }

    function _burn(uint256 tokenId) internal {
        address owner = ownerOf(tokenId);
        _approve(address(0), tokenId);
        _balances[owner] -= 1;
        delete _owners[tokenId];
        emit Transfer(owner, address(0), tokenId);
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        require(ownerOf(tokenId) == from, ""ERC721: transfer of token that is not own"");
        require(to != address(0), ""ERC721: transfer to the zero address"");
        _approve(address(0), tokenId);
        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;
        emit Transfer(from, to, tokenId);
    }

    function _approve(address to, uint256 tokenId) internal {
        _tokenApprovals[tokenId] = to;
        emit Approval(ownerOf(tokenId), to, tokenId);
    }

    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) internal returns (bool) {
        if (to.code.length > 0) {
            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data) returns (bytes4 retval) {
                return retval == IERC721Receiver.onERC721Received.selector;
            } catch (bytes memory reason) {
                if (reason.length == 0) {
                    revert(""ERC721: transfer to non ERC721Receiver implementer"");
                } else {
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        } else {
            return true;
        }
    }
}",contract_107.sol
"Create a smart contract for the RED token, implementing the ERC20 standard. The contract should include functions for managing the token supply, balance, and transfer. Initialize the token supply in the constructor. Implement a function for transferring tokens from one address to another. Include a function for approving a spender. Handle events for token transfer and approval. Focus on implementing the core functionality of the contract, using built-in Solidity features and libraries where possible.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract REDToken {
    string public name = ""RED Token"";
    string public symbol = ""RED"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }
}",contract_108.sol
"Create a Solidity smart contract that manages a cover pool, allowing users to provide, withdraw, claim, and withdraw epoch tokens. The contract should include logic for setting the epoch changing price and starting new epochs. Implement functions for adding and withdrawing tokens, claiming unclaimed profit, and withdrawing from epochs. Include variables to track cumulative profit, total share, and unwithdrawn cover tokens.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract CoverPool {
    address public owner;
    uint256 public currentEpoch;
    uint256 public epochPrice;
    uint256 public cumulativeProfit;
    uint256 public totalShare;
    uint256 public unwithdrawnCoverTokens;

    struct Epoch {
        uint256 epochId;
        uint256 startBlock;
        uint256 endBlock;
        uint256 totalTokens;
        uint256 totalShares;
        mapping(address => uint256) shares;
        mapping(address => uint256) claimedProfit;
    }

    mapping(uint256 => Epoch) public epochs;
    mapping(address => uint256) public userBalances;

    event EpochStarted(uint256 epochId, uint256 startBlock, uint256 endBlock);
    event TokensAdded(address indexed user, uint256 amount);
    event TokensWithdrawn(address indexed user, uint256 amount);
    event ProfitClaimed(address indexed user, uint256 amount);
    event EpochWithdrawn(address indexed user, uint256 epochId, uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
        currentEpoch = 1;
        epochPrice = 1 ether; // Example price
    }

    function startNewEpoch(uint256 _endBlock) external onlyOwner {
        Epoch storage epoch = epochs[currentEpoch];
        epoch.epochId = currentEpoch;
        epoch.startBlock = block.number;
        epoch.endBlock = _endBlock;
        emit EpochStarted(currentEpoch, block.number, _endBlock);
        currentEpoch++;
    }

    function setEpochPrice(uint256 _newPrice) external onlyOwner {
        epochPrice = _newPrice;
    }

    function addTokens(uint256 _amount) external {
        require(_amount > 0, ""Amount must be greater than zero"");
        userBalances[msg.sender] += _amount;
        totalShare += _amount;
        epochs[currentEpoch].totalTokens += _amount;
        epochs[currentEpoch].shares[msg.sender] += _amount;
        emit TokensAdded(msg.sender, _amount);
    }

    function withdrawTokens(uint256 _amount) external {
        require(_amount > 0, ""Amount must be greater than zero"");
        require(userBalances[msg.sender] >= _amount, ""Insufficient balance"");
        userBalances[msg.sender] -= _amount;
        totalShare -= _amount;
        epochs[currentEpoch].totalTokens -= _amount;
        epochs[currentEpoch].shares[msg.sender] -= _amount;
        emit TokensWithdrawn(msg.sender, _amount);
    }

    function claimProfit() external {
        uint256 profit = calculateProfit(msg.sender);
        require(profit > 0, ""No profit to claim"");
        epochs[currentEpoch].claimedProfit[msg.sender] += profit;
        cumulativeProfit -= profit;
        emit ProfitClaimed(msg.sender, profit);
    }

    function withdrawFromEpoch(uint256 _epochId) external {
        require(_epochId < currentEpoch, ""Epoch not yet ended"");
        Epoch storage epoch = epochs[_epochId];
        uint256 shares = epoch.shares[msg.sender];
        require(shares > 0, ""No shares in this epoch"");
        uint256 amount = (shares * epoch.totalTokens) / epoch.totalShares;
        epoch.shares[msg.sender] = 0;
        unwithdrawnCoverTokens += amount;
        emit EpochWithdrawn(msg.sender, _epochId, amount);
    }

    function calculateProfit(address _user) internal view returns (uint256) {
        uint256 userShares = epochs[currentEpoch].shares[_user];
        if (userShares == 0) return 0;
        uint256 totalProfit = cumulativeProfit;
        return (userShares * totalProfit) / totalShare;
    }
}",contract_109.sol
"Create a smart contract that allows for the transfer of tokens, checking of balances, and management of allowances. The contract should include functions for minting and burning tokens, as well as event emissions for transparency. Use the SafeMath library for reliable calculations. The contract should also include correct handling and validation of edge cases.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    using SafeMath for uint256;

    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Mint(address indexed to, uint256 value);
    event Burn(address indexed from, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(value);
        balanceOf[to] = balanceOf[to].add(value);
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance too low"");
        balanceOf[from] = balanceOf[from].sub(value);
        balanceOf[to] = balanceOf[to].add(value);
        allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);
        emit Transfer(from, to, value);
        return true;
    }

    function mint(address to, uint256 value) public returns (bool success) {
        totalSupply = totalSupply.add(value);
        balanceOf[to] = balanceOf[to].add(value);
        emit Mint(to, value);
        emit Transfer(address(0), to, value);
        return true;
    }

    function burn(uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        totalSupply = totalSupply.sub(value);
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(value);
        emit Burn(msg.sender, value);
        emit Transfer(msg.sender, address(0), value);
        return true;
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, ""SafeMath: modulo by zero"");
        return a % b;
    }
}",contract_110.sol
"Create a Solidity smart contract that inherits from CrossChainEnabled and uses the LibArbitrumL1 library to manage cross-chain interactions. The contract should store an immutable bridge address, implement methods for determining cross-chain status and retrieving the cross-chain sender's address, and integrate with the provided library for smooth interactions.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

abstract contract CrossChainEnabled {
    function isCrossChain() internal view virtual returns (bool);
    function crossChainSender() internal view virtual returns (address);
}

library LibArbitrumL1 {
    address public immutable bridge;

    constructor(address _bridge) {
        bridge = _bridge;
    }

    function getBridge() internal view returns (address) {
        return bridge;
    }

    function isArbitrumL1() internal view returns (bool) {
        // Dummy implementation for demonstration
        return true;
    }

    function getL1Sender() internal view returns (address) {
        // Dummy implementation for demonstration
        return address(0);
    }
}

contract CrossChainContract is CrossChainEnabled {
    using LibArbitrumL1 for LibArbitrumL1;

    address public immutable bridgeAddress;

    constructor(address _bridgeAddress) {
        bridgeAddress = _bridgeAddress;
        LibArbitrumL1.constructor(_bridgeAddress);
    }

    function isCrossChain() internal view override returns (bool) {
        return LibArbitrumL1.isArbitrumL1();
    }

    function crossChainSender() internal view override returns (address) {
        return LibArbitrumL1.getL1Sender();
    }

    function getBridgeAddress() public view returns (address) {
        return bridgeAddress;
    }

    function getCrossChainSender() public view returns (address) {
        if (isCrossChain()) {
            return crossChainSender();
        } else {
            return address(0);
        }
    }
}",contract_111.sol
"Create a token contract that builds upon the ERC20 standard and integrates with the IDEXRouter. The token should have a name, symbol, and decimal places. Implement functions to transfer tokens, set allowances, and get token balances. The contract should also have an owner and a modifier to restrict certain functions. Include a fee structure and a way to exclude certain addresses from fees.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface IDEXRouter {
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
}

contract MyToken is IERC20 {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 private _totalSupply;
    address public owner;
    address public router;
    uint256 public feePercentage;
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    mapping(address => bool) public excludedFromFees;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 initialSupply, address _router) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        _totalSupply = initialSupply * 10 ** uint256(_decimals);
        _balances[msg.sender] = _totalSupply;
        owner = msg.sender;
        router = _router;
        feePercentage = 1; // 1% fee
        excludedFromFees[msg.sender] = true;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function totalSupply() external view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address _owner, address spender) external view override returns (uint256) {
        return _allowances[_owner][spender];
    }

    function approve(address spender, uint256 amount) external override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""Transfer from the zero address"");
        require(recipient != address(0), ""Transfer to the zero address"");
        require(_balances[sender] >= amount, ""Insufficient balance"");

        uint256 fee = 0;
        if (!excludedFromFees[sender] && !excludedFromFees[recipient]) {
            fee = amount * feePercentage / 100;
        }

        _balances[sender] -= amount;
        _balances[recipient] += (amount - fee);
        _balances[owner] += fee;

        emit Transfer(sender, recipient, amount - fee);
        emit Transfer(sender, owner, fee);
    }

    function _approve(address _owner, address spender, uint256 amount) internal {
        require(_owner != address(0), ""Approve from the zero address"");
        require(spender != address(0), ""Approve to the zero address"");

        _allowances[_owner][spender] = amount;
        emit Approval(_owner, spender, amount);
    }

    function setFeePercentage(uint256 newFeePercentage) external onlyOwner {
        require(newFeePercentage <= 10, ""Fee percentage too high"");
        feePercentage = newFeePercentage;
    }

    function excludeFromFees(address account, bool exclude) external onlyOwner {
        excludedFromFees[account] = exclude;
    }
}",contract_112.sol
"Develop a smart contract that manages a digital asset with features such as token transfer, minting, and burning. Ensure the contract has a total supply tracker and allows the owner to manage the minting and burning of tokens. Make sure the contract includes a minting function that checks the total supply before minting new tokens. Provide a high-level overview of the contract structure and functionality.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DigitalAssetManager {
    string public name = ""Digital Asset"";
    string public symbol = ""DA"";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    address public owner;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Mint(address indexed to, uint256 value);
    event Burn(address indexed from, uint256 value);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor(uint256 initialSupply) {
        owner = msg.sender;
        mint(owner, initialSupply);
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }

    function mint(address to, uint256 value) public onlyOwner returns (bool success) {
        require(totalSupply + value >= totalSupply, ""Overflow""); // Prevent overflow
        totalSupply += value;
        balanceOf[to] += value;
        emit Mint(to, value);
        emit Transfer(address(0), to, value);
        return true;
    }

    function burn(uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        totalSupply -= value;
        balanceOf[msg.sender] -= value;
        emit Burn(msg.sender, value);
        emit Transfer(msg.sender, address(0), value);
        return true;
    }
}",contract_113.sol
"Create a smart contract that allows users to mint, transfer, and burn NFTs. Implement a token cap and royalty mechanism. The contract should be pausable and have a base URI for token metadata. Organize your code following best practices and use OpenZeppelin's pre-written contracts for compatibility and security.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _transferOwnership(_msgSender());
    }

    modifier onlyOwner() {
        require(owner() == _msgSender(), ""Ownable: caller is not the owner"");
        _;
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

interface IERC165 {
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

abstract contract ERC165 is IERC165 {
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}

interface IERC721 is IERC165 {
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function balanceOf(address owner) external view returns (uint256 balance);
    function ownerOf(uint256 tokenId) external view returns (address owner);
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    function transferFrom(address from, address to, uint256 tokenId) external;
    function approve(address to, uint256 tokenId) external;
    function getApproved(uint256 tokenId) external view returns (address operator);
    function setApprovalForAll(address operator, bool _approved) external;
    function isApprovedForAll(address owner, address operator) external view returns (bool);
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
}

interface IERC721Metadata is IERC721 {
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function tokenURI(uint256 tokenId) external view returns (string memory);
}

library Address {
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, ""Address: insufficient balance"");
        (bool success, ) = recipient.call{ value: amount }("""");
        require(success, ""Address: unable to send value, recipient may have reverted"");
    }

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
      return functionCall(target, data, ""Address: low-level call failed"");
    }

    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, ""Address: low-level call with value failed"");
    }

    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, ""Address: insufficient balance for call"");
        require(isContract(target), ""Address: call to non-contract"");
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, ""Address: low-level static call failed"");
    }

    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
        require(isContract(target), ""Address: static call to non-contract"");
        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, ""Address: low-level delegate call failed"");
    }

    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        require(isContract(target), ""Address: delegate call to non-contract"");
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            if (returndata.length > 0) {
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

abstract contract Pausable is Context {
    event Paused(address account);
    event Unpaused(address account);

    bool private _paused;

    constructor() {
        _paused = false;
    }

    function paused() public view virtual returns (bool) {
        return _paused;
    }

    modifier whenNotPaused() {
        require(!paused(), ""Pausable: paused"");
        _;
    }

    modifier whenPaused() {
        require(paused(), ""Pausable: not paused"");
        _;
    }

    function _pause() internal virtual whenNotPaused {
        _paused = true;
        emit Paused(_msgSender());
    }

    function _unpause() internal virtual whenPaused {
        _paused = false;
        emit Unpaused(_msgSender());
    }
}

contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, Pausable, Ownable {
    using Address for address;
    using Strings for uint256;

    string private _name;
    string private _symbol;
    string private _baseURI;
    uint256 private _tokenIdCounter;
    uint256 public constant MAX_SUPPLY = 10000;
    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
        _baseURI = """";
    }

    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return
            interfaceId == type(IERC721).interfaceId ||
            interfaceId == type(IERC721Metadata).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    function balanceOf(address owner) public view virtual override returns (uint256) {
        require(owner != address(0), ""ERC721: balance query for the zero address"");
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) public view virtual override returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), ""ERC721: owner query for nonexistent token"");
        return owner;
    }

    function name() public view virtual override returns (string memory) {
        return _name;
    }

    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        require(_exists(tokenId), ""ERC721Metadata: URI query for nonexistent token"");
        return bytes(_baseURI).length > 0 ? string(abi.encodePacked(_baseURI, tokenId.toString())) : """";
    }

    function setBaseURI(string memory baseURI_) external onlyOwner {
        _baseURI = baseURI_;
    }

    function pause() public onlyOwner {
        _pause();
    }

    function unpause() public onlyOwner {
        _unpause();
    }

    function safeMint(address to) public onlyOwner whenNotPaused {
        require(_tokenIdCounter + 1 <= MAX_SUPPLY, ""ERC721: max supply reached"");
        uint256 tokenId = _tokenIdCounter + 1;
        _mint(to, tokenId);
        _tokenIdCounter++;
    }

    function burn(uint256 tokenId) public virtual {
        require(_isApprovedOrOwner(_msgSender(), tokenId), ""ERC721: caller is not owner nor approved"");
        _burn(tokenId);
    }

    function _baseURI() internal view virtual returns (string memory) {
        return _baseURI;
    }

    function approve(address to, uint256 tokenId) public virtual override {
        address owner = ERC721.ownerOf(tokenId);
        require(to != owner, ""ERC721: approval to current owner"");
        require(
            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
            ""ERC721: approve caller is not owner nor approved for all""
        );
        _approve(to, tokenId);
    }

    function getApproved(uint256 tokenId) public view virtual override returns (address) {
        require(_exists(tokenId), ""ERC721: approved query for nonexistent token"");
        return _tokenApprovals[tokenId];
    }

    function setApprovalForAll(address operator, bool approved) public virtual override {
        require(operator != _msgSender(), ""ERC721: approve to caller"");
        _operatorApprovals[_msgSender()][operator] = approved;
        emit ApprovalForAll(_msgSender(), operator, approved);
    }

    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function transferFrom(address from, address to, uint256 tokenId) public virtual override {
        require(_isApprovedOrOwner(_msgSender(), tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _transfer(from, to, tokenId);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {
        safeTransferFrom(from, to, tokenId, """");
    }

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {
        require(_isApprovedOrOwner(_msgSender(), tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _safeTransfer(from, to, tokenId, _data);
    }

    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _exists(uint256 tokenId) internal view virtual returns (bool) {
        return _owners[tokenId] != address(0);
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");
        address owner = ERC721.ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    function _safeMint(address to, uint256 tokenId) internal virtual {
        _safeMint(to, tokenId, """");
    }

    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {
        _mint(to, tokenId);
        require(
            _checkOnERC721Received(address(0), to, tokenId, _data),
            ""ERC721: transfer to non ERC721Receiver implementer""
        );
    }

    function _mint(address to, uint256 tokenId) internal virtual {
        require(to != address(0), ""ERC721: mint to the zero address"");
        require(!_exists(tokenId), ""ERC721: token already minted"");
        _beforeTokenTransfer(address(0), to, tokenId);
        _balances[to] += 1;
        _owners[tokenId] = to;
        emit Transfer(address(0), to, tokenId);
    }

    function _burn(uint256 tokenId) internal virtual {
        address owner = ERC721.ownerOf(tokenId);
        _beforeTokenTransfer(owner, address(0), tokenId);
        _approve(address(0), tokenId);
        _balances[owner] -= 1;
        delete _owners[tokenId];
        emit Transfer(owner, address(0), tokenId);
    }

    function _transfer(address from, address to, uint256 tokenId) internal virtual {
        require(ERC721.ownerOf(tokenId) == from, ""ERC721: transfer of token that is not own"");
        require(to != address(0), ""ERC721: transfer to the zero address"");
        _beforeTokenTransfer(from, to, tokenId);
        _approve(address(0), tokenId);
        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;
        emit Transfer(from, to, tokenId);
    }

    function _approve(address to, uint256 tokenId) internal virtual {
        _tokenApprovals[tokenId] = to;
        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);
    }

    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) private returns (bool) {
        if (to.isContract()) {
            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
                return retval == IERC721Receiver.onERC721Received.selector;
            } catch (bytes memory reason) {
                if (reason.length == 0) {
                    revert(""ERC721: transfer to non ERC721Receiver implementer"");
                } else {
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        } else {
            return true;
        }
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }
}

interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}

library Strings {
    bytes16 private constant _HEX_SYMBOLS = ""0123456789abcdef"";

    function toString(uint256 value) internal pure returns (string memory) {",contract_114.sol
"Develop a smart contract that follows the ERC20 token standard. The contract should manage token balances and allowance values for each address. Implement transfer, approve, and transferFrom functions. Ensure minting and burning tokens are supported. Include a constructor for initializing the token's name, symbol, and decimals.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    mapping(address => uint256) private balances;
    mapping(address => mapping(address => uint256)) private allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
    }

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return allowances[owner][spender];
    }

    function transfer(address to, uint256 value) public returns (bool) {
        require(to != address(0), ""ERC20: transfer to the zero address"");
        require(balances[msg.sender] >= value, ""ERC20: transfer amount exceeds balance"");

        balances[msg.sender] -= value;
        balances[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool) {
        allowances[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        require(to != address(0), ""ERC20: transfer to the zero address"");
        require(balances[from] >= value, ""ERC20: transfer amount exceeds balance"");
        require(allowances[from][msg.sender] >= value, ""ERC20: transfer amount exceeds allowance"");

        balances[from] -= value;
        balances[to] += value;
        allowances[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }

    function mint(address to, uint256 value) public {
        require(to != address(0), ""ERC20: mint to the zero address"");

        totalSupply += value;
        balances[to] += value;
        emit Transfer(address(0), to, value);
    }

    function burn(uint256 value) public {
        require(balances[msg.sender] >= value, ""ERC20: burn amount exceeds balance"");

        totalSupply -= value;
        balances[msg.sender] -= value;
        emit Transfer(msg.sender, address(0), value);
    }
}",contract_115.sol
"Create a smart contract for the Olympus ERC20 token, implementing minting, burning, and total supply functionality. Integrate the OlympusAuthority contract and ensure token security measures are in place. Test the contract for reliability, including edge cases such as unauthorized minting and burn excess.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract OlympusERC20 {
    string public name = ""Olympus"";
    string public symbol = ""OLY"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    address public minter;
    OlympusAuthority public authority;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Mint(address indexed to, uint256 value);
    event Burn(address indexed from, uint256 value);

    modifier onlyMinter() {
        require(msg.sender == minter, ""Only minter can call this function"");
        _;
    }

    modifier onlyAuthority() {
        require(authority.canCall(msg.sender, address(this), msg.sig), ""Unauthorized"");
        _;
    }

    constructor(address _minter, address _authority) {
        minter = _minter;
        authority = OlympusAuthority(_authority);
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], ""Insufficient balance"");
        require(_value <= allowance[_from][msg.sender], ""Allowance exceeded"");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    function mint(address _to, uint256 _value) public onlyMinter onlyAuthority {
        totalSupply += _value;
        balanceOf[_to] += _value;
        emit Mint(_to, _value);
        emit Transfer(address(0), _to, _value);
    }

    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        totalSupply -= _value;
        balanceOf[msg.sender] -= _value;
        emit Burn(msg.sender, _value);
        emit Transfer(msg.sender, address(0), _value);
        return true;
    }
}

contract OlympusAuthority {
    mapping(address => mapping(address => mapping(bytes4 => bool))) public canCall;

    event SetAuthority(address indexed user, address indexed target, bytes4 indexed functionSig, bool authorized);

    function setAuthority(address user, address target, bytes4 functionSig, bool authorized) public {
        canCall[user][target][functionSig] = authorized;
        emit SetAuthority(user, target, functionSig, authorized);
    }
}",contract_116.sol
"Develop an NFT contract that allows the creation and minting of unique digital assets. The contract should support a role-based access control system and allow certain authorized users to mint new NFTs. Include a way to safely mint new NFTs, increment the token ID counter, and provide the new token ID to the caller. Additionally, consider implementing basic ERC-721 functionality, like token names and descriptions.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract NFTContract is ERC721 {
    address public owner;
    uint256 public tokenCounter;

    mapping(address => bool) public minters;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier onlyMinter() {
        require(minters[msg.sender], ""Not a minter"");
        _;
    }

    constructor(string memory name, string memory symbol) ERC721(name, symbol) {
        owner = msg.sender;
        tokenCounter = 0;
    }

    function addMinter(address _minter) public onlyOwner {
        minters[_minter] = true;
    }

    function removeMinter(address _minter) public onlyOwner {
        minters[_minter] = false;
    }

    function mintNFT(address _to) public onlyMinter returns (uint256) {
        tokenCounter++;
        _safeMint(_to, tokenCounter);
        return tokenCounter;
    }
}

abstract contract ERC721 {
    string private _name;
    string private _symbol;

    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function _safeMint(address to, uint256 tokenId) internal virtual {
        require(to != address(0), ""ERC721: mint to the zero address"");
        require(!_exists(tokenId), ""ERC721: token already minted"");

        _beforeTokenTransfer(address(0), to, tokenId);

        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(address(0), to, tokenId);
    }

    function _exists(uint256 tokenId) internal view virtual returns (bool) {
        return _owners[tokenId] != address(0);
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual {}

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
}",contract_117.sol
"Create a smart contract that implements a subscription-based membership system for an NFT collection. The contract should allow users to subscribe to different plans, which specify the subscription duration and price. Develop functions to manage subscription plans, mint tokens, and track user subscriptions. Include checks for valid inputs and handle exceptions for invalid requests. Prioritize maintainability and scalability for future updates.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SubscriptionNFT {
    struct SubscriptionPlan {
        uint256 duration; // Duration in seconds
        uint256 price; // Price in wei
        bool active;
    }

    struct UserSubscription {
        uint256 planId;
        uint256 startTimestamp;
    }

    address public owner;
    uint256 public nextPlanId;
    mapping(uint256 => SubscriptionPlan) public plans;
    mapping(address => UserSubscription) public userSubscriptions;
    mapping(address => uint256) public balances;

    event PlanAdded(uint256 planId, uint256 duration, uint256 price);
    event SubscriptionStarted(address user, uint256 planId, uint256 startTimestamp);
    event Withdrawal(address indexed to, uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
        nextPlanId = 1;
    }

    function addPlan(uint256 duration, uint256 price) external onlyOwner {
        require(duration > 0, ""Duration must be greater than 0"");
        require(price > 0, ""Price must be greater than 0"");

        plans[nextPlanId] = SubscriptionPlan(duration, price, true);
        emit PlanAdded(nextPlanId, duration, price);
        nextPlanId++;
    }

    function subscribe(uint256 planId) external payable {
        SubscriptionPlan storage plan = plans[planId];
        require(plan.active, ""Plan is not active"");
        require(msg.value == plan.price, ""Incorrect subscription price"");

        UserSubscription storage userSub = userSubscriptions[msg.sender];
        require(userSub.planId == 0 || block.timestamp > userSub.startTimestamp + plans[userSub.planId].duration, ""User already subscribed"");

        userSub.planId = planId;
        userSub.startTimestamp = block.timestamp;
        balances[owner] += msg.value;

        emit SubscriptionStarted(msg.sender, planId, block.timestamp);
    }

    function withdraw(uint256 amount) external onlyOwner {
        require(amount <= balances[owner], ""Insufficient balance"");
        balances[owner] -= amount;
        payable(owner).transfer(amount);
        emit Withdrawal(owner, amount);
    }

    function deactivatePlan(uint256 planId) external onlyOwner {
        require(plans[planId].active, ""Plan is already inactive"");
        plans[planId].active = false;
    }

    function activatePlan(uint256 planId) external onlyOwner {
        require(!plans[planId].active, ""Plan is already active"");
        plans[planId].active = true;
    }

    function updatePlan(uint256 planId, uint256 duration, uint256 price) external onlyOwner {
        require(duration > 0, ""Duration must be greater than 0"");
        require(price > 0, ""Price must be greater than 0"");
        SubscriptionPlan storage plan = plans[planId];
        require(plan.duration > 0, ""Plan does not exist"");

        plan.duration = duration;
        plan.price = price;
    }

    function isSubscribed(address user) public view returns (bool) {
        UserSubscription storage userSub = userSubscriptions[user];
        return userSub.planId != 0 && block.timestamp <= userSub.startTimestamp + plans[userSub.planId].duration;
    }
}",contract_118.sol
"Create a smart contract that enables liquidity pool management, including deposit and withdrawal functionality, and administrator control. The contract should use mappings to track pool balances and total supply, and include functions for depositing and withdrawing tokens, setting administrators, and emitting events.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract LiquidityPoolManager {
    mapping(address => uint256) public poolBalances;
    uint256 public totalSupply;
    mapping(address => bool) public administrators;

    event Deposit(address indexed user, uint256 amount);
    event Withdrawal(address indexed user, uint256 amount);
    event AdministratorSet(address indexed admin, bool isAdmin);

    modifier onlyAdmin() {
        require(administrators[msg.sender], ""Not an administrator"");
        _;
    }

    constructor() {
        administrators[msg.sender] = true;
    }

    function deposit(uint256 amount) external {
        require(amount > 0, ""Amount must be greater than 0"");
        poolBalances[msg.sender] += amount;
        totalSupply += amount;
        emit Deposit(msg.sender, amount);
    }

    function withdraw(uint256 amount) external {
        require(amount > 0, ""Amount must be greater than 0"");
        require(poolBalances[msg.sender] >= amount, ""Insufficient balance"");
        poolBalances[msg.sender] -= amount;
        totalSupply -= amount;
        emit Withdrawal(msg.sender, amount);
    }

    function setAdministrator(address admin, bool isAdmin) external onlyAdmin {
        administrators[admin] = isAdmin;
        emit AdministratorSet(admin, isAdmin);
    }
}",contract_119.sol
"Implement a smart contract for a token that is compatible with the IERC20 interface. The contract should include functions for transferring tokens, approving transfers, and emitting events for transaction records. It should also include variables for keeping track of token balances and allowances. The SafeMath library should be used for arithmetic operations.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }
}

contract ERC20Token is IERC20 {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    constructor(string memory name_, string memory symbol_, uint8 decimals_, uint256 totalSupply_) {
        _name = name_;
        _symbol = symbol_;
        _decimals = decimals_;
        _totalSupply = totalSupply_;
        _balances[msg.sender] = totalSupply_;
        emit Transfer(address(0), msg.sender, totalSupply_);
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}",contract_120.sol
"Create a smart contract that builds upon the OraclizeI contract by introducing a mechanism to manage data sources. Develop functions to set and retrieve data sources, and include a mapping to track gas prices. Utilize the Buffer and CBOR libraries in your implementation. Ensure the contract is well-structured and correctly implemented.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract OraclizeI {
    // Placeholder for OraclizeI contract functionality
}

contract Buffer {
    // Placeholder for Buffer library functionality
}

contract CBOR {
    // Placeholder for CBOR library functionality
}

contract DataSourceManager is OraclizeI {
    mapping(bytes32 => string) public dataSources;
    mapping(bytes32 => uint256) public gasPrices;

    event DataSourceSet(bytes32 indexed id, string source);
    event GasPriceSet(bytes32 indexed id, uint256 price);

    function setDataSource(bytes32 _id, string memory _source) public {
        dataSources[_id] = _source;
        emit DataSourceSet(_id, _source);
    }

    function getDataSource(bytes32 _id) public view returns (string memory) {
        return dataSources[_id];
    }

    function setGasPrice(bytes32 _id, uint256 _price) public {
        gasPrices[_id] = _price;
        emit GasPriceSet(_id, _price);
    }

    function getGasPrice(bytes32 _id) public view returns (uint256) {
        return gasPrices[_id];
    }
}

// Placeholder implementations for Buffer and CBOR libraries
contract Buffer {
    function buffer(uint capacity) internal pure returns (Buffer memory r) {
        assembly {
            r := mload(0x40)
            mstore(0x40, add(r, and(add(add(0x20, 0x1f), capacity), not(0x1f))))
            mstore(r, capacity)
        }
    }

    function append(Buffer memory buf, uint8 data) internal pure {
        assembly {
            let newOffset := add(buf, 0x20)
            mstore8(newOffset, data)
            mstore(buf, add(mload(buf), 1))
        }
    }
}

contract CBOR {
    using Buffer for Buffer.Buffer;

    function encodeType(Buffer.Buffer memory buf, uint8 major, uint value) internal pure {
        if(value < 24) {
            buf.append(uint8((major << 5) | value));
        } else if(value <= 0xFF) {
            buf.append(uint8((major << 5) | 24));
            buf.append(uint8(value));
        } else if(value <= 0xFFFF) {
            buf.append(uint8((major << 5) | 25));
            buf.append(uint8((value >> 8) & 0xFF));
            buf.append(uint8(value & 0xFF));
        } else if(value <= 0xFFFFFFFF) {
            buf.append(uint8((major << 5) | 26));
            buf.append(uint8((value >> 24) & 0xFF));
            buf.append(uint8((value >> 16) & 0xFF));
            buf.append(uint8((value >> 8) & 0xFF));
            buf.append(uint8(value & 0xFF));
        } else {
            buf.append(uint8((major << 5) | 27));
            buf.append(uint8((value >> 56) & 0xFF));
            buf.append(uint8((value >> 48) & 0xFF));
            buf.append(uint8((value >> 40) & 0xFF));
            buf.append(uint8((value >> 32) & 0xFF));
            buf.append(uint8((value >> 24) & 0xFF));
            buf.append(uint8((value >> 16) & 0xFF));
            buf.append(uint8((value >> 8) & 0xFF));
            buf.append(uint8(value & 0xFF));
        }
    }
}",contract_121.sol
"Create a Solidity smart contract that allows token minting and tracks token count. The contract should inherit from ERC721 and include a function for minting new tokens. The function should take owner's address, token amount, and delegate's address as parameters and emit an event for tracking minting activity. Focus on implementing the necessary functions and views for token URI generation.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC721 {
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    function balanceOf(address owner) public view returns (uint256) {
        require(owner != address(0), ""ERC721: balance query for the zero address"");
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) public view returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), ""ERC721: owner query for nonexistent token"");
        return owner;
    }

    function approve(address to, uint256 tokenId) public {
        address owner = ownerOf(tokenId);
        require(to != owner, ""ERC721: approval to current owner"");
        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), ""ERC721: approve caller is not owner nor approved for all"");
        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    function getApproved(uint256 tokenId) public view returns (address) {
        require(_exists(tokenId), ""ERC721: approved query for nonexistent token"");
        return _tokenApprovals[tokenId];
    }

    function setApprovalForAll(address operator, bool approved) public {
        require(operator != msg.sender, ""ERC721: approve to caller"");
        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function isApprovedForAll(address owner, address operator) public view returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function transferFrom(address from, address to, uint256 tokenId) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _transfer(from, to, tokenId);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) public {
        safeTransferFrom(from, to, tokenId, """");
    }

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _safeTransfer(from, to, tokenId, _data);
    }

    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return _owners[tokenId] != address(0);
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    function _safeMint(address to, uint256 tokenId) internal {
        _safeMint(to, tokenId, """");
    }

    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal {
        _mint(to, tokenId);
        require(_checkOnERC721Received(address(0), to, tokenId, _data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _mint(address to, uint256 tokenId) internal {
        require(to != address(0), ""ERC721: mint to the zero address"");
        require(!_exists(tokenId), ""ERC721: token already minted"");
        _beforeTokenTransfer(address(0), to, tokenId);
        _balances[to] += 1;
        _owners[tokenId] = to;
        emit Transfer(address(0), to, tokenId);
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        require(ownerOf(tokenId) == from, ""ERC721: transfer of token that is not own"");
        require(to != address(0), ""ERC721: transfer to the zero address"");
        _beforeTokenTransfer(from, to, tokenId);
        _approve(address(0), tokenId);
        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;
        emit Transfer(from, to, tokenId);
    }

    function _approve(address to, uint256 tokenId) internal {
        _tokenApprovals[tokenId] = to;
        emit Approval(ownerOf(tokenId), to, tokenId);
    }

    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) internal returns (bool) {
        if (to.code.length > 0) {
            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data) returns (bytes4 retval) {
                return retval == IERC721Receiver.onERC721Received.selector;
            } catch (bytes memory reason) {
                if (reason.length == 0) {
                    revert(""ERC721: transfer to non ERC721Receiver implementer"");
                } else {
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        } else {
            return true;
        }
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual {}
}

interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}

contract MyToken is ERC721 {
    event TokenMinted(address indexed owner, uint256 indexed tokenId, address indexed delegate);

    uint256 private _tokenIdCounter;
    string private _baseTokenURI;

    constructor(string memory baseTokenURI) {
        _baseTokenURI = baseTokenURI;
    }

    function mintToken(address owner, uint256 amount, address delegate) public {
        for (uint256 i = 0; i < amount; i++) {
            _tokenIdCounter++;
            _safeMint(owner, _tokenIdCounter);
            emit TokenMinted(owner, _tokenIdCounter, delegate);
        }
    }

    function tokenURI(uint256 tokenId) public view returns (string memory) {
        require(_exists(tokenId), ""ERC721Metadata: URI query for nonexistent token"");
        return string(abi.encodePacked(_baseTokenURI, tokenId));
    }
}",contract_122.sol
Create a smart contract that builds upon the provided Contract and Ownable contract. The contract should allow users to create and manage assets. Include a constructor that takes a unique identifier and a name. Add functions for creating and transferring assets. Ensure the owner has control over creating and managing assets. Utilize the IBEP20 interface for interacting with assets. Keep the contract easy to understand and maintainable.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IBEP20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract AssetManager is Ownable {
    struct Asset {
        uint256 id;
        string name;
        address owner;
    }

    uint256 private _assetIdCounter;
    mapping(uint256 => Asset) private _assets;

    event AssetCreated(uint256 indexed id, string name, address owner);
    event AssetTransferred(uint256 indexed id, address from, address to);

    constructor(uint256 uniqueIdentifier, string memory name) {
        _createAsset(uniqueIdentifier, name, msg.sender);
    }

    function createAsset(uint256 uniqueIdentifier, string memory name) public onlyOwner {
        _createAsset(uniqueIdentifier, name, msg.sender);
    }

    function transferAsset(uint256 id, address newOwner) public {
        Asset storage asset = _assets[id];
        require(asset.owner == msg.sender, ""AssetManager: caller is not the owner of the asset"");
        asset.owner = newOwner;
        emit AssetTransferred(id, msg.sender, newOwner);
    }

    function getAsset(uint256 id) public view returns (uint256, string memory, address) {
        Asset storage asset = _assets[id];
        return (asset.id, asset.name, asset.owner);
    }

    function _createAsset(uint256 uniqueIdentifier, string memory name, address owner) internal {
        _assetIdCounter++;
        _assets[_assetIdCounter] = Asset({
            id: uniqueIdentifier,
            name: name,
            owner: owner
        });
        emit AssetCreated(uniqueIdentifier, name, owner);
    }
}",contract_123.sol
"Create a token contract that enables token transfer between addresses, approves external transactions, and tracks token balances. The contract should provide functions for allowing and withdrawing token approvals. Implement arithmetic operations using the SafeMath library to ensure security. Include a constructor to set the initial token supply and owner.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    address public owner;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        owner = msg.sender;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance too low"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }

    function withdrawApproval(address spender) public returns (bool success) {
        allowance[msg.sender][spender] = 0;
        emit Approval(msg.sender, spender, 0);
        return true;
    }
}",contract_124.sol
"Create a token contract called 'PucieToken' that provides basic token functionality and advanced features. The contract should allow users to transfer tokens, approve transfers, and retrieve token balances. It should also include taxation on transfers, fee exemption, and integration with a swapper interface. The taxation mechanism should deduct fees from the transfer amount and allocate them to a designated recipient. Fee exemption should enable specific addresses to be exempt from paying fees. The swapper interface should enable token transfer between PucieToken and other tokens. Implement the contract with thorough testing and good documentation.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract PucieToken {
    string public name = ""PucieToken"";
    string public symbol = ""PUC"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    mapping(address => bool) public feeExempt;

    address public taxRecipient;
    uint256 public taxRate; // Basis points (100 = 1%)

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event TaxRateUpdated(uint256 newTaxRate);
    event TaxRecipientUpdated(address newTaxRecipient);
    event FeeExemptionUpdated(address indexed account, bool isExempt);

    constructor(uint256 initialSupply, uint256 initialTaxRate, address initialTaxRecipient) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        taxRate = initialTaxRate;
        taxRecipient = initialTaxRecipient;
        feeExempt[msg.sender] = true;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        _transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        allowance[from][msg.sender] -= value;
        _transfer(from, to, value);
        return true;
    }

    function updateTaxRate(uint256 newTaxRate) public {
        require(msg.sender == taxRecipient, ""Only tax recipient can update tax rate"");
        taxRate = newTaxRate;
        emit TaxRateUpdated(newTaxRate);
    }

    function updateTaxRecipient(address newTaxRecipient) public {
        require(msg.sender == taxRecipient, ""Only tax recipient can update tax recipient"");
        taxRecipient = newTaxRecipient;
        emit TaxRecipientUpdated(newTaxRecipient);
    }

    function updateFeeExemption(address account, bool isExempt) public {
        require(msg.sender == taxRecipient, ""Only tax recipient can update fee exemption"");
        feeExempt[account] = isExempt;
        emit FeeExemptionUpdated(account, isExempt);
    }

    function _transfer(address from, address to, uint256 value) internal {
        require(to != address(0), ""Cannot transfer to the zero address"");
        require(balanceOf[from] >= value, ""Insufficient balance"");

        uint256 taxAmount = feeExempt[from] ? 0 : (value * taxRate) / 10000;
        uint256 transferAmount = value - taxAmount;

        balanceOf[from] -= value;
        balanceOf[to] += transferAmount;
        balanceOf[taxRecipient] += taxAmount;

        emit Transfer(from, to, transferAmount);
        emit Transfer(from, taxRecipient, taxAmount);
    }
}",contract_125.sol
"Create a smart contract that verifies identities using World ID and provides a unique identifier for each user. The contract should include functions for verifying proofs, storing hashes, and executing specific logic when a proof is verified. Implement the contract with clear documentation of variables, functions, and logic.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract IdentityVerifier {
    // Struct to store user identity information
    struct Identity {
        bool verified;
        bytes32 hash;
    }

    // Mapping from user address to their identity information
    mapping(address => Identity) public identities;

    // Event emitted when an identity is verified
    event IdentityVerified(address indexed user, bytes32 hash);

    // Function to verify a proof and store the hash
    function verifyProof(bytes32 proofHash) external {
        // Placeholder for actual World ID verification logic
        // In a real scenario, this would involve verifying the proofHash against World ID's API
        bool proofIsValid = true; // Assume proof is valid for demonstration purposes

        if (proofIsValid) {
            identities[msg.sender] = Identity({
                verified: true,
                hash: proofHash
            });
            emit IdentityVerified(msg.sender, proofHash);
        } else {
            revert(""Proof verification failed"");
        }
    }

    // Function to check if an address has a verified identity
    function isVerified(address user) external view returns (bool) {
        return identities[user].verified;
    }

    // Function to get the hash of a verified identity
    function getIdentityHash(address user) external view returns (bytes32) {
        require(identities[user].verified, ""Identity not verified"");
        return identities[user].hash;
    }

    // Example function that executes specific logic when a proof is verified
    function executeVerifiedLogic(address user) external {
        require(identities[user].verified, ""Identity not verified"");
        // Placeholder for specific logic to be executed
        // For example, granting access to certain functionalities or assets
    }
}",contract_126.sol
Create a smart contract that uses the OpenZeppelin's AccessControl contract and implements a simple role-based access control system. The contract should allow users to grant and revoke roles for addresses and check if a specific role is held by an address. Provide a detailed description of the required functionality and include specific Solidity functions and variables as necessary. The contract should adhere to the IAccessControl interface and emit relevant events.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract AccessControl {
    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    struct RoleData {
        mapping(address => bool) members;
        bytes32 adminRole;
    }

    mapping(bytes32 => RoleData) private _roles;

    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    function hasRole(bytes32 role, address account) public view returns (bool) {
        return _roles[role].members[account];
    }

    function getRoleAdmin(bytes32 role) public view returns (bytes32) {
        return _roles[role].adminRole;
    }

    function grantRole(bytes32 role, address account) public {
        require(hasRole(_roles[role].adminRole, msg.sender), ""AccessControl: sender must be an admin to grant"");
        _grantRole(role, account);
    }

    function revokeRole(bytes32 role, address account) public {
        require(hasRole(_roles[role].adminRole, msg.sender), ""AccessControl: sender must be an admin to revoke"");
        _revokeRole(role, account);
    }

    function renounceRole(bytes32 role, address account) public {
        require(account == msg.sender, ""AccessControl: can only renounce roles for self"");
        _revokeRole(role, account);
    }

    function _setupRole(bytes32 role, address account) internal {
        _grantRole(role, account);
    }

    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {
        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);
        _roles[role].adminRole = adminRole;
    }

    function _grantRole(bytes32 role, address account) private {
        if (!hasRole(role, account)) {
            _roles[role].members[account] = true;
            emit RoleGranted(role, account, msg.sender);
        }
    }

    function _revokeRole(bytes32 role, address account) private {
        if (hasRole(role, account)) {
            _roles[role].members[account] = false;
            emit RoleRevoked(role, account, msg.sender);
        }
    }
}",contract_127.sol
"Create a smart contract that implements the Anyswap USDC v5 ERC20 standard. The contract should allow for token transfers, approve and call other contracts, and permit-based approvals. Include a function for token approval and another for token transfer. Utilize the SafeERC20 library for secure and efficient token handling. Implement necessary logic for managing token balances and allowances. Focus on ensuring the contract adheres to common ERC20 and EIP-677 standards.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface IERC20Permit {
    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
}

library SafeERC20 {
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            ""SafeERC20: approve from non-zero to non-zero allowance"");
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        bytes memory returndata = address(token).functionCall(data, ""SafeERC20: low-level call failed"");
        if (returndata.length > 0) {
            require(abi.decode(returndata, (bool)), ""SafeERC20: ERC20 operation did not succeed"");
        }
    }
}

library Address {
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, ""Address: insufficient balance for call"");
        require(isContract(target), ""Address: call to non-contract"");

        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            if (returndata.length > 0) {
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

contract AnyswapUSDC is IERC20, IERC20Permit {
    using SafeERC20 for IERC20;

    string public constant name = ""Anyswap USDC"";
    string public constant symbol = ""aUSDC"";
    uint8 public constant decimals = 6;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    uint256 private _totalSupply;

    bytes32 public DOMAIN_SEPARATOR;
    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
    mapping(address => uint256) public nonces;

    constructor() {
        uint256 chainId;
        assembly {
            chainId := chainid()
        }
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),
                keccak256(bytes(name)),
                keccak256(bytes('1')),
                chainId,
                address(this)
            )
        );
    }

    function totalSupply() external view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) external view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) external override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) external view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) external override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external override {
        require(deadline >= block.timestamp, 'AnyswapUSDC: EXPIRED');
        bytes32 digest = keccak256(
            abi.encodePacked(
                '\x19\x01',
                DOMAIN_SEPARATOR,
                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))
            )
        );
        address recoveredAddress = ecrecover(digest, v, r, s);
        require(recoveredAddress != address(0) && recoveredAddress == owner, 'AnyswapUSDC: INVALID_SIGNATURE');
        _approve(owner, spender, value);
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""AnyswapUSDC: transfer from the zero address"");
        require(recipient != address(0), ""AnyswapUSDC: transfer to the zero address"");

        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""AnyswapUSDC: approve from the zero address"");
        require(spender != address(0), ""AnyswapUSDC: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _mint(address account, uint256 amount) internal {
        require(account != address(0), ""AnyswapUSDC: mint to the zero address"");

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) internal {
        require(account != address(0), ""AnyswapUSDC: burn from the zero address"");

        _balances[account] -= amount;
        _totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }
}",contract_128.sol
"Create a smart contract that is similar to an existing one, but with some modifications. The contract should be based on the provided code and should implement a new token with its own symbol, name, and contract owner. The contract should allow for token transfers and approvals, and should emit events when such actions occur. Include a constructor to initialize the contract's main variables.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MyToken {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    address public owner;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply;
        balanceOf[msg.sender] = _totalSupply;
        owner = msg.sender;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], ""Insufficient balance"");
        require(_value <= allowance[_from][msg.sender], ""Allowance too low"");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }
}",contract_129.sol
Create a smart contract that allows for initialization and reinitialization to a specific version. Use modifiers to control the initialization process. Implement functions to manage initialization and reinitialization. Incorporate a library that enables contract interaction and value sending. Make sure the contract complies with the MIT license. Keep in mind the need for flexibility in initializable contracts.,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }
}

contract InitializableContract {
    using SafeMath for uint256;

    address private _owner;
    uint256 private _version;
    bool private _initialized;

    modifier onlyOwner() {
        require(msg.sender == _owner, ""Not the contract owner"");
        _;
    }

    modifier notInitialized() {
        require(!_initialized, ""Already initialized"");
        _;
    }

    modifier initialized() {
        require(_initialized, ""Not initialized yet"");
        _;
    }

    constructor() {
        _owner = msg.sender;
        _version = 0;
        _initialized = false;
    }

    function initialize(uint256 version) public onlyOwner notInitialized {
        _version = version;
        _initialized = true;
    }

    function reinitialize(uint256 newVersion) public onlyOwner initialized {
        _version = newVersion;
    }

    function getVersion() public view returns (uint256) {
        return _version;
    }

    function isInitialized() public view returns (bool) {
        return _initialized;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""New owner is the zero address"");
        _owner = newOwner;
    }

    function getOwner() public view returns (address) {
        return _owner;
    }

    function sendValue(address payable recipient, uint256 amount) public onlyOwner {
        require(address(this).balance >= amount, ""Insufficient balance"");
        (bool success, ) = recipient.call{value: amount}("""");
        require(success, ""Transfer failed"");
    }

    receive() external payable {}
}",contract_130.sol
"Create a TRC20 token smart contract that supports token transfer, approval, and allowance management. The contract should include methods for token minting and burning. Consider implementing address validation to prevent unauthorized transactions. Ensure that the contract complies with the ITRC20 standard and follows best practices for coding and security.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TRC20Token {
    string public name = ""MyTRC20Token"";
    string public symbol = ""MTT"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Mint(address indexed to, uint256 value);
    event Burn(address indexed from, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(to != address(0), ""Invalid address"");
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        require(spender != address(0), ""Invalid address"");
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(from != address(0) && to != address(0), ""Invalid address"");
        require(balanceOf[from] >= value, ""Insufficient balance"");
        require(allowance[from][msg.sender] >= value, ""Allowance too low"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }

    function mint(address to, uint256 value) public returns (bool success) {
        require(to != address(0), ""Invalid address"");
        totalSupply += value;
        balanceOf[to] += value;
        emit Mint(to, value);
        emit Transfer(address(0), to, value);
        return true;
    }

    function burn(uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        totalSupply -= value;
        balanceOf[msg.sender] -= value;
        emit Burn(msg.sender, value);
        emit Transfer(msg.sender, address(0), value);
        return true;
    }
}",contract_131.sol
"Develop a smart contract that implements a token with a maximum supply of 600 Billion tokens. The token should have a pre-minted balance of 600 Billion tokens. The contract should allow for token transfers between accounts, approve spending of tokens, and enable or disable transfer of frozen accounts. Include a function to burn tokens. Implement safe math operations and ensure proper permissions checks.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MyToken {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    address public owner;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    mapping(address => bool) public frozenAccounts;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Burn(address indexed from, uint256 value);
    event FrozenAccount(address target, bool frozen);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 600 * 10**9 * 10**uint256(decimals); // 600 Billion tokens
        balanceOf[owner] = totalSupply;
        emit Transfer(address(0), owner, totalSupply);
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0), ""Invalid address"");
        require(!frozenAccounts[msg.sender], ""Sender account is frozen"");
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0), ""Invalid address"");
        require(!frozenAccounts[_from], ""From account is frozen"");
        require(balanceOf[_from] >= _value, ""Insufficient balance"");
        require(allowance[_from][msg.sender] >= _value, ""Allowance too low"");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        totalSupply -= _value;
        emit Burn(msg.sender, _value);
        return true;
    }

    function freezeAccount(address target, bool freeze) public onlyOwner {
        frozenAccounts[target] = freeze;
        emit FrozenAccount(target, freeze);
    }
}",contract_132.sol
Develop a smart contract that splits payments to multiple recipients based on their shares. The contract should have a constructor that initializes the payees and their shares. Implement functions to release payments to payees and track the total amount released. The contract should also release ERC20 tokens to payees. Include descriptive comments to explain the logic and error handling mechanisms.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

contract PaymentSplitter {
    address[] private payees;
    uint256[] private shares;
    mapping(address => uint256) private released;
    uint256 private totalReleased;

    event PaymentReleased(address to, uint256 amount);
    event ERC20PaymentReleased(IERC20 token, address to, uint256 amount);

    constructor(address[] memory _payees, uint256[] memory _shares) payable {
        require(_payees.length == _shares.length, ""PaymentSplitter: payees and shares length mismatch"");
        require(_payees.length > 0, ""PaymentSplitter: no payees"");

        for (uint256 i = 0; i < _payees.length; i++) {
            _addPayee(_payees[i], _shares[i]);
        }
    }

    function _addPayee(address _payee, uint256 _share) private {
        require(_payee != address(0), ""PaymentSplitter: payee is the zero address"");
        require(_share > 0, ""PaymentSplitter: share is 0"");
        payees.push(_payee);
        shares.push(_share);
    }

    function release(address payable _payee) public {
        uint256 totalReceived = address(this).balance + totalReleased;
        uint256 payment = (totalReceived * shares[indexOf(_payee)]) / totalShares() - released[_payee];

        require(payment != 0, ""PaymentSplitter: _payee is not due payment"");
        require(address(this).balance >= payment, ""PaymentSplitter: not enough balance"");

        released[_payee] += payment;
        totalReleased += payment;

        _payee.transfer(payment);
        emit PaymentReleased(_payee, payment);
    }

    function releaseERC20(IERC20 token, address _payee) public {
        uint256 totalReceived = token.balanceOf(address(this)) + totalReleased;
        uint256 payment = (totalReceived * shares[indexOf(_payee)]) / totalShares() - released[_payee];

        require(payment != 0, ""PaymentSplitter: _payee is not due payment"");
        require(token.balanceOf(address(this)) >= payment, ""PaymentSplitter: not enough token balance"");

        released[_payee] += payment;
        totalReleased += payment;

        require(token.transfer(_payee, payment), ""PaymentSplitter: ERC20 transfer failed"");
        emit ERC20PaymentReleased(token, _payee, payment);
    }

    function totalShares() public view returns (uint256) {
        uint256 total = 0;
        for (uint256 i = 0; i < shares.length; i++) {
            total += shares[i];
        }
        return total;
    }

    function indexOf(address _payee) private view returns (uint256) {
        for (uint256 i = 0; i < payees.length; i++) {
            if (payees[i] == _payee) {
                return i;
            }
        }
        revert(""PaymentSplitter: payee not found"");
    }
}",contract_133.sol
"Write a Solidity contract that includes assertion functions for boolean conditions. The contract should have three test cases: one for a successful assertion, one for a failed assertion, and one that handles errors. Use a specific function to emit logs and handle errors accordingly. Implement unit tests for these assertions, considering error handling and logging.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract AssertionContract {
    event AssertionResult(bool success, string message);

    function assertSuccess() external {
        bool condition = true;
        string memory message = ""Assertion succeeded"";
        emit AssertionResult(condition, message);
        assert(condition);
    }

    function assertFailure() external {
        bool condition = false;
        string memory message = ""Assertion failed"";
        emit AssertionResult(condition, message);
        assert(condition);
    }

    function assertWithErrorHandling() external {
        bool condition = false;
        string memory message = ""Handling error without assert"";
        emit AssertionResult(condition, message);
        if (!condition) {
            revert(message);
        }
    }
}

// Unit tests are not directly executable in Solidity, but they can be described as follows:
// Note: These tests are conceptual and should be implemented in a testing framework like Truffle, Hardhat, or using JavaScript VM in Remix.

// Test 1: Successful Assertion
// Deploy the contract and call assertSuccess().
// Expected Result: Transaction should succeed, and the event AssertionResult should be emitted with success = true and message = ""Assertion succeeded"".

// Test 2: Failed Assertion
// Deploy the contract and call assertFailure().
// Expected Result: Transaction should revert, and the event AssertionResult should be emitted with success = false and message = ""Assertion failed"".

// Test 3: Error Handling
// Deploy the contract and call assertWithErrorHandling().
// Expected Result: Transaction should revert, and the event AssertionResult should be emitted with success = false and message = ""Handling error without assert"".",contract_134.sol
"Design a Solidity smart contract that enables the creation and management of sets. The contract should include functions for adding, removing, and checking membership. Include a function to retrieve the length of the set. Modify the contract to work with bytes32 values. Consider adding additional functionality, such as inserting and sorting the set, while maintaining the original order.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SetManager {
    struct Set {
        bytes32[] values;
        mapping(bytes32 => bool) isMember;
    }

    mapping(address => Set) private sets;

    function add(bytes32 value) public {
        Set storage set = sets[msg.sender];
        if (!set.isMember[value]) {
            set.values.push(value);
            set.isMember[value] = true;
        }
    }

    function remove(bytes32 value) public {
        Set storage set = sets[msg.sender];
        if (set.isMember[value]) {
            for (uint256 i = 0; i < set.values.length; i++) {
                if (set.values[i] == value) {
                    set.values[i] = set.values[set.values.length - 1];
                    set.values.pop();
                    set.isMember[value] = false;
                    break;
                }
            }
        }
    }

    function isMember(bytes32 value) public view returns (bool) {
        return sets[msg.sender].isMember[value];
    }

    function getLength() public view returns (uint256) {
        return sets[msg.sender].values.length;
    }

    function getValues() public view returns (bytes32[] memory) {
        return sets[msg.sender].values;
    }

    function insertSorted(bytes32 value) public {
        Set storage set = sets[msg.sender];
        if (!set.isMember[value]) {
            uint256 i = 0;
            while (i < set.values.length && set.values[i] < value) {
                i++;
            }
            set.values.push(bytes32(0)); // Temporary placeholder
            for (uint256 j = set.values.length - 1; j > i; j--) {
                set.values[j] = set.values[j - 1];
            }
            set.values[i] = value;
            set.isMember[value] = true;
        }
    }
}",contract_135.sol
"Create a new token contract based on the OpenZeppelin ERC-20 implementation, specifying the token's name, symbol, and total supply. Implement increase and decrease allowance functionality, transfer capabilities, and event triggers for token transfers. Utilize OpenZeppelin's Context and IERC20 contracts as a foundation for the new token. Use mapping variables to track token balances, allowance, and global token supply, and incorporate robust exception handling to ensure secure and reliable token operations.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string private _name;
    string private _symbol;
    uint256 private _totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory name_, string memory symbol_, uint256 totalSupply_) {
        _name = name_;
        _symbol = symbol_;
        _totalSupply = totalSupply_;
        _balances[msg.sender] = totalSupply_;
        emit Transfer(address(0), msg.sender, totalSupply_);
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        require(_balances[msg.sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        _balances[msg.sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        require(_balances[sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        require(_allowances[sender][msg.sender] >= amount, ""ERC20: transfer amount exceeds allowance"");
        _balances[sender] -= amount;
        _balances[recipient] += amount;
        _allowances[sender][msg.sender] -= amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _allowances[msg.sender][spender] += addedValue;
        emit Approval(msg.sender, spender, _allowances[msg.sender][spender]);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        require(_allowances[msg.sender][spender] >= subtractedValue, ""ERC20: decreased allowance below zero"");
        _allowances[msg.sender][spender] -= subtractedValue;
        emit Approval(msg.sender, spender, _allowances[msg.sender][spender]);
        return true;
    }
}",contract_136.sol
"Create a smart contract that allows users to deposit and withdraw ERC721 tokens. The contract should support single and batch transactions. The deposit function should handle single and batch deposits, while the withdraw and withdrawBatch functions should handle single and batch withdrawals. The contract should also have role-based access control and emit events for withdrawn batches.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC721Vault {
    address public owner;
    mapping(address => mapping(uint256 => bool)) public depositedTokens;
    mapping(address => bool) public admins;

    event TokenDeposited(address indexed user, uint256 tokenId);
    event TokenWithdrawn(address indexed user, uint256 tokenId);
    event BatchWithdrawn(address indexed user, uint256[] tokenIds);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier onlyAdmin() {
        require(admins[msg.sender] || msg.sender == owner, ""Not an admin"");
        _;
    }

    constructor() {
        owner = msg.sender;
        admins[msg.sender] = true;
    }

    function addAdmin(address admin) external onlyOwner {
        admins[admin] = true;
    }

    function removeAdmin(address admin) external onlyOwner {
        admins[admin] = false;
    }

    function deposit(uint256 tokenId) external {
        require(!depositedTokens[msg.sender][tokenId], ""Token already deposited"");
        depositedTokens[msg.sender][tokenId] = true;
        emit TokenDeposited(msg.sender, tokenId);
    }

    function depositBatch(uint256[] calldata tokenIds) external {
        for (uint256 i = 0; i < tokenIds.length; i++) {
            require(!depositedTokens[msg.sender][tokenIds[i]], ""Token already deposited"");
            depositedTokens[msg.sender][tokenIds[i]] = true;
            emit TokenDeposited(msg.sender, tokenIds[i]);
        }
    }

    function withdraw(uint256 tokenId) external {
        require(depositedTokens[msg.sender][tokenId], ""Token not deposited"");
        depositedTokens[msg.sender][tokenId] = false;
        emit TokenWithdrawn(msg.sender, tokenId);
    }

    function withdrawBatch(uint256[] calldata tokenIds) external {
        for (uint256 i = 0; i < tokenIds.length; i++) {
            require(depositedTokens[msg.sender][tokenIds[i]], ""Token not deposited"");
            depositedTokens[msg.sender][tokenIds[i]] = false;
        }
        emit BatchWithdrawn(msg.sender, tokenIds);
    }
}",contract_137.sol
"Create a smart contract in Solidity that implements an ERC-20 token, taking into account the following requirements: the token shall have a name and symbol; it shall have a total supply; it shall have a balance for each account; it shall have functionality for transferring tokens between accounts; it shall have functionality for allowing one account to spend tokens on behalf of another account; the contract shall emit events for these actions. Focus on the overall structure and relationships between functions.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply;
        balanceOf[msg.sender] = _totalSupply;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], ""Insufficient balance"");
        require(_value <= allowance[_from][msg.sender], ""Allowance exceeded"");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }
}",contract_138.sol
"Create a smart contract that manages a permission list for disputable items. The contract should allow users to submit, clear, or challenge items, as well as resolve disputes. Consider implementing lists for item submission and clearing requests, as well as a system to manage dispute resolution. Ensure that the contract has the ability to flag items as blacklisted or whitelisted, depending on the 'blacklist' variable. Include functions for submitting, clearing, and challenging items, as well as resolving disputes.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DisputableItems {
    struct Item {
        address submitter;
        bool isBlacklisted;
        bool isDisputed;
        address challenger;
    }

    mapping(uint256 => Item) public items;
    uint256 public itemCount;

    event ItemSubmitted(uint256 indexed itemId, address indexed submitter);
    event ItemCleared(uint256 indexed itemId);
    event ItemChallenged(uint256 indexed itemId, address indexed challenger);
    event DisputeResolved(uint256 indexed itemId, bool isBlacklisted);

    function submitItem() external returns (uint256) {
        itemCount++;
        items[itemCount] = Item({
            submitter: msg.sender,
            isBlacklisted: false,
            isDisputed: false,
            challenger: address(0)
        });
        emit ItemSubmitted(itemCount, msg.sender);
        return itemCount;
    }

    function clearItem(uint256 itemId) external {
        require(itemId <= itemCount && itemId > 0, ""Invalid item ID"");
        Item storage item = items[itemId];
        require(item.submitter == msg.sender, ""Not the submitter"");
        item.isBlacklisted = false;
        emit ItemCleared(itemId);
    }

    function challengeItem(uint256 itemId) external {
        require(itemId <= itemCount && itemId > 0, ""Invalid item ID"");
        Item storage item = items[itemId];
        require(!item.isDisputed, ""Item already disputed"");
        item.isDisputed = true;
        item.challenger = msg.sender;
        emit ItemChallenged(itemId, msg.sender);
    }

    function resolveDispute(uint256 itemId, bool blacklist) external {
        require(itemId <= itemCount && itemId > 0, ""Invalid item ID"");
        Item storage item = items[itemId];
        require(item.isDisputed, ""Item not disputed"");
        item.isDisputed = false;
        item.isBlacklisted = blacklist;
        emit DisputeResolved(itemId, blacklist);
    }
}",contract_139.sol
"Create a smart contract that serves as a service administration system, providing service and finance management. The contract should include admin-only functions and modifiers. Develop a library for safe arithmetic operations and interfaces for IBitGuildToken and IAgonFight. Design a contract that manages agon fights, including functions for creating, canceling, challenging, and resolving fights. Set max agon count and agon fight contract address during deployment.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }
}

interface IBitGuildToken {
    function transfer(address to, uint256 value) external returns (bool);
    function balanceOf(address who) external view returns (uint256);
}

interface IAgonFight {
    function createFight(address challenger, address opponent) external returns (uint256);
    function cancelFight(uint256 fightId) external;
    function challengeFight(uint256 fightId) external;
    function resolveFight(uint256 fightId, address winner) external;
}

contract ServiceAdministrationSystem {
    using SafeMath for uint256;

    address public admin;
    uint256 public maxAgonCount;
    address public agonFightContractAddress;

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can call this function"");
        _;
    }

    constructor(uint256 _maxAgonCount, address _agonFightContractAddress) {
        admin = msg.sender;
        maxAgonCount = _maxAgonCount;
        agonFightContractAddress = _agonFightContractAddress;
    }

    function setMaxAgonCount(uint256 _maxAgonCount) external onlyAdmin {
        maxAgonCount = _maxAgonCount;
    }

    function setAgonFightContractAddress(address _agonFightContractAddress) external onlyAdmin {
        agonFightContractAddress = _agonFightContractAddress;
    }

    function createFight(address challenger, address opponent) external onlyAdmin returns (uint256) {
        IAgonFight agonFight = IAgonFight(agonFightContractAddress);
        return agonFight.createFight(challenger, opponent);
    }

    function cancelFight(uint256 fightId) external onlyAdmin {
        IAgonFight agonFight = IAgonFight(agonFightContractAddress);
        agonFight.cancelFight(fightId);
    }

    function challengeFight(uint256 fightId) external onlyAdmin {
        IAgonFight agonFight = IAgonFight(agonFightContractAddress);
        agonFight.challengeFight(fightId);
    }

    function resolveFight(uint256 fightId, address winner) external onlyAdmin {
        IAgonFight agonFight = IAgonFight(agonFightContractAddress);
        agonFight.resolveFight(fightId, winner);
    }

    function transferBitGuildTokens(address to, uint256 value) external onlyAdmin returns (bool) {
        IBitGuildToken bitGuildToken = IBitGuildToken(agonFightContractAddress);
        return bitGuildToken.transfer(to, value);
    }

    function getBitGuildTokenBalance(address who) external view returns (uint256) {
        IBitGuildToken bitGuildToken = IBitGuildToken(agonFightContractAddress);
        return bitGuildToken.balanceOf(who);
    }
}",contract_140.sol
"Create a Solidity smart contract that allows for airdrops of items. The contract should include functions for minting new items, retrieving the items held by an owner, and retrieving the URI of an item. Implement the ERC721Enumerable and Ownable contracts from OpenZeppelin to enable access controls and enumeration of items. Include functions for setting the cost of new item minting, maximum mint amount, not revealed URI, and base URI. Add event logs for the mint function and reveal function.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC721Enumerable {
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _owners;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;
    uint256 private _totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function balanceOf(address owner) public view returns (uint256) {
        require(owner != address(0), ""ERC721: balance query for the zero address"");
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) public view returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), ""ERC721: owner query for nonexistent token"");
        return owner;
    }

    function approve(address to, uint256 tokenId) public {
        address owner = ownerOf(tokenId);
        require(to != owner, ""ERC721: approval to current owner"");
        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), ""ERC721: approve caller is not owner nor approved for all"");
        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    function getApproved(uint256 tokenId) public view returns (address) {
        require(_exists(tokenId), ""ERC721: approved query for nonexistent token"");
        return _tokenApprovals[tokenId];
    }

    function setApprovalForAll(address operator, bool approved) public {
        require(operator != msg.sender, ""ERC721: approve to caller"");
        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function isApprovedForAll(address owner, address operator) public view returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function transferFrom(address from, address to, uint256 tokenId) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _transfer(from, to, tokenId);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) public {
        safeTransferFrom(from, to, tokenId, """");
    }

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _safeTransfer(from, to, tokenId, _data);
    }

    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return _owners[tokenId] != address(0);
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    function _safeMint(address to, uint256 tokenId) internal {
        _safeMint(to, tokenId, """");
    }

    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal {
        _mint(to, tokenId);
        require(_checkOnERC721Received(address(0), to, tokenId, _data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _mint(address to, uint256 tokenId) internal {
        require(to != address(0), ""ERC721: mint to the zero address"");
        require(!_exists(tokenId), ""ERC721: token already minted"");
        _beforeTokenTransfer(address(0), to, tokenId);
        _balances[to] += 1;
        _owners[tokenId] = to;
        emit Transfer(address(0), to, tokenId);
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        require(ownerOf(tokenId) == from, ""ERC721: transfer of token that is not own"");
        require(to != address(0), ""ERC721: transfer to the zero address"");
        _beforeTokenTransfer(from, to, tokenId);
        _approve(address(0), tokenId);
        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;
        emit Transfer(from, to, tokenId);
    }

    function _approve(address to, uint256 tokenId) internal {
        _tokenApprovals[tokenId] = to;
        emit Approval(ownerOf(tokenId), to, tokenId);
    }

    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) internal returns (bool) {
        if (to.code.length > 0) {
            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data) returns (bytes4 retval) {
                return retval == IERC721Receiver.onERC721Received.selector;
            } catch (bytes memory reason) {
                if (reason.length == 0) {
                    revert(""ERC721: transfer to non ERC721Receiver implementer"");
                } else {
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        } else {
            return true;
        }
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal {}

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {
        require(index < balanceOf(owner), ""ERC721Enumerable: owner index out of bounds"");
        uint256 count;
        for (uint256 i; i < _totalSupply; i++) {
            if (_owners[i] == owner) {
                if (count == index) return i;
                else count++;
            }
        }
        revert(""ERC721Enumerable: owner index out of bounds"");
    }

    function tokenByIndex(uint256 index) public view returns (uint256) {
        require(index < totalSupply(), ""ERC721Enumerable: global index out of bounds"");
        return index;
    }
}

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(_owner == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract AirdropContract is ERC721Enumerable, Ownable {
    string private _baseURI;
    string private _notRevealedURI;
    uint256 public cost;
    uint256 public maxMintAmount;
    bool public revealed;

    event Mint(address indexed to, uint256 indexed tokenId);
    event Reveal();

    constructor(string memory baseURI, string memory notRevealedURI, uint256 _cost, uint256 _maxMintAmount) {
        _baseURI = baseURI;
        _notRevealedURI = notRevealedURI;
        cost = _cost;
        maxMintAmount = _maxMintAmount;
        revealed = false;
    }

    function mint(address to, uint256 tokenId) public payable {
        require(msg.value >= cost, ""Not enough ETH sent to mint"");
        require(tokenId < maxMintAmount, ""Token ID exceeds maximum mint amount"");
        _safeMint(to, tokenId);
        emit Mint(to, tokenId);
    }

    function reveal() public onlyOwner {
        revealed = true;
        emit Reveal();
    }

    function setCost(uint256 _newCost) public onlyOwner {
        cost = _newCost;
    }

    function setMaxMintAmount(uint256 _newMaxMintAmount) public onlyOwner {
        maxMintAmount = _newMaxMintAmount;
    }

    function setNotRevealedURI(string memory _newNotRevealedURI) public onlyOwner {
        _notRevealedURI = _newNotRevealedURI;
    }

    function setBaseURI(string memory _newBaseURI) public onlyOwner {
        _baseURI = _newBaseURI;
    }

    function tokenURI(uint256 tokenId) public view returns (string memory) {
        require(_exists(tokenId), ""ERC721Metadata: URI query for nonexistent token"");
        if (!revealed) {
            return _notRevealedURI;
        }
        return bytes(_baseURI).length > 0 ? string(abi.encodePacked(_baseURI, tokenId)) : """";
    }
}",contract_141.sol
"Develop a smart contract that provides a data structure for storing and managing a set of values. This set should allow for efficient addition, removal, and membership checking. Implement the necessary logic for maintaining the set's storage and indexing. Include functions for setting and getting the set's length and individual values. Ensure the contract is well-structured and follows best practices in Solidity syntax and organization.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ValueSet {
    struct Set {
        uint256[] values;
        mapping(uint256 => uint256) valueToIndex;
        mapping(uint256 => bool) isValueInSet;
    }

    Set private valueSet;

    function addValue(uint256 _value) public {
        require(!valueSet.isValueInSet[_value], ""Value already in set"");
        valueSet.values.push(_value);
        valueSet.valueToIndex[_value] = valueSet.values.length - 1;
        valueSet.isValueInSet[_value] = true;
    }

    function removeValue(uint256 _value) public {
        require(valueSet.isValueInSet[_value], ""Value not in set"");
        uint256 indexToRemove = valueSet.valueToIndex[_value];
        uint256 lastIndex = valueSet.values.length - 1;
        uint256 lastValue = valueSet.values[lastIndex];

        // Swap the value to remove with the last value and update the index
        valueSet.values[indexToRemove] = lastValue;
        valueSet.valueToIndex[lastValue] = indexToRemove;

        // Remove the last element
        valueSet.values.pop();
        valueSet.isValueInSet[_value] = false;
    }

    function containsValue(uint256 _value) public view returns (bool) {
        return valueSet.isValueInSet[_value];
    }

    function getValueAtIndex(uint256 _index) public view returns (uint256) {
        require(_index < valueSet.values.length, ""Index out of bounds"");
        return valueSet.values[_index];
    }

    function getSetLength() public view returns (uint256) {
        return valueSet.values.length;
    }

    function getAllValues() public view returns (uint256[] memory) {
        return valueSet.values;
    }
}",contract_142.sol
"Create an ERC721 token contract that allows for the minting, transfer, approval, and ownership of tokens. The contract should include functions for querying the total supply of tokens, the balance of tokens for each owner, and the ownership of each token. The transfer function should enable the transfer of tokens between owners, the approve function should enable approval of a third party to manage tokens on behalf of the owner, and the takeOwnership function should enable the owner of a token to transfer ownership of the token to another address.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC721 {
    string public name;
    string public symbol;
    uint256 public totalSupply;

    mapping(uint256 => address) private _tokenOwner;
    mapping(address => uint256) private _ownedTokensCount;
    mapping(uint256 => address) private _tokenApprovals;

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    constructor(string memory _name, string memory _symbol) {
        name = _name;
        symbol = _symbol;
    }

    function balanceOf(address owner) public view returns (uint256) {
        require(owner != address(0), ""ERC721: balance query for the zero address"");
        return _ownedTokensCount[owner];
    }

    function ownerOf(uint256 tokenId) public view returns (address) {
        address owner = _tokenOwner[tokenId];
        require(owner != address(0), ""ERC721: owner query for nonexistent token"");
        return owner;
    }

    function approve(address to, uint256 tokenId) public {
        address owner = ownerOf(tokenId);
        require(to != owner, ""ERC721: approval to current owner"");
        require(msg.sender == owner, ""ERC721: approve caller is not owner"");

        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    function getApproved(uint256 tokenId) public view returns (address) {
        require(_exists(tokenId), ""ERC721: approved query for nonexistent token"");
        return _tokenApprovals[tokenId];
    }

    function transfer(address to, uint256 tokenId) public {
        address owner = ownerOf(tokenId);
        require(msg.sender == owner, ""ERC721: transfer caller is not owner"");
        require(to != address(0), ""ERC721: transfer to the zero address"");

        _transfer(owner, to, tokenId);
    }

    function takeOwnership(uint256 tokenId) public {
        require(_exists(tokenId), ""ERC721: token does not exist"");
        address newOwner = msg.sender;
        address owner = ownerOf(tokenId);
        require(newOwner != owner, ""ERC721: new owner is the current owner"");
        require(_tokenApprovals[tokenId] == newOwner, ""ERC721: caller is not approved for token"");

        _transfer(owner, newOwner, tokenId);
    }

    function mint(address to, uint256 tokenId) public {
        require(to != address(0), ""ERC721: mint to the zero address"");
        require(!_exists(tokenId), ""ERC721: token already minted"");

        _tokenOwner[tokenId] = to;
        _ownedTokensCount[to] += 1;
        totalSupply += 1;

        emit Transfer(address(0), to, tokenId);
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return _tokenOwner[tokenId] != address(0);
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        _ownedTokensCount[from] -= 1;
        _ownedTokensCount[to] += 1;
        _tokenOwner[tokenId] = to;

        emit Transfer(from, to, tokenId);
    }
}",contract_143.sol
"Create a smart contract that extends the InterestRateModel contract. The contract should have a function that calculates the interest rate for borrowing based on the amount of cash, borrows, and reserves. The rate calculation should be influenced by the amount of borrows. The function should return a success flag and the calculated rate. A separate function should be added to verify if the contract is an InterestRateModel.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract InterestRateModel {
    function getBorrowRate(uint256 cash, uint256 borrows, uint256 reserves) external virtual returns (bool, uint256) {
        return (false, 0);
    }

    function isInterestRateModel() public virtual returns (bool) {
        return false;
    }
}

contract CustomInterestRateModel is InterestRateModel {
    function getBorrowRate(uint256 cash, uint256 borrows, uint256 reserves) external override returns (bool, uint256) {
        if (borrows == 0) {
            return (true, 0); // No borrows, no interest rate
        }

        uint256 utilizationRate = (borrows * 1e18) / (cash + borrows - reserves);
        uint256 borrowRate = (utilizationRate * 3) / 100; // Example formula, 3% base rate

        return (true, borrowRate);
    }

    function isInterestRateModel() public override returns (bool) {
        return true;
    }
}",contract_144.sol
"Create a smart contract that simulates a sports AMM, allowing users to place bets on sports games. The contract should support bet creation, bet settlement, and payment processing. Implement logic for calculating odds and handling multiple collateral tokens. Integrate with interfaces like IERC20Upgradeable and IStakingThales.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20Upgradeable {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface IStakingThales {
    function stake(uint amount) external;
    function unstake(uint amount) external;
    function getStakedAmount(address account) external view returns (uint);
}

contract SportsAMM {
    struct Bet {
        address creator;
        address collateralToken;
        uint256 amount;
        uint256 outcome;
        bool settled;
    }

    mapping(uint256 => Bet) public bets;
    mapping(address => uint256) public userBalances;
    uint256 public betCounter;

    function createBet(address _collateralToken, uint256 _amount, uint256 _outcome) external {
        require(_amount > 0, ""Amount must be greater than 0"");
        require(IERC20Upgradeable(_collateralToken).transferFrom(msg.sender, address(this), _amount), ""Transfer failed"");

        bets[betCounter] = Bet({
            creator: msg.sender,
            collateralToken: _collateralToken,
            amount: _amount,
            outcome: _outcome,
            settled: false
        });

        betCounter++;
    }

    function settleBet(uint256 _betId, uint256 _result) external {
        Bet storage bet = bets[_betId];
        require(!bet.settled, ""Bet already settled"");
        require(bet.creator != address(0), ""Bet does not exist"");

        if (bet.outcome == _result) {
            userBalances[bet.creator] += bet.amount;
        }

        bet.settled = true;
    }

    function withdraw(address _collateralToken, uint256 _amount) external {
        require(userBalances[msg.sender] >= _amount, ""Insufficient balance"");
        require(IERC20Upgradeable(_collateralToken).transfer(msg.sender, _amount), ""Transfer failed"");

        userBalances[msg.sender] -= _amount;
    }

    function calculateOdds(uint256 _betId) public view returns (uint256) {
        // Simplified odds calculation
        Bet storage bet = bets[_betId];
        require(bet.creator != address(0), ""Bet does not exist"");

        // Placeholder logic for odds calculation
        return 2; // 2:1 odds
    }
}",contract_145.sol
"Create a Smart Contract that implements NFKeyStaking functionality, including a constructor to set the NFKey address. The contract should have an admin feature with a mapping to store admin addresses, add, and remove admin capabilities. Define a staker struct with properties for token ID, token index, rewards earned, and rewards released. Implement functions for staking, unstaking, and updating treasure reward times. Include getter functions for staked tokens, rewards count, and treasure unlock times. Make sure the contract includes logging for emissions, chest tiers, and token IDs.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract NFKeyStaking {
    address public nfKeyAddress;
    address public owner;

    struct Staker {
        uint256 tokenId;
        uint256 tokenIndex;
        uint256 rewardsEarned;
        uint256 rewardsReleased;
    }

    mapping(address => bool) public admins;
    mapping(address => Staker[]) public stakers;
    mapping(uint256 => uint256) public treasureUnlockTimes;

    event Staked(address indexed user, uint256 tokenId);
    event Unstaked(address indexed user, uint256 tokenId);
    event RewardsUpdated(address indexed user, uint256 rewardsEarned);
    event TreasureUnlockTimeUpdated(uint256 tokenId, uint256 unlockTime);
    event AdminAdded(address indexed admin);
    event AdminRemoved(address indexed admin);

    modifier onlyAdmin() {
        require(admins[msg.sender] || msg.sender == owner, ""Not an admin"");
        _;
    }

    constructor(address _nfKeyAddress) {
        nfKeyAddress = _nfKeyAddress;
        owner = msg.sender;
        admins[msg.sender] = true;
    }

    function addAdmin(address _admin) external onlyAdmin {
        admins[_admin] = true;
        emit AdminAdded(_admin);
    }

    function removeAdmin(address _admin) external onlyAdmin {
        admins[_admin] = false;
        emit AdminRemoved(_admin);
    }

    function stake(uint256 _tokenId) external {
        stakers[msg.sender].push(Staker({
            tokenId: _tokenId,
            tokenIndex: stakers[msg.sender].length,
            rewardsEarned: 0,
            rewardsReleased: 0
        }));
        emit Staked(msg.sender, _tokenId);
    }

    function unstake(uint256 _tokenIndex) external {
        Staker[] storage userStakes = stakers[msg.sender];
        require(_tokenIndex < userStakes.length, ""Invalid token index"");
        uint256 tokenId = userStakes[_tokenIndex].tokenId;
        userStakes[_tokenIndex] = userStakes[userStakes.length - 1];
        userStakes.pop();
        emit Unstaked(msg.sender, tokenId);
    }

    function updateRewards(address _user, uint256 _rewardsEarned) external onlyAdmin {
        Staker[] storage userStakes = stakers[_user];
        for (uint256 i = 0; i < userStakes.length; i++) {
            userStakes[i].rewardsEarned += _rewardsEarned;
        }
        emit RewardsUpdated(_user, _rewardsEarned);
    }

    function updateTreasureUnlockTime(uint256 _tokenId, uint256 _unlockTime) external onlyAdmin {
        treasureUnlockTimes[_tokenId] = _unlockTime;
        emit TreasureUnlockTimeUpdated(_tokenId, _unlockTime);
    }

    function getStakedTokens(address _user) external view returns (uint256[] memory) {
        Staker[] storage userStakes = stakers[_user];
        uint256[] memory tokenIds = new uint256[](userStakes.length);
        for (uint256 i = 0; i < userStakes.length; i++) {
            tokenIds[i] = userStakes[i].tokenId;
        }
        return tokenIds;
    }

    function getRewardsCount(address _user) external view returns (uint256) {
        Staker[] storage userStakes = stakers[_user];
        uint256 totalRewards = 0;
        for (uint256 i = 0; i < userStakes.length; i++) {
            totalRewards += userStakes[i].rewardsEarned;
        }
        return totalRewards;
    }

    function getTreasureUnlockTime(uint256 _tokenId) external view returns (uint256) {
        return treasureUnlockTimes[_tokenId];
    }
}",contract_146.sol
"Develop a Solidity smart contract that tests the receipt of ERC721 tokens. The contract should include a function to mint and transfer a mock ERC721 token, and another function to test token reception with varying amounts.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MockERC721 {
    string public name = ""MockERC721"";
    string public symbol = ""MOCK"";
    uint256 private _tokenIdCounter;
    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function balanceOf(address owner) public view returns (uint256) {
        require(owner != address(0), ""ERC721: balance query for the zero address"");
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) public view returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), ""ERC721: owner query for nonexistent token"");
        return owner;
    }

    function approve(address to, uint256 tokenId) public {
        address owner = ownerOf(tokenId);
        require(to != owner, ""ERC721: approval to current owner"");
        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), ""ERC721: approve caller is not owner nor approved for all"");
        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    function getApproved(uint256 tokenId) public view returns (address) {
        require(_exists(tokenId), ""ERC721: approved query for nonexistent token"");
        return _tokenApprovals[tokenId];
    }

    function setApprovalForAll(address operator, bool approved) public {
        require(operator != msg.sender, ""ERC721: approve to caller"");
        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function isApprovedForAll(address owner, address operator) public view returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function transferFrom(address from, address to, uint256 tokenId) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _transfer(from, to, tokenId);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) public {
        safeTransferFrom(from, to, tokenId, """");
    }

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _safeTransfer(from, to, tokenId, data);
    }

    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return _owners[tokenId] != address(0);
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    function _safeMint(address to, uint256 tokenId) internal {
        _safeMint(to, tokenId, """");
    }

    function _safeMint(address to, uint256 tokenId, bytes memory data) internal {
        _mint(to, tokenId);
        require(_checkOnERC721Received(address(0), to, tokenId, data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _mint(address to, uint256 tokenId) internal {
        require(to != address(0), ""ERC721: mint to the zero address"");
        require(!_exists(tokenId), ""ERC721: token already minted"");
        _beforeTokenTransfer(address(0), to, tokenId);
        _balances[to] += 1;
        _owners[tokenId] = to;
        emit Transfer(address(0), to, tokenId);
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        require(ownerOf(tokenId) == from, ""ERC721: transfer of token that is not own"");
        require(to != address(0), ""ERC721: transfer to the zero address"");
        _beforeTokenTransfer(from, to, tokenId);
        _approve(address(0), tokenId);
        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;
        emit Transfer(from, to, tokenId);
    }

    function _approve(address to, uint256 tokenId) internal {
        _tokenApprovals[tokenId] = to;
        emit Approval(ownerOf(tokenId), to, tokenId);
    }

    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) internal returns (bool) {
        if (to.code.length == 0) return true;
        try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data) returns (bytes4 retval) {
            return retval == IERC721Receiver.onERC721Received.selector;
        } catch (bytes memory reason) {
            if (reason.length == 0) {
                revert(""ERC721: transfer to non ERC721Receiver implementer"");
            } else {
                assembly {
                    revert(add(32, reason), mload(reason))
                }
            }
        }
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal {}
}

interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}

contract ERC721ReceiverTest is IERC721Receiver {
    MockERC721 public mockERC721;

    constructor() {
        mockERC721 = new MockERC721();
    }

    function mintAndTransferToken(address to) public {
        uint256 tokenId = mockERC721._tokenIdCounter();
        mockERC721._mint(to, tokenId);
    }

    function testTokenReception(address to, uint256 amount) public {
        for (uint256 i = 0; i < amount; i++) {
            mintAndTransferToken(to);
        }
    }

    function onERC721Received(address, address, uint256, bytes memory) public pure override returns (bytes4) {
        return this.onERC721Received.selector;
    }
}",contract_147.sol
"Create a Smart Contract that implements the IERC20 standard, allowing users to transfer tokens and manage their balances. The contract should have a function to calculate the total supply of tokens, and update the total supply. Include an event for token transfers and a function to approve and transfer tokens. The contract should be compatible with the IERC20 standard and follow best practices for smart contract development.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 private _totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        _totalSupply = initialSupply * 10 ** uint256(decimals);
        _balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        require(_balances[msg.sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        _balances[msg.sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        require(_balances[sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        require(_allowances[sender][msg.sender] >= amount, ""ERC20: transfer amount exceeds allowance"");

        _balances[sender] -= amount;
        _balances[recipient] += amount;
        _allowances[sender][msg.sender] -= amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _allowances[msg.sender][spender] += addedValue;
        emit Approval(msg.sender, spender, _allowances[msg.sender][spender]);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        require(_allowances[msg.sender][spender] >= subtractedValue, ""ERC20: decreased allowance below zero"");
        _allowances[msg.sender][spender] -= subtractedValue;
        emit Approval(msg.sender, spender, _allowances[msg.sender][spender]);
        return true;
    }
}",contract_148.sol
"Create a smart contract that manages a collection of NFTs. The contract should enable users to mint NFTs, re-roll NFTs, and deposit tokens. Implement functionality for checking the accessibility of tokens within a specific time limit.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract NFTCollection {
    struct NFT {
        address owner;
        uint256 tokenId;
        uint256 timestamp;
    }

    NFT[] public nfts;
    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public ownerTokenCount;
    mapping(uint256 => uint256) public tokenTimestamps;

    uint256 public tokenCounter;
    uint256 public rerollCost = 100; // Example cost for re-rolling
    uint256 public depositCost = 50; // Example cost for depositing tokens

    event Minted(address indexed owner, uint256 tokenId);
    event Rerolled(address indexed owner, uint256 tokenId);
    event Deposited(address indexed owner, uint256 amount);

    modifier onlyOwnerOf(uint256 _tokenId) {
        require(tokenOwner[_tokenId] == msg.sender, ""Not the owner of this NFT"");
        _;
    }

    function mintNFT() public payable {
        require(msg.value >= depositCost, ""Insufficient payment for minting"");
        uint256 newTokenId = tokenCounter++;
        nfts.push(NFT({owner: msg.sender, tokenId: newTokenId, timestamp: block.timestamp}));
        tokenOwner[newTokenId] = msg.sender;
        ownerTokenCount[msg.sender]++;
        tokenTimestamps[newTokenId] = block.timestamp;
        emit Minted(msg.sender, newTokenId);
    }

    function rerollNFT(uint256 _tokenId) public payable onlyOwnerOf(_tokenId) {
        require(msg.value >= rerollCost, ""Insufficient payment for re-rolling"");
        nfts[_tokenId].timestamp = block.timestamp;
        emit Rerolled(msg.sender, _tokenId);
    }

    function depositTokens() public payable {
        require(msg.value > 0, ""Deposit amount must be greater than 0"");
        emit Deposited(msg.sender, msg.value);
    }

    function checkTokenAccessibility(uint256 _tokenId, uint256 _timeLimit) public view returns (bool) {
        require(_tokenId < tokenCounter, ""Token ID does not exist"");
        return (block.timestamp - tokenTimestamps[_tokenId]) <= _timeLimit;
    }
}",contract_149.sol
"Develop a smart contract that can upgrade and change the admin address, implementing the TransparentUpgradeableProxy contract. Ensure the contract includes functions for the admin and implementation slots, utilizing the _admin and _implementation functions. Integrate a mechanism for handling errors and provide informative error messages.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TransparentUpgradeableProxy {
    address private _admin;
    address private _implementation;

    constructor(address admin_, address implementation_) {
        _admin = admin_;
        _implementation = implementation_;
    }

    modifier onlyAdmin() {
        require(msg.sender == _admin, ""TransparentUpgradeableProxy: caller is not the admin"");
        _;
    }

    function changeAdmin(address newAdmin) external onlyAdmin {
        require(newAdmin != address(0), ""TransparentUpgradeableProxy: new admin is the zero address"");
        _admin = newAdmin;
    }

    function upgradeTo(address newImplementation) external onlyAdmin {
        require(newImplementation != address(0), ""TransparentUpgradeableProxy: new implementation is the zero address"");
        _implementation = newImplementation;
    }

    function implementation() external view returns (address) {
        return _implementation;
    }

    function admin() external view returns (address) {
        return _admin;
    }

    fallback() external payable {
        _fallback();
    }

    receive() external payable {
        _fallback();
    }

    function _fallback() internal {
        address impl = _implementation;
        require(impl != address(0), ""TransparentUpgradeableProxy: implementation is not set"");
        assembly {
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())
            switch result
            case 0 { revert(0, returndatasize()) }
            default { return(0, returndatasize()) }
        }
    }
}",contract_150.sol
"Create a smart contract that enables users to deposit, withdraw, and borrow DAI. The contract should interact with the RegistryInterface to get user wallets and check if the user is the owner of the wallet. Implement functions to mint, repay, and redeem DAI using the CTokenInterface. Include functions for ERC20 transfers and approvals. Structure the contract to include modifiers for user authentication and administration.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface RegistryInterface {
    function isOwner(address wallet, address user) external view returns (bool);
}

interface CTokenInterface {
    function mint(uint mintAmount) external returns (uint);
    function redeem(uint redeemTokens) external returns (uint);
    function repayBorrow(uint repayAmount) external returns (uint);
}

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

contract DAIContract {
    address public admin;
    RegistryInterface public registry;
    CTokenInterface public cToken;
    IERC20 public daiToken;

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can call this function"");
        _;
    }

    modifier onlyOwner(address wallet) {
        require(registry.isOwner(wallet, msg.sender), ""Caller is not the owner of the wallet"");
        _;
    }

    constructor(address _registryAddress, address _cTokenAddress, address _daiTokenAddress) {
        admin = msg.sender;
        registry = RegistryInterface(_registryAddress);
        cToken = CTokenInterface(_cTokenAddress);
        daiToken = IERC20(_daiTokenAddress);
    }

    function deposit(address wallet, uint256 amount) external onlyOwner(wallet) {
        require(daiToken.transferFrom(wallet, address(this), amount), ""Transfer failed"");
    }

    function withdraw(address wallet, uint256 amount) external onlyOwner(wallet) {
        require(daiToken.transfer(wallet, amount), ""Transfer failed"");
    }

    function borrowDAI(uint256 amount) external onlyOwner(msg.sender) {
        require(daiToken.transfer(msg.sender, amount), ""Transfer failed"");
    }

    function mintDAI(uint256 amount) external onlyOwner(msg.sender) {
        require(daiToken.approve(address(cToken), amount), ""Approval failed"");
        require(cToken.mint(amount) == 0, ""Minting failed"");
    }

    function repayDAI(uint256 amount) external onlyOwner(msg.sender) {
        require(daiToken.transferFrom(msg.sender, address(this), amount), ""Transfer failed"");
        require(daiToken.approve(address(cToken), amount), ""Approval failed"");
        require(cToken.repayBorrow(amount) == 0, ""Repayment failed"");
    }

    function redeemDAI(uint256 amount) external onlyOwner(msg.sender) {
        require(cToken.redeem(amount) == 0, ""Redemption failed"");
    }

    function setRegistry(address _registryAddress) external onlyAdmin {
        registry = RegistryInterface(_registryAddress);
    }

    function setCToken(address _cTokenAddress) external onlyAdmin {
        cToken = CTokenInterface(_cTokenAddress);
    }

    function setDAIToken(address _daiTokenAddress) external onlyAdmin {
        daiToken = IERC20(_daiTokenAddress);
    }
}",contract_151.sol
"Create a smart contract for a token that can be upgraded to a newer version. The contract should be able to transition to a new address and continue functioning. Implement functions for standard ERC20 operations, such as transferring tokens and checking balances. Include a mechanism for handling deprecation and redirection to the newer contract. Focus on ensuring the contract's continuity and compatibility with the upgraded version.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract ERC20Token is IERC20 {
    string public name = ""UpgradeableToken"";
    string public symbol = ""UTKN"";
    uint8 public decimals = 18;
    uint256 private _totalSupply;
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    address public newContractAddress;
    bool public deprecated;

    constructor(uint256 initialSupply) {
        _totalSupply = initialSupply * 10 ** uint256(decimals);
        _balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function totalSupply() external view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) external view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) external override returns (bool) {
        require(!deprecated, ""Contract is deprecated"");
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) external view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) external override returns (bool) {
        require(!deprecated, ""Contract is deprecated"");
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {
        require(!deprecated, ""Contract is deprecated"");
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    function deprecate(address _newContractAddress) external {
        require(msg.sender == owner(), ""Only owner can deprecate the contract"");
        deprecated = true;
        newContractAddress = _newContractAddress;
    }

    function owner() public view returns (address) {
        return address(0); // This should be replaced with actual owner logic
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""Transfer from the zero address"");
        require(recipient != address(0), ""Transfer to the zero address"");
        require(_balances[sender] >= amount, ""Transfer amount exceeds balance"");
        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""Approve from the zero address"");
        require(spender != address(0), ""Approve to the zero address"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}",contract_152.sol
Design a Solidity smart contract that represents a token with a limited supply. The contract should enable users to transfer tokens to each other and allow for token burning and increased allowance. The contract should have a maximum supply of 50 million tokens and use the OpenZeppelin ERC20 contract as a base. The contract's behavior should closely resemble the provided code fragment.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MyToken is ERC20 {
    uint256 public constant MAX_SUPPLY = 50000000 * 10**18;

    constructor() ERC20(""MyToken"", ""MTK"") {
        _mint(msg.sender, MAX_SUPPLY);
    }

    function burn(uint256 amount) public {
        _burn(msg.sender, amount);
    }

    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(msg.sender, spender, allowance(msg.sender, spender) + addedValue);
        return true;
    }
}

abstract contract ERC20 {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    uint256 private _totalSupply;
    string private _name;
    string private _symbol;

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function name() public view virtual returns (string memory) {
        return _name;
    }

    function symbol() public view virtual returns (string memory) {
        return _symbol;
    }

    function decimals() public view virtual returns (uint8) {
        return 18;
    }

    function totalSupply() public view virtual returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view virtual returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public virtual returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view virtual returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public virtual returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool) {
        _transfer(sender, recipient, amount);

        uint256 currentAllowance = _allowances[sender][msg.sender];
        require(currentAllowance >= amount, ""ERC20: transfer amount exceeds allowance"");
        unchecked {
            _approve(sender, msg.sender, currentAllowance - amount);
        }

        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        uint256 senderBalance = _balances[sender];
        require(senderBalance >= amount, ""ERC20: transfer amount exceeds balance"");
        unchecked {
            _balances[sender] = senderBalance - amount;
        }
        _balances[recipient] += amount;

        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: burn from the zero address"");

        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, ""ERC20: burn amount exceeds balance"");
        unchecked {
            _balances[account] = accountBalance - amount;
        }
        _totalSupply -= amount;

        emit Transfer(account, address(0), amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}",contract_153.sol
"Create a smart contract that extends the ERC20 standard, with a focus on managing node rewards and liquidity. The contract should have functions for initializing the contract state variables, tracking blacklisted addresses, and updating the UniswapV2 router and swap tokens amount. Implement the required interfaces and libraries. Ensure the contract has modular design and follows best practices for smart contract development.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

abstract contract IERC20 {
    function totalSupply() public view virtual returns (uint256);
    function balanceOf(address account) public view virtual returns (uint256);
    function transfer(address recipient, uint256 amount) public virtual returns (bool);
    function allowance(address owner, address spender) public view virtual returns (uint256);
    function approve(address spender, uint256 amount) public virtual returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract ERC20 is IERC20 {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    uint256 private _totalSupply;
    string private _name;
    string private _symbol;

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view virtual returns (uint8) {
        return 18;
    }

    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: burn from the zero address"");

        _balances[account] -= amount;
        _totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }
}

contract NodeRewardsToken is ERC20 {
    address public owner;
    address public uniswapV2Router;
    uint256 public swapTokensAmount;
    mapping(address => bool) public isBlacklisted;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor(address _uniswapV2Router) ERC20(""NodeRewardsToken"", ""NRT"") {
        owner = msg.sender;
        uniswapV2Router = _uniswapV2Router;
        swapTokensAmount = 1000 * 10**18; // Example amount
    }

    function blacklistAddress(address account, bool value) external onlyOwner {
        isBlacklisted[account] = value;
    }

    function updateUniswapV2Router(address newAddress) external onlyOwner {
        uniswapV2Router = newAddress;
    }

    function updateSwapTokensAmount(uint256 newAmount) external onlyOwner {
        swapTokensAmount = newAmount;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal override {
        require(!isBlacklisted[sender] && !isBlacklisted[recipient], ""Blacklisted address"");
        super._transfer(sender, recipient, amount);
    }
}",contract_154.sol
"Create a smart contract that implements role-based access control using the provided AccessControl contract as a reference. The contract should allow administrators to create, manage, and assign roles. Include functions for role creation, revocation, and assignment. The contract should support role-based access control, ensuring that only authorized users can perform specific actions. Ensure that the contract emits events for role administration and role changes.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract AccessControl {
    mapping(bytes32 => mapping(address => bool)) private _roles;
    mapping(bytes32 => bytes32) private _roleAdmins;

    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);

    function hasRole(bytes32 role, address account) public view returns (bool) {
        return _roles[role][account];
    }

    function getRoleAdmin(bytes32 role) public view returns (bytes32) {
        return _roleAdmins[role];
    }

    function grantRole(bytes32 role, address account) public {
        require(hasRole(_roleAdmins[role], msg.sender), ""AccessControl: sender must be an admin to grant"");
        _grantRole(role, account);
    }

    function revokeRole(bytes32 role, address account) public {
        require(hasRole(_roleAdmins[role], msg.sender), ""AccessControl: sender must be an admin to revoke"");
        _revokeRole(role, account);
    }

    function renounceRole(bytes32 role) public {
        _revokeRole(role, msg.sender);
    }

    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {
        bytes32 previousAdminRole = _roleAdmins[role];
        _roleAdmins[role] = adminRole;
        emit RoleAdminChanged(role, previousAdminRole, adminRole);
    }

    function _grantRole(bytes32 role, address account) internal {
        if (!hasRole(role, account)) {
            _roles[role][account] = true;
            emit RoleGranted(role, account, msg.sender);
        }
    }

    function _revokeRole(bytes32 role, address account) internal {
        if (hasRole(role, account)) {
            _roles[role][account] = false;
            emit RoleRevoked(role, account, msg.sender);
        }
    }
}

contract RoleBasedAccessControl is AccessControl {
    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");

    constructor() {
        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);
        _grantRole(ADMIN_ROLE, msg.sender);
    }

    function createRole(bytes32 role, bytes32 adminRole) public {
        require(hasRole(ADMIN_ROLE, msg.sender), ""RoleBasedAccessControl: must have admin role to create role"");
        _setRoleAdmin(role, adminRole);
    }

    function assignRole(bytes32 role, address account) public {
        require(hasRole(_roleAdmins[role], msg.sender), ""RoleBasedAccessControl: sender must be an admin to assign"");
        _grantRole(role, account);
    }

    function revokeRole(bytes32 role, address account) public {
        require(hasRole(_roleAdmins[role], msg.sender), ""RoleBasedAccessControl: sender must be an admin to revoke"");
        _revokeRole(role, account);
    }
}",contract_155.sol
"Design a smart contract to manage scheduled operations, allowing authorized proposers to submit tasks, tracked by unique identifiers. Implement delay periods, block and execute operations based on timestamp checks.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ScheduledOperations {
    struct Task {
        address proposer;
        uint256 delayPeriod;
        uint256 submissionTime;
        bool executed;
    }

    mapping(uint256 => Task) public tasks;
    mapping(address => bool) public authorizedProposers;
    uint256 public taskCounter;

    event TaskSubmitted(uint256 taskId, address proposer, uint256 delayPeriod);
    event TaskExecuted(uint256 taskId);

    modifier onlyAuthorized() {
        require(authorizedProposers[msg.sender], ""Not authorized"");
        _;
    }

    constructor(address[] memory initialProposers) {
        for (uint256 i = 0; i < initialProposers.length; i++) {
            authorizedProposers[initialProposers[i]] = true;
        }
        taskCounter = 0;
    }

    function submitTask(uint256 delayPeriod) external onlyAuthorized {
        require(delayPeriod > 0, ""Delay period must be greater than 0"");
        tasks[taskCounter] = Task({
            proposer: msg.sender,
            delayPeriod: delayPeriod,
            submissionTime: block.timestamp,
            executed: false
        });
        emit TaskSubmitted(taskCounter, msg.sender, delayPeriod);
        taskCounter++;
    }

    function executeTask(uint256 taskId) external {
        Task storage task = tasks[taskId];
        require(!task.executed, ""Task already executed"");
        require(block.timestamp >= task.submissionTime + task.delayPeriod, ""Delay period not yet passed"");
        // Perform the task operation here
        // For example, task.proposer.call{value: 0}("""");
        task.executed = true;
        emit TaskExecuted(taskId);
    }

    function authorizeProposer(address proposer) external {
        require(msg.sender == address(this), ""Only contract can authorize"");
        authorizedProposers[proposer] = true;
    }

    function deauthorizeProposer(address proposer) external {
        require(msg.sender == address(this), ""Only contract can deauthorize"");
        authorizedProposers[proposer] = false;
    }
}",contract_156.sol
"Develop a smart contract that mimics the PancakeSwap router, allowing users to add and remove liquidity. The contract should include a constructor that sets the factory and WETH addresses. The addLiquidity function should calculate the amount of tokens to add, and the removeLiquidity function should calculate the amount of liquidity to remove. Include the necessary logic for ownership transfer and locking/unlocking. Use the provided code as a reference for the Ownable and Context contract structures.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _transferOwnership(msg.sender);
    }

    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

interface IWETH {
    function deposit() external payable;
    function transfer(address to, uint value) external returns (bool);
    function withdraw(uint) external;
}

interface IPancakeFactory {
    function getPair(address tokenA, address tokenB) external view returns (address pair);
}

interface IPancakePair {
    function mint(address to) external returns (uint liquidity);
    function burn(address to) external returns (uint amount0, uint amount1);
}

contract PancakeRouter is Ownable, Context {
    address public factory;
    address public WETH;

    modifier ensure(uint deadline) {
        require(deadline >= block.timestamp, 'PancakeRouter: EXPIRED');
        _;
    }

    constructor(address _factory, address _WETH) {
        factory = _factory;
        WETH = _WETH;
    }

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {
        address pair = IPancakeFactory(factory).getPair(tokenA, tokenB);
        require(pair != address(0), ""PancakeRouter: PAIR_NOT_EXIST"");

        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);
        IERC20(tokenA).transferFrom(msg.sender, pair, amountA);
        IERC20(tokenB).transferFrom(msg.sender, pair, amountB);
        liquidity = IPancakePair(pair).mint(to);
    }

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) public ensure(deadline) returns (uint amountA, uint amountB) {
        address pair = IPancakeFactory(factory).getPair(tokenA, tokenB);
        require(pair != address(0), ""PancakeRouter: PAIR_NOT_EXIST"");

        IERC20(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair
        (amountA, amountB) = IPancakePair(pair).burn(to);
        require(amountA >= amountAMin, 'PancakeRouter: INSUFFICIENT_A_AMOUNT');
        require(amountB >= amountBMin, 'PancakeRouter: INSUFFICIENT_B_AMOUNT');
    }

    function _addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin
    ) internal view returns (uint amountA, uint amountB) {
        // For simplicity, assuming equal distribution for desired amounts
        amountA = amountADesired;
        amountB = amountBDesired;
        require(amountA >= amountAMin && amountB >= amountBMin, ""PancakeRouter: INSUFFICIENT_INPUT_AMOUNT"");
    }
}",contract_157.sol
"Design a smart contract for an Original Token Vault that manages token deposits and withdrawals. Incorporate security measures like ReentrancyGuard, Pauser, VolumeControl, and DelayedTransfer. The contract should have functions for depositing and withdrawing tokens, utilizing IERC20 and IWETH interfaces. Implement a constructor for initializing sigsVerifier. Ensure that the contract handles token safety and functionality for deposit and withdrawal events. Focus on the overall structure and functionality of the contract.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
    function approve(address spender, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
    function balanceOf(address who) external view returns (uint256);
}

interface IWETH {
    function deposit() external payable;
    function transfer(address to, uint value) external returns (bool);
    function withdraw(uint) external;
}

contract ReentrancyGuard {
    bool private _notEntered;

    constructor () {
        _notEntered = true;
    }

    modifier nonReentrant() {
        require(_notEntered, ""ReentrancyGuard: reentrant call"");
        _notEntered = false;
        _;
        _notEntered = true;
    }
}

contract Pauser {
    bool private _paused;

    constructor () {
        _paused = false;
    }

    modifier whenNotPaused() {
        require(!_paused, ""Pauser: paused"");
        _;
    }

    function pause() public {
        _paused = true;
    }

    function unpause() public {
        _paused = false;
    }
}

contract VolumeControl {
    uint256 private _dailyLimit;
    uint256 private _usedToday;
    uint256 private _dayStart;

    constructor (uint256 dailyLimit) {
        _dailyLimit = dailyLimit;
        _usedToday = 0;
        _dayStart = block.timestamp;
    }

    modifier withinLimit(uint256 amount) {
        if (block.timestamp >= _dayStart + 1 days) {
            _dayStart = block.timestamp;
            _usedToday = 0;
        }
        require(_usedToday + amount <= _dailyLimit, ""VolumeControl: daily limit exceeded"");
        _;
        _usedToday += amount;
    }
}

contract DelayedTransfer {
    struct Transfer {
        address recipient;
        uint256 amount;
        uint256 unlockTime;
    }

    mapping(address => Transfer) private _transfers;

    function scheduleTransfer(address recipient, uint256 amount, uint256 delay) public {
        _transfers[msg.sender] = Transfer(recipient, amount, block.timestamp + delay);
    }

    function executeTransfer(address sender) public {
        Transfer storage transfer = _transfers[sender];
        require(block.timestamp >= transfer.unlockTime, ""DelayedTransfer: transfer is still locked"");
        IERC20(msg.sender).transfer(transfer.recipient, transfer.amount);
        delete _transfers[sender];
    }
}

contract OriginalTokenVault is ReentrancyGuard, Pauser, VolumeControl, DelayedTransfer {
    address public sigsVerifier;
    IERC20 public token;
    IWETH public weth;

    event Deposit(address indexed user, uint256 amount);
    event Withdrawal(address indexed user, uint256 amount);

    constructor(address _sigsVerifier, address _token, address _weth, uint256 dailyLimit) VolumeControl(dailyLimit) {
        sigsVerifier = _sigsVerifier;
        token = IERC20(_token);
        weth = IWETH(_weth);
    }

    function depositTokens(uint256 amount) public whenNotPaused nonReentrant withinLimit(amount) {
        require(token.transferFrom(msg.sender, address(this), amount), ""OriginalTokenVault: token transfer failed"");
        emit Deposit(msg.sender, amount);
    }

    function withdrawTokens(uint256 amount) public whenNotPaused nonReentrant {
        require(token.balanceOf(address(this)) >= amount, ""OriginalTokenVault: insufficient balance"");
        require(token.transfer(msg.sender, amount), ""OriginalTokenVault: token transfer failed"");
        emit Withdrawal(msg.sender, amount);
    }

    function depositETH() public payable whenNotPaused nonReentrant {
        weth.deposit{value: msg.value}();
        emit Deposit(msg.sender, msg.value);
    }

    function withdrawETH(uint256 amount) public whenNotPaused nonReentrant {
        weth.withdraw(amount);
        (bool success, ) = msg.sender.call{value: amount}("""");
        require(success, ""OriginalTokenVault: ETH transfer failed"");
        emit Withdrawal(msg.sender, amount);
    }
}",contract_158.sol
"Create a smart contract that allows for role-based access control. The contract should be based on OpenZeppelin's AccessControl contract and include functions for managing roles, such as granting, revoking, and renouncing roles. The contract should also track role changes and notify relevant parties. The implementation should be efficient, secure, and follow industry best practices.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract RoleBasedAccessControl {
    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    struct RoleData {
        mapping(address => bool) members;
        bytes32 adminRole;
    }

    mapping(bytes32 => RoleData) private _roles;

    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);

    modifier onlyRole(bytes32 role) {
        require(hasRole(role, msg.sender), ""RoleBasedAccessControl: sender must be an admin to grant"");
        _;
    }

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(DEFAULT_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);
    }

    function hasRole(bytes32 role, address account) public view returns (bool) {
        return _roles[role].members[account];
    }

    function getRoleAdmin(bytes32 role) public view returns (bytes32) {
        return _roles[role].adminRole;
    }

    function grantRole(bytes32 role, address account) public onlyRole(getRoleAdmin(role)) {
        _grantRole(role, account);
    }

    function revokeRole(bytes32 role, address account) public onlyRole(getRoleAdmin(role)) {
        _revokeRole(role, account);
    }

    function renounceRole(bytes32 role) public {
        _revokeRole(role, msg.sender);
    }

    function _setupRole(bytes32 role, address account) internal {
        _grantRole(role, account);
    }

    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {
        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);
        _roles[role].adminRole = adminRole;
    }

    function _grantRole(bytes32 role, address account) private {
        if (!hasRole(role, account)) {
            _roles[role].members[account] = true;
            emit RoleGranted(role, account, msg.sender);
        }
    }

    function _revokeRole(bytes32 role, address account) private {
        if (hasRole(role, account)) {
            _roles[role].members[account] = false;
            emit RoleRevoked(role, account, msg.sender);
        }
    }
}",contract_159.sol
"Create a smart contract that allows users to mint and manage tokens. The contract should support token metadata and allow for token approvals. Implement functions for minting tokens, updating metadata, and managing approvals. Ensure that the contract includes logging for token events.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TokenContract {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    mapping(uint256 => string) public tokenMetadata;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event MetadataUpdate(uint256 indexed tokenId, string metadata);

    function mint(address to, uint256 value, string memory metadata) public returns (bool) {
        require(to != address(0), ""Invalid address"");
        totalSupply += value;
        balanceOf[to] += value;
        tokenMetadata[totalSupply] = metadata;
        emit Transfer(address(0), to, value);
        emit MetadataUpdate(totalSupply, metadata);
        return true;
    }

    function transfer(address to, uint256 value) public returns (bool) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        require(balanceOf[from] >= value, ""Insufficient balance"");
        require(allowance[from][msg.sender] >= value, ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }

    function updateMetadata(uint256 tokenId, string memory metadata) public returns (bool) {
        require(balanceOf[msg.sender] >= tokenId, ""Token not owned by sender"");
        tokenMetadata[tokenId] = metadata;
        emit MetadataUpdate(tokenId, metadata);
        return true;
    }
}",contract_160.sol
Develop a smart contract called SevenToken that enables users to deposit and withdraw Ether. The contract should keep track of user balances and allow for withdrawals. Include a feature for getting the balance of a specific address and the total balance of the owner. Implement logging for withdrawals and ensure gas fees are correctly handled. Consider potential attacks and include measures to prevent them.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SevenToken {
    mapping(address => uint256) private balances;
    address private owner;

    event Deposit(address indexed user, uint256 amount);
    event Withdrawal(address indexed user, uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function deposit() public payable {
        require(msg.value > 0, ""Deposit amount must be greater than 0"");
        balances[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }

    function withdraw(uint256 amount) public {
        require(amount > 0, ""Withdrawal amount must be greater than 0"");
        require(balances[msg.sender] >= amount, ""Insufficient balance"");
        balances[msg.sender] -= amount;
        (bool success, ) = msg.sender.call{value: amount}("""");
        require(success, ""Transfer failed"");
        emit Withdrawal(msg.sender, amount);
    }

    function getBalance(address user) public view returns (uint256) {
        return balances[user];
    }

    function getTotalBalance() public view onlyOwner returns (uint256) {
        return address(this).balance;
    }

    receive() external payable {
        deposit();
    }

    fallback() external payable {
        deposit();
    }
}",contract_161.sol
Create a smart contract that allows the minting of NFTs based on digital signatures. The contract should have a function to verify the signature and process the mint request. It should also store the requesting address and the signature provided. The contract should allow for the minting of multiple tokens and keep track of the minted tokens. The contract should also allow for the verification and processing of the mint request in a single transaction.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract NFTMinter {
    struct MintRequest {
        address requester;
        bytes signature;
    }

    mapping(uint256 => MintRequest) public mintRequests;
    mapping(address => uint256[]) public mintedTokens;
    uint256 public tokenCounter;

    event TokenMinted(uint256 tokenId, address requester);

    function verifySignature(bytes32 messageHash, bytes memory signature, address signer) internal pure returns (bool) {
        bytes32 ethSignedMessageHash = keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", messageHash));
        return recoverSigner(ethSignedMessageHash, signature) == signer;
    }

    function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature) internal pure returns (address) {
        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);
        return ecrecover(_ethSignedMessageHash, v, r, s);
    }

    function splitSignature(bytes memory sig) internal pure returns (bytes32 r, bytes32 s, uint8 v) {
        require(sig.length == 65, ""invalid signature length"");
        assembly {
            r := mload(add(sig, 32))
            s := mload(add(sig, 64))
            v := byte(0, mload(add(sig, 96)))
        }
    }

    function mintNFT(bytes32 messageHash, bytes memory signature) external {
        require(verifySignature(messageHash, signature, msg.sender), ""Signature verification failed"");

        uint256 tokenId = tokenCounter++;
        mintRequests[tokenId] = MintRequest({requester: msg.sender, signature: signature});
        mintedTokens[msg.sender].push(tokenId);

        emit TokenMinted(tokenId, msg.sender);
    }

    function getMintedTokens(address owner) external view returns (uint256[] memory) {
        return mintedTokens[owner];
    }
}",contract_162.sol
"Develop a smart contract that manages access control for a system with different roles and administrators. The contract should allow administrators to grant and revoke roles, and include a way to query the membership of a role. Implement a new role with moderately restrictive permissions. Provide a clear and concise description of the contract's functionality and structure.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract AccessControl {
    struct Role {
        mapping(address => bool) members;
        string roleName;
    }

    mapping(bytes32 => Role) private roles;
    mapping(address => bool) private administrators;

    bytes32 public constant MODERATOR_ROLE = keccak256(""MODERATOR"");

    event RoleGranted(bytes32 indexed role, address indexed account);
    event RoleRevoked(bytes32 indexed role, address indexed account);
    event AdministratorAdded(address indexed account);
    event AdministratorRemoved(address indexed account);

    modifier onlyAdmin() {
        require(administrators[msg.sender], ""Not an administrator"");
        _;
    }

    modifier onlyRole(bytes32 role) {
        require(roles[role].members[msg.sender], ""Missing role"");
        _;
    }

    constructor() {
        administrators[msg.sender] = true;
        emit AdministratorAdded(msg.sender);
        _createRole(MODERATOR_ROLE, ""Moderator"");
    }

    function addAdministrator(address account) external onlyAdmin {
        administrators[account] = true;
        emit AdministratorAdded(account);
    }

    function removeAdministrator(address account) external onlyAdmin {
        require(account != msg.sender, ""Cannot remove yourself"");
        administrators[account] = false;
        emit AdministratorRemoved(account);
    }

    function grantRole(bytes32 role, address account) external onlyAdmin {
        _grantRole(role, account);
    }

    function revokeRole(bytes32 role, address account) external onlyAdmin {
        _revokeRole(role, account);
    }

    function hasRole(bytes32 role, address account) public view returns (bool) {
        return roles[role].members[account];
    }

    function getRoleName(bytes32 role) public view returns (string memory) {
        return roles[role].roleName;
    }

    function _createRole(bytes32 role, string memory roleName) internal {
        roles[role].roleName = roleName;
    }

    function _grantRole(bytes32 role, address account) internal {
        roles[role].members[account] = true;
        emit RoleGranted(role, account);
    }

    function _revokeRole(bytes32 role, address account) internal {
        roles[role].members[account] = false;
        emit RoleRevoked(role, account);
    }
}",contract_163.sol
Design a smart contract that allows users to invest and earn interest on their deposits. The contract should have a system in place to regulate daily investments and have a referral system for earning more interest. The contract should also have a mechanism to pay out dividends to investors. Provide a general outline of the contract's structure and key functions.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract InvestmentContract {
    struct Investor {
        uint256 deposit;
        uint256 lastDepositTime;
        uint256 referralEarnings;
        address referrer;
    }

    mapping(address => Investor) public investors;
    uint256 public totalInvestments;
    uint256 public dailyLimit;
    uint256 public interestRate;
    uint256 public referralBonusRate;

    event Invested(address indexed investor, uint256 amount);
    event Withdrawn(address indexed investor, uint256 amount);
    event ReferralEarned(address indexed referrer, address indexed investor, uint256 amount);

    constructor(uint256 _dailyLimit, uint256 _interestRate, uint256 _referralBonusRate) {
        dailyLimit = _dailyLimit;
        interestRate = _interestRate;
        referralBonusRate = _referralBonusRate;
    }

    function invest(address _referrer) public payable {
        require(msg.value > 0, ""Investment amount must be greater than zero"");
        require(investors[msg.sender].lastDepositTime + 24 hours <= block.timestamp, ""Daily investment limit reached"");

        Investor storage investor = investors[msg.sender];
        investor.deposit += msg.value;
        investor.lastDepositTime = block.timestamp;
        totalInvestments += msg.value;

        if (_referrer != address(0) && _referrer != msg.sender) {
            investors[_referrer].referralEarnings += (msg.value * referralBonusRate) / 100;
            emit ReferralEarned(_referrer, msg.sender, (msg.value * referralBonusRate) / 100);
        }

        emit Invested(msg.sender, msg.value);
    }

    function withdraw() public {
        Investor storage investor = investors[msg.sender];
        uint256 totalEarnings = calculateEarnings(msg.sender);
        require(totalEarnings > 0, ""No earnings to withdraw"");

        investor.deposit = 0;
        investor.lastDepositTime = block.timestamp;
        investor.referralEarnings = 0;

        payable(msg.sender).transfer(totalEarnings);
        emit Withdrawn(msg.sender, totalEarnings);
    }

    function calculateEarnings(address _investor) public view returns (uint256) {
        Investor storage investor = investors[_investor];
        uint256 depositTime = block.timestamp - investor.lastDepositTime;
        uint256 interestEarnings = (investor.deposit * interestRate * depositTime) / (100 * 365 days);
        return interestEarnings + investor.referralEarnings;
    }
}",contract_164.sol
"Create a smart contract that builds upon the IncrementalMerkleTree library by introducing a constructor that initializes the tree's structure with customizable parameters and a reusable function for inserting new leaves, focusing on facilitating the management of large datasets within the Ethereum network.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract IncrementalMerkleTree {
    struct Tree {
        uint256 depth;
        uint256[] leaves;
        uint256[] nodes;
        uint256 root;
    }

    Tree public tree;

    constructor(uint256 _depth) {
        require(_depth > 0, ""Depth must be greater than 0"");
        tree.depth = _depth;
        tree.nodes = new uint256[](2 ** (_depth + 1) - 1);
        initializeTree(0, 0, _depth);
    }

    function initializeTree(uint256 nodeIndex, uint256 level, uint256 depth) internal {
        if (level == depth) {
            tree.nodes[nodeIndex] = 0;
        } else {
            tree.nodes[nodeIndex] = 0;
            initializeTree(2 * nodeIndex + 1, level + 1, depth);
            initializeTree(2 * nodeIndex + 2, level + 1, depth);
        }
    }

    function insertLeaf(uint256 _leaf) public {
        require(tree.leaves.length < 2 ** tree.depth, ""Tree is full"");
        tree.leaves.push(_leaf);
        updateTree(tree.leaves.length - 1, _leaf);
    }

    function updateTree(uint256 leafIndex, uint256 leafValue) internal {
        uint256 nodeIndex = 2 ** tree.depth - 1 + leafIndex;
        tree.nodes[nodeIndex] = leafValue;
        while (nodeIndex != 0) {
            nodeIndex = (nodeIndex - 1) / 2;
            uint256 leftChild = tree.nodes[2 * nodeIndex + 1];
            uint256 rightChild = tree.nodes[2 * nodeIndex + 2];
            tree.nodes[nodeIndex] = hash(leftChild, rightChild);
        }
        tree.root = tree.nodes[0];
    }

    function hash(uint256 a, uint256 b) internal pure returns (uint256) {
        return uint256(keccak256(abi.encodePacked(a, b)));
    }
}",contract_165.sol
"Create a Solidity smart contract that deploys a money market with various facets, including functions for lending, borrowing, and liquidation. The contract should utilize a library to deploy the money market diamond and retrieve facet addresses. Implement functions to serialize and write JSON data for the money market and facet addresses. Design the contract to provide flexibility in managing the money market and its facets.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MoneyMarket {
    struct Facet {
        address facetAddress;
        string facetName;
    }

    Facet[] public facets;
    mapping(address => uint256) public balances;
    mapping(address => uint256) public borrows;
    uint256 public totalSupply;
    uint256 public totalBorrow;

    event Lend(address indexed lender, uint256 amount);
    event Borrow(address indexed borrower, uint256 amount);
    event Liquidate(address indexed liquidator, address indexed borrower, uint256 amount);

    function addFacet(address _facetAddress, string memory _facetName) external {
        facets.push(Facet(_facetAddress, _facetName));
    }

    function getFacetAddresses() external view returns (Facet[] memory) {
        return facets;
    }

    function lend(uint256 _amount) external {
        require(_amount > 0, ""Amount must be greater than 0"");
        balances[msg.sender] += _amount;
        totalSupply += _amount;
        emit Lend(msg.sender, _amount);
    }

    function borrow(uint256 _amount) external {
        require(_amount > 0, ""Amount must be greater than 0"");
        require(totalSupply >= totalBorrow + _amount, ""Not enough liquidity"");
        borrows[msg.sender] += _amount;
        totalBorrow += _amount;
        emit Borrow(msg.sender, _amount);
    }

    function liquidate(address _borrower, uint256 _amount) external {
        require(_amount > 0, ""Amount must be greater than 0"");
        require(borrows[_borrower] >= _amount, ""Borrower does not have enough debt"");
        borrows[_borrower] -= _amount;
        totalBorrow -= _amount;
        emit Liquidate(msg.sender, _borrower, _amount);
    }

    function serializeFacetAddresses() external view returns (string memory) {
        string memory json = ""["";
        for (uint256 i = 0; i < facets.length; i++) {
            json = string(abi.encodePacked(
                json,
                '{""facetAddress"":""',
                toHexString(facets[i].facetAddress),
                '"",""facetName"":""',
                facets[i].facetName,
                '""}'
            ));
            if (i < facets.length - 1) {
                json = string(abi.encodePacked(json, "",""));
            }
        }
        json = string(abi.encodePacked(json, ""]""));
        return json;
    }

    function toHexString(address addr) internal pure returns (string memory) {
        bytes32 value = bytes32(uint256(uint160(addr)));
        bytes memory alphabet = ""0123456789abcdef"";
        bytes memory str = new bytes(42);
        str[0] = '0';
        str[1] = 'x';
        for (uint256 i = 0; i < 20; i++) {
            str[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];
            str[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];
        }
        return string(str);
    }
}",contract_166.sol
"Design a smart contract that conforms to the ERC20 token standard, enabling token transfers, setting Allowance levels, and emitting events for transfers and approvals. Ensure the contract includes variables for storing token balances and allowance amounts, as well as event emissions for transfer and approval operations.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance too low"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }
}",contract_167.sol
"Create a smart contract that allows users to invest in a smart contract-based investment portfolio. The contract should enable users to deposit and withdraw funds, calculate investment returns based on block time, and allow for secure withdrawal of earnings. Focus on implementing the logic and structure for this functionality, without delving into low-level details.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract InvestmentPortfolio {
    address public owner;
    uint256 public totalInvestment;
    uint256 public totalReturns;
    uint256 public startTime;
    uint256 public constant RETURN_RATE = 1; // 1% return rate per block

    struct Investor {
        uint256 investment;
        uint256 lastWithdrawBlock;
    }

    mapping(address => Investor) public investors;

    event Deposited(address indexed investor, uint256 amount);
    event Withdrawn(address indexed investor, uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
        startTime = block.number;
    }

    function deposit() public payable {
        require(msg.value > 0, ""Deposit amount must be greater than zero"");
        Investor storage investor = investors[msg.sender];
        investor.investment += msg.value;
        totalInvestment += msg.value;
        emit Deposited(msg.sender, msg.value);
    }

    function calculateReturns(address investorAddress) public view returns (uint256) {
        Investor storage investor = investors[investorAddress];
        uint256 blocksPassed = block.number - investor.lastWithdrawBlock;
        return (investor.investment * RETURN_RATE / 100) * blocksPassed;
    }

    function withdraw(uint256 amount) public {
        require(amount > 0, ""Withdrawal amount must be greater than zero"");
        Investor storage investor = investors[msg.sender];
        uint256 availableReturns = calculateReturns(msg.sender);
        require(availableReturns >= amount, ""Insufficient returns"");

        investor.lastWithdrawBlock = block.number;
        totalReturns += amount;
        payable(msg.sender).transfer(amount);
        emit Withdrawn(msg.sender, amount);
    }

    function withdrawInvestment(uint256 amount) public {
        require(amount > 0, ""Withdrawal amount must be greater than zero"");
        Investor storage investor = investors[msg.sender];
        require(investor.investment >= amount, ""Insufficient investment"");

        investor.investment -= amount;
        totalInvestment -= amount;
        payable(msg.sender).transfer(amount);
        emit Withdrawn(msg.sender, amount);
    }

    function emergencyWithdraw() public onlyOwner {
        payable(owner).transfer(address(this).balance);
    }
}",contract_168.sol
"Create a Smart Contract that allows users to deposit funds and track their profits. Implement functions to add F1 and network deposits, retrieve deposited amounts, and display overall deposited amounts. Include modifiers to restrict access to certain functions based on user roles. Ensure accurate decimal calculations using the SafeMath library. Focus on simplicity and modularity in the contract structure.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DepositTracker {
    using SafeMath for uint256;

    address public owner;
    mapping(address => uint256) public deposits;
    mapping(address => uint256) public profits;
    uint256 public totalDeposits;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function depositFunds() public payable {
        require(msg.value > 0, ""Deposit amount must be greater than 0"");
        deposits[msg.sender] = deposits[msg.sender].add(msg.value);
        totalDeposits = totalDeposits.add(msg.value);
    }

    function addF1Deposit(address f1Address, uint256 amount) public onlyOwner {
        require(amount > 0, ""Amount must be greater than 0"");
        deposits[f1Address] = deposits[f1Address].add(amount);
        totalDeposits = totalDeposits.add(amount);
    }

    function addNetworkDeposit(address networkAddress, uint256 amount) public onlyOwner {
        require(amount > 0, ""Amount must be greater than 0"");
        deposits[networkAddress] = deposits[networkAddress].add(amount);
        totalDeposits = totalDeposits.add(amount);
    }

    function getDepositedAmount(address user) public view returns (uint256) {
        return deposits[user];
    }

    function getTotalDeposits() public view returns (uint256) {
        return totalDeposits;
    }

    function updateProfit(address user, uint256 profitAmount) public onlyOwner {
        require(profitAmount > 0, ""Profit amount must be greater than 0"");
        profits[user] = profits[user].add(profitAmount);
    }

    function getProfit(address user) public view returns (uint256) {
        return profits[user];
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, ""SafeMath: modulo by zero"");
        return a % b;
    }
}",contract_169.sol
"Create a smart contract that allows users to register names, track player information, and incentivize affiliate referrals. Ensure the contract includes a fee structure for registering names and validation for preventing duplicates. Include a simple constructor for initializing the contract and basic controls for moderation. Utilize the provided NameFilter and SafeMath libraries for additional functionality. Focus on creating a user-friendly and scalable solution.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract PlayerRegistry {
    using SafeMath for uint256;

    struct Player {
        string name;
        address referrer;
        uint256 referralReward;
    }

    mapping(address => Player) public players;
    mapping(string => bool) public nameExists;
    address public owner;
    uint256 public registrationFee;

    event PlayerRegistered(address indexed player, string name, address referrer);
    event RewardAdded(address indexed player, uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor(uint256 _registrationFee) {
        owner = msg.sender;
        registrationFee = _registrationFee;
    }

    function registerName(string memory _name, address _referrer) public payable {
        require(msg.value == registrationFee, ""Incorrect registration fee"");
        require(!nameExists[toLower(_name)], ""Name already exists"");

        players[msg.sender] = Player({
            name: _name,
            referrer: _referrer,
            referralReward: 0
        });
        nameExists[toLower(_name)] = true;

        if (_referrer != address(0)) {
            players[_referrer].referralReward = players[_referrer].referralReward.add(msg.value.div(10));
            emit RewardAdded(_referrer, msg.value.div(10));
        }

        emit PlayerRegistered(msg.sender, _name, _referrer);
    }

    function addReward(address _player, uint256 _amount) public onlyOwner {
        players[_player].referralReward = players[_player].referralReward.add(_amount);
        emit RewardAdded(_player, _amount);
    }

    function withdrawReward() public {
        uint256 reward = players[msg.sender].referralReward;
        require(reward > 0, ""No reward to withdraw"");

        players[msg.sender].referralReward = 0;
        payable(msg.sender).transfer(reward);
    }

    function setRegistrationFee(uint256 _newFee) public onlyOwner {
        registrationFee = _newFee;
    }

    function toLower(string memory str) internal pure returns (string memory) {
        bytes memory bStr = bytes(str);
        bytes memory bLower = new bytes(bStr.length);
        for (uint i = 0; i < bStr.length; i++) {
            if ((uint8(bStr[i]) >= 65) && (uint8(bStr[i]) <= 90)) {
                bLower[i] = bytes1(uint8(bStr[i]) + 32);
            } else {
                bLower[i] = bStr[i];
            }
        }
        return string(bLower);
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, ""SafeMath: modulo by zero"");
        return a % b;
    }
}",contract_170.sol
"Create a Solidity smart contract that allows for pausing and unpausing of smart contract functionality, utilizing the Pausable abstract contract. Implement interfaces for receiving IAccounting, AggregatorV3Interface, and IHedgingReactor, integrating them to facilitate delta hedging, collateralling, and withdrawals. Utilize state variables and modifiers to restrict functionality when paused or unpaused. Include functions for interacting with above interfaces and emitting events during significant transactions.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Pausable {
    bool private _paused;

    event Paused(address account);
    event Unpaused(address account);

    constructor() {
        _paused = false;
    }

    modifier whenNotPaused() {
        require(!_paused, ""Pausable: paused"");
        _;
    }

    modifier whenPaused() {
        require(_paused, ""Pausable: not paused"");
        _;
    }

    function paused() public view returns (bool) {
        return _paused;
    }

    function _pause() internal whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    function _unpause() internal whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}

interface IAccounting {
    function deposit() external payable;
    function withdraw(uint256 amount) external;
}

interface AggregatorV3Interface {
    function latestRoundData() external view returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    );
}

interface IHedgingReactor {
    function hedgeDelta(int256 delta) external;
    function withdraw(uint256 amount) external;
}

contract DeltaHedgingContract is Pausable {
    IAccounting public accounting;
    AggregatorV3Interface public priceFeed;
    IHedgingReactor public hedgingReactor;

    event Deposit(address indexed user, uint256 amount);
    event Withdrawal(address indexed user, uint256 amount);
    event DeltaHedged(int256 delta);

    constructor(address _accounting, address _priceFeed, address _hedgingReactor) {
        accounting = IAccounting(_accounting);
        priceFeed = AggregatorV3Interface(_priceFeed);
        hedgingReactor = IHedgingReactor(_hedgingReactor);
    }

    function deposit() external payable whenNotPaused {
        accounting.deposit{value: msg.value}();
        emit Deposit(msg.sender, msg.value);
    }

    function withdraw(uint256 amount) external whenNotPaused {
        accounting.withdraw(amount);
        emit Withdrawal(msg.sender, amount);
    }

    function hedgeDelta() external whenNotPaused {
        (, int256 price, , , ) = priceFeed.latestRoundData();
        int256 delta = calculateDelta(price);
        hedgingReactor.hedgeDelta(delta);
        emit DeltaHedged(delta);
    }

    function calculateDelta(int256 price) internal pure returns (int256) {
        // Placeholder for actual delta calculation logic
        return price / 100;
    }

    function pause() external {
        _pause();
    }

    function unpause() external {
        _unpause();
    }
}",contract_171.sol
Create a smart contract that utilizes the IPoseidonHasher interface to compute the poseidon hash of a given input vector. The contract should include a function to register a new poseidon hash and retrieve the poseidon hash of a given input. Take into consideration the technical requirements outlined in the provided code and ensure the contract is well-structured and maintainable.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IPoseidonHasher {
    function poseidon(uint256[2] memory input) external pure returns (uint256);
}

contract PoseidonHashRegistry {
    IPoseidonHasher private poseidonHasher;
    mapping(uint256 => uint256) public hashes;

    constructor(address _poseidonHasherAddress) {
        poseidonHasher = IPoseidonHasher(_poseidonHasherAddress);
    }

    function registerPoseidonHash(uint256[2] memory input) public {
        uint256 hash = poseidonHasher.poseidon(input);
        hashes[input[0]] = hash;
    }

    function getPoseidonHash(uint256[2] memory input) public view returns (uint256) {
        return poseidonHasher.poseidon(input);
    }
}",contract_172.sol
"Create a token contract that supports both ERC20 and ERC223 standards. The contract should allow for token transfers, balance checks, and allowance management. Implement the necessary logic for token transfers, including balance checks and transfer notifications. Make use of the SafeMath library to ensure secure arithmetic operations. Include variables for the token's name, symbol, and total supply. Implement methods for getting the token name, symbol, and total supply. The contract should be compatible with both ERC20 and ERC223 standards.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    using SafeMath for uint256;

    string public name;
    string public symbol;
    uint256 public totalSupply;
    mapping(address => uint256) private balances;
    mapping(address => mapping(address => uint256)) private allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint256 _totalSupply) {
        name = _name;
        symbol = _symbol;
        totalSupply = _totalSupply;
        balances[msg.sender] = _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, allowances[sender][msg.sender].sub(amount));
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");
        require(balances[sender] >= amount, ""ERC20: transfer amount exceeds balance"");

        balances[sender] = balances[sender].sub(amount);
        balances[recipient] = balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }
}",contract_173.sol
"Create a Solidity smart contract that manages the Treasury's PIGGY token supply, delegation of bonds, and seigniorage distribution. Implement functions for initializing the contract, setting operator roles, and interacting with Oracle and Masonry interfaces for PIGGY prices and supply management. Remember to handle edge cases and implement logical error checking for contract reliability.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Treasury {
    address public operator;
    uint256 public totalPiggySupply;
    uint256 public seigniorage;
    mapping(address => uint256) public bonds;
    mapping(address => bool) public isOracle;
    mapping(address => bool) public isMasonry;

    modifier onlyOperator() {
        require(msg.sender == operator, ""Not the operator"");
        _;
    }

    modifier onlyOracle() {
        require(isOracle[msg.sender], ""Not an oracle"");
        _;
    }

    modifier onlyMasonry() {
        require(isMasonry[msg.sender], ""Not a masonry"");
        _;
    }

    constructor(address _operator) {
        operator = _operator;
    }

    function setOperator(address _newOperator) external onlyOperator {
        operator = _newOperator;
    }

    function setOracle(address _oracle, bool _status) external onlyOperator {
        isOracle[_oracle] = _status;
    }

    function setMasonry(address _masonry, bool _status) external onlyOperator {
        isMasonry[_masonry] = _status;
    }

    function updatePiggyPrice(uint256 _newPrice) external onlyOracle {
        // Logic to update Piggy price based on Oracle's input
    }

    function delegateBond(address _to, uint256 _amount) external onlyMasonry {
        require(_amount > 0, ""Amount must be greater than 0"");
        bonds[_to] += _amount;
    }

    function distributeSeigniorage(uint256 _amount) external onlyOperator {
        require(_amount <= seigniorage, ""Not enough seigniorage"");
        seigniorage -= _amount;
        // Logic to distribute seigniorage
    }

    function mintPiggy(uint256 _amount) external onlyOperator {
        require(_amount > 0, ""Amount must be greater than 0"");
        totalPiggySupply += _amount;
        // Logic to mint new Piggy tokens
    }

    function burnPiggy(uint256 _amount) external onlyOperator {
        require(_amount > 0, ""Amount must be greater than 0"");
        require(_amount <= totalPiggySupply, ""Not enough supply"");
        totalPiggySupply -= _amount;
        // Logic to burn Piggy tokens
    }

    function addSeigniorage(uint256 _amount) external onlyOperator {
        require(_amount > 0, ""Amount must be greater than 0"");
        seigniorage += _amount;
    }
}",contract_174.sol
"Create a smart contract that allows for ownership management, including the ability to initialize and transfer ownership. The contract should include functions for transferring ownership and retrieving the current owner. Use the provided code as a reference. Modify the code to fit the required functionality and include necessary variables and modifiers.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    modifier onlyOwner() {
        require(isOwner(), ""Ownable: caller is not the owner"");
        _;
    }

    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    function owner() public view returns (address) {
        return _owner;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}",contract_175.sol
"Create a smart contract for a mintable token that has an owner and allows for token minting and transfer. The contract should have an owner that can start and stop the minting process. The contract should also track the last time a token was moved by an address. Additionally, the owner should be able to unlock the minting process and allow tokens to be transferred.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MintableToken {
    string public name = ""MintableToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    address public owner;
    bool public mintingStopped = false;
    bool public transferAllowed = false;

    mapping(address => uint256) public balanceOf;
    mapping(address => uint256) public lastMove;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Mint(address indexed to, uint256 value);
    event MintingStopped(address indexed by);
    event MintingStarted(address indexed by);
    event TransferAllowed(address indexed by);
    event TransferDisallowed(address indexed by);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function mint(address _to, uint256 _amount) external onlyOwner {
        require(!mintingStopped, ""Minting is stopped"");
        totalSupply += _amount;
        balanceOf[_to] += _amount;
        lastMove[_to] = block.timestamp;
        emit Mint(_to, _amount);
        emit Transfer(address(0), _to, _amount);
    }

    function stopMinting() external onlyOwner {
        mintingStopped = true;
        emit MintingStopped(msg.sender);
    }

    function startMinting() external onlyOwner {
        mintingStopped = false;
        emit MintingStarted(msg.sender);
    }

    function allowTransfer() external onlyOwner {
        transferAllowed = true;
        emit TransferAllowed(msg.sender);
    }

    function disallowTransfer() external onlyOwner {
        transferAllowed = false;
        emit TransferDisallowed(msg.sender);
    }

    function transfer(address _to, uint256 _amount) external {
        require(transferAllowed, ""Transfers are not allowed"");
        require(balanceOf[msg.sender] >= _amount, ""Insufficient balance"");
        balanceOf[msg.sender] -= _amount;
        balanceOf[_to] += _amount;
        lastMove[msg.sender] = block.timestamp;
        lastMove[_to] = block.timestamp;
        emit Transfer(msg.sender, _to, _amount);
    }
}",contract_176.sol
Create a smart contract that has a owner and allows for ownership transfer. Implement a pause and unpause function to pause and resume the contract's functionality. The contract should emit events when ownership is transferred or paused/unpaused. The contract should inherit from OpenZeppelin's contracts and implement the required functions.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;
    bool private _paused;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event Paused(address account);
    event Unpaused(address account);

    constructor() {
        _owner = msg.sender;
        _paused = false;
    }

    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    modifier whenNotPaused() {
        require(!_paused, ""Pausable: paused"");
        _;
    }

    modifier whenPaused() {
        require(_paused, ""Pausable: not paused"");
        _;
    }

    function owner() public view returns (address) {
        return _owner;
    }

    function paused() public view returns (bool) {
        return _paused;
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }

    function pause() public virtual onlyOwner whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    function unpause() public virtual onlyOwner whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}",contract_177.sol
Create a smart contract that performs basic arithmetic operations and token transfers. The contract should include libraries for safe arithmetic operations and address handling. Ensure that the contract handles overflow and underflow conditions. Implement the contract using Solidity and include descriptions of the functions and variables used.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ArithmeticOperations {
    // SafeMath library for safe arithmetic operations
    library SafeMath {
        function add(uint256 a, uint256 b) internal pure returns (uint256) {
            uint256 c = a + b;
            require(c >= a, ""SafeMath: addition overflow"");
            return c;
        }

        function sub(uint256 a, uint256 b) internal pure returns (uint256) {
            require(b <= a, ""SafeMath: subtraction overflow"");
            uint256 c = a - b;
            return c;
        }

        function mul(uint256 a, uint256 b) internal pure returns (uint256) {
            if (a == 0) {
                return 0;
            }
            uint256 c = a * b;
            require(c / a == b, ""SafeMath: multiplication overflow"");
            return c;
        }

        function div(uint256 a, uint256 b) internal pure returns (uint256) {
            require(b > 0, ""SafeMath: division by zero"");
            uint256 c = a / b;
            return c;
        }
    }

    // Address library for address handling
    library Address {
        function isContract(address account) internal view returns (bool) {
            uint256 size;
            assembly { size := extcodesize(account) }
            return size > 0;
        }
    }

    using SafeMath for uint256;
    using Address for address;

    // Token balance mapping
    mapping(address => uint256) private _balances;

    // Event for token transfer
    event Transfer(address indexed from, address indexed to, uint256 value);

    // Function to perform addition
    function add(uint256 a, uint256 b) public pure returns (uint256) {
        return a.add(b);
    }

    // Function to perform subtraction
    function sub(uint256 a, uint256 b) public pure returns (uint256) {
        return a.sub(b);
    }

    // Function to perform multiplication
    function mul(uint256 a, uint256 b) public pure returns (uint256) {
        return a.mul(b);
    }

    // Function to perform division
    function div(uint256 a, uint256 b) public pure returns (uint256) {
        return a.div(b);
    }

    // Function to transfer tokens
    function transfer(address recipient, uint256 amount) public returns (bool) {
        require(recipient != address(0), ""Transfer to the zero address"");
        require(_balances[msg.sender] >= amount, ""Insufficient balance"");

        _balances[msg.sender] = _balances[msg.sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);

        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    // Function to get the balance of an address
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    // Function to mint tokens
    function mint(address account, uint256 amount) public {
        require(account != address(0), ""Mint to the zero address"");

        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    // Function to burn tokens
    function burn(address account, uint256 amount) public {
        require(account != address(0), ""Burn from the zero address"");
        require(_balances[account] >= amount, ""Insufficient balance"");

        _balances[account] = _balances[account].sub(amount);
        emit Transfer(account, address(0), amount);
    }
}",contract_178.sol
"Create a smart contract that defines a router for equalizing liquidity. The contract should have functions for adding and removing liquidity, swapping tokens, and getting the amount of tokens out given the amount in. Implement the logic for these functions, including checks and error handling. Ensure that the contract inherits from OpenZeppelin's Pausable and Ownable contracts.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Pausable {
    bool private _paused;

    event Paused(address account);
    event Unpaused(address account);

    constructor() {
        _paused = false;
    }

    modifier whenNotPaused() {
        require(!_paused, ""Pausable: paused"");
        _;
    }

    modifier whenPaused() {
        require(_paused, ""Pausable: not paused"");
        _;
    }

    function paused() public view returns (bool) {
        return _paused;
    }

    function _pause() internal virtual whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    function _unpause() internal virtual whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    modifier onlyOwner() {
        require(_owner == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function owner() public view returns (address) {
        return _owner;
    }

    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract LiquidityRouter is Pausable, Ownable {
    mapping(address => mapping(address => uint256)) private _balances;

    event LiquidityAdded(address indexed tokenA, address indexed tokenB, uint256 amountA, uint256 amountB);
    event LiquidityRemoved(address indexed tokenA, address indexed tokenB, uint256 amountA, uint256 amountB);
    event TokensSwapped(address indexed tokenIn, address indexed tokenOut, uint256 amountIn, uint256 amountOut);

    function addLiquidity(address tokenA, address tokenB, uint256 amountA, uint256 amountB) external whenNotPaused {
        require(tokenA != tokenB, ""LiquidityRouter: TOKEN_MISMATCH"");
        require(amountA > 0 && amountB > 0, ""LiquidityRouter: INSUFFICIENT_INPUT_AMOUNT"");

        _balances[tokenA][tokenB] += amountA;
        _balances[tokenB][tokenA] += amountB;

        emit LiquidityAdded(tokenA, tokenB, amountA, amountB);
    }

    function removeLiquidity(address tokenA, address tokenB, uint256 amountA, uint256 amountB) external whenNotPaused {
        require(tokenA != tokenB, ""LiquidityRouter: TOKEN_MISMATCH"");
        require(amountA > 0 && amountB > 0, ""LiquidityRouter: INSUFFICIENT_INPUT_AMOUNT"");
        require(_balances[tokenA][tokenB] >= amountA && _balances[tokenB][tokenA] >= amountB, ""LiquidityRouter: INSUFFICIENT_LIQUIDITY"");

        _balances[tokenA][tokenB] -= amountA;
        _balances[tokenB][tokenA] -= amountB;

        emit LiquidityRemoved(tokenA, tokenB, amountA, amountB);
    }

    function swapTokens(address tokenIn, address tokenOut, uint256 amountIn) external whenNotPaused returns (uint256 amountOut) {
        require(tokenIn != tokenOut, ""LiquidityRouter: TOKEN_MISMATCH"");
        require(amountIn > 0, ""LiquidityRouter: INSUFFICIENT_INPUT_AMOUNT"");
        require(_balances[tokenIn][tokenOut] > 0, ""LiquidityRouter: INSUFFICIENT_LIQUIDITY"");

        amountOut = (_balances[tokenIn][tokenOut] * amountIn) / (_balances[tokenIn][tokenOut] + amountIn);
        require(amountOut > 0, ""LiquidityRouter: INSUFFICIENT_OUTPUT_AMOUNT"");

        _balances[tokenIn][tokenOut] -= amountOut;
        _balances[tokenOut][tokenIn] += amountOut;

        emit TokensSwapped(tokenIn, tokenOut, amountIn, amountOut);
    }

    function getAmountOut(address tokenIn, address tokenOut, uint256 amountIn) external view returns (uint256 amountOut) {
        require(tokenIn != tokenOut, ""LiquidityRouter: TOKEN_MISMATCH"");
        require(amountIn > 0, ""LiquidityRouter: INSUFFICIENT_INPUT_AMOUNT"");
        require(_balances[tokenIn][tokenOut] > 0, ""LiquidityRouter: INSUFFICIENT_LIQUIDITY"");

        amountOut = (_balances[tokenIn][tokenOut] * amountIn) / (_balances[tokenIn][tokenOut] + amountIn);
    }

    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }
}",contract_179.sol
"Develop a smart contract that simulates the modularLong contract's structure and functionality. Incorporate event triggers for player registration, game timers, and affiliate payouts. Include functions for calculating game metrics and managing player data. Ensure the smart contract is well-organized, readable, and follows conventional coding practices.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ModularLong {
    struct Player {
        address payable walletAddress;
        uint256 balance;
        bool isRegistered;
    }

    mapping(address => Player) public players;
    address[] public playerList;
    uint256 public gameStartTime;
    uint256 public constant GAME_DURATION = 3600; // 1 hour in seconds

    event PlayerRegistered(address indexed player);
    event GameTimerStarted(uint256 startTime);
    event AffiliatePayout(address indexed affiliate, uint256 amount);

    modifier onlyRegisteredPlayer() {
        require(players[msg.sender].isRegistered, ""Player is not registered"");
        _;
    }

    function registerPlayer() external {
        require(!players[msg.sender].isRegistered, ""Player already registered"");
        players[msg.sender] = Player({
            walletAddress: payable(msg.sender),
            balance: 0,
            isRegistered: true
        });
        playerList.push(msg.sender);
        emit PlayerRegistered(msg.sender);
    }

    function startGameTimer() external onlyRegisteredPlayer {
        require(gameStartTime == 0, ""Game timer already started"");
        gameStartTime = block.timestamp;
        emit GameTimerStarted(gameStartTime);
    }

    function calculateGameMetrics() external view returns (uint256 totalPlayers, uint256 totalBalance) {
        totalPlayers = playerList.length;
        for (uint256 i = 0; i < playerList.length; i++) {
            totalBalance += players[playerList[i]].balance;
        }
    }

    function managePlayerData(address playerAddress, uint256 newBalance) external onlyRegisteredPlayer {
        require(players[playerAddress].isRegistered, ""Player not registered"");
        players[playerAddress].balance = newBalance;
    }

    function payoutAffiliate(address payable affiliate, uint256 amount) external onlyRegisteredPlayer {
        require(affiliate != address(0), ""Invalid affiliate address"");
        require(players[msg.sender].balance >= amount, ""Insufficient balance"");
        players[msg.sender].balance -= amount;
        affiliate.transfer(amount);
        emit AffiliatePayout(affiliate, amount);
    }

    function isGameActive() public view returns (bool) {
        return gameStartTime != 0 && block.timestamp < gameStartTime + GAME_DURATION;
    }

    receive() external payable {
        require(players[msg.sender].isRegistered, ""Player not registered"");
        players[msg.sender].balance += msg.value;
    }
}",contract_180.sol
"Design a smart contract to manage a token for digital entertainment. The contract should include features for owner transfer, approval, and token transfer. Implement a system for tracking token balances and allowed transactions. Emit events for transfer and approval. Build upon a library that provides safe arithmetic operations. Keep in mind the specific functionality demonstrated in the provided code snippet.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DigitalEntertainmentToken {
    string public name = ""DigitalEntertainmentToken"";
    string public symbol = ""DET"";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    address public owner;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        owner = msg.sender;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance too low"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""Invalid address"");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}",contract_181.sol
"Create a token contract that allows users to transfer tokens, track balances, and grant approvals. The contract should include features for pausing and unpausing token transfers. Implement the total supply tracking and provide functions for users to check their balances and approve token transfers.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    bool public paused;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    address public owner;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Paused(address account);
    event Unpaused(address account);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Paused"");
        _;
    }

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        owner = msg.sender;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address to, uint256 value) public whenNotPaused returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance too low"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }

    function pause() public onlyOwner {
        paused = true;
        emit Paused(msg.sender);
    }

    function unpause() public onlyOwner {
        paused = false;
        emit Unpaused(msg.sender);
    }
}",contract_182.sol
"Develop a smart contract that manages a token, allowing users to send and receive tokens, with the ability to freeze and unfreeze values for future release. The contract should include functions for transferring tokens, freezing, and unfreezing values, as well as variables to store the total supply, user balances, and a data structure to store frozen values and release times.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    mapping(address => FrozenBalance[]) public frozenBalances;

    struct FrozenBalance {
        uint256 amount;
        uint256 releaseTime;
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Frozen(address indexed owner, uint256 value, uint256 releaseTime);
    event Unfrozen(address indexed owner, uint256 value);

    constructor(uint256 _totalSupply) {
        totalSupply = _totalSupply;
        balanceOf[msg.sender] = _totalSupply;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], ""Insufficient balance"");
        require(_value <= allowance[_from][msg.sender], ""Allowance too low"");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    function freeze(uint256 _value, uint256 _releaseTime) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        frozenBalances[msg.sender].push(FrozenBalance(_value, _releaseTime));
        emit Frozen(msg.sender, _value, _releaseTime);
        return true;
    }

    function unfreeze(uint256 _index) public returns (bool success) {
        require(_index < frozenBalances[msg.sender].length, ""Invalid index"");
        FrozenBalance storage frozenBalance = frozenBalances[msg.sender][_index];
        require(block.timestamp >= frozenBalance.releaseTime, ""Release time not reached"");
        balanceOf[msg.sender] += frozenBalance.amount;
        frozenBalances[msg.sender][_index] = frozenBalances[msg.sender][frozenBalances[msg.sender].length - 1];
        frozenBalances[msg.sender].pop();
        emit Unfrozen(msg.sender, frozenBalance.amount);
        return true;
    }
}",contract_183.sol
"Create a smart contract that enables the creation of a basic ERC20 token. The token should have a total supply of 500 million and 8 decimal places. Include functionality for transferring tokens, approving allowances, and checking remaining balances. Utilize the SafeMath library for arithmetic operations. Pay attention to event emissions and ensure that the contract is compliant with the ERC20 standard.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 8;
    uint256 public totalSupply = 500000000 * 10**uint256(decimals);

    mapping(address => uint256) private balances;
    mapping(address => mapping(address => uint256)) private allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        balances[msg.sender] = totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        require(amount <= balances[msg.sender], ""Insufficient balance"");
        balances[msg.sender] = balances[msg.sender] - amount;
        balances[recipient] = balances[recipient] + amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        require(amount <= balances[sender], ""Insufficient balance"");
        require(amount <= allowances[sender][msg.sender], ""Allowance too low"");
        balances[sender] = balances[sender] - amount;
        balances[recipient] = balances[recipient] + amount;
        allowances[sender][msg.sender] = allowances[sender][msg.sender] - amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }
}",contract_184.sol
"Develop a smart contract that follows the IERC721Full standard, allowing for the creation, management, and transfer of unique digital assets. The contract should include functions for token minting, updating, and querying, as well as support for token metadata and enumeration. Consider gas efficiency and error handling in your implementation.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC721 {
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function balanceOf(address owner) external view returns (uint256 balance);
    function ownerOf(uint256 tokenId) external view returns (address owner);
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    function transferFrom(address from, address to, uint256 tokenId) external;
    function approve(address to, uint256 tokenId) external;
    function getApproved(uint256 tokenId) external view returns (address operator);
    function setApprovalForAll(address operator, bool _approved) external;
    function isApprovedForAll(address owner, address operator) external view returns (bool);
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
}

interface IERC721Metadata {
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function tokenURI(uint256 tokenId) external view returns (string memory);
}

interface IERC721Enumerable {
    function totalSupply() external view returns (uint256);
    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);
    function tokenByIndex(uint256 index) external view returns (uint256);
}

contract ERC721 is IERC721, IERC721Metadata, IERC721Enumerable {
    string private _name;
    string private _symbol;
    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;
    uint256[] private _allTokens;
    mapping(uint256 => string) private _tokenURIs;

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function balanceOf(address owner) public view override returns (uint256) {
        require(owner != address(0), ""ERC721: balance query for the zero address"");
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) public view override returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), ""ERC721: owner query for nonexistent token"");
        return owner;
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) public override {
        safeTransferFrom(from, to, tokenId, """");
    }

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public override {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _safeTransfer(from, to, tokenId, data);
    }

    function transferFrom(address from, address to, uint256 tokenId) public override {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _transfer(from, to, tokenId);
    }

    function approve(address to, uint256 tokenId) public override {
        address owner = ownerOf(tokenId);
        require(to != owner, ""ERC721: approval to current owner"");
        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), ""ERC721: approve caller is not owner nor approved for all"");
        _approve(to, tokenId);
    }

    function getApproved(uint256 tokenId) public view override returns (address) {
        require(_exists(tokenId), ""ERC721: approved query for nonexistent token"");
        return _tokenApprovals[tokenId];
    }

    function setApprovalForAll(address operator, bool approved) public override {
        require(operator != msg.sender, ""ERC721: approve to caller"");
        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function isApprovedForAll(address owner, address operator) public view override returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function name() public view override returns (string memory) {
        return _name;
    }

    function symbol() public view override returns (string memory) {
        return _symbol;
    }

    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        require(_exists(tokenId), ""ERC721Metadata: URI query for nonexistent token"");
        return _tokenURIs[tokenId];
    }

    function totalSupply() public view override returns (uint256) {
        return _allTokens.length;
    }

    function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {
        require(index < balanceOf(owner), ""ERC721Enumerable: owner index out of bounds"");
        uint256 count;
        for (uint256 i = 0; i < _allTokens.length; i++) {
            if (ownerOf(_allTokens[i]) == owner) {
                if (count == index) {
                    return _allTokens[i];
                }
                count++;
            }
        }
        revert(""ERC721Enumerable: owner index out of bounds"");
    }

    function tokenByIndex(uint256 index) public view override returns (uint256) {
        require(index < totalSupply(), ""ERC721Enumerable: global index out of bounds"");
        return _allTokens[index];
    }

    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return _owners[tokenId] != address(0);
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    function _safeMint(address to, uint256 tokenId) internal {
        _safeMint(to, tokenId, """");
    }

    function _safeMint(address to, uint256 tokenId, bytes memory data) internal {
        _mint(to, tokenId);
        require(_checkOnERC721Received(address(0), to, tokenId, data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _mint(address to, uint256 tokenId) internal {
        require(to != address(0), ""ERC721: mint to the zero address"");
        require(!_exists(tokenId), ""ERC721: token already minted"");
        _beforeTokenTransfer(address(0), to, tokenId);
        _balances[to] += 1;
        _owners[tokenId] = to;
        _allTokens.push(tokenId);
        emit Transfer(address(0), to, tokenId);
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        require(ownerOf(tokenId) == from, ""ERC721: transfer of token that is not own"");
        require(to != address(0), ""ERC721: transfer to the zero address"");
        _beforeTokenTransfer(from, to, tokenId);
        _approve(address(0), tokenId);
        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;
        emit Transfer(from, to, tokenId);
    }

    function _approve(address to, uint256 tokenId) internal {
        _tokenApprovals[tokenId] = to;
        emit Approval(ownerOf(tokenId), to, tokenId);
    }

    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) internal returns (bool) {
        if (to.code.length > 0) {
            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data) returns (bytes4 retval) {
                return retval == IERC721Receiver.onERC721Received.selector;
            } catch (bytes memory reason) {
                if (reason.length == 0) {
                    revert(""ERC721: transfer to non ERC721Receiver implementer"");
                } else {
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        } else {
            return true;
        }
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual {}

    interface IERC721Receiver {
        function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
    }
}",contract_185.sol
"Create a smart contract called 'StakingWarmup' that supports withdrawals. The contract should have two immutable addresses, 'staking' and 'sHocus'. Implement a constructor function to set these addresses. Include a function 'retrieve' that allows the 'staking' address to withdraw a specified amount to a specified staker. The function should validate that the caller is indeed the 'staking' address.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract StakingWarmup {
    address public immutable staking;
    address public immutable sHocus;

    constructor(address _staking, address _sHocus) {
        staking = _staking;
        sHocus = _sHocus;
    }

    function retrieve(address staker, uint256 amount) external {
        require(msg.sender == staking, ""Only staking contract can call this function"");
        (bool success, ) = staker.call{value: amount}("""");
        require(success, ""Transfer failed"");
    }
}",contract_186.sol
"Create a Solidity smart contract that implements the Moloch token system. The contract should include functions for submitting proposals, voting, and executing proposals. Implement mechanisms for managing member roles and delegate keys. Ensure the contract can handle multiple proposals and events for tracking proposal status. Optimize the contract for gas efficiency and follow proper coding standards.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MolochTokenSystem {
    struct Proposal {
        address proposer;
        uint256 id;
        uint256 votesFor;
        uint256 votesAgainst;
        bool executed;
        mapping(address => bool) voted;
    }

    mapping(uint256 => Proposal) public proposals;
    mapping(address => address) public delegates;
    mapping(address => bool) public members;
    uint256 public proposalCount;

    event ProposalSubmitted(uint256 indexed id, address indexed proposer);
    event VoteCasted(uint256 indexed id, address indexed voter, bool inSupport);
    event ProposalExecuted(uint256 indexed id);

    modifier onlyMember() {
        require(members[msg.sender], ""Not a member"");
        _;
    }

    function submitProposal() external onlyMember {
        proposalCount++;
        Proposal storage p = proposals[proposalCount];
        p.proposer = msg.sender;
        p.id = proposalCount;
        p.executed = false;

        emit ProposalSubmitted(proposalCount, msg.sender);
    }

    function castVote(uint256 proposalId, bool inSupport) external onlyMember {
        Proposal storage p = proposals[proposalId];
        require(!p.voted[msg.sender], ""Already voted"");
        p.voted[msg.sender] = true;

        if (inSupport) {
            p.votesFor++;
        } else {
            p.votesAgainst++;
        }

        emit VoteCasted(proposalId, msg.sender, inSupport);
    }

    function executeProposal(uint256 proposalId) external onlyMember {
        Proposal storage p = proposals[proposalId];
        require(!p.executed, ""Proposal already executed"");
        require(p.votesFor > p.votesAgainst, ""Majority not in support"");

        p.executed = true;

        emit ProposalExecuted(proposalId);
    }

    function setDelegate(address delegate) external onlyMember {
        delegates[msg.sender] = delegate;
    }

    function addMember(address member) external onlyMember {
        members[member] = true;
    }

    function removeMember(address member) external onlyMember {
        members[member] = false;
    }
}",contract_187.sol
"Create a smart contract that allows users to deposit funds, receive marketing and commission rates based on their investment amounts. The contract should keep track of total deposits made by users and allow users to withdraw their funds. Implement a mechanism to calculate contract balance rate, leader bonus rate, and community bonus rate. Define events for deposit creation, withdrawal, and bonus payment. Utilize a safe math library to prevent overflow and underflow issues.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract InvestmentPlatform {
    using SafeMath for uint256;

    struct User {
        uint256 deposit;
        uint256 lastDepositTime;
        uint256 marketingRate;
        uint256 commissionRate;
    }

    mapping(address => User) public users;
    uint256 public totalDeposits;
    uint256 public contractBalanceRate;
    uint256 public leaderBonusRate;
    uint256 public communityBonusRate;

    event DepositCreated(address indexed user, uint256 amount);
    event Withdrawal(address indexed user, uint256 amount);
    event BonusPaid(address indexed user, uint256 amount, string bonusType);

    function deposit() public payable {
        require(msg.value > 0, ""Deposit amount must be greater than zero"");
        User storage user = users[msg.sender];
        user.deposit = user.deposit.add(msg.value);
        user.lastDepositTime = block.timestamp;
        totalDeposits = totalDeposits.add(msg.value);
        emit DepositCreated(msg.sender, msg.value);
    }

    function withdraw(uint256 amount) public {
        User storage user = users[msg.sender];
        require(amount > 0 && amount <= user.deposit, ""Invalid withdrawal amount"");
        user.deposit = user.deposit.sub(amount);
        totalDeposits = totalDeposits.sub(amount);
        payable(msg.sender).transfer(amount);
        emit Withdrawal(msg.sender, amount);
    }

    function calculateBonus(address userAddress) internal view returns (uint256) {
        User storage user = users[userAddress];
        uint256 timeSinceLastDeposit = block.timestamp.sub(user.lastDepositTime);
        uint256 bonus = user.deposit.mul(contractBalanceRate.add(leaderBonusRate).add(communityBonusRate)).mul(timeSinceLastDeposit).div(365 days);
        return bonus;
    }

    function payBonus(address userAddress) public {
        uint256 bonus = calculateBonus(userAddress);
        require(bonus > 0, ""No bonus available"");
        payable(userAddress).transfer(bonus);
        emit BonusPaid(userAddress, bonus, ""General"");
    }

    function setRates(uint256 _contractBalanceRate, uint256 _leaderBonusRate, uint256 _communityBonusRate) public {
        contractBalanceRate = _contractBalanceRate;
        leaderBonusRate = _leaderBonusRate;
        communityBonusRate = _communityBonusRate;
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }
}",contract_188.sol
"Develop a smart contract that allows users to lend and borrow tokens. The contract should provide functionality for depositing and withdrawing tokens, as well as borrowing and repaying loans. Implement a basic interest rate system and manage borrower and lender relationships. Utilize OpenZeppelin's ERC20 and SafeMath libraries to ensure efficiency and reliability. Include simple logic for handling TryAdd, TrySub, TryMul, TryDiv, and TryMod calculations. Focus on creating a functional and secure contract, with documentation and comments to help others understand the code. Consider implementing mechanisms for borrowers to participate in lending pools and for lenders to earn interest and returns.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// ERC20 contract interface
abstract contract IERC20 {
    function totalSupply() public view virtual returns (uint256);
    function balanceOf(address account) public view virtual returns (uint256);
    function transfer(address recipient, uint256 amount) public virtual returns (bool);
    function allowance(address owner, address spender) public view virtual returns (uint256);
    function approve(address spender, uint256 amount) public virtual returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

// SafeMath library
library SafeMath {
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            uint256 c = a + b;
            if (c < a) return (false, 0);
            return (true, c);
        }
    }

    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b > a) return (false, 0);
            return (true, a - b);
        }
    }

    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (a == 0) return (true, 0);
            uint256 c = a * b;
            if (c / a != b) return (false, 0);
            return (true, c);
        }
    }

    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a / b);
        }
    }

    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a % b);
        }
    }
}

contract LendingBorrowingContract {
    using SafeMath for uint256;

    IERC20 public token;
    mapping(address => uint256) public deposits;
    mapping(address => uint256) public borrowings;
    uint256 public totalDeposits;
    uint256 public totalBorrowings;
    uint256 public interestRate = 5; // 5% interest rate

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function deposit(uint256 amount) public {
        require(token.transferFrom(msg.sender, address(this), amount), ""Transfer failed"");
        deposits[msg.sender] += amount;
        totalDeposits += amount;
    }

    function withdraw(uint256 amount) public {
        require(deposits[msg.sender] >= amount, ""Insufficient deposits"");
        require(token.transfer(msg.sender, amount), ""Transfer failed"");
        deposits[msg.sender] -= amount;
        totalDeposits -= amount;
    }

    function borrow(uint256 amount) public {
        require(totalDeposits >= totalBorrowings + amount, ""Not enough liquidity"");
        borrowings[msg.sender] += amount;
        totalBorrowings += amount;
        require(token.transfer(msg.sender, amount), ""Transfer failed"");
    }

    function repay(uint256 amount) public {
        require(borrowings[msg.sender] >= amount, ""Repayment exceeds borrowings"");
        require(token.transferFrom(msg.sender, address(this), amount), ""Transfer failed"");
        borrowings[msg.sender] -= amount;
        totalBorrowings -= amount;
    }

    function calculateInterest(address borrower) public view returns (uint256) {
        return borrowings[borrower] * interestRate / 100;
    }
}",contract_189.sol
"Create a smart contract for a cryptocurrency-based miner engineer game. The contract should allow players to buy and sell engineer characters, buy boosters for mining, and change virus types. The contract should have an interface for mining war games and mini-games. The contract structure should include defining structs for miner and boost data, mapping player information, and implementing functions for buying and selling engineers. Implement the contract functionality by writing Solidity code that mirrors the functionality of the provided code snippet.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MinerEngineerGame {
    struct Miner {
        uint256 id;
        uint256 miningPower;
        uint256 price;
    }

    struct Booster {
        uint256 id;
        uint256 boostPercentage;
        uint256 price;
    }

    struct Player {
        uint256 balance;
        uint256[] minerIds;
        uint256[] boosterIds;
    }

    mapping(uint256 => Miner) public miners;
    mapping(uint256 => Booster) public boosters;
    mapping(address => Player) public players;

    uint256 public minerIdCounter;
    uint256 public boosterIdCounter;

    event MinerBought(address indexed player, uint256 minerId);
    event MinerSold(address indexed player, uint256 minerId);
    event BoosterBought(address indexed player, uint256 boosterId);
    event VirusTypeChanged(uint256 newVirusType);

    function buyMiner(uint256 _minerId) external {
        Miner storage miner = miners[_minerId];
        require(miner.price > 0, ""Miner does not exist"");
        Player storage player = players[msg.sender];
        require(player.balance >= miner.price, ""Not enough balance"");

        player.balance -= miner.price;
        player.minerIds.push(_minerId);
        emit MinerBought(msg.sender, _minerId);
    }

    function sellMiner(uint256 _minerId) external {
        Player storage player = players[msg.sender];
        uint256 minerIndex = findMinerIndex(player.minerIds, _minerId);
        require(minerIndex < player.minerIds.length, ""Miner not owned by player"");

        Miner storage miner = miners[_minerId];
        player.balance += miner.price;
        removeMiner(player.minerIds, minerIndex);
        emit MinerSold(msg.sender, _minerId);
    }

    function buyBooster(uint256 _boosterId) external {
        Booster storage booster = boosters[_boosterId];
        require(booster.price > 0, ""Booster does not exist"");
        Player storage player = players[msg.sender];
        require(player.balance >= booster.price, ""Not enough balance"");

        player.balance -= booster.price;
        player.boosterIds.push(_boosterId);
        emit BoosterBought(msg.sender, _boosterId);
    }

    function changeVirusType(uint256 _newVirusType) external {
        // Assuming this function changes some game state related to virus types
        // Implementation details would depend on the specific game mechanics
        emit VirusTypeChanged(_newVirusType);
    }

    function findMinerIndex(uint256[] storage _minerIds, uint256 _minerId) private view returns (uint256) {
        for (uint256 i = 0; i < _minerIds.length; i++) {
            if (_minerIds[i] == _minerId) {
                return i;
            }
        }
        return _minerIds.length; // Return an invalid index if not found
    }

    function removeMiner(uint256[] storage _minerIds, uint256 _index) private {
        _minerIds[_index] = _minerIds[_minerIds.length - 1];
        _minerIds.pop();
    }
}",contract_190.sol
"Create a Solidity smart contract that extends the provided 'ERC20' contract to implement a basic token. The contract should allow for setting the token name and symbol. Implement functions for minting and burning tokens. Also, add a function to set the allowance for a spender account. Consider implementing a pending transaction signature verification mechanism. Focus on creating a functional smart contract that fulfills the provided contract's requirements.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20 {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    uint256 private _totalSupply;
    string private _name;
    string private _symbol;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public pure returns (uint8) {
        return 18;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public virtual returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view virtual returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public virtual returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool) {
        _transfer(sender, recipient, amount);

        uint256 currentAllowance = _allowances[sender][msg.sender];
        require(currentAllowance >= amount, ""ERC20: transfer amount exceeds allowance"");
        _approve(sender, msg.sender, currentAllowance - amount);

        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        uint256 senderBalance = _balances[sender];
        require(senderBalance >= amount, ""ERC20: transfer amount exceeds balance"");
        _balances[sender] = senderBalance - amount;
        _balances[recipient] += amount;

        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: burn from the zero address"");

        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, ""ERC20: burn amount exceeds balance"");
        _balances[account] = accountBalance - amount;
        _totalSupply -= amount;

        emit Transfer(account, address(0), amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}

contract MyToken is ERC20 {
    address private _owner;

    constructor(string memory name, string memory symbol) ERC20(name, symbol) {
        _owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == _owner, ""Not the contract owner"");
        _;
    }

    function mint(address account, uint256 amount) public onlyOwner {
        _mint(account, amount);
    }

    function burn(uint256 amount) public {
        _burn(msg.sender, amount);
    }

    function setAllowance(address owner, address spender, uint256 amount) public onlyOwner {
        _approve(owner, spender, amount);
    }
}",contract_191.sol
"Develop a smart contract that facilitates a malt arbitration mechanism with auction features. The contract should allow users to initiate auctions, manage commitments, and allocate arbitrage rewards. Ensure efficient gas management. Implement event emissions for key functionality.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MaltArbitration {
    struct Auction {
        address seller;
        uint256 startingPrice;
        uint256 currentBid;
        address currentBidder;
        uint256 endTime;
        bool isActive;
    }

    Auction[] public auctions;
    mapping(address => uint256) public commitments;
    mapping(address => uint256) public rewards;

    event AuctionCreated(uint256 auctionId, address seller, uint256 startingPrice, uint256 endTime);
    event BidPlaced(uint256 auctionId, address bidder, uint256 bidAmount);
    event AuctionClosed(uint256 auctionId, address winner, uint256 winningBid);
    event RewardAllocated(address arbitrator, uint256 amount);

    modifier onlyActiveAuction(uint256 _auctionId) {
        require(auctions[_auctionId].isActive, ""Auction is not active"");
        _;
    }

    function createAuction(uint256 _startingPrice, uint256 _duration) external {
        uint256 endTime = block.timestamp + _duration;
        Auction memory newAuction = Auction({
            seller: msg.sender,
            startingPrice: _startingPrice,
            currentBid: 0,
            currentBidder: address(0),
            endTime: endTime,
            isActive: true
        });
        uint256 auctionId = auctions.length;
        auctions.push(newAuction);
        emit AuctionCreated(auctionId, msg.sender, _startingPrice, endTime);
    }

    function placeBid(uint256 _auctionId) external payable onlyActiveAuction(_auctionId) {
        Auction storage auction = auctions[_auctionId];
        require(block.timestamp < auction.endTime, ""Auction has ended"");
        require(msg.value > auction.currentBid, ""Bid must be higher than current bid"");

        if (auction.currentBidder != address(0)) {
            commitments[auction.currentBidder] += auction.currentBid;
        }

        auction.currentBid = msg.value;
        auction.currentBidder = msg.sender;
        emit BidPlaced(_auctionId, msg.sender, msg.value);
    }

    function closeAuction(uint256 _auctionId) external onlyActiveAuction(_auctionId) {
        Auction storage auction = auctions[_auctionId];
        require(block.timestamp >= auction.endTime, ""Auction has not ended yet"");

        auction.isActive = false;
        if (auction.currentBidder != address(0)) {
            rewards[auction.seller] += auction.currentBid;
            emit AuctionClosed(_auctionId, auction.currentBidder, auction.currentBid);
        } else {
            emit AuctionClosed(_auctionId, address(0), 0);
        }
    }

    function allocateReward(address _arbitrator, uint256 _amount) external {
        require(_amount <= rewards[_arbitrator], ""Not enough rewards available"");
        rewards[_arbitrator] -= _amount;
        (bool success, ) = _arbitrator.call{value: _amount}("""");
        require(success, ""Transfer failed"");
        emit RewardAllocated(_arbitrator, _amount);
    }

    function withdrawCommitment() external {
        uint256 amount = commitments[msg.sender];
        require(amount > 0, ""No commitment to withdraw"");
        commitments[msg.sender] = 0;
        (bool success, ) = msg.sender.call{value: amount}("""");
        require(success, ""Transfer failed"");
    }

    receive() external payable {}
}",contract_192.sol
Create a Solidity smart contract that can be used to mint a limited number of NFTs. The contract should have a way to set the base URI and base extension. It should also allow the owner to set the cost and maximum supply of NFTs. The contract should include a minting function that checks if the total supply is below the maximum supply and if the sender has sufficient Ether to cover the cost. Implement a way to retrieve the token URI using the token ID.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract NFTMinter {
    string private baseURI;
    string private baseExtension;
    uint256 public cost;
    uint256 public maxSupply;
    uint256 public totalSupply;
    address public owner;

    mapping(uint256 => address) private _owners;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor(
        string memory _baseURI,
        string memory _baseExtension,
        uint256 _cost,
        uint256 _maxSupply
    ) {
        baseURI = _baseURI;
        baseExtension = _baseExtension;
        cost = _cost;
        maxSupply = _maxSupply;
        owner = msg.sender;
    }

    function setBaseURI(string memory _newBaseURI) public onlyOwner {
        baseURI = _newBaseURI;
    }

    function setBaseExtension(string memory _newBaseExtension) public onlyOwner {
        baseExtension = _newBaseExtension;
    }

    function setCost(uint256 _newCost) public onlyOwner {
        cost = _newCost;
    }

    function setMaxSupply(uint256 _newMaxSupply) public onlyOwner {
        require(_newMaxSupply >= totalSupply, ""New max supply must be greater or equal to current total supply"");
        maxSupply = _newMaxSupply;
    }

    function mint() public payable {
        require(totalSupply < maxSupply, ""Max supply reached"");
        require(msg.value >= cost, ""Insufficient Ether sent"");

        uint256 tokenId = totalSupply + 1;
        _owners[tokenId] = msg.sender;
        totalSupply++;
    }

    function tokenURI(uint256 tokenId) public view returns (string memory) {
        require(_owners[tokenId] != address(0), ""Token does not exist"");
        return string(abi.encodePacked(baseURI, uint2str(tokenId), baseExtension));
    }

    function uint2str(uint256 _i) internal pure returns (string memory str) {
        if (_i == 0) {
            return ""0"";
        }
        uint256 j = _i;
        uint256 length;
        while (j != 0) {
            length++;
            j /= 10;
        }
        bytes memory bstr = new bytes(length);
        uint256 k = length;
        j = _i;
        while (j != 0) {
            bstr[--k] = bytes1(uint8(48 + j % 10));
            j /= 10;
        }
        str = string(bstr);
    }
}",contract_193.sol
"Write a smart contract that allows for token swaps and liquidities. The contract should interact with the IERC20, SwapperInterface, and IUniswapV2Router01 interfaces. Make sure to include functions for swapping, adding and removing liquidity, and getting balances and token information.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface SwapperInterface {
    function swap(address tokenIn, address tokenOut, uint256 amountIn, uint256 amountOutMin, address to) external returns (uint256);
}

interface IUniswapV2Router01 {
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);
}

contract TokenSwapper is SwapperInterface {
    address public uniswapV2Router;

    constructor(address _uniswapV2Router) {
        uniswapV2Router = _uniswapV2Router;
    }

    function swap(address tokenIn, address tokenOut, uint256 amountIn, uint256 amountOutMin, address to) external override returns (uint256) {
        IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn);
        IERC20(tokenIn).approve(uniswapV2Router, amountIn);

        address[] memory path = new address[](2);
        path[0] = tokenIn;
        path[1] = tokenOut;

        uint[] memory amounts = IUniswapV2Router01(uniswapV2Router).swapExactTokensForTokens(
            amountIn,
            amountOutMin,
            path,
            to,
            block.timestamp
        );

        return amounts[amounts.length - 1];
    }

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity) {
        IERC20(tokenA).transferFrom(msg.sender, address(this), amountADesired);
        IERC20(tokenB).transferFrom(msg.sender, address(this), amountBDesired);

        IERC20(tokenA).approve(uniswapV2Router, amountADesired);
        IERC20(tokenB).approve(uniswapV2Router, amountBDesired);

        return IUniswapV2Router01(uniswapV2Router).addLiquidity(
            tokenA,
            tokenB,
            amountADesired,
            amountBDesired,
            amountAMin,
            amountBMin,
            to,
            deadline
        );
    }

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB) {
        IERC20(tokenA).transferFrom(msg.sender, address(this), liquidity);
        IERC20(tokenA).approve(uniswapV2Router, liquidity);

        return IUniswapV2Router01(uniswapV2Router).removeLiquidity(
            tokenA,
            tokenB,
            liquidity,
            amountAMin,
            amountBMin,
            to,
            deadline
        );
    }

    function getBalance(address token, address account) external view returns (uint256) {
        return IERC20(token).balanceOf(account);
    }

    function getTokenInfo(address token) external view returns (uint256 totalSupply, uint256 balance) {
        totalSupply = IERC20(token).totalSupply();
        balance = IERC20(token).balanceOf(msg.sender);
    }
}",contract_194.sol
"Create a basic smart contract for managing digital assets with owner and operator approvals, implementing ERC721 and ERC721Metadata functionality, while allowing for token minting and transferring, with approval and operator approval management.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC721 {
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    function balanceOf(address owner) public view returns (uint256) {
        require(owner != address(0), ""ERC721: balance query for the zero address"");
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) public view returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), ""ERC721: owner query for nonexistent token"");
        return owner;
    }

    function approve(address to, uint256 tokenId) public {
        address owner = ownerOf(tokenId);
        require(to != owner, ""ERC721: approval to current owner"");
        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), ""ERC721: approve caller is not owner nor approved for all"");

        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    function getApproved(uint256 tokenId) public view returns (address) {
        require(_exists(tokenId), ""ERC721: approved query for nonexistent token"");
        return _tokenApprovals[tokenId];
    }

    function setApprovalForAll(address operator, bool approved) public {
        require(operator != msg.sender, ""ERC721: approve to caller"");
        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function isApprovedForAll(address owner, address operator) public view returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function transferFrom(address from, address to, uint256 tokenId) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _transfer(from, to, tokenId);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) public {
        safeTransferFrom(from, to, tokenId, """");
    }

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _safeTransfer(from, to, tokenId, data);
    }

    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return _owners[tokenId] != address(0);
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    function _safeMint(address to, uint256 tokenId) internal {
        _safeMint(to, tokenId, """");
    }

    function _safeMint(address to, uint256 tokenId, bytes memory data) internal {
        _mint(to, tokenId);
        require(_checkOnERC721Received(address(0), to, tokenId, data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _mint(address to, uint256 tokenId) internal {
        require(to != address(0), ""ERC721: mint to the zero address"");
        require(!_exists(tokenId), ""ERC721: token already minted"");

        _beforeTokenTransfer(address(0), to, tokenId);

        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(address(0), to, tokenId);
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        require(ownerOf(tokenId) == from, ""ERC721: transfer of token that is not own"");
        require(to != address(0), ""ERC721: transfer to the zero address"");

        _beforeTokenTransfer(from, to, tokenId);

        _approve(address(0), tokenId);

        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(from, to, tokenId);
    }

    function _approve(address to, uint256 tokenId) internal {
        _tokenApprovals[tokenId] = to;
        emit Approval(ownerOf(tokenId), to, tokenId);
    }

    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private returns (bool) {
        if (to.code.length > 0) {
            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data) returns (bytes4 retval) {
                return retval == IERC721Receiver.onERC721Received.selector;
            } catch (bytes memory reason) {
                if (reason.length == 0) {
                    revert(""ERC721: transfer to non ERC721Receiver implementer"");
                } else {
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        } else {
            return true;
        }
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual {}
}

interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}

contract ERC721Metadata is ERC721 {
    string private _name;
    string private _symbol;
    mapping(uint256 => string) private _tokenURIs;

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function tokenURI(uint256 tokenId) public view returns (string memory) {
        require(_exists(tokenId), ""ERC721Metadata: URI query for nonexistent token"");
        return _tokenURIs[tokenId];
    }

    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal {
        require(_exists(tokenId), ""ERC721Metadata: URI set of nonexistent token"");
        _tokenURIs[tokenId] = _tokenURI;
    }
}

contract DigitalAssetManager is ERC721Metadata {
    constructor() ERC721Metadata(""DigitalAsset"", ""DA"") {}

    function mint(address to, uint256 tokenId, string memory tokenURI) public {
        _safeMint(to, tokenId);
        _setTokenURI(tokenId, tokenURI);
    }
}",contract_195.sol
Design a smart contract that manages fee settings for a decentralized platform. The contract should have two main functions: one to set the fee maker's rate and another to set the fee taker's rate. The fees should be represented as uint values and be bounded by a maximum allowed rate. The contract should provide a clean and structured way to manage these settings. Provide a general overview of the contract's architecture and functionality.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract FeeManager {
    uint public constant MAX_FEE_RATE = 10000; // Maximum fee rate (e.g., 10000 for 100%)
    uint public feeMakerRate;
    uint public feeTakerRate;

    event FeeMakerRateSet(uint newRate);
    event FeeTakerRateSet(uint newRate);

    constructor(uint _feeMakerRate, uint _feeTakerRate) {
        require(_feeMakerRate <= MAX_FEE_RATE, ""Fee rate exceeds maximum allowed"");
        require(_feeTakerRate <= MAX_FEE_RATE, ""Fee rate exceeds maximum allowed"");
        feeMakerRate = _feeMakerRate;
        feeTakerRate = _feeTakerRate;
    }

    function setFeeMakerRate(uint _newRate) external {
        require(_newRate <= MAX_FEE_RATE, ""Fee rate exceeds maximum allowed"");
        feeMakerRate = _newRate;
        emit FeeMakerRateSet(_newRate);
    }

    function setFeeTakerRate(uint _newRate) external {
        require(_newRate <= MAX_FEE_RATE, ""Fee rate exceeds maximum allowed"");
        feeTakerRate = _newRate;
        emit FeeTakerRateSet(_newRate);
    }
}",contract_196.sol
"Create a Solidity smart contract for the '10xAmin Token'. The contract should allow for token transfers, approvals, and minting capabilities. Implement the ERC223 and ERC20 standards. Define the token's name, symbol, and decimal places. Include functionality for owner-only access to certain functions and implement modifiers as necessary.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TenxAminToken {
    string public name = ""10xAmin Token"";
    string public symbol = ""10XA"";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    address public owner;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Mint(address indexed to, uint256 value);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor(uint256 initialSupply) {
        owner = msg.sender;
        mint(owner, initialSupply);
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        _transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= allowance[from][msg.sender], ""Allowance limit exceeded"");
        allowance[from][msg.sender] -= value;
        _transfer(from, to, value);
        return true;
    }

    function mint(address to, uint256 value) public onlyOwner {
        totalSupply += value;
        balanceOf[to] += value;
        emit Mint(to, value);
        emit Transfer(address(0), to, value);
    }

    function _transfer(address from, address to, uint256 value) internal {
        require(to != address(0), ""Invalid recipient address"");
        require(balanceOf[from] >= value, ""Insufficient balance"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        emit Transfer(from, to, value);
    }
}",contract_197.sol
"Create a Solidity smart contract that mimics the Uniswap V2 router functionality. The contract should allow for adding and removing liquidity, swapping tokens, and getting quotes. Implement the most important functions such as addLiquidity and removeLiquidity. Consider the router's interaction with the factory contract, managing the pairs and fee management. Focus on robustness and simplicity, making it easy to understand and maintain. Write a brief description and documentation for each function or variable, making it easy for other developers to use the contract.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract UniswapV2RouterMock {
    address public factory;
    address public WETH;

    modifier ensure(uint deadline) {
        require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');
        _;
    }

    constructor(address _factory, address _WETH) {
        factory = _factory;
        WETH = _WETH;
    }

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {
        // Implementation of addLiquidity logic
        // This is a simplified version for demonstration purposes
        // In a real-world scenario, you would interact with the factory and pair contracts
        // to mint liquidity tokens and transfer them to the `to` address.
        amountA = amountADesired;
        amountB = amountBDesired;
        liquidity = 1000; // Placeholder for actual liquidity calculation
    }

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) public ensure(deadline) returns (uint amountA, uint amountB) {
        // Implementation of removeLiquidity logic
        // This is a simplified version for demonstration purposes
        // In a real-world scenario, you would interact with the factory and pair contracts
        // to burn liquidity tokens and transfer the underlying tokens to the `to` address.
        amountA = 500; // Placeholder for actual amount calculation
        amountB = 500; // Placeholder for actual amount calculation
    }

    // Additional functions like swapExactTokensForTokens, getAmountsOut, etc., can be added similarly
    // These functions would interact with the pair contracts to perform swaps and quote amounts.

    // Helper function to get the pair address from the factory
    function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
        // This is a simplified version for demonstration purposes
        // In a real-world scenario, you would call the factory contract to get the pair address.
        pair = address(0); // Placeholder for actual pair address
    }
}

// Note: This contract is a simplified mock version of Uniswap V2 Router for educational purposes.
// Real-world implementation would require handling more complex logic, including interactions with
// the factory and pair contracts, proper error handling, and security considerations.",contract_198.sol
"Create a smart contract that utilizes the AggregatorV3Interface to retrieve current prices and IERC20 interface for token management. Implement functions for permit, nonce, DOMAIN_SEPARATOR, totalSupply, balanceOf, transfer, allowance, and approve to manage token ownership and transfer. Utilize the SafeERC20 library to ensure secure token transfers. Consider implementing re-entrancy protection and handling potential errors.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface AggregatorV3Interface {
    function latestRoundData() external view returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    );
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

library SafeERC20 {
    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        require(token.transfer(to, value), ""SafeERC20: transfer failed"");
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        require(token.transferFrom(from, to, value), ""SafeERC20: transferFrom failed"");
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        require(token.approve(spender, value), ""SafeERC20: approve failed"");
    }
}

contract TokenContract is IERC20 {
    using SafeERC20 for IERC20;

    string public constant name = ""MyToken"";
    string public constant symbol = ""MTK"";
    uint8 public constant decimals = 18;

    mapping(address => uint256) balances;
    mapping(address => mapping (address => uint256)) allowed;
    uint256 totalSupply_;

    bytes32 public DOMAIN_SEPARATOR;
    // keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");
    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
    mapping(address => uint) public nonces;

    constructor(uint256 total) {
        totalSupply_ = total;
        balances[msg.sender] = totalSupply_;
        uint256 chainId;
        assembly {
            chainId := chainid()
        }
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),
                keccak256(bytes(name)),
                keccak256(bytes('1')),
                chainId,
                address(this)
            )
        );
    }

    function totalSupply() public override view returns (uint256) {
        return totalSupply_;
    }

    function balanceOf(address tokenOwner) public override view returns (uint256 balance) {
        return balances[tokenOwner];
    }

    function transfer(address receiver, uint256 numTokens) public override returns (bool) {
        require(numTokens <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender] - numTokens;
        balances[receiver] = balances[receiver] + numTokens;
        emit Transfer(msg.sender, receiver, numTokens);
        return true;
    }

    function approve(address delegate, uint256 numTokens) public override returns (bool) {
        allowed[msg.sender][delegate] = numTokens;
        emit Approval(msg.sender, delegate, numTokens);
        return true;
    }

    function allowance(address owner, address delegate) public override view returns (uint256) {
        return allowed[owner][delegate];
    }

    function transferFrom(address owner, address buyer, uint256 numTokens) public override returns (bool) {
        require(numTokens <= balances[owner]);
        require(numTokens <= allowed[owner][msg.sender]);

        balances[owner] = balances[owner] - numTokens;
        allowed[owner][msg.sender] = allowed[owner][msg.sender] - numTokens;
        balances[buyer] = balances[buyer] + numTokens;
        emit Transfer(owner, buyer, numTokens);
        return true;
    }

    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {
        require(deadline >= block.timestamp, 'EXPIRED');
        bytes32 digest = keccak256(
            abi.encodePacked(
                '\x19\x01',
                DOMAIN_SEPARATOR,
                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))
            )
        );
        address recoveredAddress = ecrecover(digest, v, r, s);
        require(recoveredAddress != address(0) && recoveredAddress == owner, 'INVALID_SIGNATURE');
        allowed[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    function getLatestPrice(address aggregator) public view returns (int) {
        (
            uint80 roundID, 
            int price,
            uint startedAt,
            uint timeStamp,
            uint80 answeredInRound
        ) = AggregatorV3Interface(aggregator).latestRoundData();
        return price;
    }
}",contract_199.sol
"Create a smart contract that allows for the creation of a KoalaToken. The token should be mintable with a maximum total supply of 400 million tokens. Implement a mint function that allows authorized addresses to mint new tokens to a specified recipient address. Ensure that the contract checks for invalid recipient addresses and excess token minting. For development, utilize the provided ERC20 contract as a base and build upon its functionality.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20 {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply;
        balanceOf[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], ""Insufficient balance"");
        require(_value <= allowance[_from][msg.sender], ""Allowance exceeded"");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }
}

contract KoalaToken is ERC20 {
    address public owner;
    uint256 public constant MAX_SUPPLY = 400000000 * 10**18; // 400 million tokens with 18 decimals

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor() ERC20(""KoalaToken"", ""KOALA"", 18, 0) {
        owner = msg.sender;
    }

    function mint(address _to, uint256 _amount) public onlyOwner {
        require(_to != address(0), ""Invalid address"");
        require(totalSupply + _amount <= MAX_SUPPLY, ""Exceeds maximum supply"");
        totalSupply += _amount;
        balanceOf[_to] += _amount;
        emit Transfer(address(0), _to, _amount);
    }
}",contract_200.sol
"Create a smart contract that mimics the functionality of the provided TriggerOrderManager contract. The contract should have functions for setting the router, triggering positions, canceling trigger orders, and executing trigger orders. Include events for when the router is set or trigger orders are executed. The contract should also have modifiers for restricting access to certain functions. Focus on creating a clean and readable code structure.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TriggerOrderManager {
    address public router;
    address public owner;

    event RouterSet(address indexed router);
    event PositionTriggered(uint256 indexed orderId);
    event TriggerOrderCanceled(uint256 indexed orderId);
    event TriggerOrderExecuted(uint256 indexed orderId);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier onlyRouter() {
        require(msg.sender == router, ""Not the router"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setRouter(address _router) external onlyOwner {
        router = _router;
        emit RouterSet(_router);
    }

    function triggerPosition(uint256 orderId) external onlyRouter {
        // Logic to trigger a position
        emit PositionTriggered(orderId);
    }

    function cancelTriggerOrder(uint256 orderId) external onlyRouter {
        // Logic to cancel a trigger order
        emit TriggerOrderCanceled(orderId);
    }

    function executeTriggerOrder(uint256 orderId) external onlyRouter {
        // Logic to execute a trigger order
        emit TriggerOrderExecuted(orderId);
    }
}",contract_201.sol
"Create a token smart contract that allows the owner to transfer ownership to another address. The contract should include functions to mint and burn tokens. Ensure that the total supply of tokens does not exceed 100 million. Utilize the OpenZeppelin's SafeMath library to prevent arithmetic overflow. Define the token's total supply, balance, and allowance functions using the IERC20 interface. Implement a transfer function that logs the transfer event.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MyToken {
    using SafeMath for uint256;

    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    address public owner;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""New owner is the zero address"");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }

    function mint(address to, uint256 value) public onlyOwner {
        require(totalSupply.add(value) <= 100000000 * (10 ** uint256(decimals)), ""Total supply exceeds 100 million"");
        totalSupply = totalSupply.add(value);
        balanceOf[to] = balanceOf[to].add(value);
        emit Transfer(address(0), to, value);
    }

    function burn(uint256 value) public {
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(value);
        totalSupply = totalSupply.sub(value);
        emit Transfer(msg.sender, address(0), value);
    }

    function transfer(address to, uint256 value) public returns (bool) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(value);
        balanceOf[to] = balanceOf[to].add(value);
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        require(balanceOf[from] >= value, ""Insufficient balance"");
        require(allowance[from][msg.sender] >= value, ""Allowance too low"");
        balanceOf[from] = balanceOf[from].sub(value);
        balanceOf[to] = balanceOf[to].add(value);
        allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);
        emit Transfer(from, to, value);
        return true;
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, ""SafeMath: modulo by zero"");
        return a % b;
    }
}",contract_202.sol
"Create a smart contract in Solidity that implements the ERC-20 token standard for the Voken token, utilizing the SafeMath library for basic arithmetic operations. Ensure the contract includes necessary functions for minting, transferring, and approving token transfers. Don't forget to implement necessary security measures and logging for debugging purposes.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract VokenToken {
    using SafeMath for uint256;

    string public constant name = ""Voken"";
    string public constant symbol = ""VKN"";
    uint8 public constant decimals = 18;

    mapping(address => uint256) balances;
    mapping(address => mapping (address => uint256)) allowed;
    uint256 totalSupply_;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Mint(address indexed to, uint256 amount);

    constructor(uint256 initialSupply) {
        totalSupply_ = initialSupply * 10 ** uint256(decimals);
        balances[msg.sender] = totalSupply_;
        emit Mint(msg.sender, totalSupply_);
    }

    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }

    function balanceOf(address tokenOwner) public view returns (uint256 balance) {
        return balances[tokenOwner];
    }

    function transfer(address to, uint256 tokens) public returns (bool success) {
        require(tokens <= balances[msg.sender], ""Insufficient balance"");
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }

    function approve(address spender, uint256 tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    function transferFrom(address from, address to, uint256 tokens) public returns (bool success) {
        require(tokens <= balances[from], ""Insufficient balance"");
        require(tokens <= allowed[from][msg.sender], ""Allowance exceeded"");
        balances[from] = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(from, to, tokens);
        return true;
    }

    function allowance(address tokenOwner, address spender) public view returns (uint256 remaining) {
        return allowed[tokenOwner][spender];
    }

    function mint(address account, uint256 amount) public {
        require(account != address(0), ""Mint to the zero address"");

        totalSupply_ = totalSupply_.add(amount);
        balances[account] = balances[account].add(amount);
        emit Mint(account, amount);
        emit Transfer(address(0), account, amount);
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }
}",contract_203.sol
"Create a token contract that follows the ERC-20 standard. The contract should allow for token transfer, approval, and allowance management. It should have a total supply limit of 1,000,000 tokens. Implement a constructor function for the contract. Include functions for increase and decrease in allowance, token transfer, approval, transfer from, and burn. Use the ERC20 interface as a reference.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply = 1000000 * 10 ** uint256(decimals);

    mapping(address => uint256) private balances;
    mapping(address => mapping(address => uint256)) private allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        balances[msg.sender] = totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        require(balances[msg.sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        balances[msg.sender] -= amount;
        balances[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return allowances[owner][spender];
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        require(balances[sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        require(allowances[sender][msg.sender] >= amount, ""ERC20: transfer amount exceeds allowance"");
        balances[sender] -= amount;
        balances[recipient] += amount;
        allowances[sender][msg.sender] -= amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        allowances[msg.sender][spender] += addedValue;
        emit Approval(msg.sender, spender, allowances[msg.sender][spender]);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        require(allowances[msg.sender][spender] >= subtractedValue, ""ERC20: decreased allowance below zero"");
        allowances[msg.sender][spender] -= subtractedValue;
        emit Approval(msg.sender, spender, allowances[msg.sender][spender]);
        return true;
    }

    function burn(uint256 amount) public returns (bool) {
        require(balances[msg.sender] >= amount, ""ERC20: burn amount exceeds balance"");
        balances[msg.sender] -= amount;
        totalSupply -= amount;
        emit Transfer(msg.sender, address(0), amount);
        return true;
    }
}",contract_204.sol
"Develop a smart contract that allows users to request and fulfill healing requests, implementing a pending heal system, managing token IDs, and utilizing Chainlink VRF for random number generation. Consider pausing/unpausing the contract and maintaining upgradeability. Ensure smart contract logic is reasonable and efficient.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface VRFCoordinatorV2Interface {
    function requestRandomWords(
        bytes32 keyHash,
        uint64 subId,
        uint16 minimumRequestConfirmations,
        uint32 callbackGasLimit,
        uint32 numWords
    ) external returns (uint256 requestId);
}

contract HealingRequest {
    enum Status { Pending, Fulfilled, Cancelled }

    struct Request {
        address requester;
        uint256 tokenId;
        Status status;
        uint256 randomNumber;
    }

    VRFCoordinatorV2Interface private immutable i_vrfCoordinator;
    bytes32 private immutable i_keyHash;
    uint64 private immutable i_subId;
    uint16 private constant i_minimumRequestConfirmations = 3;
    uint32 private constant i_callbackGasLimit = 100000;
    uint32 private constant i_numWords = 1;

    Request[] public requests;
    address public owner;
    bool public paused;

    event RequestCreated(uint256 requestId, address requester, uint256 tokenId);
    event RequestFulfilled(uint256 requestId, uint256 randomNumber);
    event RequestCancelled(uint256 requestId);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    constructor(address vrfCoordinatorV2, bytes32 keyHash, uint64 subId) {
        i_vrfCoordinator = VRFCoordinatorV2Interface(vrfCoordinatorV2);
        i_keyHash = keyHash;
        i_subId = subId;
        owner = msg.sender;
    }

    function createRequest(uint256 tokenId) external whenNotPaused returns (uint256) {
        uint256 requestId = requests.length;
        requests.push(Request({
            requester: msg.sender,
            tokenId: tokenId,
            status: Status.Pending,
            randomNumber: 0
        }));
        emit RequestCreated(requestId, msg.sender, tokenId);
        return requestId;
    }

    function fulfillRequest(uint256 requestId, uint256 randomNumber) external onlyOwner {
        Request storage request = requests[requestId];
        require(request.status == Status.Pending, ""Request is not pending"");
        request.randomNumber = randomNumber;
        request.status = Status.Fulfilled;
        emit RequestFulfilled(requestId, randomNumber);
    }

    function cancelRequest(uint256 requestId) external {
        Request storage request = requests[requestId];
        require(request.requester == msg.sender || msg.sender == owner, ""Not authorized to cancel"");
        require(request.status == Status.Pending, ""Request is not pending"");
        request.status = Status.Cancelled;
        emit RequestCancelled(requestId);
    }

    function requestRandomNumber(uint256 requestId) external onlyOwner {
        Request storage request = requests[requestId];
        require(request.status == Status.Pending, ""Request is not pending"");
        i_vrfCoordinator.requestRandomWords(
            i_keyHash,
            i_subId,
            i_minimumRequestConfirmations,
            i_callbackGasLimit,
            i_numWords
        );
    }

    function pause() external onlyOwner {
        paused = true;
    }

    function unpause() external onlyOwner {
        paused = false;
    }

    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0), ""New owner is the zero address"");
        owner = newOwner;
    }
}",contract_205.sol
Create a smart contract that utilizes the SafeMath library to perform arithmetic operations with safety checks. Implement a function that checks if an address is a contract or not using the Address library. Include a function that sends Ether to a specified recipient. Ensure the contract includes error handling and documentation explaining the logic behind the contract functions.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SafeMathContract {
    // SafeMath library for safe arithmetic operations
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }

    // Address library to check if an address is a contract
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }

    // Function to send Ether to a specified recipient
    function sendEther(address payable recipient) public payable {
        require(recipient != address(0), ""Invalid address"");
        require(msg.value > 0, ""Amount must be greater than 0"");
        recipient.transfer(msg.value);
    }
}

// Documentation:
// The SafeMathContract includes functions for safe arithmetic operations using the SafeMath library, which prevents overflow and underflow.
// The isContract function checks if an address is a contract by examining its code size.
// The sendEther function allows sending Ether to a specified recipient, ensuring the recipient address is valid and the amount is greater than 0.",contract_206.sol
"Create a token distribution smart contract that uses the provided SafeMath library for arithmetic operations. Include functions for token transfer, balance retrieval, allowance setting, and approval. Initialize the token supply and set the token wallet in the constructor.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TokenDistribution {
    using SafeMath for uint256;

    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    address public owner;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        owner = msg.sender;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(value);
        balanceOf[to] = balanceOf[to].add(value);
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance too low"");
        balanceOf[from] = balanceOf[from].sub(value);
        balanceOf[to] = balanceOf[to].add(value);
        allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);
        emit Transfer(from, to, value);
        return true;
    }
}

library SafeMath {
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}",contract_207.sol
"Create a smart contract that can encode and decode Leb128 integers. The contract should have methods for encoding and decoding unsigned integers with Leb128. The encoding methods should take uint64 values as input and output the encoded byte arrays. The decoding methods should take encoded byte arrays as input and output the decoded uint64 values. Use the Buffer library to implement the Leb128 encoding and decoding logic, ensuring accurate results.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Leb128 {
    function encodeUnsignedLeb128(uint64 value) public pure returns (bytes memory) {
        bytes memory buffer = new bytes(10); // Max 10 bytes for uint64
        uint index = 0;
        do {
            uint8 byteValue = uint8(value & 0x7F);
            value >>= 7;
            if (value != 0) {
                byteValue |= 0x80;
            }
            buffer[index++] = bytes1(byteValue);
        } while (value != 0);

        bytes memory result = new bytes(index);
        for (uint i = 0; i < index; i++) {
            result[i] = buffer[i];
        }
        return result;
    }

    function decodeUnsignedLeb128(bytes memory data) public pure returns (uint64, uint) {
        uint64 result = 0;
        uint shift = 0;
        uint index = 0;

        while (true) {
            uint8 byteValue = uint8(data[index++]);
            result |= uint64(byteValue & 0x7F) << shift;
            if ((byteValue & 0x80) == 0) {
                break;
            }
            shift += 7;
        }

        return (result, index);
    }
}",contract_208.sol
"Develop a smart contract that enables management of item sets with varying rarity. The contract should permit registering and deregistering items, and provide functionality to retrieve item sets based on set ID, rarity, and the list of all sets. Follow the existing code structure and logic, making necessary adjustments to complete the implementation.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ItemSetManager {
    struct Item {
        uint256 id;
        string name;
        string rarity;
    }

    struct ItemSet {
        uint256 id;
        Item[] items;
    }

    uint256 private nextSetId = 1;
    mapping(uint256 => ItemSet) private itemSets;
    mapping(string => ItemSet[]) private raritySets;

    event ItemSetRegistered(uint256 setId);
    event ItemDeregistered(uint256 setId, uint256 itemId);

    function registerItemSet(Item[] memory items) external returns (uint256) {
        uint256 setId = nextSetId++;
        ItemSet storage newSet = itemSets[setId];
        newSet.id = setId;

        for (uint256 i = 0; i < items.length; i++) {
            items[i].id = i + 1;
            newSet.items.push(items[i]);
            raritySets[items[i].rarity].push(newSet);
        }

        emit ItemSetRegistered(setId);
        return setId;
    }

    function deregisterItem(uint256 setId, uint256 itemId) external {
        ItemSet storage set = itemSets[setId];
        require(set.id != 0, ""Set does not exist"");

        for (uint256 i = 0; i < set.items.length; i++) {
            if (set.items[i].id == itemId) {
                string memory rarity = set.items[i].rarity;
                for (uint256 j = 0; j < raritySets[rarity].length; j++) {
                    if (raritySets[rarity][j].id == setId) {
                        raritySets[rarity][j] = raritySets[rarity][raritySets[rarity].length - 1];
                        raritySets[rarity].pop();
                        break;
                    }
                }
                set.items[i] = set.items[set.items.length - 1];
                set.items.pop();
                emit ItemDeregistered(setId, itemId);
                return;
            }
        }

        revert(""Item not found in the set"");
    }

    function getItemSet(uint256 setId) external view returns (Item[] memory) {
        return itemSets[setId].items;
    }

    function getItemSetsByRarity(string memory rarity) external view returns (ItemSet[] memory) {
        return raritySets[rarity];
    }

    function getAllItemSets() external view returns (ItemSet[] memory) {
        ItemSet[] memory sets = new ItemSet[](nextSetId - 1);
        for (uint256 i = 1; i < nextSetId; i++) {
            sets[i - 1] = itemSets[i];
        }
        return sets;
    }
}",contract_209.sol
"Create a smart contract that represents a token, enabling users to transfer tokens, freeze/unfreeze accounts, and manage token supply. The contract should include functions for calculating total supply, checking account balances, and managing allowances. Include modifiers to restrict access to certain functions, such as pausing/unpausing token transfers. Ensure the contract is secure, with error handling for invalid mathematical operations, and includes necessary events for auditing and tracking changes.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    bool public paused = false;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    mapping(address => bool) public frozenAccounts;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Freeze(address indexed target, bool frozen);
    event Pause();
    event Unpause();

    modifier whenNotPaused() {
        require(!paused, ""Pausable: paused"");
        _;
    }

    modifier whenPaused() {
        require(paused, ""Pausable: not paused"");
        _;
    }

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool success) {
        require(_to != address(0), ""Invalid address"");
        require(!frozenAccounts[msg.sender], ""Sender account is frozen"");
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool success) {
        require(_to != address(0), ""Invalid address"");
        require(!frozenAccounts[_from], ""From account is frozen"");
        require(balanceOf[_from] >= _value, ""Insufficient balance"");
        require(allowance[_from][msg.sender] >= _value, ""Allowance too low"");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    function freezeAccount(address target, bool freeze) public {
        frozenAccounts[target] = freeze;
        emit Freeze(target, freeze);
    }

    function pause() public whenNotPaused {
        paused = true;
        emit Pause();
    }

    function unpause() public whenPaused {
        paused = false;
        emit Unpause();
    }
}",contract_210.sol
"Develop a smart contract that allows users to participate in a node-staking system. The contract should manage node settings, user data, and rewards. Include functions for initializing node settings, retrieving general node data, and claiming rewards. Implement basic smart contract features such as modifiers and inheritance. Integrate the contract with external services like UniswapV2Router02.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IUniswapV2Router02 {
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
}

contract NodeStaking {
    struct Node {
        uint256 stakeAmount;
        uint256 rewardRate;
        bool isActive;
    }

    struct User {
        uint256 stakedAmount;
        uint256 lastClaimTimestamp;
    }

    address public owner;
    Node public node;
    mapping(address => User) public users;
    IUniswapV2Router02 public uniswapRouter;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor(address _uniswapRouter) {
        owner = msg.sender;
        uniswapRouter = IUniswapV2Router02(_uniswapRouter);
    }

    function initializeNode(uint256 _stakeAmount, uint256 _rewardRate) external onlyOwner {
        node = Node({
            stakeAmount: _stakeAmount,
            rewardRate: _rewardRate,
            isActive: true
        });
    }

    function stake() external payable {
        require(node.isActive, ""Node is not active"");
        require(msg.value >= node.stakeAmount, ""Insufficient stake amount"");

        User storage user = users[msg.sender];
        user.stakedAmount += msg.value;
        user.lastClaimTimestamp = block.timestamp;
    }

    function claimRewards() external {
        User storage user = users[msg.sender];
        require(user.stakedAmount > 0, ""No stake to claim rewards"");

        uint256 reward = calculateReward(msg.sender);
        require(reward > 0, ""No rewards to claim"");

        user.lastClaimTimestamp = block.timestamp;
        payable(msg.sender).transfer(reward);
    }

    function calculateReward(address _user) public view returns (uint256) {
        User storage user = users[_user];
        if (user.stakedAmount == 0) return 0;

        uint256 timeSinceLastClaim = block.timestamp - user.lastClaimTimestamp;
        return (user.stakedAmount * node.rewardRate * timeSinceLastClaim) / 100;
    }

    function swapRewards(uint amountIn, uint amountOutMin, address[] calldata path, uint deadline) external {
        require(path[0] == address(this), ""Invalid path"");

        uint[] memory amounts = uniswapRouter.swapExactTokensForTokens(
            amountIn,
            amountOutMin,
            path,
            msg.sender,
            deadline
        );

        // Handle the amounts if necessary
    }
}",contract_211.sol
"Create a Solidity smart contract that allows for the creation, transfer, and management of tokens. The contract should include functions for basic token operations such as totalSupply(), balanceOf(), transfer(), and allowance(). The contract should also include a constructor that allows for the initialization of the token's name, symbol, and decimal places. Include a method to mint new tokens and a method to burn existing tokens.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Mint(address indexed to, uint256 value);
    event Burn(address indexed from, uint256 value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _initialSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], ""Insufficient balance"");
        require(_value <= allowance[_from][msg.sender], ""Allowance too low"");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    function mint(address _to, uint256 _value) public returns (bool success) {
        totalSupply += _value;
        balanceOf[_to] += _value;
        emit Mint(_to, _value);
        emit Transfer(address(0), _to, _value);
        return true;
    }

    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        totalSupply -= _value;
        balanceOf[msg.sender] -= _value;
        emit Burn(msg.sender, _value);
        emit Transfer(msg.sender, address(0), _value);
        return true;
    }
}",contract_212.sol
"Develop a smart contract that has two functions: 'f' and 'g'. Function 'f' should accept three parameters: a bytes array, a bytes calldata, and a uint array. It should return six values. Function 'g' should call function 'f' with predefined input. Explain the basic logic and structure of the contract without delving into minute technical details.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MyContract {
    function f(bytes memory param1, bytes calldata param2, uint[] memory param3) public pure returns (uint, uint, uint, uint, uint, uint) {
        // Placeholder logic for demonstration purposes
        uint result1 = param1.length;
        uint result2 = param2.length;
        uint result3 = param3.length;
        uint result4 = 0;
        uint result5 = 0;
        uint result6 = 0;

        // Additional logic can be implemented here

        return (result1, result2, result3, result4, result5, result6);
    }

    function g() public pure returns (uint, uint, uint, uint, uint, uint) {
        bytes memory predefinedBytes = new bytes(1); // Example predefined bytes
        bytes memory predefinedCalldata = ""example""; // Example predefined calldata
        uint[] memory predefinedUintArray = new uint[](2); // Example predefined uint array

        // Call function 'f' with predefined inputs
        return f(predefinedBytes, predefinedCalldata, predefinedUintArray);
    }
}",contract_213.sol
"Create a smart contract that allows for ownership transfer, allowing either direct transfer to a new address or pending transfer followed by a claim by the new owner. Implement inheritance from the Ownable contract, with a constructor that sets the owner to the message sender. Include a function for transferring ownership, using either direct transfer or pending transfer. Ensure that the owner function can only be called by the current owner. Include modifier onlyOwner that checks the sender for the current owner.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;
    address private _pendingOwner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event OwnershipTransferPending(address indexed currentOwner, address indexed pendingOwner);

    modifier onlyOwner() {
        require(msg.sender == _owner, ""Ownable: caller is not the owner"");
        _;
    }

    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    function transferOwnership(address newOwner, bool direct) public onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        if (direct) {
            _transferOwnership(newOwner);
        } else {
            _pendingOwner = newOwner;
            emit OwnershipTransferPending(_owner, newOwner);
        }
    }

    function claimOwnership() public {
        require(msg.sender == _pendingOwner, ""Ownable: caller is not the pending owner"");
        _transferOwnership(msg.sender);
    }

    function _transferOwnership(address newOwner) internal {
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
        _pendingOwner = address(0);
    }
}",contract_214.sol
"Create an ERC1155-compliant token standard that allows for flexible token management. The contract should enable token transfers, balance inquiries, and operator approval management. Implement the necessary functions, such as balanceOf, balanceOfBatch, setApprovalForAll, isApprovedForAll, safeTransferFrom, and safeBatchTransferFrom. Consider using mapping data structures to efficiently manage token balances and operator approvals. Write clear, concise documentation explaining the contract's functionality and technical implementation.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC1155 {
    mapping(address => mapping(uint256 => uint256)) private _balances;
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);
    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);
    event ApprovalForAll(address indexed account, address indexed operator, bool approved);

    function balanceOf(address account, uint256 id) public view returns (uint256) {
        require(account != address(0), ""ERC1155: balance query for the zero address"");
        return _balances[account][id];
    }

    function balanceOfBatch(address[] memory accounts, uint256[] memory ids) public view returns (uint256[] memory) {
        require(accounts.length == ids.length, ""ERC1155: accounts and ids length mismatch"");

        uint256[] memory batchBalances = new uint256[](accounts.length);

        for (uint256 i = 0; i < accounts.length; ++i) {
            batchBalances[i] = balanceOf(accounts[i], ids[i]);
        }

        return batchBalances;
    }

    function setApprovalForAll(address operator, bool approved) public {
        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function isApprovedForAll(address account, address operator) public view returns (bool) {
        return _operatorApprovals[account][operator];
    }

    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes memory data) public {
        require(to != address(0), ""ERC1155: transfer to the zero address"");
        require(from == msg.sender || isApprovedForAll(from, msg.sender), ""ERC1155: caller is not owner nor approved"");

        _balances[from][id] -= amount;
        _balances[to][id] += amount;

        emit TransferSingle(msg.sender, from, to, id, amount);

        _doSafeTransferAcceptanceCheck(msg.sender, from, to, id, amount, data);
    }

    function safeBatchTransferFrom(address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) public {
        require(ids.length == amounts.length, ""ERC1155: ids and amounts length mismatch"");
        require(to != address(0), ""ERC1155: transfer to the zero address"");
        require(from == msg.sender || isApprovedForAll(from, msg.sender), ""ERC1155: transfer caller is not owner nor approved"");

        for (uint256 i = 0; i < ids.length; ++i) {
            uint256 id = ids[i];
            uint256 amount = amounts[i];

            _balances[from][id] -= amount;
            _balances[to][id] += amount;
        }

        emit TransferBatch(msg.sender, from, to, ids, amounts);

        _doSafeBatchTransferAcceptanceCheck(msg.sender, from, to, ids, amounts, data);
    }

    function _doSafeTransferAcceptanceCheck(address operator, address from, address to, uint256 id, uint256 amount, bytes memory data) private {
        if (to.code.length > 0) {
            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {
                if (response != IERC1155Receiver.onERC1155Received.selector) {
                    revert(""ERC1155: ERC1155Receiver rejected tokens"");
                }
            } catch Error(string memory reason) {
                revert(reason);
            } catch {
                revert(""ERC1155: transfer to non ERC1155Receiver implementer"");
            }
        }
    }

    function _doSafeBatchTransferAcceptanceCheck(address operator, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) private {
        if (to.code.length > 0) {
            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {
                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {
                    revert(""ERC1155: ERC1155Receiver rejected tokens"");
                }
            } catch Error(string memory reason) {
                revert(reason);
            } catch {
                revert(""ERC1155: transfer to non ERC1155Receiver implementer"");
            }
        }
    }
}

interface IERC1155Receiver {
    function onERC1155Received(address operator, address from, uint256 id, uint256 value, bytes calldata data) external returns (bytes4);
    function onERC1155BatchReceived(address operator, address from, uint256[] calldata ids, uint256[] calldata values, bytes calldata data) external returns (bytes4);
}",contract_215.sol
"Design a smart contract that complies with the ERC20 standard, focusing on token transfer, approval, and ownership management. Implement a token supply of 1,000,000, with half of the initial distribution going to the owner and the remaining half to a reserve address. Use the SafeMath library for arithmetical operations. Concentrate on creating secure and well-maintained code. Note that this prompt is designed for users with some knowledge of smart contract development and programming languages like Solidity.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    address public owner;
    address public reserve;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(address _reserve) {
        owner = msg.sender;
        reserve = _reserve;
        totalSupply = 1000000 * 10 ** uint256(decimals);
        balanceOf[owner] = totalSupply / 2;
        balanceOf[reserve] = totalSupply / 2;
        emit Transfer(address(0), owner, totalSupply / 2);
        emit Transfer(address(0), reserve, totalSupply / 2);
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        _transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        allowance[from][msg.sender] -= value;
        _transfer(from, to, value);
        return true;
    }

    function _transfer(address from, address to, uint256 value) internal {
        balanceOf[from] -= value;
        balanceOf[to] += value;
        emit Transfer(from, to, value);
    }

    // SafeMath library for arithmetic operations
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, ""SafeMath: modulo by zero"");
        return a % b;
    }
}",contract_216.sol
"Create a smart contract that represents a token, allowing users to transfer tokens between accounts. Implement functions for sending, approving, and burning tokens. Use a constructor to initialize the total token supply and distribute the initial tokens to the contract creator. Consider implementing reentrancy protection and ensuring accurate token balance updates.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Burn(address indexed from, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        _transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        allowance[from][msg.sender] -= value;
        _transfer(from, to, value);
        return true;
    }

    function burn(uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        totalSupply -= value;
        emit Burn(msg.sender, value);
        emit Transfer(msg.sender, address(0), value);
        return true;
    }

    function _transfer(address from, address to, uint256 value) internal {
        require(to != address(0), ""Invalid address"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        emit Transfer(from, to, value);
    }
}",contract_217.sol
"Create a smart contract that implements an ERC-20 token. The contract should have the ability to transfer tokens between addresses, allow for token approvals, and have events for token transfers and approvals. The contract should also have a total supply of 1,156,789,000 tokens and a fixed precision of 18 decimals.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply = 1156789000 * 10**uint256(decimals);

    mapping(address => uint256) private balances;
    mapping(address => mapping(address => uint256)) private allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        balances[msg.sender] = totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        require(balances[msg.sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        balances[msg.sender] -= amount;
        balances[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        require(balances[sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        require(allowances[sender][msg.sender] >= amount, ""ERC20: transfer amount exceeds allowance"");
        balances[sender] -= amount;
        balances[recipient] += amount;
        allowances[sender][msg.sender] -= amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }
}",contract_218.sol
"Create a smart contract that resembles a standard token (ERC20) and has functions for transferring tokens, approving token spending, and getting the token balance. It should also have customizable name, symbol, and supply. Make sure to include logic for token allowance and return values.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    mapping(address => uint256) private balances;
    mapping(address => mapping(address => uint256)) private allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint256 _totalSupply) {
        name = _name;
        symbol = _symbol;
        decimals = 18;
        totalSupply = _totalSupply * 10 ** uint256(decimals);
        balances[msg.sender] = totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        require(balances[msg.sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        balances[msg.sender] -= amount;
        balances[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        require(balances[sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        require(allowances[sender][msg.sender] >= amount, ""ERC20: transfer amount exceeds allowance"");
        balances[sender] -= amount;
        balances[recipient] += amount;
        allowances[sender][msg.sender] -= amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return allowances[owner][spender];
    }
}",contract_219.sol
"Create a Solidity smart contract that allows users to query external APIs using the Oraclize API. The contract should include functions for querying data, managing network connections, and handling gas limits. The contract should support querying data using different timestamps, data sources, and query limits. Make sure to include error handling and customizable gas prices.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract OraclizeAPI {
    address private oraclizeAddress;
    uint256 public queryCount;

    struct Query {
        string dataSource;
        string query;
        uint256 timestamp;
        uint256 gasLimit;
        uint256 gasPrice;
    }

    mapping(uint256 => Query) public queries;

    event QueryCreated(uint256 indexed queryId, string dataSource, string query, uint256 timestamp, uint256 gasLimit, uint256 gasPrice);
    event QueryResult(uint256 indexed queryId, string result);
    event QueryError(uint256 indexed queryId, string error);

    constructor(address _oraclizeAddress) {
        oraclizeAddress = _oraclizeAddress;
        queryCount = 0;
    }

    function createQuery(string memory _dataSource, string memory _query, uint256 _timestamp, uint256 _gasLimit, uint256 _gasPrice) public {
        uint256 queryId = queryCount++;
        queries[queryId] = Query(_dataSource, _query, _timestamp, _gasLimit, _gasPrice);
        emit QueryCreated(queryId, _dataSource, _query, _timestamp, _gasLimit, _gasPrice);
    }

    function executeQuery(uint256 _queryId) public payable {
        Query storage query = queries[_queryId];
        require(query.gasLimit > 0, ""Query does not exist"");
        require(msg.value >= query.gasPrice, ""Insufficient gas price"");

        // Simulate calling Oraclize API
        // This part would normally interact with the Oraclize service
        // For demonstration, we simulate a result or error

        bool success = simulateOraclizeCall(query.dataSource, query.query, query.timestamp, query.gasLimit, query.gasPrice);
        if (success) {
            emit QueryResult(_queryId, ""Simulated result"");
        } else {
            emit QueryError(_queryId, ""Simulated error"");
        }
    }

    function simulateOraclizeCall(string memory _dataSource, string memory _query, uint256 _timestamp, uint256 _gasLimit, uint256 _gasPrice) internal pure returns (bool) {
        // Simulate the logic of calling Oraclize API
        // In a real scenario, this function would interact with the Oraclize service
        // Here, we just return a simulated success or failure

        // For demonstration, we assume the query is always successful
        return true;
    }

    function setOraclizeAddress(address _newOraclizeAddress) public {
        oraclizeAddress = _newOraclizeAddress;
    }

    function getOraclizeAddress() public view returns (address) {
        return oraclizeAddress;
    }
}",contract_220.sol
"Design a smart contract for a custom token that can be minted, transferred, and burned. The contract should allow users to set a name and symbol for the token and implement basic token functionality, such as approval and allowance management. Include event logging for critical operations.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract CustomToken {
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Burn(address indexed from, uint256 value);

    constructor(string memory _name, string memory _symbol, uint256 _initialSupply) {
        name = _name;
        symbol = _symbol;
        mint(msg.sender, _initialSupply);
    }

    function mint(address _to, uint256 _value) internal {
        totalSupply += _value;
        balanceOf[_to] += _value;
        emit Transfer(address(0), _to, _value);
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], ""Insufficient balance"");
        require(_value <= allowance[_from][msg.sender], ""Allowance too low"");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        totalSupply -= _value;
        emit Burn(msg.sender, _value);
        emit Transfer(msg.sender, address(0), _value);
        return true;
    }
}",contract_221.sol
"Create a smart contract that allows for the transfer of tokens between addresses, including the option to approve spending by other contracts. The contract should include functions to set the token name, symbol, and owner, as well as methods for transferring tokens, approving spending, and minting new tokens. Focus on the functional aspects of the contract, ensuring that tokens can be transferred and balances updated correctly.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    string private _name;
    string private _symbol;
    uint256 private _totalSupply;
    address private _owner;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        _owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == _owner, ""Not the contract owner"");
        _;
    }

    function setTokenDetails(string memory name_, string memory symbol_) public onlyOwner {
        _name = name_;
        _symbol = symbol_;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        require(_balances[msg.sender] >= amount, ""Insufficient balance"");
        _balances[msg.sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        require(_balances[sender] >= amount, ""Insufficient balance"");
        require(_allowances[sender][msg.sender] >= amount, ""Allowance too low"");
        _balances[sender] -= amount;
        _balances[recipient] += amount;
        _allowances[sender][msg.sender] -= amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }

    function mint(address account, uint256 amount) public onlyOwner {
        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }
}",contract_222.sol
"Develop a smart contract for a governance system that enables proposals, vote counting, and quorum checking. The contract should include functionality for proposal creation, voting, and state evaluation. Utilize OpenZeppelin's Governor and GovernorSettings modules. Implement basic functions for voting delay, voting period, proposal threshold, quorum calculation, and proposal state evaluation. ","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _transferOwnership(_msgSender());
    }

    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), ""Ownable: caller is not the owner"");
    }

    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

library Counters {
    struct Counter {
        uint256 _value; // default: 0
    }

    function current(Counter storage counter) internal view returns (uint256) {
        return counter._value;
    }

    function increment(Counter storage counter) internal {
        unchecked {
            counter._value += 1;
        }
    }

    function decrement(Counter storage counter) internal {
        uint256 value = counter._value;
        require(value > 0, ""Counter: decrement overflow"");
        unchecked {
            counter._value = value - 1;
        }
    }

    function reset(Counter storage counter) internal {
        counter._value = 0;
    }
}

interface IERC165 {
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

abstract contract ERC165 is IERC165 {
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}

interface IGovernor is IERC165 {
    enum ProposalState {
        Pending,
        Active,
        Canceled,
        Defeated,
        Succeeded,
        Queued,
        Expired,
        Executed
    }

    event ProposalCreated(
        uint256 proposalId,
        address proposer,
        address[] targets,
        uint256[] values,
        string[] signatures,
        bytes[] calldatas,
        uint256 startBlock,
        uint256 endBlock,
        string description
    );

    event VoteCast(address indexed voter, uint256 proposalId, uint8 support, uint256 votes, string reason);

    function name() external view returns (string memory);
    function version() external view returns (string memory);
    function hashProposal(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        bytes32 descriptionHash
    ) external pure returns (uint256);
    function state(uint256 proposalId) external view returns (ProposalState);
    function proposalSnapshot(uint256 proposalId) external view returns (uint256);
    function proposalDeadline(uint256 proposalId) external view returns (uint256);
    function proposalVotes(uint256 proposalId) external view returns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes);
    function quorum(uint256 blockNumber) external view returns (uint256);
    function getVotes(address account, uint256 blockNumber) external view returns (uint256);
    function propose(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        string memory description
    ) external returns (uint256 proposalId);
    function castVote(uint256 proposalId, uint8 support) external returns (uint256 balance);
    function castVoteWithReason(uint256 proposalId, uint8 support, string calldata reason) external returns (uint256 balance);
    function castVoteBySig(uint256 proposalId, uint8 support, uint8 v, bytes32 r, bytes32 s) external returns (uint256 balance);
}

abstract contract Governor is IGovernor, ERC165, Context, Ownable {
    using Counters for Counters.Counter;

    struct ProposalCore {
        uint256 voteStart;
        uint256 voteEnd;
        bool executed;
        bool canceled;
    }

    string private _name;
    string private _version;

    mapping(uint256 => ProposalCore) private _proposals;
    Counters.Counter private _proposalCounter;

    constructor(string memory name_, string memory version_) {
        _name = name_;
        _version = version_;
    }

    function name() public view virtual override returns (string memory) {
        return _name;
    }

    function version() public view virtual override returns (string memory) {
        return _version;
    }

    function hashProposal(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        bytes32 descriptionHash
    ) public pure virtual override returns (uint256) {
        return uint256(keccak256(abi.encode(targets, values, calldatas, descriptionHash)));
    }

    function state(uint256 proposalId) public view virtual override returns (ProposalState) {
        require(_proposals[proposalId].voteStart != 0, ""Governor: unknown proposal id"");

        if (_proposals[proposalId].canceled) {
            return ProposalState.Canceled;
        } else if (block.number <= _proposals[proposalId].voteStart) {
            return ProposalState.Pending;
        } else if (block.number <= _proposals[proposalId].voteEnd) {
            return ProposalState.Active;
        } else if (!_proposals[proposalId].executed) {
            return ProposalState.Succeeded;
        } else {
            return ProposalState.Executed;
        }
    }

    function proposalSnapshot(uint256 proposalId) public view virtual override returns (uint256) {
        return _proposals[proposalId].voteStart;
    }

    function proposalDeadline(uint256 proposalId) public view virtual override returns (uint256) {
        return _proposals[proposalId].voteEnd;
    }

    function propose(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        string memory description
    ) public virtual override returns (uint256) {
        uint256 proposalId = hashProposal(targets, values, calldatas, keccak256(bytes(description)));

        require(_proposals[proposalId].voteStart == 0, ""Governor: proposal already exists"");

        uint256 currentBlock = block.number;
        uint256 startBlock = currentBlock + votingDelay();
        uint256 endBlock = startBlock + votingPeriod();

        _proposals[proposalId] = ProposalCore({
            voteStart: startBlock,
            voteEnd: endBlock,
            executed: false,
            canceled: false
        });

        emit ProposalCreated(
            proposalId,
            _msgSender(),
            targets,
            values,
            new string[](targets.length),
            calldatas,
            startBlock,
            endBlock,
            description
        );

        return proposalId;
    }

    function votingDelay() public view virtual returns (uint256) {
        return 1; // 1 block
    }

    function votingPeriod() public view virtual returns (uint256) {
        return 5; // 5 blocks
    }

    function quorum(uint256 blockNumber) public view virtual override returns (uint256) {
        return 1; // 1 vote
    }

    function getVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {
        return 1; // 1 vote per account
    }

    function castVote(uint256 proposalId, uint8 support) public virtual override returns (uint256) {
        return _castVote(proposalId, _msgSender(), support, """");
    }

    function castVoteWithReason(uint256 proposalId, uint8 support, string calldata reason) public virtual override returns (uint256) {
        return _castVote(proposalId, _msgSender(), support, reason);
    }

    function _castVote(uint256 proposalId, address account, uint8 support, string memory reason) internal virtual returns (uint256) {
        require(state(proposalId) == ProposalState.Active, ""Governor: vote not currently active"");

        uint256 votes = getVotes(account, proposalSnapshot(proposalId));

        emit VoteCast(account, proposalId, support, votes, reason);

        return votes;
    }
}

contract MyGovernor is Governor {
    constructor() Governor(""MyGovernor"", ""1"") {}
}",contract_223.sol
"Create a smart contract that allows for the creation of a basic decentralized asset transfer system. Utilize the Owned contract to manage ownership and provide a way to transfer ownership. Implement a simple halt mechanism to pause or resume the contract's execution. The contract should also use the Proxy mechanism to enable efficient transactions. Include functions for depositing, withdrawing, and transferring assets. Make sure to include logging and monitoring functionality for auditing and tracking purposes.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Owned {
    address public owner;

    event OwnershipTransferred(address indexed _from, address indexed _to);

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    function transferOwnership(address _newOwner) public onlyOwner {
        require(_newOwner != address(0), ""Invalid address"");
        emit OwnershipTransferred(owner, _newOwner);
        owner = _newOwner;
    }
}

contract Proxy {
    address public implementation;

    constructor(address _implementation) {
        implementation = _implementation;
    }

    fallback() external payable {
        address _impl = implementation;
        assembly {
            let ptr := mload(0x40)
            calldatacopy(ptr, 0, calldatasize())
            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)
            let size := returndatasize()
            returndatacopy(ptr, 0, size)

            switch result
            case 0 { revert(ptr, size) }
            default { return(ptr, size) }
        }
    }
}

contract AssetTransfer is Owned {
    bool public halted;
    mapping(address => uint256) public balances;

    event Deposit(address indexed user, uint256 amount);
    event Withdrawal(address indexed user, uint256 amount);
    event Transfer(address indexed from, address indexed to, uint256 amount);

    modifier notHalted {
        require(!halted, ""Contract is halted"");
        _;
    }

    function deposit() public payable notHalted {
        balances[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }

    function withdraw(uint256 amount) public notHalted {
        require(balances[msg.sender] >= amount, ""Insufficient balance"");
        balances[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);
        emit Withdrawal(msg.sender, amount);
    }

    function transfer(address to, uint256 amount) public notHalted {
        require(balances[msg.sender] >= amount, ""Insufficient balance"");
        require(to != address(0), ""Invalid address"");
        balances[msg.sender] -= amount;
        balances[to] += amount;
        emit Transfer(msg.sender, to, amount);
    }

    function setHalt(bool _halted) public onlyOwner {
        halted = _halted;
    }
}

// To deploy, first deploy AssetTransfer, then deploy Proxy with the address of the deployed AssetTransfer contract.",contract_224.sol
"Create a smart contract that enables the transfer of tokens, allowing users to approve and revoke spending limits for other accounts. The contract should support minting and burning tokens. Utilize the SafeMath library for arithmetic operations. Implement event emissions for notable actions.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Burn(address indexed from, uint256 value);
    event Mint(address indexed to, uint256 value);

    using SafeMath for uint256;

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], ""Insufficient balance"");
        require(_value <= allowance[_from][msg.sender], ""Allowance too low"");
        balanceOf[_from] = balanceOf[_from].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }

    function mint(address _to, uint256 _value) public returns (bool success) {
        totalSupply = totalSupply.add(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        emit Mint(_to, _value);
        emit Transfer(address(0), _to, _value);
        return true;
    }

    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        totalSupply = totalSupply.sub(_value);
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        emit Burn(msg.sender, _value);
        emit Transfer(msg.sender, address(0), _value);
        return true;
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, ""SafeMath: modulo by zero"");
        return a % b;
    }
}",contract_225.sol
"Create a smart contract that manages CryptoPuppies, allowing for gene mixing and gaming. Implement functions to mix genes, play games, and manage access control for CEO, CFO, and COO roles. The contract should also include events and logging mechanisms for auditing purposes. Reference the provided code fragment for implementation details, specifically the GeneScience, PuppySports, and PuppyAccessControl contracts.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract CryptoPuppies {
    struct Puppy {
        uint256 genes;
        uint256 birthTime;
    }

    Puppy[] public puppies;

    address public ceoAddress;
    address public cfoAddress;
    address public cooAddress;

    event PuppyCreated(uint256 puppyId, uint256 genes, uint256 birthTime);
    event GenesMixed(uint256 puppyId1, uint256 puppyId2, uint256 newGenes);
    event GamePlayed(uint256 puppyId, uint256 score);

    modifier onlyCEO() {
        require(msg.sender == ceoAddress, ""Only CEO can call this function"");
        _;
    }

    modifier onlyCFO() {
        require(msg.sender == cfoAddress, ""Only CFO can call this function"");
        _;
    }

    modifier onlyCOO() {
        require(msg.sender == cooAddress, ""Only COO can call this function"");
        _;
    }

    constructor(address _ceoAddress, address _cfoAddress, address _cooAddress) {
        ceoAddress = _ceoAddress;
        cfoAddress = _cfoAddress;
        cooAddress = _cooAddress;
    }

    function createPuppy(uint256 _genes) external onlyCOO {
        Puppy memory newPuppy = Puppy({
            genes: _genes,
            birthTime: block.timestamp
        });
        uint256 newPuppyId = puppies.length;
        puppies.push(newPuppy);
        emit PuppyCreated(newPuppyId, _genes, block.timestamp);
    }

    function mixGenes(uint256 _puppyId1, uint256 _puppyId2) external onlyCOO returns (uint256) {
        require(_puppyId1 < puppies.length && _puppyId2 < puppies.length, ""Puppy ID out of range"");
        uint256 newGenes = _mixGenes(puppies[_puppyId1].genes, puppies[_puppyId2].genes);
        emit GenesMixed(_puppyId1, _puppyId2, newGenes);
        return newGenes;
    }

    function playGame(uint256 _puppyId) external onlyCFO returns (uint256) {
        require(_puppyId < puppies.length, ""Puppy ID out of range"");
        uint256 score = _playGame(puppies[_puppyId].genes);
        emit GamePlayed(_puppyId, score);
        return score;
    }

    function _mixGenes(uint256 _genes1, uint256 _genes2) internal pure returns (uint256) {
        return (_genes1 + _genes2) / 2;
    }

    function _playGame(uint256 _genes) internal pure returns (uint256) {
        return _genes % 100; // Simple game logic for demonstration
    }

    function setCEO(address _newCEO) external onlyCEO {
        ceoAddress = _newCEO;
    }

    function setCFO(address _newCFO) external onlyCEO {
        cfoAddress = _newCFO;
    }

    function setCOO(address _newCOO) external onlyCEO {
        cooAddress = _newCOO;
    }
}",contract_226.sol
"Create a smart contract that allows users to transfer and manage an ERC20 token. Include functions for transferring tokens, checking token balances, and approving and checking allowance. The contract should also emit events for token transfers and approvals. Consider implementing safety features to prevent common smart contract vulnerabilities.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private balances;
    mapping(address => mapping(address => uint256)) private allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balances[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        require(balances[msg.sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        balances[msg.sender] -= amount;
        balances[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return allowances[owner][spender];
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        require(balances[sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        require(allowances[sender][msg.sender] >= amount, ""ERC20: transfer amount exceeds allowance"");
        balances[sender] -= amount;
        balances[recipient] += amount;
        allowances[sender][msg.sender] -= amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }
}",contract_227.sol
Create a smart contract that utilizes the Compound Comptroller interface to provide functionality for claiming COMP and retrieving the COMPFee address. The contract should ensure that only valid addresses can initiate the claim process and include basic error handling for potential exceptions. The implementation should follow established best practices for Solidity development and utilize the provided SPDX-License-Identifier: GPL-3.0-or-later.,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity ^0.8.0;

interface IComptroller {
    function claimComp(address holder) external;
    function getCompAddress() external view returns (address);
}

contract CompoundInteraction {
    IComptroller public comptroller;
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor(address _comptroller) {
        comptroller = IComptroller(_comptroller);
        owner = msg.sender;
    }

    function claimComp() external onlyOwner {
        try comptroller.claimComp(owner) {
            // Successfully claimed COMP
        } catch {
            revert(""Claiming COMP failed"");
        }
    }

    function getCompAddress() external view returns (address) {
        return comptroller.getCompAddress();
    }

    function changeComptroller(address _newComptroller) external onlyOwner {
        comptroller = IComptroller(_newComptroller);
    }
}",contract_228.sol
Create a solidity smart contract that allows users to register names in a locked system. The contract should have a boolean variable 'unlocked' that determines whether new name registrations are allowed. The contract should also store name registrations in a mapping structure and allow users to resolve hashes to addresses. Implement a function that allows users to register new names. Make sure the contract is secure and follows best practices.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract NameRegistry {
    bool public unlocked = false;
    mapping(bytes32 => address) public names;
    mapping(address => bytes32) public addresses;

    event NameRegistered(bytes32 indexed name, address indexed registrant);

    modifier onlyUnlocked() {
        require(unlocked, ""Contract is locked"");
        _;
    }

    function registerName(bytes32 name) external onlyUnlocked {
        require(names[name] == address(0), ""Name already registered"");
        require(addresses[msg.sender] == bytes32(0), ""Address already registered a name"");

        names[name] = msg.sender;
        addresses[msg.sender] = name;

        emit NameRegistered(name, msg.sender);
    }

    function resolveAddress(bytes32 name) external view returns (address) {
        return names[name];
    }

    function getName(address addr) external view returns (bytes32) {
        return addresses[addr];
    }

    function setUnlocked(bool _unlocked) external {
        unlocked = _unlocked;
    }
}",contract_229.sol
"Create a smart contract that manages a game with multiple stages, where players can participate and receive rewards. The contract should include functions for initializing game stages, tracking player progress, and distributing rewards. Implement a random number generator to determine game outcomes and ensure fairness. Consider incorporating data structures and algorithms to optimize performance.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GameManager {
    struct Player {
        uint256 progress;
        uint256 rewards;
    }

    struct GameStage {
        uint256 id;
        uint256 rewardPool;
        bool active;
    }

    address public owner;
    uint256 public currentStage;
    mapping(address => Player) public players;
    mapping(uint256 => GameStage) public stages;
    uint256 public stageCount;

    event StageInitialized(uint256 stageId, uint256 rewardPool);
    event PlayerProgressUpdated(address player, uint256 progress);
    event RewardDistributed(address player, uint256 reward);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
        currentStage = 0;
        stageCount = 0;
    }

    function initializeStage(uint256 _rewardPool) external onlyOwner {
        stageCount++;
        stages[stageCount] = GameStage({
            id: stageCount,
            rewardPool: _rewardPool,
            active: true
        });
        currentStage = stageCount;
        emit StageInitialized(stageCount, _rewardPool);
    }

    function participate() external {
        require(stages[currentStage].active, ""Current stage is not active"");
        players[msg.sender].progress = 1;
        emit PlayerProgressUpdated(msg.sender, 1);
    }

    function completeStage() external {
        require(players[msg.sender].progress > 0, ""Player has not participated"");
        uint256 reward = _generateRandomReward();
        players[msg.sender].rewards += reward;
        stages[currentStage].rewardPool -= reward;
        emit RewardDistributed(msg.sender, reward);
    }

    function _generateRandomReward() internal view returns (uint256) {
        uint256 randomNumber = uint256(keccak256(abi.encodePacked(block.difficulty, block.timestamp, msg.sender)));
        return randomNumber % stages[currentStage].rewardPool;
    }

    function withdrawRewards() external {
        uint256 reward = players[msg.sender].rewards;
        require(reward > 0, ""No rewards to withdraw"");
        players[msg.sender].rewards = 0;
        (bool success, ) = msg.sender.call{value: reward}("""");
        require(success, ""Transfer failed"");
    }

    receive() external payable {
        stages[currentStage].rewardPool += msg.value;
    }
}",contract_230.sol
"Create a simple ERC20 token contract with basic functionality, including token transfers, approvals, and balance queries. Include a migration feature to allow tokens to be transferred to a new version of the contract. The contract should allow for token airdrops and support for older contract versions. The code should be easy to understand and follow best practices for Solidity smart contract development.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }

    function airdrop(address[] memory recipients, uint256[] memory amounts) public returns (bool success) {
        require(recipients.length == amounts.length, ""Arrays length mismatch"");
        for (uint256 i = 0; i < recipients.length; i++) {
            require(transfer(recipients[i], amounts[i]), ""Transfer failed"");
        }
        return true;
    }

    function migrate(address newContract, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[newContract] += value;
        emit Transfer(msg.sender, newContract, value);
        return true;
    }
}",contract_231.sol
"Create a smart contract that enables the creation and trading of unique tokens. The contract should allow users to mint tokens, set prices, and manage token metadata. Consider incorporating features like token attributes, royalty payments, and dynamic presale and sale activation. Pay close attention to token supply management, fund allocation, and staking mechanics. Ensure the contract handles arithmetic operations securely by utilizing SafeMath.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract UniqueTokens {
    using SafeMath for uint256;

    struct Token {
        uint256 id;
        address creator;
        string metadata;
        uint256 price;
        bool isForSale;
        uint256 royaltyPercentage;
    }

    uint256 public tokenCounter;
    mapping(uint256 => Token) public tokens;
    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256) public ownerTokenCount;

    event TokenMinted(uint256 indexed tokenId, address indexed creator, string metadata);
    event TokenPriceSet(uint256 indexed tokenId, uint256 price);
    event TokenSold(uint256 indexed tokenId, address indexed buyer, uint256 price);

    modifier onlyTokenOwner(uint256 _tokenId) {
        require(tokenOwner[_tokenId] == msg.sender, ""Not the owner of the token"");
        _;
    }

    function mintToken(string memory _metadata, uint256 _royaltyPercentage) public {
        tokenCounter = tokenCounter.add(1);
        uint256 newTokenId = tokenCounter;
        Token memory newToken = Token({
            id: newTokenId,
            creator: msg.sender,
            metadata: _metadata,
            price: 0,
            isForSale: false,
            royaltyPercentage: _royaltyPercentage
        });
        tokens[newTokenId] = newToken;
        tokenOwner[newTokenId] = msg.sender;
        ownerTokenCount[msg.sender] = ownerTokenCount[msg.sender].add(1);
        emit TokenMinted(newTokenId, msg.sender, _metadata);
    }

    function setTokenPrice(uint256 _tokenId, uint256 _price) public onlyTokenOwner(_tokenId) {
        tokens[_tokenId].price = _price;
        tokens[_tokenId].isForSale = true;
        emit TokenPriceSet(_tokenId, _price);
    }

    function buyToken(uint256 _tokenId) public payable {
        Token storage token = tokens[_tokenId];
        require(token.isForSale, ""Token is not for sale"");
        require(msg.value >= token.price, ""Insufficient payment"");

        address previousOwner = tokenOwner[_tokenId];
        uint256 royaltyAmount = msg.value.mul(token.royaltyPercentage).div(100);
        uint256 sellerAmount = msg.value.sub(royaltyAmount);

        payable(token.creator).transfer(royaltyAmount);
        payable(previousOwner).transfer(sellerAmount);

        tokenOwner[_tokenId] = msg.sender;
        ownerTokenCount[previousOwner] = ownerTokenCount[previousOwner].sub(1);
        ownerTokenCount[msg.sender] = ownerTokenCount[msg.sender].add(1);

        token.isForSale = false;
        emit TokenSold(_tokenId, msg.sender, msg.value);
    }

    function SafeMath() internal pure returns (uint256) {
        function add(uint256 a, uint256 b) internal pure returns (uint256) {
            uint256 c = a + b;
            require(c >= a, ""SafeMath: addition overflow"");
            return c;
        }

        function sub(uint256 a, uint256 b) internal pure returns (uint256) {
            require(b <= a, ""SafeMath: subtraction overflow"");
            uint256 c = a - b;
            return c;
        }

        function mul(uint256 a, uint256 b) internal pure returns (uint256) {
            if (a == 0) {
                return 0;
            }
            uint256 c = a * b;
            require(c / a == b, ""SafeMath: multiplication overflow"");
            return c;
        }

        function div(uint256 a, uint256 b) internal pure returns (uint256) {
            require(b > 0, ""SafeMath: division by zero"");
            uint256 c = a / b;
            return c;
        }
    }
}",contract_232.sol
"Create a Tron-based smart contract that manages user referrals and allows users to deposit and withdraw funds. The contract should include functions for setting up user referral networks, tracking user deposits and withdrawals, and managing the contract balance. The contract should also include event handling for tracking user activities.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TronReferral {
    address public owner;
    mapping(address => address) public referrals;
    mapping(address => uint256) public balances;
    mapping(address => uint256) public referralEarnings;

    event Deposit(address indexed user, uint256 amount);
    event Withdrawal(address indexed user, uint256 amount);
    event ReferralSet(address indexed user, address indexed referral);
    event ReferralEarned(address indexed user, uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setReferral(address _referral) external {
        require(referrals[msg.sender] == address(0), ""Referral already set"");
        require(_referral != msg.sender, ""Cannot refer yourself"");
        referrals[msg.sender] = _referral;
        emit ReferralSet(msg.sender, _referral);
    }

    function deposit() external payable {
        require(msg.value > 0, ""Deposit amount must be greater than 0"");
        balances[msg.sender] += msg.value;
        if (referrals[msg.sender] != address(0)) {
            uint256 referralBonus = msg.value / 10; // 10% bonus
            referralEarnings[referrals[msg.sender]] += referralBonus;
            emit ReferralEarned(referrals[msg.sender], referralBonus);
        }
        emit Deposit(msg.sender, msg.value);
    }

    function withdraw(uint256 amount) external {
        require(amount > 0, ""Withdrawal amount must be greater than 0"");
        require(balances[msg.sender] >= amount, ""Insufficient balance"");
        balances[msg.sender] -= amount;
        (bool success, ) = msg.sender.call{value: amount}("""");
        require(success, ""Transfer failed"");
        emit Withdrawal(msg.sender, amount);
    }

    function withdrawReferralEarnings() external {
        uint256 earnings = referralEarnings[msg.sender];
        require(earnings > 0, ""No referral earnings to withdraw"");
        referralEarnings[msg.sender] = 0;
        (bool success, ) = msg.sender.call{value: earnings}("""");
        require(success, ""Transfer failed"");
        emit Withdrawal(msg.sender, earnings);
    }

    function getContractBalance() external view returns (uint256) {
        return address(this).balance;
    }

    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0), ""New owner is the zero address"");
        owner = newOwner;
    }
}",contract_233.sol
"Create a smart contract for the E4Token that allows for token transactions, including minting, transferring, and approving tokens. The contract should include a mapping to track token balances and allow holders to withdraw dividends. Implement functions for token transfers, approvals, and allowance tracking. Ensure the contract includes events for token transfers and approvals. Consider implementing modifiers and functions to govern token minting and burning. Develop a comprehensive and understandable smart contract that implements the E4Token functionality.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract E4Token {
    string public name = ""E4Token"";
    string public symbol = ""E4T"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    mapping(address => uint256) public dividends;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Mint(address indexed to, uint256 value);
    event Burn(address indexed from, uint256 value);
    event DividendWithdrawn(address indexed to, uint256 value);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    address public owner;

    constructor() {
        owner = msg.sender;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], ""Insufficient balance"");
        require(_value <= allowance[_from][msg.sender], ""Allowance too low"");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    function mint(address _to, uint256 _value) public onlyOwner returns (bool success) {
        totalSupply += _value;
        balanceOf[_to] += _value;
        emit Mint(_to, _value);
        emit Transfer(address(0), _to, _value);
        return true;
    }

    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        totalSupply -= _value;
        balanceOf[msg.sender] -= _value;
        emit Burn(msg.sender, _value);
        emit Transfer(msg.sender, address(0), _value);
        return true;
    }

    function withdrawDividend(uint256 _value) public returns (bool success) {
        require(dividends[msg.sender] >= _value, ""Insufficient dividends"");
        dividends[msg.sender] -= _value;
        (bool sent, ) = msg.sender.call{value: _value}("""");
        require(sent, ""Failed to send Ether"");
        emit DividendWithdrawn(msg.sender, _value);
        return true;
    }

    receive() external payable {
        dividends[msg.sender] += msg.value;
    }
}",contract_234.sol
"Design a smart contract that prevents delegate calls. The contract should have two key functions: observe and updateTickCum. Observe will allow for reading tick cumulative values and seconds per liquidity cumulative values, while updateTickCum will update these values. The contract should also have a constructor to initialize the contract owner, and include modifiers to restrict the owner's updates.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract PreventDelegateCall {
    address public owner;
    uint256 public tickCumulative;
    uint256 public secondsPerLiquidityCumulative;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function observe() public view returns (uint256, uint256) {
        return (tickCumulative, secondsPerLiquidityCumulative);
    }

    function updateTickCum(uint256 newTickCumulative, uint256 newSecondsPerLiquidityCumulative) public onlyOwner {
        tickCumulative = newTickCumulative;
        secondsPerLiquidityCumulative = newSecondsPerLiquidityCumulative;
    }

    fallback() external {
        revert(""Delegate call not allowed"");
    }

    receive() external payable {
        revert(""Delegate call not allowed"");
    }
}",contract_235.sol
"Create a smart contract that builds upon AccessControlUpgradeable, implementing a custom role, 'Admin', with defined functions for role management, including granting, revoking, and renouncing. Ensure proper access control using inherited functions and modifiers. Concentrate on the overall functionality and interaction with users.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract AccessControlUpgradeable {
    mapping(bytes32 => mapping(address => bool)) private _roles;

    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    modifier onlyRole(bytes32 role) {
        require(hasRole(role, msg.sender), ""AccessControl: sender must be an admin"");
        _;
    }

    function hasRole(bytes32 role, address account) public view returns (bool) {
        return _roles[role][account];
    }

    function _grantRole(bytes32 role, address account) internal {
        if (!hasRole(role, account)) {
            _roles[role][account] = true;
            emit RoleGranted(role, account, msg.sender);
        }
    }

    function _revokeRole(bytes32 role, address account) internal {
        if (hasRole(role, account)) {
            _roles[role][account] = false;
            emit RoleRevoked(role, account, msg.sender);
        }
    }
}

contract AdminRoleContract is AccessControlUpgradeable {
    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");

    function grantAdminRole(address account) public onlyRole(ADMIN_ROLE) {
        _grantRole(ADMIN_ROLE, account);
    }

    function revokeAdminRole(address account) public onlyRole(ADMIN_ROLE) {
        _revokeRole(ADMIN_ROLE, account);
    }

    function renounceAdminRole() public {
        _revokeRole(ADMIN_ROLE, msg.sender);
    }

    function initialize() public {
        _grantRole(ADMIN_ROLE, msg.sender);
    }
}",contract_236.sol
"Create a Solidity smart contract that manages a banana-based NFT system, featuring whitelist sales and public mints. The contract should include mechanisms for NFT ownership tracking, minting limits, and SuperBanana address management. Ensure that only the owner can pause and resume sales and withdraw funds. Implement functions for checking claimed bananas and burning NFTs","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract BananaNFT {
    address public owner;
    bool public salesPaused;
    uint256 public totalSupply;
    uint256 public maxSupply;
    uint256 public whitelistMintLimit;
    uint256 public publicMintLimit;
    mapping(address => bool) public whitelist;
    mapping(address => uint256) public mintedCount;
    mapping(uint256 => address) public nftOwners;
    address public superBananaAddress;

    event NFTMinted(address indexed owner, uint256 tokenId);
    event NFTRedeemed(address indexed owner, uint256 tokenId);
    event SalesPaused();
    event SalesResumed();
    event FundsWithdrawn(uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier whenSalesNotPaused() {
        require(!salesPaused, ""Sales are paused"");
        _;
    }

    constructor(uint256 _maxSupply, uint256 _whitelistMintLimit, uint256 _publicMintLimit) {
        owner = msg.sender;
        maxSupply = _maxSupply;
        whitelistMintLimit = _whitelistMintLimit;
        publicMintLimit = _publicMintLimit;
        salesPaused = false;
    }

    function addToWhitelist(address[] memory _addresses) external onlyOwner {
        for (uint256 i = 0; i < _addresses.length; i++) {
            whitelist[_addresses[i]] = true;
        }
    }

    function removeFromWhitelist(address[] memory _addresses) external onlyOwner {
        for (uint256 i = 0; i < _addresses.length; i++) {
            whitelist[_addresses[i]] = false;
        }
    }

    function mintNFT(uint256 _quantity) external payable whenSalesNotPaused {
        require(totalSupply + _quantity <= maxSupply, ""Exceeds max supply"");
        if (whitelist[msg.sender]) {
            require(mintedCount[msg.sender] + _quantity <= whitelistMintLimit, ""Whitelist mint limit exceeded"");
        } else {
            require(mintedCount[msg.sender] + _quantity <= publicMintLimit, ""Public mint limit exceeded"");
        }

        for (uint256 i = 0; i < _quantity; i++) {
            uint256 tokenId = totalSupply + 1;
            nftOwners[tokenId] = msg.sender;
            emit NFTMinted(msg.sender, tokenId);
            totalSupply++;
        }
        mintedCount[msg.sender] += _quantity;
    }

    function redeemNFT(uint256 _tokenId) external {
        require(nftOwners[_tokenId] == msg.sender, ""Not the owner of the NFT"");
        delete nftOwners[_tokenId];
        emit NFTRedeemed(msg.sender, _tokenId);
    }

    function pauseSales() external onlyOwner {
        salesPaused = true;
        emit SalesPaused();
    }

    function resumeSales() external onlyOwner {
        salesPaused = false;
        emit SalesResumed();
    }

    function withdrawFunds() external onlyOwner {
        uint256 balance = address(this).balance;
        payable(owner).transfer(balance);
        emit FundsWithdrawn(balance);
    }

    function setSuperBananaAddress(address _newAddress) external onlyOwner {
        superBananaAddress = _newAddress;
    }

    function checkClaimedBananas(address _user) external view returns (uint256) {
        return mintedCount[_user];
    }

    function burnNFT(uint256 _tokenId) external {
        require(nftOwners[_tokenId] == msg.sender || msg.sender == superBananaAddress, ""Not authorized to burn"");
        delete nftOwners[_tokenId];
        emit NFTRedeemed(msg.sender, _tokenId);
    }
}",contract_237.sol
"Develop a Solidity smart contract that includes two functions: uintToHex and uintToEther. uintToHex should convert a uint256 input into a hexadecimal string with leading zeros if necessary. uintToEther should convert a uint256 input into a human-readable string with appropriate units ('MIC') and formatting. Consider the value range and provide specific guidelines for values less than, equal to, and greater than 0.001 MIC.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Converter {
    function uintToHex(uint256 value) public pure returns (string memory) {
        bytes memory buffer = new bytes(64); // Enough to hold 256 bits in hexadecimal
        for (uint256 i = 0; i < 64; i++) {
            uint8 nibble = uint8(value >> ((63 - i) * 4)) & 0xF;
            if (nibble < 10) {
                buffer[i] = bytes1(uint8(nibble + 48)); // 0-9
            } else {
                buffer[i] = bytes1(uint8(nibble + 87)); // a-f
            }
        }
        return string(buffer);
    }

    function uintToEther(uint256 value) public pure returns (string memory) {
        if (value == 0) {
            return ""0 MIC"";
        }
        if (value < 1e15) { // Less than 0.001 MIC (1e15 wei)
            return ""< 0.001 MIC"";
        }
        if (value == 1e15) { // Exactly 0.001 MIC
            return ""0.001 MIC"";
        }
        if (value > 1e15) { // Greater than 0.001 MIC
            uint256 wholePart = value / 1e18;
            uint256 fractionalPart = value % 1e18;
            string memory result = string(abi.encodePacked(uint2str(wholePart), "".""));
            // Convert fractional part to string with leading zeros if necessary
            bytes memory fractionalBytes = bytes(uint2str(fractionalPart));
            uint256 leadingZeros = 18 - fractionalBytes.length;
            for (uint256 i = 0; i < leadingZeros; i++) {
                result = string(abi.encodePacked(result, ""0""));
            }
            result = string(abi.encodePacked(result, fractionalBytes, "" MIC""));
            return result;
        }
        return """"; // Fallback, should never reach here
    }

    function uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {
        if (_i == 0) {
            return ""0"";
        }
        uint256 j = _i;
        uint256 len;
        while (j != 0) {
            len++;
            j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint256 k = len;
        while (_i != 0) {
            k = k - 1;
            uint8 temp = (48 + uint8(_i - _i / 10 * 10));
            bytes1 b1 = bytes1(temp);
            bstr[k] = b1;
            _i /= 10;
        }
        return string(bstr);
    }
}",contract_238.sol
"Create a Solidity smart contract that allows for governance and treasury management in the Nouns DAO, including logic for proposing, voting, and executing proposals, as well as managing the treasury and random number generation.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract NounsDAO {
    address public owner;
    uint256 public proposalCount;
    mapping(uint256 => Proposal) public proposals;
    mapping(address => uint256) public balances;
    mapping(address => mapping(uint256 => bool)) public votes;
    uint256 public totalSupply;

    struct Proposal {
        uint256 id;
        string description;
        uint256 amount;
        address recipient;
        uint256 voteCount;
        bool executed;
        mapping(address => bool) voted;
    }

    event ProposalCreated(uint256 id, string description, uint256 amount, address recipient);
    event VoteCast(uint256 proposalId, address voter);
    event ProposalExecuted(uint256 id);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function createProposal(string memory description, uint256 amount, address recipient) public onlyOwner {
        proposalCount++;
        Proposal storage p = proposals[proposalCount];
        p.id = proposalCount;
        p.description = description;
        p.amount = amount;
        p.recipient = recipient;
        p.executed = false;
        emit ProposalCreated(proposalCount, description, amount, recipient);
    }

    function vote(uint256 proposalId) public {
        require(balances[msg.sender] > 0, ""No tokens to vote"");
        Proposal storage p = proposals[proposalId];
        require(!p.voted[msg.sender], ""Already voted"");
        p.voted[msg.sender] = true;
        p.voteCount += balances[msg.sender];
        emit VoteCast(proposalId, msg.sender);
    }

    function executeProposal(uint256 proposalId) public onlyOwner {
        Proposal storage p = proposals[proposalId];
        require(!p.executed, ""Proposal already executed"");
        require(p.voteCount > totalSupply / 2, ""Not enough votes"");
        p.executed = true;
        (bool success, ) = p.recipient.call{value: p.amount}("""");
        require(success, ""Transfer failed"");
        emit ProposalExecuted(proposalId);
    }

    function mint(address to, uint256 amount) public onlyOwner {
        balances[to] += amount;
        totalSupply += amount;
    }

    function getRandomNumber() public view returns (uint256) {
        return uint256(keccak256(abi.encodePacked(block.difficulty, block.timestamp)));
    }

    receive() external payable {
        // Accept ETH for treasury
    }
}",contract_239.sol
"Design a smart contract that allows for permission-based access control and integrates with an EntryPoint. The contract should have functions for initializing the contract, setting operator permissions, and validating user operations. Include data structures for storing operator permissions, remaining fees, and remaining values. Consider implementing EIP712 and ECDSA signature verification. The contract should be compatible with OpenZeppelin contracts and EIP712 specifications.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract PermissionedEntryPoint {
    address public owner;
    mapping(address => bool) public operators;
    mapping(bytes32 => bool) public usedHashes;
    uint256 public remainingFees;
    uint256 public remainingValue;

    struct UserOperation {
        address sender;
        uint256 nonce;
        bytes initCode;
        bytes callData;
        uint256 callGasLimit;
        uint256 verificationGasLimit;
        uint256 preVerificationGas;
        uint256 maxFeePerGas;
        uint256 maxPriorityFeePerGas;
        address paymaster;
        bytes paymasterData;
        bytes signature;
    }

    event OperatorPermissionSet(address indexed operator, bool permission);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier onlyOperator() {
        require(operators[msg.sender], ""Not an operator"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function initialize(address _owner) external {
        require(owner == address(0), ""Already initialized"");
        owner = _owner;
    }

    function setOperatorPermission(address operator, bool permission) external onlyOwner {
        operators[operator] = permission;
        emit OperatorPermissionSet(operator, permission);
    }

    function validateUserOperation(UserOperation calldata userOp, bytes32 requestId, uint256 missingAccountFunds) external onlyOperator {
        require(!usedHashes[requestId], ""User operation already used"");
        usedHashes[requestId] = true;

        bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(
            keccak256(""UserOperation(address sender,uint256 nonce,bytes initCode,bytes callData,uint256 callGasLimit,uint256 verificationGasLimit,uint256 preVerificationGas,uint256 maxFeePerGas,uint256 maxPriorityFeePerGas,address paymaster,bytes paymasterData)""),
            userOp.sender,
            userOp.nonce,
            keccak256(userOp.initCode),
            keccak256(userOp.callData),
            userOp.callGasLimit,
            userOp.verificationGasLimit,
            userOp.preVerificationGas,
            userOp.maxFeePerGas,
            userOp.maxPriorityFeePerGas,
            userOp.paymaster,
            keccak256(userOp.paymasterData)
        )));

        address recoveredAddress = ECDSA.recover(digest, userOp.signature);
        require(recoveredAddress == userOp.sender, ""Invalid signature"");

        if (missingAccountFunds > 0) {
            remainingFees += missingAccountFunds;
            remainingValue += missingAccountFunds;
        }
    }

    function _hashTypedDataV4(bytes32 structHash) internal view returns (bytes32) {
        return ECDSA.toTypedDataHash(domainSeparator(), structHash);
    }

    function domainSeparator() public view returns (bytes32) {
        return keccak256(abi.encode(
            keccak256(""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""),
            keccak256(bytes(""PermissionedEntryPoint"")),
            keccak256(bytes(""1"")),
            block.chainid,
            address(this)
        ));
    }
}

library ECDSA {
    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
        if (signature.length != 65) {
            revert(""ECDSA: invalid signature length"");
        }

        bytes32 r;
        bytes32 s;
        uint8 v;

        assembly {
            r := mload(add(signature, 0x20))
            s := mload(add(signature, 0x40))
            v := byte(0, mload(add(signature, 0x60)))
        }

        if (v < 27) {
            v += 27;
        }

        if (v != 27 && v != 28) {
            revert(""ECDSA: invalid signature 'v' value"");
        }

        return ecrecover(hash, v, r, s);
    }

    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(""\x19\x01"", domainSeparator, structHash));
    }
}",contract_240.sol
"Create a new smart contract that implements the IAnyswapV3ERC20 interface, allowing for token transfers, approvals, and permits. Focus on the functional requirements, ensuring the contract provides accurate token balances, allows for token transfers with optional data, and adheres to the ERC-20 standard. Consider the use of libraries, such as SafeERC20, to simplify common operations. Provide a high-level overview of the contract's variables, functions, and logic.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IAnyswapV3ERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract AnyswapV3ERC20 is IAnyswapV3ERC20 {
    string public constant name = ""AnyswapV3ERC20"";
    string public constant symbol = ""ANY"";
    uint8 public constant decimals = 18;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    uint256 private _totalSupply;

    bytes32 public DOMAIN_SEPARATOR;
    // keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");
    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
    mapping(address => uint256) public nonces;

    constructor() {
        uint256 chainId;
        assembly {
            chainId := chainid()
        }
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),
                keccak256(bytes(name)),
                keccak256(bytes('1')),
                chainId,
                address(this)
            )
        );
    }

    function totalSupply() external view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) external view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) external override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) external view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) external override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external override {
        require(deadline >= block.timestamp, ""AnyswapV3ERC20: EXPIRED"");
        bytes32 digest = keccak256(
            abi.encodePacked(
                '\x19\x01',
                DOMAIN_SEPARATOR,
                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))
            )
        );
        address recoveredAddress = ecrecover(digest, v, r, s);
        require(recoveredAddress != address(0) && recoveredAddress == owner, ""AnyswapV3ERC20: INVALID_SIGNATURE"");
        _approve(owner, spender, value);
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""AnyswapV3ERC20: transfer from the zero address"");
        require(recipient != address(0), ""AnyswapV3ERC20: transfer to the zero address"");

        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""AnyswapV3ERC20: approve from the zero address"");
        require(spender != address(0), ""AnyswapV3ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _mint(address account, uint256 amount) internal {
        require(account != address(0), ""AnyswapV3ERC20: mint to the zero address"");

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) internal {
        require(account != address(0), ""AnyswapV3ERC20: burn from the zero address"");

        _balances[account] -= amount;
        _totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }
}",contract_241.sol
"Create a smart contract that implements the IERC1822Proxiable interface. Use the Address library to interact with other contracts and the StorageSlot library to store and retrieve data. Design a data structure or mapping to manage data. Focus on functionality and simplicity, while ensuring gas efficiency and code organization.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC1822Proxiable {
    function proxiableUUID() external view returns (bytes32);
    function updateCodeAddress(address newAddress) external;
}

library Address {
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }
}

library StorageSlot {
    struct AddressSlot {
        address value;
    }

    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {
        assembly {
            r.slot := slot
        }
    }
}

contract MyContract is IERC1822Proxiable {
    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

    function proxiableUUID() external pure override returns (bytes32) {
        return _IMPLEMENTATION_SLOT;
    }

    function updateCodeAddress(address newAddress) external override {
        require(Address.isContract(newAddress), ""New address is not a contract"");
        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newAddress;
    }

    function _delegate(address implementation) internal virtual {
        assembly {
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())
            switch result
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
        }
    }

    fallback() external payable {
        _delegate(StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value);
    }

    receive() external payable {
        _delegate(StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value);
    }
}",contract_242.sol
"Write a smart contract that adheres to the IBEP20 standard. The contract should have a total supply of 100 trillion and the owner being the address that deploys the contract. Include functions to get the owner, decimals, symbol, and name of the token. Implement functionality for users to transfer tokens and approve or transfer tokens on behalf of others. Make sure to emit events when necessary.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract IBEP20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;
    uint256 private _totalSupply;
    address private _owner;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory name_, string memory symbol_, uint8 decimals_) {
        _name = name_;
        _symbol = symbol_;
        _decimals = decimals_;
        _totalSupply = 100000000000000 * 10**uint256(decimals_);
        _balances[msg.sender] = _totalSupply;
        _owner = msg.sender;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""IBEP20: transfer from the zero address"");
        require(recipient != address(0), ""IBEP20: transfer to the zero address"");
        require(_balances[sender] >= amount, ""IBEP20: transfer amount exceeds balance"");

        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""IBEP20: approve from the zero address"");
        require(spender != address(0), ""IBEP20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function getOwner() public view returns (address) {
        return _owner;
    }
}",contract_243.sol
"Create a Solidity smart contract that implements the ERC20 standard. The contract should allow token transfers, approve and track allowances for token transfers, mint and burn tokens, and retrieve token balances and allowances. The contract should also keep track of the token's name, symbol, and decimals. Structure the contract in a logical and readable manner.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20 {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    mapping(address => uint256) private balances;
    mapping(address => mapping(address => uint256)) private allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _initialSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _initialSupply * 10 ** uint256(decimals);
        balances[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        require(balances[msg.sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        balances[msg.sender] -= amount;
        balances[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        require(balances[sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        require(allowances[sender][msg.sender] >= amount, ""ERC20: transfer amount exceeds allowance"");
        balances[sender] -= amount;
        balances[recipient] += amount;
        allowances[sender][msg.sender] -= amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }

    function mint(address account, uint256 amount) public {
        require(account != address(0), ""ERC20: mint to the zero address"");
        totalSupply += amount;
        balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function burn(address account, uint256 amount) public {
        require(account != address(0), ""ERC20: burn from the zero address"");
        require(balances[account] >= amount, ""ERC20: burn amount exceeds balance"");
        totalSupply -= amount;
        balances[account] -= amount;
        emit Transfer(account, address(0), amount);
    }
}",contract_244.sol
"Create a simple smart contract that allows for ownership transfer, renunciation, and basic arithmetic operations. Use the SafeMath library for precision and implement ownership transfer and renunciation functions. Ensure the contract includes a modifier for the owner and provides basic functionality for setting and retrieving the owner's address.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    modifier onlyOwner() {
        require(isOwner(), ""Ownable: caller is not the owner"");
        _;
    }

    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    function owner() public view returns (address) {
        return _owner;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, ""SafeMath: modulo by zero"");
        return a % b;
    }
}

contract SimpleContract is Ownable {
    using SafeMath for uint256;

    function add(uint256 a, uint256 b) public pure returns (uint256) {
        return a.add(b);
    }

    function sub(uint256 a, uint256 b) public pure returns (uint256) {
        return a.sub(b);
    }

    function mul(uint256 a, uint256 b) public pure returns (uint256) {
        return a.mul(b);
    }

    function div(uint256 a, uint256 b) public pure returns (uint256) {
        return a.div(b);
    }

    function mod(uint256 a, uint256 b) public pure returns (uint256) {
        return a.mod(b);
    }
}",contract_245.sol
"Write a smart contract that allows for the creation and management of NFT collections. Include functionality for setting new addresses for the NFT collection factories and launchpad fee wallet, as well as updates to the mint cap and launchpad fee percentage. The contract should also have methods for creating new NFT collections and setting the admin role. Consider using OpenZeppelin's AccessControl library for role-based access control.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract NFTCollectionManager {
    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    bytes32 public constant CREATOR_ROLE = keccak256(""CREATOR_ROLE"");

    address public nftCollectionFactory;
    address public launchpadFeeWallet;
    uint256 public mintCap;
    uint256 public launchpadFeePercentage;

    struct NFTCollection {
        address collectionAddress;
        string name;
        string symbol;
    }

    NFTCollection[] public collections;

    mapping(address => bool) public isCollection;
    mapping(address => mapping(bytes32 => bool)) private roles;

    event NFTCollectionCreated(address indexed collectionAddress, string name, string symbol);
    event FactoryAddressUpdated(address indexed newFactoryAddress);
    event FeeWalletUpdated(address indexed newFeeWallet);
    event MintCapUpdated(uint256 newMintCap);
    event FeePercentageUpdated(uint256 newFeePercentage);

    modifier onlyRole(bytes32 role) {
        require(roles[msg.sender][role], ""Not authorized"");
        _;
    }

    constructor(address _nftCollectionFactory, address _launchpadFeeWallet, uint256 _mintCap, uint256 _launchpadFeePercentage) {
        nftCollectionFactory = _nftCollectionFactory;
        launchpadFeeWallet = _launchpadFeeWallet;
        mintCap = _mintCap;
        launchpadFeePercentage = _launchpadFeePercentage;

        _grantRole(msg.sender, ADMIN_ROLE);
    }

    function createNFTCollection(string memory _name, string memory _symbol) public onlyRole(CREATOR_ROLE) {
        // Dummy implementation for creating NFT collection
        address newCollectionAddress = address(uint160(uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender)))));
        collections.push(NFTCollection(newCollectionAddress, _name, _symbol));
        isCollection[newCollectionAddress] = true;

        emit NFTCollectionCreated(newCollectionAddress, _name, _symbol);
    }

    function setNFTCollectionFactory(address _newFactoryAddress) public onlyRole(ADMIN_ROLE) {
        nftCollectionFactory = _newFactoryAddress;
        emit FactoryAddressUpdated(_newFactoryAddress);
    }

    function setLaunchpadFeeWallet(address _newFeeWallet) public onlyRole(ADMIN_ROLE) {
        launchpadFeeWallet = _newFeeWallet;
        emit FeeWalletUpdated(_newFeeWallet);
    }

    function setMintCap(uint256 _newMintCap) public onlyRole(ADMIN_ROLE) {
        mintCap = _newMintCap;
        emit MintCapUpdated(_newMintCap);
    }

    function setLaunchpadFeePercentage(uint256 _newFeePercentage) public onlyRole(ADMIN_ROLE) {
        launchpadFeePercentage = _newFeePercentage;
        emit FeePercentageUpdated(_newFeePercentage);
    }

    function grantRole(address account, bytes32 role) public onlyRole(ADMIN_ROLE) {
        _grantRole(account, role);
    }

    function revokeRole(address account, bytes32 role) public onlyRole(ADMIN_ROLE) {
        _revokeRole(account, role);
    }

    function _grantRole(address account, bytes32 role) internal {
        roles[account][role] = true;
    }

    function _revokeRole(address account, bytes32 role) internal {
        roles[account][role] = false;
    }
}",contract_246.sol
"Create a smart contract that manages a collection of unique digital assets, allowing users to buy, sell, and transfer ownership. Include functions for token enumeration, owner lookup, and balance retrieval. Make sure the contract adheres to the IERC721 standard and includes necessary event emitters for token transfer and approval.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC721 {
    string private _name;
    string private _symbol;
    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function supportsInterface(bytes4 interfaceId) public pure returns (bool) {
        return interfaceId == 0x80ac58cd || interfaceId == 0x5b5e139f;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function balanceOf(address owner) public view returns (uint256) {
        require(owner != address(0), ""ERC721: balance query for the zero address"");
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) public view returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), ""ERC721: owner query for nonexistent token"");
        return owner;
    }

    function approve(address to, uint256 tokenId) public {
        address owner = ownerOf(tokenId);
        require(to != owner, ""ERC721: approval to current owner"");
        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), ""ERC721: approve caller is not owner nor approved for all"");
        _approve(to, tokenId);
    }

    function getApproved(uint256 tokenId) public view returns (address) {
        require(_exists(tokenId), ""ERC721: approved query for nonexistent token"");
        return _tokenApprovals[tokenId];
    }

    function setApprovalForAll(address operator, bool approved) public {
        require(operator != msg.sender, ""ERC721: approve to caller"");
        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function isApprovedForAll(address owner, address operator) public view returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function transferFrom(address from, address to, uint256 tokenId) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _transfer(from, to, tokenId);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) public {
        safeTransferFrom(from, to, tokenId, """");
    }

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _safeTransfer(from, to, tokenId, _data);
    }

    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return _owners[tokenId] != address(0);
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    function _safeMint(address to, uint256 tokenId) internal {
        _safeMint(to, tokenId, """");
    }

    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal {
        _mint(to, tokenId);
        require(_checkOnERC721Received(address(0), to, tokenId, _data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _mint(address to, uint256 tokenId) internal {
        require(to != address(0), ""ERC721: mint to the zero address"");
        require(!_exists(tokenId), ""ERC721: token already minted"");
        _balances[to] += 1;
        _owners[tokenId] = to;
        emit Transfer(address(0), to, tokenId);
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        require(ownerOf(tokenId) == from, ""ERC721: transfer of token that is not own"");
        require(to != address(0), ""ERC721: transfer to the zero address"");
        _approve(address(0), tokenId);
        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;
        emit Transfer(from, to, tokenId);
    }

    function _approve(address to, uint256 tokenId) internal {
        _tokenApprovals[tokenId] = to;
        emit Approval(ownerOf(tokenId), to, tokenId);
    }

    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) internal returns (bool) {
        if (to.code.length == 0) return true;
        try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data) returns (bytes4 retval) {
            return retval == IERC721Receiver.onERC721Received.selector;
        } catch (bytes memory reason) {
            if (reason.length == 0) {
                revert(""ERC721: transfer to non ERC721Receiver implementer"");
            } else {
                assembly {
                    revert(add(32, reason), mload(reason))
                }
            }
        }
    }
}

interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}",contract_247.sol
"Create a token-based smart contract that allows for token transfer, approval, and balance inquiry. Implement functions for token transfer, approval, and total supply. Utilize the SafeMath library for secure arithmetic operations. Incorporate event triggers for token transfer and approval. Consider the smart contract code provided and modify it to fit your requirements.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 _initialSupply) {
        totalSupply = _initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        _transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], ""Insufficient balance"");
        require(_value <= allowance[_from][msg.sender], ""Allowance exceeded"");
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    function _transfer(address _from, address _to, uint256 _value) internal {
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
    }
}",contract_248.sol
"Develop a smart contract that enables market positioning, funding rate management, and liquidator control. The contract should include functions to settle funding for traders, set default fee receivers, and update index price oracles. Implement pausability and reentrancy protection. Use upgradeable contracts from OpenZeppelin to ensure security and maintainability. Focus on providing a robust and secure foundation for managing market positions and funding rates.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MarketPositioning {
    address public owner;
    bool public paused;
    mapping(address => uint256) public fundingRates;
    address public defaultFeeReceiver;
    mapping(address => uint256) public indexPrices;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    constructor() {
        owner = msg.sender;
        paused = false;
    }

    function pause() external onlyOwner {
        paused = true;
    }

    function unpause() external onlyOwner {
        paused = false;
    }

    function setFundingRate(address trader, uint256 rate) external onlyOwner whenNotPaused {
        fundingRates[trader] = rate;
    }

    function settleFunding(address trader) external whenNotPaused {
        // Implementation for settling funding
    }

    function setDefaultFeeReceiver(address receiver) external onlyOwner whenNotPaused {
        defaultFeeReceiver = receiver;
    }

    function updateIndexPrice(address oracle, uint256 price) external onlyOwner whenNotPaused {
        indexPrices[oracle] = price;
    }

    function liquidatePosition(address trader) external whenNotPaused {
        // Implementation for liquidating a position
    }

    // Reentrancy guard
    bool internal locked;

    modifier nonReentrant() {
        require(!locked, ""Reentrant call"");
        locked = true;
        _;
        locked = false;
    }

    function safeTransfer(address token, address to, uint256 value) internal nonReentrant {
        // Safe transfer implementation
    }
}",contract_249.sol
"Create a smart contract that follows the ERC20 token standard, allowing for token transfers, approvals, and allowance management. Use the SafeMath library for mathematical operations. Implement data structures to track token balances, ownership, and allowance details within the contract. Focus on ensuring the functionality and security of the contract.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    using SafeMath for uint256;

    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    address public owner;

    mapping(address => uint256) private balances;
    mapping(address => mapping(address => uint256)) private allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply;
        balances[msg.sender] = _totalSupply;
        owner = msg.sender;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        require(balances[msg.sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        balances[msg.sender] = balances[msg.sender].sub(amount);
        balances[recipient] = balances[recipient].add(amount);
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address _owner, address spender) public view returns (uint256) {
        return allowances[_owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        require(balances[sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        require(allowances[sender][msg.sender] >= amount, ""ERC20: transfer amount exceeds allowance"");
        balances[sender] = balances[sender].sub(amount);
        balances[recipient] = balances[recipient].add(amount);
        allowances[sender][msg.sender] = allowances[sender][msg.sender].sub(amount);
        emit Transfer(sender, recipient, amount);
        return true;
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }
}",contract_250.sol
