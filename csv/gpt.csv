gpt_file_name,gpt_contracts,gpt_prompt
contract_31.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

abstract contract ERC165 {
    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool);
}

interface IERC721 is ERC165 {
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function balanceOf(address owner) external view returns (uint256 balance);
    function ownerOf(uint256 tokenId) external view returns (address owner);
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    function transferFrom(address from, address to, uint256 tokenId) external;
    function approve(address to, uint256 tokenId) external;
    function getApproved(uint256 tokenId) external view returns (address operator);
    function setApprovalForAll(address operator, bool _approved) external;
    function isApprovedForAll(address owner, address operator) external view returns (bool);
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
}

contract DigitalAsset is IERC721 {
    string private _name;
    string private _symbol;
    mapping(uint256 => address) private _tokenOwners;
    mapping(address => uint256) private _ownerTokenCount;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC721).interfaceId;
    }

    function balanceOf(address owner) public view override returns (uint256) {
        return _ownerTokenCount[owner];
    }

    function ownerOf(uint256 tokenId) public view override returns (address) {
        return _tokenOwners[tokenId];
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) public override {
        transferFrom(from, to, tokenId);
    }

    function transferFrom(address from, address to, uint256 tokenId) public override {
        require(ownerOf(tokenId) == from, ""Not token owner"");
        require(to != address(0), ""Invalid address"");
        _ownerTokenCount[from] -= 1;
        _ownerTokenCount[to] += 1;
        emit Transfer(from, to, tokenId);
    }

    function approve(address to, uint256 tokenId) public override {
        address owner = ownerOf(tokenId);
        require(to != owner);
        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    function getApproved(uint256 tokenId) public view override returns (address) {
        return _tokenApprovals[tokenId];
    }

    function setApprovalForAll(address operator, bool _approved) public override {
        _operatorApprovals[msg.sender][operator] = _approved;
        emit ApprovalForAll(msg.sender, operator, _approved);
    }

    function isApprovedForAll(address owner, address operator) public view override returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public override {
        safeTransferFrom(from, to, tokenId);
    }
}","Develop a smart contract that enables the creation, transfer, and management of digital assets. The contract should implement the IERC721 interface and support functions for retrieving the balance of assets, retrieving the owner of an asset, approving and transferring assets, and retrieving the approved operator for an asset. The contract should also provide metadata about the assets, including the name, symbol, and token URI. Finally, the contract should emit events to track changes in asset ownership and approval."
contract_72.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


    constructor () {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }


    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }


    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}",Create a smart contract that enables the control and management of ownership. The contract should allow for the transfer of ownership to a new address and renounce ownership. It should also set the initial owner. Use the provided code fragment as a reference and implement the necessary functions and logic for ownership management.
contract_177.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return payable(msg.sender);
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this;
        return msg.data;
    }
}

contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = _msgSender();
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(owner() == _msgSender(), ""Ownable: caller is not the owner"");
        _;
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal virtual {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract Pausable is Context, Ownable {
    event Paused(address account);
    event Unpaused(address account);

    bool private _paused;

    constructor() {
        _paused = false;
    }

    function paused() public view virtual returns (bool) {
        return _paused;
    }

    modifier whenNotPaused() {
        require(!_paused, ""Pausable: paused"");
        _;
    }

    modifier whenPaused() {
        require(_paused, ""Pausable: not paused"");
        _;
    }

    function pause() public virtual onlyOwner whenNotPaused {
        _paused = true;
        emit Paused(_msgSender());
    }

    function unpause() public virtual onlyOwner whenPaused {
        _paused = false;
        emit Unpaused(_msgSender());
    }
}",Create a smart contract that has a owner and allows for ownership transfer. Implement a pause and unpause function to pause and resume the contract's functionality. The contract should emit events when ownership is transferred or paused/unpaused. The contract should inherit from OpenZeppelin's contracts and implement the required functions.
contract_123.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// Ownership Contract
contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(_owner == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

// IBEP20 interface
interface IBEP20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

// Asset Management Contract
contract AssetManager is Ownable {
    struct Asset {
        uint256 id;
        string name;
        address owner;
    }

    Asset[] public assets;

    constructor(string memory _name, uint256 _id) {
        assets.push(Asset(_id, _name, msg.sender));
    }

    function createAsset(string memory _name, uint256 _id) public onlyOwner {
        assets.push(Asset(_id, _name, msg.sender));
    }

    function transferAsset(uint256 _id, address _recipient) public onlyOwner {
        for(uint256 i = 0; i < assets.length; i++){
            if(assets[i].id == _id){
                assets[i].owner = _recipient;
                break;
            }
        }
    }
}",Create a smart contract that builds upon the provided Contract and Ownable contract. The contract should allow users to create and manage assets. Include a constructor that takes a unique identifier and a name. Add functions for creating and transferring assets. Ensure the owner has control over creating and managing assets. Utilize the IBEP20 interface for interacting with assets. Keep the contract easy to understand and maintainable.
contract_54.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MyToken {
    string public constant name = ""MyToken"";
    string public constant symbol = ""MTK"";
    uint8 public constant decimals = 18;
  
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    event Transfer(address indexed from, address indexed to, uint tokens);

    mapping(address => uint256) balances;
    mapping(address => mapping (address => uint256)) allowed;
  
    uint256 totalSupply_;

    address public owner_;

    constructor(uint256 total) {
        totalSupply_ = total;
        balances[msg.sender] = totalSupply_;
        owner_ = msg.sender;
    }

    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }

    function balanceOf(address tokenOwner) public view returns (uint) {
        return balances[tokenOwner];
    }

    function transfer(address receiver, uint numTokens) public returns (bool) {
        require(numTokens <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender] - numTokens;
        balances[receiver] = balances[receiver] + numTokens;
        emit Transfer(msg.sender, receiver, numTokens);
        return true;
    }

    function approve(address delegate, uint numTokens) public returns (bool) {
        allowed[msg.sender][delegate] = numTokens;
        emit Approval(msg.sender, delegate, numTokens);
        return true;
    }

    function allowance(address owner, address delegate) public view returns (uint) {
        return allowed[owner][delegate];
    }

    function transferFrom(address owner, address buyer, uint numTokens) public returns (bool) {
        require(numTokens <= balances[owner]);    
        require(numTokens <= allowed[owner][msg.sender]);

        balances[owner] = balances[owner] - numTokens;
        allowed[owner][msg.sender] = allowed[owner][msg.sender] - numTokens;
        balances[buyer] = balances[buyer] + numTokens;
        
        emit Transfer(owner, buyer, numTokens);
        return true;
    }

    function mint(uint256 amount) public {
        require(msg.sender == owner_);
        totalSupply_ += amount;
        balances[owner_] += amount;
    }

    function burn(uint256 amount) public {
        require(msg.sender == owner_ && balances[owner_] >= amount);
        totalSupply_ -= amount;
        balances[owner_] -= amount;
    }

    function getOwner() public view returns (address) {
        return owner_;
    }

    function setOwner(address newOwner) public {
        require(msg.sender == owner_);
        owner_ = newOwner;
    }
}","Create a smart contract that allows for minting, transferring, and burning tokens. The contract should have a way to query the total supply, get the owner, and set a new owner. It should also allow for token allowance and approval. Implement a mapping for tracking token balances and include functions for getting the balance of an address and transferring tokens between accounts."
contract_242.sol,"pragma solidity ^0.8.0;

library Address {
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, ""Insufficient balance"");
        (bool success, ) = recipient.call{ value: amount }("""");
        if (!success) { revert('Unsuccessful'); }
    }
    
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0);
    }

    function functionCallWithValue(address target, bytes memory data, uint256 weiValue) internal returns (bytes memory) {
        require(isContract(target), ""Target address is not a contract"");
        (bool success, bytes memory result) = target.call{ value: weiValue }(data);
        return _verifyCallResult(success, result, ""Low-level call failed"");
    }

    function _verifyCallResult(bool success, bytes memory returndata, string memory revertReason) internal pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            if (returndata.length > 0) {
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(revertReason);
            }
        }
    }
}

library StorageSlot {
    struct Uint256Slot { uint256 value; }
    struct AddressSlot { address value; }

    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {
        assembly { r.slot := slot }
    }

    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {
        assembly { r.slot := slot }
    }
}

contract ProxiableContract {
    bytes32 constant IMPLEMENTATION_SLOT = keccak256(""ProxiableContract.implementation"");
    
    modifier onlyProxy() {
        require(isProxy(), ""Only proxy can call"");
        _;
    }
    
    function isProxy() internal view returns (bool) {
        return Address.isContract(_implementation());
    }
    
    function _implementation() internal view returns (address impl) {
        impl = StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;
    }

    function proxiableUUID() public pure virtual returns (bytes32) {
        return keccak256(""org.1820a.proxiable"");
    }

    function updateCode(address newAddress) internal onlyProxy {
        require(Address.isContract(newAddress), ""Cannot set a proxy implementation to a non-contract address"");
        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newAddress;
    }

    function updateCodeAndCall(address newCode, bytes calldata data) payable onlyProxy returns(bytes memory) {
        updateCode(newCode);
        return Address.functionCallWithValue(newCode, data, msg.value);
    }
}","Create a smart contract that implements the IERC1822Proxiable interface. Use the Address library to interact with other contracts and the StorageSlot library to store and retrieve data. Design a data structure or mapping to manage data. Focus on functionality and simplicity, while ensuring gas efficiency and code organization."
contract_75.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract FactoryInstanceManager {

  struct Factory {
    address owner;
    bool isRetired;
    string name;
  }

  struct Instance {
    address factoryOwner;
    address owner;
    bool isRetired;
    string name;
  }

  mapping (address => Factory) public factories;
  mapping (address => Instance) public instances;
  address[] public factoryList;
  address[] public instanceList;

  function registerFactory(address _factory, string memory _name) public {
    Factory storage factory = factories[_factory];
    factory.owner = msg.sender;
    factory.isRetired = false;
    factory.name = _name;
    factoryList.push(_factory);
  }

  function registerInstance(address _factory, address _instance, string memory _name) public {
    require(factories[_factory].owner == msg.sender, ""Only factory owners can register instances"");
    Instance storage instance = instances[_instance];
    instance.factoryOwner = msg.sender;
    instance.owner = _instance;
    instance.isRetired = false;
    instance.name = _name;
    instanceList.push(_instance);
  }

  function retireFactory(address _factory) public {
    require(factories[_factory].owner == msg.sender, ""Only factory owners can retire factories"");
    factories[_factory].isRetired = true;
  }

  function retireInstance(address _instance) public {
    require(instances[_instance].factoryOwner == msg.sender, ""Only instance owners can retire instances"");
    instances[_instance].isRetired = true;
  }

  function getFactory(address _factory) public view returns (address, bool, string memory) {
    return (factories[_factory].owner, factories[_factory].isRetired, factories[_factory].name);
  }

  function getInstance(address _instance) public view returns (address, address, bool, string memory) {
    return (instances[_instance].factoryOwner, instances[_instance].owner, instances[_instance].isRetired, instances[_instance].name);
  }

  function getFactories(uint _start, uint _length) public view returns (address[] memory) {
    require(_start + _length <= factoryList.length, ""Requested index out of bounds"");
    address[] memory _factories = new address[](_length);
    for (uint i = _start; i < _start + _length; i++) {
      _factories[i - _start] = factoryList[i];
    }
    return _factories;
  }

  function getInstances(uint _start, uint _length) public view returns (address[] memory) {
    require(_start + _length <= instanceList.length, ""Requested index out of bounds"");
    address[] memory _instances = new address[](_length);
    for (uint i = _start; i < _start + _length; i++) {
      _instances[i - _start] = instanceList[i];
    }
    return _instances;
  }
}","Create a Solidity smart contract that allows users to manage factories and instances. The contract should provide functions for registering new factories and instances, retrieving factory and instance information, and retrieving paginated lists of factories and instances. The contract should also handle factory and instance retirement. Note: You can refer to the provided iRegistry interface for guidance on the required functions and their functionality."
contract_206.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;

        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;

        return c;
    }

}

library Address {
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}

contract MyContract {
  using SafeMath for uint256;
  using Address for address;

  function isContractAddress(address _address) public view returns(bool) {
    return _address.isContract();
  }

  function sendEther(address payable _to, uint256 _amount) public payable {
    require(_amount <= address(this).balance, ""Insufficient balance in the contract"");
    _to.transfer(_amount);
  }
}",Create a smart contract that utilizes the SafeMath library to perform arithmetic operations with safety checks. Implement a function that checks if an address is a contract or not using the Address library. Include a function that sends Ether to a specified recipient. Ensure the contract includes error handling and documentation explaining the logic behind the contract functions.
contract_109.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Epoch {
    uint256 public epochPrice;
}

contract CoverPool {
    mapping(address => uint256) public providers;
    uint256 public cumulativeProfit;
    uint256 public totalShare;
    uint256 public unwithdrawnCoverTokens;
    Epoch public currentEpoch;

    event NewEpoch(address epoch, uint256 price);
    event Deposit(address indexed from, uint256 amount);
    event Withdraw(address indexed from, uint256 share);
    event Claim(address indexed from, uint256 profit);

    function startNewEpoch(uint256 price) external {
        Epoch newEpoch = new Epoch();
        newEpoch.epochPrice = price;
        currentEpoch = newEpoch;
        emit NewEpoch(address(newEpoch), price);
    }

    function deposit(uint256 amount) external {
        providers[msg.sender] += amount;
        totalShare += amount;
        emit Deposit(msg.sender, amount);
    }

    function withdraw(uint256 share) external {
        require(providers[msg.sender] >= share, ""Not enough shares to withdraw"");
        providers[msg.sender] -= share;
        totalShare -= share;
        emit Withdraw(msg.sender, share);
    }

    function claim() external {
        uint256 share = providers[msg.sender];
        require(share > 0, ""No shares to claim"");
        uint256 profit = (cumulativeProfit * share) / totalShare;
        require(profit <= unwithdrawnCoverTokens, ""Not enough unwithdrawn tokens"");
        unwithdrawnCoverTokens -= profit;
        cumulativeProfit -= profit;
        providers[msg.sender] -= share;
        totalShare -= share;
        emit Claim(msg.sender, profit);
    }
}","Create a Solidity smart contract that manages a cover pool, allowing users to provide, withdraw, claim, and withdraw epoch tokens. The contract should include logic for setting the epoch changing price and starting new epochs. Implement functions for adding and withdrawing tokens, claiming unclaimed profit, and withdrawing from epochs. Include variables to track cumulative profit, total share, and unwithdrawn cover tokens."
contract_238.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Converters {

    function uintToHex(uint256 value) public pure returns (string memory) {
        return appendHexPrefix(_toHex(value));
    }

    function uintToEther(uint256 value) public pure returns (string memory) {
        uint256 MIC = value;
        uint256 milliMIC = value / 1e3;
        uint256 Gwei = value / 1e9;
        if(Gwei > 0) {
            return appendGweiUnits(toString(Gwei));
        } else if(milliMIC > 0) {
            return appendMilliMicUnits(toString(milliMIC));
        } else {
            return appendMicUnits(toString(MIC));
        }
    }
    
    function _toHex(uint256 value) private pure returns (string memory) {
        if (value == 0)
            return ""0"";
        uint j = value.length;
        bytes memory bstr = new bytes(j);
        uint i;

        while (value != 0) {
            uint remainder = value % 16;
            value = value / 16;
            if (remainder < 10)
                bstr[--j] = bytes1(uint8(48 + remainder));
            else
                bstr[--j] = bytes1(uint8(87 + remainder));
        }
        return string(bstr);
    }
    
    function appendHexPrefix(string memory _hex) private pure returns (string memory) {
        return string(abi.encodePacked(""0x"", _hex));
    }
    
    function appendMicUnits(string memory _value) private pure returns(string memory){
        return string(abi.encodePacked(_value, "" MIC""));
    }
    
    function appendMilliMicUnits(string memory _value) private pure returns(string memory){
        return string(abi.encodePacked(_value, "" milliMIC""));
    }
    
    function appendGweiUnits(string memory _value) private pure returns(string memory){
        return string(abi.encodePacked(_value, "" Gwei""));
    }
    
    function toString(uint256 value) private pure returns (string memory) {
        if (value == 0) {
            return ""0"";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }
}","Develop a Solidity smart contract that includes two functions: uintToHex and uintToEther. uintToHex should convert a uint256 input into a hexadecimal string with leading zeros if necessary. uintToEther should convert a uint256 input into a human-readable string with appropriate units ('MIC') and formatting. Consider the value range and provide specific guidelines for values less than, equal to, and greater than 0.001 MIC."
contract_187.sol,"pragma solidity ^0.8.0;

contract Moloch {
    struct Member {
        bool exists;
        uint shares;
        mapping (address => bool) delegateKeys;
    }

    struct Proposal {
        address proposer;
        uint sharesRequested;
        address recipient;
        bool executed;
        uint yesVotes;
        uint noVotes;
    }
   
    mapping (address =>  Member) public members;
    mapping (address => bool) public hasVoted;
    Proposal[] public proposals;

    function submitProposal (uint sharesRequested, address recipient) public returns(uint){
        require(members[msg.sender].exists, ""Only members can submit proposals"");
        Proposal memory newProposal = Proposal({
            proposer: msg.sender,
            sharesRequested: sharesRequested,
            recipient: recipient,
            executed: false,
            yesVotes: 0,
            noVotes: 0
        });
        proposals.push(newProposal);
        return proposals.length - 1;
    }

    function vote(uint proposalIndex, bool vote) public {
        require(members[msg.sender].exists, ""Only members can vote"");
        require(!hasVoted[msg.sender], ""Member has already voted"");

        Proposal storage proposal = proposals[proposalIndex];
        require(!proposal.executed, ""Proposal has been executed"");

        if(vote){
            proposal.yesVotes += members[msg.sender].shares;
        } else {
            proposal.noVotes += members[msg.sender].shares;
        }
        hasVoted[msg.sender] = true;
    }

    function executeProposal(uint proposalIndex) public {
        Proposal storage proposal = proposals[proposalIndex];
        require(!proposal.executed, ""Proposal has been executed"");
        require(proposal.yesVotes > proposal.noVotes, ""Proposal did not pass"");
        
        
        proposal.executed = true;
    }

    function addMember(address newMember, uint shares) public {
        require(!members[newMember].exists, ""Must not be a member already"");
        require(shares > 0, ""Shares must be more than 0"");
        members[newMember].exists = true;
        members[newMember].shares = shares;
    }
    
    
    function addDelegateKey(address member, address delegateKey) public {
        require(members[member].exists, ""Member must exist"");
        require(!members[member].delegateKeys[delegateKey], ""Delegate key already exists"");
        
        members[member].delegateKeys[delegateKey] = true;
    }

    function removeDelegateKey(address member, address delegateKey) public {
        require(members[member].exists, ""Member must exist"");
        require(members[member].delegateKeys[delegateKey], ""Delegate key does not exist"");
        
        delete members[member].delegateKeys[delegateKey];
    }
}","Create a Solidity smart contract that implements the Moloch token system. The contract should include functions for submitting proposals, voting, and executing proposals. Implement mechanisms for managing member roles and delegate keys. Ensure the contract can handle multiple proposals and events for tracking proposal status. Optimize the contract for gas efficiency and follow proper coding standards."
contract_4.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DAOManagement {

    struct DAO {
        bytes32 name;
        address owner;
        address[] members;
    }

    struct Script {
        string name;
        bytes evmCode;
    }

    mapping(bytes32 => DAO) public daos;
    mapping(address => bytes32[]) public daoRegistry;
    mapping(address => Script[]) public scriptRegistry;

    event DaoDeployed(bytes32 indexed daoName, address indexed owner);
    event ScriptRegistered(string scriptName, address indexed owner);

    modifier daoOwner(bytes32 _name) {
        require(daos[_name].owner == msg.sender, ""Not the DAO owner"");
        _;
    }

    function deployDAO(bytes32 _name) public {
        require(daos[_name].owner == address(0), ""DAO with this name already exists"");
        DAO storage dao = daos[_name];
        dao.name = _name;
        dao.owner = msg.sender;

        daoRegistry[msg.sender].push(_name);

        emit DaoDeployed(_name, msg.sender);
    }

    function manageDAO(bytes32 _name, address _newMember) public daoOwner(_name) {
        daos[_name].members.push(_newMember);
    }

    function registerScript(string memory _name, bytes memory _evmCode) public {
        scriptRegistry[msg.sender].push(Script(_name, _evmCode));
        emit ScriptRegistered(_name, msg.sender);
    }

    function getDAOsByOwner() public view returns (bytes32[] memory) {
        return daoRegistry[msg.sender];
    }

    function getScriptsByOwner() public view returns (Script[] memory) {
        return scriptRegistry[msg.sender];
    }
}","Create a smart contract for managing decentralized autonomous organizations (DAOs) and embedded registries of EVM scripts. The contract should enable the deployment and management of DAOs, as well as the registration and management of EVM script registries. Include event emitters for tracking deployments and implement permission and access control mechanisms for DAOs and registries."
contract_68.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC20Burnable.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol"";

import ""https://github.com/smartcontractkit/Chainlink-Brownie-Contracts/blob/main/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract AoriToken is ERC20Burnable, Ownable {
    mapping (address => uint) private _balances;
    mapping (address => bool) private _vaultsTrusted;
    mapping (address => bool) private _oraclesTrusted;
    
    AggregatorV3Interface public priceFeed;
    
    constructor(AggregatorV3Interface _priceFeed) ERC20(""Aori Token"", ""AORI"") {
        priceFeed = _priceFeed;
        _mint(msg.sender, 1000 * 10 ** decimals());
    }
    
    function getPrice() public view returns (int) {
        (
            uint80 roundID, 
            int price,
            uint startedAt,
            uint timeStamp,
            uint80 answeredInRound
        ) = priceFeed.latestRoundData();
        return price;
    }
    
    function deposit(uint _amount) external {
        require(_vaultsTrusted[msg.sender], ""Vault not trusted"");
        _mint(msg.sender, _amount);
    }
    
    function withdraw(uint _amount) external {
        require(_vaultsTrusted[msg.sender], ""Vault not trusted"");
        _burn(msg.sender, _amount);
    }
    
    function claim(uint _amount) external {
        require(_balances[msg.sender] >= _amount, ""Insufficient funds"");
        _balances[msg.sender] -= _amount;
        _transfer(address(this), msg.sender, _amount);
    }
    
    function setVaultTrusted(address _vault, bool _isTrusted) external onlyOwner {
        _vaultsTrusted[_vault] = _isTrusted;
    }
    
    function setOracleTrusted(address _oracle, bool _isTrusted) external onlyOwner {
        _oraclesTrusted[_oracle] = _isTrusted;
    }
    
    function isVaultTrusted(address _vault) external view returns (bool) {
        return _vaultsTrusted[_vault];
    }
    
    function isOracleTrusted(address _oracle) external view returns (bool) {
        return _oraclesTrusted[_oracle];
    }
}","Create a smart contract that allows users to stake LP tokens in a vault and earn AORI tokens. The contract should retrieve real-time prices from Chainlink. Implement functions for depositing, withdrawing, and claiming AORI tokens. Include a mechanism for whitelisting vaults and oracles. Adhere to the OpenZeppelin ERC20 and ERC4626 standards."
contract_154.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return payable(msg.sender);
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this;
        return msg.data;
    }
}

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function decimals() external view returns (uint8);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, ""SafeMath: subtraction overflow"");
    }

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        return a - b;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }
}

contract MyToken is Context, IERC20 {
    using SafeMath for uint256;

    mapping (address => uint256) _balances;
    mapping (address => mapping (address => uint256)) _allowances;
    mapping (address => bool) _blacklisted;

    uint256 _totalSupply;
    string private _name;
    string private _symbol;

    constructor (string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view virtual override returns (uint8) {
        return 18;
    }

    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, ""ERC20: transfer amount exceeds allowance""));
        return true;
    }

    function blacklist(address account) public {
        require(account != _msgSender(), ""ERC20: cannot blacklist self"");
        _blacklisted[account] = true;
    }

    function unblacklist(address account) public {
        require(account != _msgSender(), ""ERC20: cannot unblacklist self"");
        _blacklisted[account] = false;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(!_blacklisted[sender] && !_blacklisted[recipient], ""ERC20: account is blacklisted"");

        _beforeTokenTransfer(sender, recipient, amount);

        _balances[sender] = _balances[sender].sub(amount, ""ERC20: transfer amount exceeds balance"");
        _balances[recipient] = _balances[recipient].add(amount);

        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: mint to the zero address"");
        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: burn from the zero address"");
        _beforeTokenTransfer(account, address(0), amount);
        _balances[account] = _balances[account].sub(amount, ""ERC20: burn amount exceeds balance"");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}
}","Create a smart contract that extends the ERC20 standard, with a focus on managing node rewards and liquidity. The contract should have functions for initializing the contract state variables, tracking blacklisted addresses, and updating the UniswapV2 router and swap tokens amount. Implement the required interfaces and libraries. Ensure the contract has modular design and follows best practices for smart contract development."
contract_183.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ManageableToken {
    string public constant name = ""ManageableToken"";
    string public constant symbol = ""MGT"";
    uint8 public constant decimals = 18;
    uint public totalSupply;

    mapping(address => uint) balances;
    mapping(address => mapping(address => uint)) allowed;
    
    struct Frozen {
        uint value;
        uint releaseTime;
    }

    mapping(address => Frozen) frozenBalances;

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed owner, address indexed spender, uint tokens);
    event Freeze(address indexed account, uint value, uint releaseTime);
    event Unfreeze(address indexed account, uint value);

    constructor(uint _initialSupply) {
        totalSupply = _initialSupply;
        balances[msg.sender] = _initialSupply;
        emit Transfer(address(0), msg.sender, _initialSupply);
    }

    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }

    function transfer(address to, uint tokens) public returns (bool success) {
        require(balances[msg.sender] >= tokens,""Insufficient balance"");
        
        balances[msg.sender] -= tokens;
        balances[to] += tokens;
        
        emit Transfer(msg.sender, to, tokens);
        
        return true;
    }

    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        require(tokens <= balances[from],""Insufficient balance"");
        require(tokens <= allowed[from][msg.sender], ""Not allowed"");
        
        balances[from] -= tokens;
        balances[to] += tokens;
        allowed[from][msg.sender] -= tokens;
        
        emit Transfer(from, to, tokens);
        
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint remaining) {
        return allowed[owner][spender];
    }

    function freeze(uint value, uint releaseTime) public {
        require(value <= balances[msg.sender], ""Insufficient balance"");
        require(releaseTime > block.timestamp, ""Invalid release time"");

        balances[msg.sender] -= value;
        frozenBalances[msg.sender] = Frozen(value, releaseTime);

        emit Freeze(msg.sender, value, releaseTime);
    }

    function unfreeze() public {
        require(block.timestamp >= frozenBalances[msg.sender].releaseTime, ""Tokens are still frozen"");
        
        uint oldValue = frozenBalances[msg.sender].value;
        
        balances[msg.sender] += oldValue;
        delete frozenBalances[msg.sender];
        
        emit Unfreeze(msg.sender, oldValue);
    }

    function frozenBalanceOf(address account) public view returns (uint value, uint releaseTime) {
        return (frozenBalances[account].value, frozenBalances[account].releaseTime);
    }
}","Develop a smart contract that manages a token, allowing users to send and receive tokens, with the ability to freeze and unfreeze values for future release. The contract should include functions for transferring tokens, freezing, and unfreezing values, as well as variables to store the total supply, user balances, and a data structure to store frozen values and release times."
contract_176.sol,"pragma solidity ^0.8.0;

contract MintableToken {
    mapping (address => uint256) private _balances;
    mapping (address => uint256) private _lastMove;
    
    address public owner;
    bool public isMinting;
    
    event Transfer(address indexed from, address indexed to, uint value);
    event MintingEnabled();
    event MintingDisabled();
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor(){
        owner = msg.sender;
        isMinting = true;
    }

    modifier onlyOwner() {
        require(owner == msg.sender, ""Only owner can call this function."");
        _;
    }
    
    function mint(address to, uint256 amount) external onlyOwner {
        require(isMinting == true, ""Minting is currently disabled."");
        _balances[to] += amount;
        _lastMove[to] = block.timestamp;
    }
    
    function enableMinting() external onlyOwner {
        require(isMinting == false, ""Minting is already enabled."");
        isMinting = true;
        emit MintingEnabled();
    }
    
    function disableMinting() external onlyOwner {
        require(isMinting == true, ""Minting is already disabled."");
        isMinting = false;
        emit MintingDisabled();
    }
    
    function transfer(address to, uint256 amount) external {
        require(_balances[msg.sender] >= amount, ""Insufficient balance."");
        _balances[msg.sender] -= amount;
        _balances[to] += amount;
        _lastMove[to] = block.timestamp;
        _lastMove[msg.sender] = block.timestamp;
        emit Transfer(msg.sender, to, amount);
    }
    
    function getBalance(address account) external view returns (uint256) {
        return _balances[account];
    }
    
    function getLastMove(address account) external view returns (uint256) {
        return _lastMove[account];
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0x0), ""New owner is the zero address"");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}","Create a smart contract for a mintable token that has an owner and allows for token minting and transfer. The contract should have an owner that can start and stop the minting process. The contract should also track the last time a token was moved by an address. Additionally, the owner should be able to unlock the minting process and allow tokens to be transferred."
contract_92.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Certification {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    uint256 private _totalSupply;
    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    
    constructor()  {
        _totalSupply = 0;
    }
    
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }
    
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }
    
    function transfer(address recipient, uint256 amount) public returns (bool) {
        require(_balances[msg.sender] >= amount, ""Insufficient balance."");
        _balances[msg.sender] -= amount;
        _balances[recipient] += amount;
        
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }
    
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
    
    function approve(address spender, uint256 amount) public returns (bool) {
        _allowances[msg.sender][spender] = amount;
        
        emit Approval(msg.sender, spender, amount);
        return true;
    }
    
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        require(_balances[sender] >= amount, ""Insufficient balance"");
        require(_allowances[sender][msg.sender] >= amount, ""Insufficient allowance"");
        
        _balances[sender] -= amount;
        _balances[recipient] += amount;
        _allowances[sender][msg.sender] -= amount;
        
        emit Transfer(sender, recipient, amount);
        return true;
    }
    
    function mint(address account, uint256 amount) public {
        _totalSupply += amount;
        _balances[account] += amount;
        
        emit Transfer(address(0), account, amount);
    }
    
    function burn(address account, uint256 amount) public {
        require(_balances[account] >= amount, ""Insufficient balance."");
        
        _balances[account] -= amount;
        _totalSupply -= amount;
        
        emit Transfer(account, address(0), amount);
    }
}","Create a smart contract that enables the issuance, transfer, and management of certifications. The contract should include functions for tracking the total supply of certifications, getting the balance of certifications held by an entity, transferring certifications, and approving or rejecting certification transfers. The contract should also include events for tracking certification transfers and approvals."
contract_103.sol,"pragma solidity ^0.8.0;

contract Median {

    struct Rate {
        uint rate;
        uint lastUpdatedTime;
    }

    mapping(string => Rate) public rates;
    mapping(string => address) public signers;

    event RateUpdated(string symbol, uint rate);

    function updateRate(string calldata symbol, uint newRate, uint8 v, bytes32 r, bytes32 s) external {
        bytes32 message = keccak256(abi.encodePacked(symbol, newRate));
        address signer = getSigner(message, v, r, s);

        require(signers[symbol] == signer, 'Invalid signer');
        rates[symbol] = Rate(newRate, block.timestamp);

        emit RateUpdated(symbol, newRate);
    }

    function setSigner(string calldata symbol, address signer) external {
        signers[symbol] = signer;
    }

    function getSigner(bytes32 message, uint8 v, bytes32 r, bytes32 s) public pure returns (address) {
        bytes32 ethSignedMessage = prefixed(message);
        return ecrecover(ethSignedMessage, v, r, s);
    }

    function prefixed(bytes32 hash) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", hash));
    }
}","Create a smart contract for the Median protocol that supports various cryptocurrency exchange rates. The contract should be structured to manage multiple currency pairs (e.g. ETH/USD, BAT/USD, etc.) with a single function for recovering the signer's address from a signed message. Focus on implementing the necessary functions and variables to achieve this functionality."
contract_246.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract NFTCollection is ERC721, AccessControl {
    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");

    address public feeWallet;
    uint256 public feePercentage;
    uint256 public mintCap;

    mapping(address => bool) public nftFactories;

    event CollectionCreated(string _name, string _symbol);

    constructor(
        string memory _name,
        string memory _symbol,
        uint256 _mintCap,
        address _feeWallet,
        uint256 _feePercentage,
        address _admin
    ) ERC721(_name, _symbol) {
        _setupRole(ADMIN_ROLE, _admin);
        feeWallet = _feeWallet;
        feePercentage = _feePercentage;
        mintCap = _mintCap;
        emit CollectionCreated(_name, _symbol);
    }

    modifier onlyAdmin() {
        require(hasRole(ADMIN_ROLE, msg.sender), ""Must have admin role to perform this action"");
        _;
    }

    function createCollection(string memory _name, string memory _symbol) public onlyAdmin {
        _setTokenURI(ERC721.totalSupply() + 1, string(abi.encodePacked(_name, ""."", _symbol)));
        _mint(msg.sender, ERC721.totalSupply() + 1);
    }

    function setNewAdmin(address _newAdmin) public onlyAdmin {
        grantRole(ADMIN_ROLE, _newAdmin);
        revokeRole(ADMIN_ROLE, msg.sender);
    }

    function setFeeWallet(address _feeWallet) public onlyAdmin {
        feeWallet = _feeWallet;
    }

    function setFeePercentage(uint256 _feePercentage) public onlyAdmin {
        feePercentage = _feePercentage;
    }

    function setMintCap(uint256 _mintCap) public onlyAdmin {
        mintCap = _mintCap;
    }

    function setFactory(address _factory, bool _status) public onlyAdmin {
        nftFactories[_factory] = _status;
    }
}","Write a smart contract that allows for the creation and management of NFT collections. Include functionality for setting new addresses for the NFT collection factories and launchpad fee wallet, as well as updates to the mint cap and launchpad fee percentage. The contract should also have methods for creating new NFT collections and setting the admin role. Consider using OpenZeppelin's AccessControl library for role-based access control."
contract_162.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/utils/cryptography/ECDSA.sol"";

contract SignedMintableToken is ERC721 {
    using ECDSA for bytes32;
    
    mapping(uint256 => address) public tokenRequester;
    mapping(uint256 => bytes) public tokenSignature;

    constructor(string memory name, string memory symbol)
        ERC721(name, symbol)
    {
        
    }

    function mintWithSignature(uint256 tokenId, bytes memory signature) public {
        // This will reconstruct the signer's address based on the `tokenId` and `signature`
        // This assumes that the signed message was the `tokenId` (converted to bytes)
        bytes32 messageHash = keccak256(abi.encodePacked(tokenId));
        address signer = messageHash.recover(signature);

        // Check that the signer is not the zero address
        require(signer != address(0), ""SignedMintableToken: invalid signature"");

        // Record requester address and signature
        tokenRequester[tokenId] = msg.sender;
        tokenSignature[tokenId] = signature;

        // Mint the token
        _mint(msg.sender, tokenId);
    }

    function verifySignature(uint256 tokenId, bytes memory signature) public view returns (bool) {
        bytes32 messageHash = keccak256(abi.encodePacked(tokenId));
        address signer = messageHash.recover(signature);
        return tokenRequester[tokenId] == signer;
    }
}",Create a smart contract that allows the minting of NFTs based on digital signatures. The contract should have a function to verify the signature and process the mint request. It should also store the requesting address and the signature provided. The contract should allow for the minting of multiple tokens and keep track of the minted tokens. The contract should also allow for the verification and processing of the mint request in a single transaction.
contract_17.sol,"// SPDX-License-Identifier:MIT
pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(isOwner());
        _;
    }

    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) private {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract Pausable is Ownable {
    event Pause();
    event Unpause();

    bool private _paused;

    constructor () {
        _paused = false;
    }

    function paused() public view returns(bool) {
        return _paused;
    }

    modifier whenNotPaused() {
        require(!_paused);
        _;
    }

    modifier whenPaused() {
        require(_paused);
        _;
    }

    function pause() public onlyOwner whenNotPaused {
        _paused = true;
        emit Pause();
    }

    function unpause() public onlyOwner whenPaused {
        _paused = false;
        emit Unpause();
    }
}

contract InsuranceManagement is Pausable {

    struct Insurance {
        uint id;
        string name;
        uint premium;
        uint capital;
    }

    Insurance[] public insuranceProducts;
    mapping (address => uint[]) public insuranceOwners;
    mapping (uint => uint) public insuranceStatus;

    function createInsurance(string memory name, uint premium, uint capital) public onlyOwner whenNotPaused {
        uint id = insuranceProducts.length;
        insuranceProducts.push(Insurance(id, name, premium, capital));
    }

    function purchaseInsurance(uint id) public payable whenNotPaused {
        require(msg.value == insuranceProducts[id].premium);
        insuranceOwners[msg.sender].push(id);
        insuranceStatus[id]++;
    }

    function cancelInsurance(uint id) public whenNotPaused {
        require(insuranceOwners[msg.sender][id] == id);
        delete insuranceOwners[msg.sender][id];
        insuranceStatus[id]--;
    }

    function updateInsuranceStatus(uint id, uint status) public onlyOwner whenNotPaused {
        insuranceStatus[id] = status;
    }
}","Design a smart contract to manage insurance products with a focus on security matrices, capital pools, and premium pools. The contract should include functions for setup and initialization, pausing and unpausing, and secure authorizations. Implement logic for cover purchase, cancellation, and status updates. Use best practices for code organization, naming conventions, and error handling."
contract_209.sol,"pragma solidity ^0.8.0;

contract ItemSetManagement {

    enum Rarity {
        Common, 
        Uncommon,
        Rare, 
        Epic,
        Legendary
    }

    struct ItemSet {
        uint256 setId;
        Rarity rarity;
        string[] items;
    }
    
    mapping(uint256 => ItemSet) private itemSets;
    uint256 private nextItemId = 1;

    event ItemSetCreated(uint256 setId, Rarity rarity);
    event ItemSetUpdated(uint256 setId, Rarity rarity);
    event ItemSetRemoved(uint256 setId);
    
    function createItemSet(Rarity rarity, string[] memory items) public {
        ItemSet storage set = itemSets[nextItemId];
        set.setId = nextItemId;
        set.rarity = rarity;
        set.items = items;

        emit ItemSetCreated(nextItemId, rarity);

        nextItemId++;
    }

    function updateItemSet(uint256 setId, Rarity rarity, string[] memory items) public {
        require(setId < nextItemId, ""Set does not exist"");

        ItemSet storage set = itemSets[setId];
        set.rarity = rarity;
        set.items = items;

        emit ItemSetUpdated(setId, rarity);
    }
    
    function removeItemSet(uint256 setId) public {
        require(setId < nextItemId, ""Set does not exist"");

        delete itemSets[setId];

        emit ItemSetRemoved(setId);
    }

    function getItemSet(uint256 setId) public view returns (Rarity, string[] memory){
        require(setId < nextItemId, ""Set does not exist"");

        ItemSet storage set = itemSets[setId];

        return (set.rarity, set.items);
    }

    function getItemSetsByRarity(Rarity rarity) public view returns (uint256[] memory) {
        uint256 count = 0;

        for (uint256 i = 1; i < nextItemId; i++) {
            if (itemSets[i].rarity == rarity) {
                count++;
            }
        }

        uint256[] memory ids = new uint256[](count);

        count = 0;

        for (uint256 i = 1; i < nextItemId; i++) {
            if (itemSets[i].rarity == rarity) {
                ids[count] = i;
                count++;
            }
        }

        return ids;
    }

    function getAllItemSets() public view returns (uint256[] memory) {
        uint256[] memory ids = new uint256[](nextItemId - 1);

        for (uint256 i = 1; i < nextItemId; i++) {
            ids[i - 1] = i;
        }

        return ids;
    }
    
}","Develop a smart contract that enables management of item sets with varying rarity. The contract should permit registering and deregistering items, and provide functionality to retrieve item sets based on set ID, rarity, and the list of all sets. Follow the existing code structure and logic, making necessary adjustments to complete the implementation."
contract_163.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract AccessControl {
    
    struct RoleData {
        mapping (address => bool) members;
    }

    mapping (bytes32 => RoleData) private _roles;
    bytes32 public constant ADMIN_ROLE = keccak256(""admin"");
    bytes32 public constant MODERATOR_ROLE = keccak256(""moderator"");

    event RoleGranted(bytes32 indexed role, address indexed account);
    event RoleRevoked(bytes32 indexed role, address indexed account);

    constructor () {
        _grantRole(ADMIN_ROLE, msg.sender);
    }

    modifier onlyAdmin() {
        require(hasRole(ADMIN_ROLE, msg.sender), ""AccessControl: must have admin role to access"");
        _;
    }
    
    modifier onlyModerator() {
        require(hasRole(MODERATOR_ROLE, msg.sender), ""AccessControl: must have moderator role to access"");
        _;
    }

    function hasRole(bytes32 role, address account) public view returns (bool) {
        return _roles[role].members[account];
    }
    
    function grantRole(bytes32 role, address account) public onlyAdmin {
        _grantRole(role, account);
    }
    
    function revokeRole(bytes32 role, address account) public onlyAdmin {
        _revokeRole(role, account);
    }

    function _grantRole(bytes32 role, address account) private {
        _roles[role].members[account] = true;
        emit RoleGranted(role, account);
    }

    function _revokeRole(bytes32 role, address account) private {
        _roles[role].members[account] = false;
        emit RoleRevoked(role, account);
    }
}","Develop a smart contract that manages access control for a system with different roles and administrators. The contract should allow administrators to grant and revoke roles, and include a way to query the membership of a role. Implement a new role with moderately restrictive permissions. Provide a clear and concise description of the contract's functionality and structure."
contract_155.sol,"pragma solidity ^0.8.0;

contract RoleBasedAccessControl {
    struct Role {
        bool isExists;
        mapping (address => bool) members;
    }

    mapping (bytes32 => Role) private _roles;
    mapping (address => bytes32[]) private _userRoles;

    event RoleCreate(bytes32 indexed roleId);
    event RoleGrant(bytes32 indexed roleId, address indexed account);
    event RoleRevoke(bytes32 indexed roleId, address indexed account);
    
    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    
    constructor() {
        _createRole(ADMIN_ROLE);
        _grantRole(ADMIN_ROLE, msg.sender);
    }

    modifier onlyAdmin {
        require(_isRoleGranted(ADMIN_ROLE, msg.sender), ""RoleBasedAccessControl: Caller is not an admin"");
        _;
    }

    modifier onlyRole(bytes32 roleId) {
        require(_isRoleGranted(roleId, msg.sender), ""RoleBasedAccessControl: Caller does not have this role"");
        _;
    }

    function createRole(bytes32 roleId) public onlyAdmin {
        _createRole(roleId);
    }

    function grantRole(bytes32 roleId, address account) public onlyAdmin {
        _grantRole(roleId, account);
    }

    function revokeRole(bytes32 roleId, address account) public onlyAdmin {
        _revokeRole(roleId, account);
    }

    function isRoleGranted(bytes32 roleId, address account) public view returns (bool) {
        return _isRoleGranted(roleId, account);
    }

    function getUserRoles(address account) public view returns (bytes32[] memory) {
        return _userRoles[account];
    }

    function _createRole(bytes32 roleId) private {
        require(! _roles[roleId].isExists, ""RoleBasedAccessControl: Role already exists"");
        _roles[roleId].isExists = true;

        emit RoleCreate(roleId);
    }

    function _grantRole(bytes32 roleId, address account) private {
        require(_roles[roleId].isExists, ""RoleBasedAccessControl: Role does not exist"");
        require(! _roles[roleId].members[account], ""RoleBasedAccessControl: Role already granted"");
        _roles[roleId].members[account] = true;
        _userRoles[account].push(roleId);

        emit RoleGrant(roleId, account);
    }

    function _revokeRole(bytes32 roleId, address account) private {
        require(_roles[roleId].isExists, ""RoleBasedAccessControl: Role does not exist"");
        require(_roles[roleId].members[account], ""RoleBasedAccessControl: Role not granted"");
        _roles[roleId].members[account] = false;

        for (uint256 i = 0; i < _userRoles[account].length; i++) {
            if (_userRoles[account][i] == roleId) {
                _userRoles[account][i] = _userRoles[account][_userRoles[account].length - 1];
                _userRoles[account].pop();
                break;
            }
        }

        emit RoleRevoke(roleId, account);
    }

    function _isRoleGranted(bytes32 roleId, address account) private view returns (bool) {
        return _roles[roleId].members[account];
    }
}","Create a smart contract that implements role-based access control using the provided AccessControl contract as a reference. The contract should allow administrators to create, manage, and assign roles. Include functions for role creation, revocation, and assignment. The contract should support role-based access control, ensuring that only authorized users can perform specific actions. Ensure that the contract emits events for role administration and role changes."
contract_204.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string private _name;
    string private _symbol;
    uint8 private _decimals;
    uint256 private _totalSupply;

    mapping (address => uint256) private _balances;
    mapping (address => mapping(address => uint256)) private _allowances;
    
    constructor(string memory name, string memory symbol) public {
        _name = name;
        _symbol = symbol;
        _decimals = 18;
        _totalSupply = 1000000 * (10 ** uint256(_decimals));
        _balances[msg.sender] = _totalSupply;
    }
    
    function name() public view returns (string memory) {
        return _name;
    }
    
    function symbol() public view returns (string memory) {
        return _symbol;
    }
    
    function decimals() public view returns (uint8) {
        return _decimals;
    }
    
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }
    
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }
    
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }
    
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
    
    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }
    
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }
    
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }
    
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);
        return true;
    }
    
    function burn(uint256 amount) public {
        _burn(msg.sender, amount);
    }
    
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }
    
    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
    
    function _burn(address account, uint256 amount) internal {
        require(account != address(0), ""ERC20: burn from the zero address"");
        require(_balances[account] >= amount, ""ERC20: burn amount exceeds balance"");

        _balances[account] -= amount;
        _totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }
    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}","Create a token contract that follows the ERC-20 standard. The contract should allow for token transfer, approval, and allowance management. It should have a total supply limit of 1,000,000 tokens. Implement a constructor function for the contract. Include functions for increase and decrease in allowance, token transfer, approval, transfer from, and burn. Use the ERC20 interface as a reference."
contract_101.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MyToken {
    mapping(address => uint256) private _balances;
    mapping(address => mapping (address => uint256)) private _allowances;

    string private _name;
    string private _symbol;
    uint8 private _decimals;
    uint256 private _totalSupply;

    address public owner;

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
        _decimals = 18;
        owner = msg.sender;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        require(
            _balances[msg.sender] >= amount,
            ""Not enough balance to transfer.""
        );
        _balances[msg.sender] -= amount;
        _balances[recipient] += amount;
        return true;
    }

    function allow(address spender, uint256 amount) public returns (bool) {
        _allowances[msg.sender][spender] = amount;
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function burn(uint256 amount) public {
        require(
            _balances[msg.sender] >= amount,
            ""Not enough balance to burn.""
        );
        _balances[msg.sender] -= amount;
        _totalSupply -= amount;
    }

    function mint(address account, uint256 amount) public {
        require(
            msg.sender == owner,
            ""Only owner can mint tokens.""
        );
        _balances[account] += amount;
        _totalSupply += amount;
    }
}","Create a smart contract that manages a fungible token. Implement the following functionality: allow users to transfer tokens, set token allowances, and burn tokens. Include functionality for the owner to mint new tokens. Provide a high-level overview of how the contract should be structured and involve the reader in the development process."
contract_241.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IAnyswapV3ERC20 {
    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function PERMIT_TYPEHASH() external view returns (bytes32);
    function nonces(address owner) external view returns (uint);
    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);
}

contract MyToken is IAnyswapV3ERC20 {
  string public constant name = 'MyToken';
  string public constant symbol = 'MTK';
  uint8 public constant decimals = 18;
  uint  public totalSupply = 10000 * (10 ** uint(decimals));
  
  // Create a mapping to hold the balance of each owner account, accessible by address.
  mapping (address => uint256) private _balances;
  // Create a mapping from an owner to an operator, to indicate that the operator has been approved to manage the owner's tokens.
  mapping (address => mapping (address => uint256)) private _allowances;

  bytes32 public override constant PERMIT_TYPEHASH = keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");
  bytes32 public override DOMAIN_SEPARATOR;
  mapping (address => uint256) public override nonces;

  constructor() {
      DOMAIN_SEPARATOR = keccak256(
          abi.encode(
              keccak256(""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""),
              keccak256(bytes(name)),
              keccak256(bytes(""1"")),
              block.chainid,
              address(this)
          )
      );
  }

  function _mint(address account, uint256 amount) internal {
    require(account != address(0), 'ERC20: mint to the zero address');

    totalSupply += amount;
    _balances[account] += amount;
    emit Transfer(address(0), account, amount);
  }

  function balanceOf(address account) public view returns (uint256) {
    return _balances[account];
  }

  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowances[owner][spender];
  }

  function transfer(address recipient, uint256 amount) public returns (bool) {
    _transfer(msg.sender, recipient, amount);
    return true;
  }

  function approve(address spender, uint256 amount) public returns (bool) {
    _approve(msg.sender, spender, amount);
    return true;
  }

  function transferFrom(
    address sender,
    address recipient,
    uint256 amount
  ) public returns (bool) {
    _transfer(sender, recipient, amount);

    uint256 currentAllowance = _allowances[sender][msg.sender];
    require(currentAllowance >= amount, 'ERC20: transfer amount exceeds allowance');
    _approve(sender, msg.sender, currentAllowance - amount);

    return true;
  }

  function _transfer(
    address sender,
    address recipient,
    uint256 amount
  ) internal {
    require(sender != address(0), 'ERC20: transfer from the zero address');
    require(recipient != address(0), 'ERC20: transfer to the zero address');

    uint256 senderBalance = _balances[sender];
    require(senderBalance >= amount, 'ERC20: transfer amount exceeds balance');
    _balances[sender] = senderBalance - amount;
    _balances[recipient] += amount;

    emit Transfer(sender, recipient, amount);
  }

  function _approve(
    address owner,
    address spender,
    uint256 amount
  ) internal {
    require(owner != address(0), 'ERC20: approve from the zero address');
    require(spender != address(0), 'ERC20: approve to the zero address');

    _allowances[owner][spender] = amount;
    emit Approval(owner, spender, amount);
  }

  function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public virtual override {
    require(block.timestamp <= deadline, ""ERC20Permit: expired deadline"");

    bytes32 structHash = keccak256(
        abi.encode(
            PERMIT_TYPEHASH,
            owner,
            spender,
            value,
            nonces[owner]++,
            deadline
        )
    );

    bytes32 hash = keccak256(
        abi.encodePacked(
            '\x19\x01',
            DOMAIN_SEPARATOR,
            structHash
        )
    );

    address signer = ecrecover(hash, v, r, s);
    require(signer == owner, ""ERC20Permit: invalid signature"");

    _approve(owner, spender, value);
  }
}","Create a new smart contract that implements the IAnyswapV3ERC20 interface, allowing for token transfers, approvals, and permits. Focus on the functional requirements, ensuring the contract provides accurate token balances, allows for token transfers with optional data, and adheres to the ERC-20 standard. Consider the use of libraries, such as SafeERC20, to simplify common operations. Provide a high-level overview of the contract's variables, functions, and logic."
contract_138.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// Interface required for ERC-20 compliance
interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract MyToken is IERC20 {
    string private _name;
    string private _symbol;
    uint256 private _totalSupply;
    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;

    constructor (string memory name_, string memory symbol_, uint256 totalSupply_) {
        _name = name_;
        _symbol = symbol_;
        _totalSupply = totalSupply_;
        _balances[msg.sender] = totalSupply_;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function totalSupply() public override view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public override view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        require(_balances[msg.sender] >= amount, ""Not enough balance"");
        _balances[msg.sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public override view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient,uint256 amount) public override returns (bool) {
        require(_allowances[sender][msg.sender] >= amount, ""Not approved for transfer"");
        require(_balances[sender] >= amount, ""Not enough balance"");
        _balances[sender] -= amount;
        _allowances[sender][msg.sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }
}","Create a smart contract in Solidity that implements an ERC-20 token, taking into account the following requirements: the token shall have a name and symbol; it shall have a total supply; it shall have a balance for each account; it shall have functionality for transferring tokens between accounts; it shall have functionality for allowing one account to spend tokens on behalf of another account; the contract shall emit events for these actions. Focus on the overall structure and relationships between functions."
contract_74.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    mapping(address => uint256) internal balances;
    mapping(address => mapping(address => uint256)) internal allowances;

    uint256 public totalSupply;
    string public name;
    string public symbol;
    uint8 public decimals;
    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _supply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _supply;
        balances[msg.sender] = totalSupply;
    }

    function balanceOf(address _account) external view returns (uint256) {
        return balances[_account];
    }

    function transfer(address _to, uint256 _value) external returns (bool) {
        require(balances[msg.sender] >= _value, ""Insufficient balance"");

        balances[msg.sender] -= _value;
        balances[_to] += _value;
        
        emit Transfer(msg.sender, _to, _value);
        return true;
    }
    
    function approve(address _spender, uint256 _value) external returns (bool) {
        allowances[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) external view returns (uint256) {
        return allowances[_owner][_spender];
    }

    function transferFrom(address _from, address _to, uint256 _value) external returns (bool) {
        require(_value <= balances[_from], ""Insufficient balance"");
        require(_value <= allowances[_from][msg.sender], ""Insufficient allowance"");

        balances[_from] -= _value;
        balances[_to] += _value;
        allowances[_from][msg.sender] -= _value;
        
        emit Transfer(_from, _to, _value);
        return true;
    }
}","Create a smart contract that represents a standard token with custom details. The contract should include functions for transferring tokens, approving token spending, and checking balances. It should also handle token approvals and have a total supply of tokens. Make sure to include event triggers for token transfer and approval events."
contract_64.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

// IAddressProvider Interface
interface IAddressProvider {
    function getPriceProvidersAggregator() external view returns (address);
}

// IPriceProvider Interface
interface IPriceProvider {
    function getUSDPrice(address tokenAddress) external view returns (uint256);
    function quote(address baseToken, address quoteToken) external view returns (uint256);
}

// IPriceProvidersAggregator Interface
interface IPriceProvidersAggregator {
    function getDefaultPriceProvider() external view returns (address);
}

contract TokenPriceManager {
    IAddressProvider private addressProvider;

    // Only allowed address modifier
    modifier onlyAllowedAddress() {
        require(msg.sender == address(addressProvider), ""OnlyAllowedAddress: caller is not the allowed address"");
        _;
    }

    constructor(IAddressProvider _addressProvider) {
        addressProvider = _addressProvider;
    }

    // Update the Address Provider
    function updateAddressProvider(IAddressProvider _addressProvider) external onlyAllowedAddress() {
        addressProvider = _addressProvider;
    }

    // Get the current price of a token in USD
    function getCurrentPriceInUSD(address tokenAddress) external view returns (uint256) {
        IPriceProvidersAggregator aggregator = IPriceProvidersAggregator(addressProvider.getPriceProvidersAggregator());
        IPriceProvider priceProvider = IPriceProvider(aggregator.getDefaultPriceProvider());

        return priceProvider.getUSDPrice(tokenAddress);
    }

    // Quote a token pair
    function quoteTokenPair(address baseToken, address quoteToken) external view returns (uint256) {
        IPriceProvidersAggregator aggregator = IPriceProvidersAggregator(addressProvider.getPriceProvidersAggregator());
        IPriceProvider priceProvider = IPriceProvider(aggregator.getDefaultPriceProvider());

        return priceProvider.quote(baseToken, quoteToken);
    }
}","Create a smart contract that interacts with IPriceProvidersAggregator, IPriceProvider, and IAddressProvider. The contract should have methods to retrieve the current price of a token in USD, quote token pairs, and update the address of the IAddressProvider. The implementation should be structured with clear functions and logic, and use modifiers to restrict access to critical functions. Focus on implementing the required functionality without focusing too much on performance or security."
contract_211.sol,"pragma solidity ^0.8.0;

contract NodeStaking {
    // Define
    struct NodeList {
        uint256 amount; // amount of tokens in the node
        uint256 createdAt; // creation time
    }

    struct Stake {
        uint256 amount; // amount of tokens staked
        uint256 createdAt; // stake creation time
    }

    mapping(address => NodeList) nodeList; // Nodes
    mapping(address => mapping(address => Stake)) stakeList; // User Stakes
    address[] nodes; // All our nodes
    uint256 rewardsPerSecond = 1e18; // Rewards generated per second

    // Staking Event
    event Staking(address indexed _user, address _node, uint256 _amount);

    // Rewards Claiming Event
    event ClaimRewards(address indexed _user, uint256 _reward);

    // To check whether a Node exists
    modifier nodeExists(address _node) {
        require(nodeList[_node].createdAt > 0, ""Node does not exist"");
        _;
    }

    // Check whether an User has staked on a Node
    modifier hasStaked(address _user, address _node) {
        require(stakeList[_user][_node].createdAt > 0, ""User has not staked on this Node"");
        _;
    }

    // To initialize a Node
    function initializeNode(address _node, uint256 _amount) external {
        nodeList[_node] = NodeList(_amount, block.timestamp);
        nodes.push(_node);
    }

    // To Staking
    function stakeTokens(address _node, uint256 _amount) external nodeExists(_node) {
        // Add Token Transfer Code here
        // Update Stake
        stakeList[msg.sender][_node] = Stake(_amount, block.timestamp);
        nodeList[_node].amount += _amount;

        emit Staking(msg.sender, _node, _amount);
    }

    // Calculate Rewards
    function calculateReward(address _user, address _node) public view hasStaked(_user, _node) returns (uint256) {
        uint256 timeStaked = (block.timestamp - stakeList[_user][_node].createdAt); // in seconds
        uint256 reward = (stakeList[_user][_node].amount * rewardsPerSecond * timeStaked) / nodeList[_node].amount;
        return reward;
    }

    // Claim Reward
    function claimReward(address _node) external hasStaked(msg.sender, _node) {
        uint256 reward = calculateReward(msg.sender, _node);
        // Token Transfer code
        emit ClaimRewards(msg.sender, reward);
    }

    // Get Node Data
    function getNodeData(address _node) external view nodeExists(_node) returns (uint256, uint256) {
        return (nodeList[_node].amount, nodeList[_node].createdAt);
    }
    
    // Returns node list
    function getNodeList() public view returns (address[] memory) {
      return nodes;
    }    
}","Develop a smart contract that allows users to participate in a node-staking system. The contract should manage node settings, user data, and rewards. Include functions for initializing node settings, retrieving general node data, and claiming rewards. Implement basic smart contract features such as modifiers and inheritance. Integrate the contract with external services like UniswapV2Router02."
contract_160.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    struct TokenData {
        uint256 tokenId;
        address owner;
        string metadata;
    }

    uint256 private _tokenIdTracker = 0;

    mapping (uint256 => TokenData) private _tokens;
    mapping (uint256 => address) private _tokenApprovals;

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    function mintToken(string memory metadata) external returns (uint256) {
        _tokenIdTracker++;
        _tokens[_tokenIdTracker] = TokenData(_tokenIdTracker, msg.sender, metadata);

        emit Transfer(address(0), msg.sender, _tokenIdTracker);

        return _tokenIdTracker;
    }

    function updateMetadata(uint256 tokenId, string memory newMetadata) external {
        require(msg.sender == _tokens[tokenId].owner, ""Only token owner can update metadata"");

        _tokens[tokenId].metadata = newMetadata;
    }

    function approve(address to, uint256 tokenId) external {
        require(msg.sender == _tokens[tokenId].owner, ""Only token owner can approve"");

        _tokenApprovals[tokenId] = to;

        emit Approval(msg.sender, to, tokenId);
    }

    function transferFrom(address from, address to, uint256 tokenId) external {
        require(_tokenApprovals[tokenId] == msg.sender, ""Transfer not approved for this address"");

        _tokens[tokenId].owner = to;
        _tokenApprovals[tokenId] = address(0);

        emit Transfer(from, to, tokenId);
    }

    function ownerOf(uint256 tokenId) external view returns (address) {
        return _tokens[tokenId].owner;
    }

    function getTokenData(uint256 tokenId) external view returns (TokenData memory) {
        return _tokens[tokenId];
    }
}","Create a smart contract that allows users to mint and manage tokens. The contract should support token metadata and allow for token approvals. Implement functions for minting tokens, updating metadata, and managing approvals. Ensure that the contract includes logging for token events."
contract_89.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }
}

contract AccessControl is Context {
    mapping (bytes32 => mapping (address => bool)) private _roles;

    event RoleAssigned(bytes32 indexed role, address indexed account);
    event RoleRevoked(bytes32 indexed role, address indexed account);

    function isAdmin(address account) public view returns (bool) {
        return _roles[keccak256(""ADMIN_ROLE"")][account];
    }

    function assignRole(bytes32 role, address account) public virtual {
        require(_roles[keccak256(""ADMIN_ROLE"")][_msgSender()], ""Access Control: must have admin role to assign"");
        _roles[role][account] = true;
        emit RoleAssigned(role, account);
    }

    function revokeRole(bytes32 role, address account) public virtual {
        require(_roles[keccak256(""ADMIN_ROLE"")][_msgSender()], ""Access Control: must have admin role to revoke"");
        _roles[role][account] = false;
        emit RoleRevoked(role, account);
    }
}

contract Pausable is AccessControl {
    event Pause();
    event Unpause();

    bool private _paused;

    modifier whenNotPaused() {
        require(!_paused, ""Pausable: paused"");
        _;
    }

    function pause() public virtual {
        require(isAdmin(_msgSender()), ""Pausable: must have admin role to pause"");
        _paused = true;

        emit Pause();
    }

    function unpause() public virtual {
        require(isAdmin(_msgSender()), ""Pausable: must have admin role to unpause"");
        _paused = false;

        emit Unpause();
    }

    function paused() public view virtual returns (bool) {
        return _paused;
    }
}

contract ReentrancyGuard {
    uint private _guardCounter = 1;

    modifier nonReentrant() {
        _guardCounter += 1;
        uint localCounter = _guardCounter;
        _;
        require(localCounter == _guardCounter, ""ReentrancyGuard: reentrant call"");
    }
}

contract SafeERC20 {
    function safeTransfer(address token, address to, uint256 value) internal virtual {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SafeERC20: TRANSFER_FAILED');
    }

    function safeApprove(address token, address spender, uint256 value) internal virtual {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, spender, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SafeERC20: APPROVE_FAILED');
    }
}

contract VaultManager is Context, Pausable, ReentrancyGuard, SafeERC20 {
    struct Vault {
        uint256 asset;
        uint256 debt;
    }

    mapping (address => Vault) private _vaults;

    event Deposit(address indexed user, uint256 amount);
    event Borrow(address indexed user, uint256 amount);
    event Repay(address indexed user, uint256 amount);

    function deposit(uint256 amount) public virtual nonReentrant whenNotPaused {
        _vaults[_msgSender()].asset += amount;

        emit Deposit(_msgSender(), amount);
    }

    function borrow(uint256 amount) public virtual nonReentrant whenNotPaused {
        require(_vaults[_msgSender()].asset >= amount, ""VaultManager: borrow amount exceeds balance"");
        _vaults[_msgSender()].debt += amount;

        emit Borrow(_msgSender(), amount);
    }

    function repay(uint256 amount) public virtual nonReentrant whenNotPaused {
        require(_vaults[_msgSender()].debt >= amount, ""VaultManager: repay amount exceeds debt"");
        _vaults[_msgSender()].debt -= amount;

        emit Repay(_msgSender(), amount);
    }

    function getAsset(address account) public view returns (uint256) {
        return _vaults[account].asset;
    }

    function getDebt(address account) public view returns (uint256) {
        return _vaults[account].debt;
    }

    function getEquity(address account) public view returns (uint256) {
        return _vaults[account].asset - _vaults[account].debt;
    }
}","Create a smart contract that manages vaults, allowing users to deposit, borrow, and repay tokens. functions should get asset and debt information, as well as calculate equity. Implement getter functions for current asset value and equity. Utilize ReentrancyGuard, Pausable, and AccessControl for added security. Familiarize yourself with the OpenZeppelin libraries and explore their usage."
contract_219.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

contract StandardToken {
    string public name;
    string public symbol;
    uint256 public totalSupply;

    mapping (address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint256 _totalSupply) {
        name = _name;
        symbol = _symbol;
        totalSupply = _totalSupply;
        balances[msg.sender] = _totalSupply;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value, ""Insufficient balance."");
        
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowances[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value, ""Insufficient balance or allowance."");
        
        balances[_to] += _value;
        balances[_from] -= _value;
        
        if (allowance < type(uint256).max) {
            allowances[_from][msg.sender] -= _value;
        }
        
        emit Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowances[msg.sender][_spender] = _value;
        
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowances[_owner][_spender];
    }
}","Create a smart contract that resembles a standard token (ERC20) and has functions for transferring tokens, approving token spending, and getting the token balance. It should also have customizable name, symbol, and supply. Make sure to include logic for token allowance and return values."
contract_15.sol,"pragma solidity ^0.8.0;

contract IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool);
    function balanceOf(address account) public view virtual returns (uint256);
}

contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return payable(msg.sender);
    }
}

contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () {
        _owner = _msgSender();
        emit OwnershipTransferred(address(0), _msgSender());
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    modifier onlyOwner {
        require(owner() == _msgSender(), ""Ownable: caller is not the owner."");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address."");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract KaijuKingzNFT is Ownable {
    struct Kaiju {
        string name;
        string bio;
        bool revealed;
    }

    uint public totalKaijus;
    mapping(uint => Kaiju) public kaijus;
    mapping(uint => address) public kaijuOwner;

    function createKaiju(string memory name, string memory bio) public onlyOwner {
        kaijus[totalKaijus] = Kaiju(name, bio, false);
        kaijuOwner[totalKaijus] = msg.sender;
        totalKaijus++;
    }

    function revealKaiju(uint id) public {
        require(msg.sender == kaijuOwner[id], 'not the owner');
        kaijus[id].revealed = true;
    }

    function updateKaiju(uint id, string memory name, string memory bio) public {
        require(msg.sender == kaijuOwner[id], 'not the owner');
        kaijus[id].name = name;
        kaijus[id].bio = bio;
    }

    function fuseKaijus(uint id1, uint id2, string memory fusedName, string memory fusedBio) public {
        require(msg.sender == kaijuOwner[id1] && msg.sender == kaijuOwner[id2], 'not the owner');
        
        delete kaijus[id1];
        delete kaijus[id2];
        delete kaijuOwner[id1];
        delete kaijuOwner[id2];
        
        kaijus[totalKaijus] = Kaiju(fusedName, fusedBio, true);
        kaijuOwner[totalKaijus] = msg.sender;
        totalKaijus++;
    }
}","Create a smart contract for a KaijuKingz NFT collection. The contract should allow for fusion of Kaijus, revealing revealed Kaijus, and changing their names and bios. Consider implementing burn mechanics for fusion and updates. Be mindful of gas efficiency and EIP-1167 compliance."
contract_116.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// SafeMath Library
library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""Addition overflow"");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""Subtraction underflow"");
        uint256 c = a - b;

        return c;
    }
}

// OlympusAuthority Contract
contract OlympusAuthority {
    mapping(address => bool) public isAuthorized;

    constructor() {
        isAuthorized[msg.sender] = true;
    }

    function authorize(address addr) public onlyAuthorized {
        isAuthorized[addr] = true;
    }

    function unauthorize(address addr) public onlyAuthorized {
        isAuthorized[addr] = false;
    }

    modifier onlyAuthorized() {
        require(isAuthorized[msg.sender], ""Unauthorized action!"");
        _;
    }
}

// OlympusToken contract implementing ERC20
contract OlympusToken is OlympusAuthority {
    using SafeMath for uint256;

    string public constant name = ""Olympus"";
    string public constant symbol = ""OLY"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Mint(address indexed to, uint256 amount);
    event Burn(address indexed from, uint256 amount);

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        require(_to != address(0), ""Invalid address"");

        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);

        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);

        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], ""Insufficient balance"");
        require(_value <= allowance[_from][msg.sender], ""Insufficient allowance"");
        require(_to != address(0), ""Invalid address"");

        balanceOf[_from] = balanceOf[_from].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);

        return true;
    }

    function mint(address _to, uint256 _amount) public onlyAuthorized returns (bool) {
        require(_to != address(0), ""Invalid address"");
        
        totalSupply = totalSupply.add(_amount);
        balanceOf[_to] = balanceOf[_to].add(_amount);
        emit Mint(_to, _amount);

        return true;
    }

    function burn(uint256 _amount) public {
        require(balanceOf[msg.sender] >= _amount, ""Insufficient balance to burn"");

        totalSupply = totalSupply.sub(_amount);
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_amount);
        emit Burn(msg.sender, _amount);
    }
}","Create a smart contract for the Olympus ERC20 token, implementing minting, burning, and total supply functionality. Integrate the OlympusAuthority contract and ensure token security measures are in place. Test the contract for reliability, including edge cases such as unauthorized minting and burn excess."
contract_186.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract StakingWarmup {

    address public immutable staking;
    address public immutable sHocus;

    constructor(address _staking, address _sHocus) {
        staking = _staking;
        sHocus = _sHocus;
    }

    function retrieve(uint256 amount, address staker) external {
        require(msg.sender == staking, ""Only staking contract can call this function"");
        require(amount <= address(this).balance, ""Not enough balance in contract"");
        payable(staker).transfer(amount);
    }
}","Create a smart contract called 'StakingWarmup' that supports withdrawals. The contract should have two immutable addresses, 'staking' and 'sHocus'. Implement a constructor function to set these addresses. Include a function 'retrieve' that allows the 'staking' address to withdraw a specified amount to a specified staker. The function should validate that the caller is indeed the 'staking' address."
contract_153.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;

        return c;
    }
}

contract ERC20BasicLimited is Context, IERC20 {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;
    
    uint256 private _totalSupply;
    uint256 constant _maxSupply = 50000000;
    string private _name = ""ERC20BasicLimited"";
    string private _symbol = ""EBL"";

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }
    
    function burn(uint256 amount) public virtual {
        _burn(_msgSender(), amount);
    }
    
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: burn from the zero address"");

        _beforeTokenTransfer(account, amount);

        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, ""ERC20: burn amount exceeds balance"");
        _balances[account] = accountBalance.sub(amount);
        _totalSupply = _totalSupply.sub(amount);

        emit Transfer(account, address(0), amount);
    }

    function _beforeTokenTransfer(address from, uint256 amount) internal virtual { }
    
    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount));
        return true;
    }
    
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), ""ERC20: mint to the zero address"");
        require(_totalSupply.add(amount) <= _maxSupply, ""ERC20: minting exceeds max supply"");

        _beforeTokenTransfer(address(0), amount);

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _beforeTokenTransfer(sender, amount);

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }
    
    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}",Design a Solidity smart contract that represents a token with a limited supply. The contract should enable users to transfer tokens to each other and allow for token burning and increased allowance. The contract should have a maximum supply of 50 million tokens and use the OpenZeppelin ERC20 contract as a base. The contract's behavior should closely resemble the provided code fragment.
contract_61.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DaiBackstopSyndicate {
    address public admin;
    mapping(address => uint256) public daiBalance;
    mapping(uint256 => Auction) public auctions;
    uint256 public nextAuctionId;
    bool public isOpen;
    
    struct Auction {
        uint256 amount;
        bool finalized;
    }

    event DaiDeposited(address indexed user, uint256 amount);
    event AuctionEntered(uint256 indexed auctionId, address indexed user, uint256 amount);
    event AuctionFinalized(uint256 indexed auctionId, address indexed user, uint256 amount);
    event DepositsHalted();

    constructor() {
        admin = msg.sender;
        isOpen = true;
    }

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can perform this action"");
        _;
    }

    modifier openForDeposits() {
        require(isOpen, ""Not open for deposits"");
        _;
    }

    function depositDai() public payable openForDeposits {
        daiBalance[msg.sender] += msg.value;
        emit DaiDeposited(msg.sender, msg.value);
    }

    function enterAuction(uint256 amount) public {
        require(daiBalance[msg.sender] >= amount, ""Insufficient Balance"");
        auctions[nextAuctionId++] = Auction(amount, false);
        daiBalance[msg.sender] -= amount;
        emit AuctionEntered(nextAuctionId - 1, msg.sender, amount);
    }

    function finalizeAuction(uint256 auctionId) public onlyAdmin {
        Auction storage auction = auctions[auctionId];
        require(!auction.finalized, ""Auction already finalized"");
        auction.finalized = true;
        emit AuctionFinalized(auctionId, msg.sender, auction.amount);
    }
    
    function haltDeposits() public onlyAdmin {
        isOpen = false;
        emit DepositsHalted();
    }
}","Develop a smart contract for the Dai Backstop Syndicate, incorporating functionality for depositing Dai, entering auctions, finalizing auctions, and halting new deposits and auctions. The contract should utilize Solidity's standard libraries and best practices for code organization and readability. Ensure proper event emission and handling for all contract interactions."
contract_77.sol,"pragma solidity ^0.8.0;

abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return payable(msg.sender);
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this;
        return msg.data;
    }
}

interface IBEP20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface IDEXFactory {
    function createPair(address tokenA, address tokenB) external returns (address pair);
}

contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () {
        _owner = _msgSender();
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(_owner == _msgSender(), ""Ownable: caller is not the owner"");
        _;
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract TokenManager is Context, Ownable {
    IDEXFactory private _factory;

    constructor (IDEXFactory factory) {
        _factory = factory;
    }
    
    function createTradingPair(IBEP20 token1, IBEP20 token2) public onlyOwner returns (address pair) {
        pair = _factory.createPair(address(token1), address(token2));
    }

}","Create a smart contract that builds upon the provided Solidity code fragment. Incorporate the necessary functions and interfaces (IBEP20, IDEXFactory) to manage BEP20 tokens and create trading pairs with IDEX. Implement authorization mechanisms to restrict specific functionality to authorized addresses. Focus on developing a robust and secure smart contract that meets the requirements of the provided code fragment."
contract_113.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DigitalAsset {
    mapping(address => uint) balances;
    address public owner;
    uint public totalSupply;
    string public name;
    string public symbol;

    constructor(string memory _name, string memory _symbol, uint _totalSupply) {
        owner = msg.sender;
        name = _name;
        symbol = _symbol;
        totalSupply = _totalSupply;
        balances[owner] = totalSupply;
    }

    function transfer(address _to, uint _amount) public {
        require(balances[msg.sender] >= _amount, ""Insufficient balance"");
        balances[msg.sender] -= _amount;
        balances[_to] += _amount;
    }

    function balanceOf(address _account) public view returns (uint) {
        return balances[_account];
    }

    function mint(uint _amount) public {
        require(msg.sender == owner, ""Only owner can mint tokens"");
        totalSupply += _amount;
        balances[owner] += _amount;
    }

    function burn(uint _amount) public {
        require(msg.sender == owner, ""Only owner can burn tokens"");
        require(balances[owner] >= _amount, ""Insufficient balance to burn"");
        totalSupply -= _amount;
        balances[owner] -= _amount;
    }
}","Develop a smart contract that manages a digital asset with features such as token transfer, minting, and burning. Ensure the contract has a total supply tracker and allows the owner to manage the minting and burning of tokens. Make sure the contract includes a minting function that checks the total supply before minting new tokens. Provide a high-level overview of the contract structure and functionality."
contract_221.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

contract CustomToken {
    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;
  

    constructor (string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    event Transfer(address indexed sender, address indexed recipient, uint256 amount);
    event Approval(address indexed owner, address indexed spender, uint256 amount);

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] - subtractedValue);
        return true;
    }
  
    function mint(address account, uint256 amount) public {
        require(account != address(0), ""ERC20: mint to the zero address"");
        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function burn(address account, uint256 amount) public {
        require(account != address(0), ""ERC20: burn from the zero address"");
        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, ""ERC20: burn amount exceeds balance"");
        _balances[account] = accountBalance - amount;
        _totalSupply -= amount;

        emit Transfer(account, address(0), amount);
    }


    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _beforeTokenTransfer(sender, recipient, amount);

        uint256 senderBalance = _balances[sender];
        require(senderBalance >= amount, ""ERC20: transfer amount exceeds balance"");
        _balances[sender] = senderBalance - amount;
        _balances[recipient] += amount;

        emit Transfer(sender, recipient, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }


    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }

    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

}","Design a smart contract for a custom token that can be minted, transferred, and burned. The contract should allow users to set a name and symbol for the token and implement basic token functionality, such as approval and allowance management. Include event logging for critical operations."
contract_236.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

//include AccessControlUpgradeable in the code

abstract contract AccessControlUpgradeable {
    function grantRole(bytes32 role, address account) public virtual;
    function revokeRole(bytes32 role, address account) public virtual;
    function renounceRole(bytes32 role, address account) public virtual;
    function hasRole(bytes32 role, address account) public view virtual returns (bool);
}

contract AdminRoleManagement is AccessControlUpgradeable {
    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");

    modifier onlyAdmin() {
        require(hasRole(ADMIN_ROLE, msg.sender), ""AdminRoleManagement: caller is not an admin"");
        _;
    }

    constructor() {
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function grantAdminRole(address account) public onlyAdmin {
        grantRole(ADMIN_ROLE, account);
    }

    function revokeAdminRole(address account) public onlyAdmin {
        revokeRole(ADMIN_ROLE, account);
    }

    function renounceAdminRole() public {
        renounceRole(ADMIN_ROLE, msg.sender);
    }

    function _setupRole(bytes32 role, address account) internal virtual {
        grantRole(role, account);
    }
}","Create a smart contract that builds upon AccessControlUpgradeable, implementing a custom role, 'Admin', with defined functions for role management, including granting, revoking, and renouncing. Ensure proper access control using inherited functions and modifiers. Concentrate on the overall functionality and interaction with users."
contract_188.sol,"pragma solidity ^0.8.0;

contract InvestorContract {
  
  using SafeMath for uint;

  struct User {
    uint id;
    uint deposit;
    uint withdrawal;
    uint totalDeposit;
    uint referralCount;
  }

  mapping(address => User) public users;
  mapping(uint => address) public userIds;
  uint public lastUserId = 2;

  event Deposit(address indexed user, uint256 amount);
  event Withdrawal(address indexed user, uint256 amount);
  event BonusPayment(address indexed user, uint256 amount);

  constructor() {
    User storage user = users[msg.sender];
    user.id = 1;
    user.deposit = 0;
    user.withdrawal = 0;
    user.totalDeposit = 0;
    user.referralCount = 0;
  }

  function deposit() public payable {
    require(msg.value > 0);

    User storage user = users[msg.sender];
    user.deposit = msg.value;
    user.totalDeposit = user.totalDeposit.add(msg.value);

    emit Deposit(msg.sender, msg.value);
  }

  function calculateContractBalanceRate() public view returns(uint) {
    // It should be changed according to the actual calculation rules.
    // This is a simple example.
    return address(this).balance;
  }

  function calculateLeaderBonusRate(uint deposit) public view returns(uint) {
    // It should be changed according to the actual calculation rules.
    // This is a simple example.
    return deposit.div(10);
  }

  function calculateCommunityBonusRate(uint deposit) public view returns(uint) {
    // It should be changed according to the actual calculation rules.
    // This is a simple example.
    return deposit.div(20);
  }

  function withdraw(uint amount) public {
    User storage user = users[msg.sender];

    require(amount <= user.deposit, ""Insufficient balance"");

    user.deposit = user.deposit.sub(amount);
    user.withdrawal = user.withdrawal.add(amount);

    emit Withdrawal(msg.sender, amount);

    payable(msg.sender).transfer(amount);
  }

  function getBonus(uint amount) public {
    User storage user = users[msg.sender];

    user.deposit = user.deposit.add(amount);

    emit BonusPayment(msg.sender, amount);
  }
}

library SafeMath {
  function add(uint a, uint b) internal pure returns (uint) {
    uint c = a + b;
    require(c >= a, ""SafeMath: addition overflow"");

    return c;
  }

  function sub(uint a, uint b) internal pure returns (uint) {
    require(b <= a, ""SafeMath: subtraction overflow"");
    uint c = a - b;

    return c;
  }

  function mul(uint a, uint b) internal pure returns (uint) {
    if (a == 0) {
      return 0;
    }

    uint c = a * b;
    require(c / a == b, ""SafeMath: multiplication overflow"");

    return c;
  }

  function div(uint a, uint b) internal pure returns (uint) {
    require(b > 0, ""SafeMath: division by zero"");
    uint c = a / b;

    return c;
  }

  function mod(uint a, uint b) internal pure returns (uint) {
    require(b != 0, ""SafeMath: modulo by zero"");
    return a % b;
  }
}","Create a smart contract that allows users to deposit funds, receive marketing and commission rates based on their investment amounts. The contract should keep track of total deposits made by users and allow users to withdraw their funds. Implement a mechanism to calculate contract balance rate, leader bonus rate, and community bonus rate. Define events for deposit creation, withdrawal, and bonus payment. Utilize a safe math library to prevent overflow and underflow issues."
contract_164.sol,"pragma solidity ^0.8.0;

contract InvestmentContract {
    struct Investor {
        uint256 balance;
        address referral;
        uint256 lastDividendPoints;
    }

    uint256 private totalInvestments;
    uint256 private totalDividendPoints;
    uint256 private unclaimedDividends;

    mapping(address => Investor) public investors;
    address[] public investorIndex;

    event Invest(address indexed investor, uint256 amount);
    event PayDividend(address indexed investor, uint256 dividend);

    modifier onlyInvestor() {
        require(investors[msg.sender].balance > 0, ""You are not an investor"");
        _;
    }

    function invest(address referral) public payable {
        require(msg.value > 0, ""Investment must be greater than 0"");
        if(investors[msg.sender].balance == 0) {
            investorIndex.push(msg.sender);
        }
        investors[msg.sender].balance += msg.value;
        totalInvestments += msg.value;
        investors[msg.sender].referral = referral;

        emit Invest(msg.sender, msg.value);
    }

    function disburseDividends() public {
        uint256 unallocatedPoints = totalDividendPoints - unclaimedDividends;
        uint256 totalUnallocated = address(this).balance - totalInvestments;
        uint256 dividendPerInvestment = unallocatedPoints.div(totalUnallocated);
        totalDividendPoints = dividendPerInvestment.mul(totalInvestments);
        unclaimedDividends = totalDividendPoints;
    }

    function withdrawDividend() public onlyInvestor {
        uint256 newDividendPoints = totalDividendPoints - investors[msg.sender].lastDividendPoints;
        uint256 toBePaid = investors[msg.sender].balance.mul(newDividendPoints);

        unclaimedDividends -= toBePaid;
        investors[msg.sender].lastDividendPoints = totalDividendPoints;

        payable(msg.sender).transfer(toBePaid);

        emit PayDividend(msg.sender, toBePaid);
    }

    function balanceOf(address investor) public view returns(uint256) {
        return investors[investor].balance;
    }

    function dividendOf(address investor) public view returns(uint256) {
        uint256 newDividendPoints = totalDividendPoints - investors[investor].lastDividendPoints;
        return investors[investor].balance.mul(newDividendPoints);
    }

    function distributeReferralRewards() public readOnly {
        for (uint256 s=0; s<investorIndex.length; s+=1){
            address investorAddress = investorIndex[s];
            payReferral(investorAddress);
        }
    }

    function payReferral(address investor) private {
        address referral = investors[investor].referral;
        if(referral != address(0)) {
            uint256 reward = investors[investor].balance / 10;
            investors[referral].balance += reward;
        }
    }
}",Design a smart contract that allows users to invest and earn interest on their deposits. The contract should have a system in place to regulate daily investments and have a referral system for earning more interest. The contract should also have a mechanism to pay out dividends to investors. Provide a general outline of the contract's structure and key functions.
contract_245.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }
}

contract Ownership is SafeMath {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    
    modifier onlyOwner() {
        require(_owner == msg.sender, ""Caller is not the Owner"");
        _;
    }

    constructor() public {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""New owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }

    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }
}","Create a simple smart contract that allows for ownership transfer, renunciation, and basic arithmetic operations. Use the SafeMath library for precision and implement ownership transfer and renunciation functions. Ensure the contract includes a modifier for the owner and provides basic functionality for setting and retrieving the owner's address."
contract_91.sol,"pragma solidity ^0.8.0;

// F3Devents contract
contract F3Devents {
    event onRegisterPlayer(address indexed newAddress, bytes32 name, address indexed affiliatedAddress, uint256 ethereumUsed, uint256 timeStamp);
    event onBuyKey(address indexed playerAddress, bytes32 name, uint256 roundID, uint256 numberOfKeys, uint256 ethereumUsed, uint256 timeStamp);
    event onReloadKey(address indexed playerAddress, bytes32 name, uint256 roundID, uint256 numberOfKeys, uint256 ethereumUsed, uint256 timeStamp);
    event onWithdraw(address indexed playerAddress, bytes32 name, uint256 ethereumOut, uint256 timeStamp);
    event onAffiliatePayout(address indexed affiliateAddress, address indexed playerAddress, bytes32 name, uint256 roundID, uint256 ethereumUsed, uint256 timeStamp);
}

// F4Kings game contract
contract F4Kings is F3Devents {
    struct Player {
        uint256 id;
        bytes32 name;
        address walletAddress;
    }
    
    mapping(address => Player) public players;
    mapping(uint => address payable) public addressIndexes;
    
    uint256 public playerIndex;
    address public admin; 
    address payable public shareCom;
    
    uint256 private airdropCounter;
    uint256 public roundTimer;
    uint256 public affiliatePercentage = 10;
    
    // game settings parameters
    uint256 public initialKeyPrice;
    uint256 public roundTimeLimit;

    constructor(
        address _admin,
        address payable _shareCom,
        uint256 _initialKeyPrice,
        uint256 _roundTimeLimit
    ) {
        require(_admin != address(0) && _shareCom != address(0), ""Invalid address"");
        admin = _admin;
        shareCom = _shareCom;
        initialKeyPrice = _initialKeyPrice;
        roundTimeLimit = _roundTimeLimit;
    }

    function registerPlayer(bytes32 _name) public payable {
        require(players[msg.sender].walletAddress == address(0), ""Player already registered"");
        require(msg.value >= initialKeyPrice, ""Insufficient Ethereum"");
        
        Player memory newPlayer = Player(playerIndex, _name, msg.sender);
        players[msg.sender] = newPlayer;
        addressIndexes[playerIndex] = payable(msg.sender);
        playerIndex++;
        
        emit onRegisterPlayer(msg.sender, _name, address(0), msg.value, block.timestamp);
    }

    function buyKey(uint _numberOfKeys) public payable {
        require(players[msg.sender].walletAddress != address(0), ""Player not registered"");
        require(msg.value >= initialKeyPrice*_numberOfKeys, ""Insufficient Ethereum"");
        if(block.timestamp > roundTimer + roundTimeLimit) {
            roundTimer = block.timestamp;
        }
        
        emit onBuyKey(msg.sender, players[msg.sender].name, playerIndex, _numberOfKeys, msg.value, block.timestamp);
    }

    function reloadKey(uint _numberOfKeys) public payable {
        require(players[msg.sender].walletAddress != address(0), ""Player not registered"");
        require(msg.value >= initialKeyPrice*_numberOfKeys, ""Insufficient Ethereum"");   
        
        emit onReloadKey(msg.sender, players[msg.sender].name, playerIndex, _numberOfKeys, msg.value, block.timestamp);
    }

    function withdraw() public {
        require(players[msg.sender].walletAddress != address(0), ""Player not registered"");
        
        emit onWithdraw(msg.sender, players[msg.sender].name, address(this).balance, block.timestamp);
    }

    function affiliatePayout(address _affiliateAddress) public payable {
        require(players[msg.sender].walletAddress != address(0), ""Player not registered"");

        uint256 payout = msg.value * affiliatePercentage / 100;
        payable(_affiliateAddress).transfer(payout);
        
        emit onAffiliatePayout(_affiliateAddress, msg.sender, players[msg.sender].name, playerIndex, payout, block.timestamp);
    }

    // admin function to withdraw all ether from contract
    function adminWithdraw() public {
        require(msg.sender == admin, ""Only admin can perform this action"");
        shareCom.transfer(address(this).balance);
    }

    function addAirdrop() public payable {
        require(players[msg.sender].walletAddress != address(0), ""Player not registered"");
        require(msg.value >= initialKeyPrice, ""Insufficient Ethereum"");
        airdropCounter++;
        if(airdropCounter >= 100) {
            airdropCounter = 0;
            shareCom.transfer(address(this).balance);
        }
    }
}","Create a smart contract for the F4Kings game, inheriting from F3Devents. The contract should track game settings, admin and shareCom addresses, and game statistics. Implement events for player registration, buying/reloading, withdrawing, and affiliate payouts. Include features for air drops, round timers, and affiliate payments. Focus on readability and maintainability."
contract_194.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint);
    function balanceOf(address tokenOwner) external view returns (uint balance);
    function allowance(address tokenOwner, address spender) external view returns (uint remaining);
    function transfer(address to, uint tokens) external returns (bool success);
    function approve(address spender, uint tokens) external returns (bool success);
    function transferFrom(address from, address to, uint tokens) external returns (bool success);
}

interface SwapperInterface {
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);

    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts); 
}

interface IUniswapV2Router01 {
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);
}

contract TokenSwapper {
    SwapperInterface public swapper;
    IUniswapV2Router01 public router;

    constructor(address _swapper, address _router) {
        swapper = SwapperInterface(_swapper);
        router = IUniswapV2Router01(_router);
    }

    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        uint deadline
    ) external {
        swapper.swapExactTokensForTokens(amountIn, amountOutMin, path, msg.sender, deadline);
    }

    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        uint deadline
    ) external {
        swapper.swapTokensForExactTokens(amountOut, amountInMax, path, msg.sender, deadline);
    }

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        uint deadline
    ) external {
        router.addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin, msg.sender, deadline);
    }

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        uint deadline
    ) external {
        router.removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, msg.sender, deadline);
    }
}","Write a smart contract that allows for token swaps and liquidities. The contract should interact with the IERC20, SwapperInterface, and IUniswapV2Router01 interfaces. Make sure to include functions for swapping, adding and removing liquidity, and getting balances and token information."
contract_122.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

abstract contract ERC165 {
    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool);
}

abstract contract ERC721 is ERC165 {
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
    
    function balanceOf(address owner) public view virtual returns (uint256);
    function ownerOf(uint256 tokenId) public view virtual returns (address);
    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual;
    function transferFrom(address from, address to, uint256 tokenId) public virtual;
    function approve(address to, uint256 tokenId) public virtual;
    function getApproved(uint256 tokenId) public view virtual returns (address);
    function setApprovalForAll(address operator, bool _approved) public virtual;
    function isApprovedForAll(address owner, address operator) public view virtual returns (bool);
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual;
}

abstract contract ERC721TokenReceiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data) public virtual returns (bytes4);
}

contract ERC721Mintable is ERC721 {
  
    uint256 public tokenCount = 0;
    mapping(uint256 => address) private _tokenOwners;
    mapping(address => mapping (address => bool)) private _operatorApprovals;
    mapping(uint256 => string) private _tokenURIs;
    event Minted(address indexed owner, uint256 indexed amount, address indexed delegate);

    function mint(address to, uint256 amount, address delegate) public {
        for(uint i=0; i<amount; i++){
            _mint(to, tokenCount);
            emit Minted(to, amount, delegate);
            tokenCount += 1;
        }
    }

    function _mint(address to, uint256 tokenId) internal {
        require(to != address(0), ""ERC721: mint to the zero address"");
        _tokenOwners[tokenId] = to;
        emit Transfer(address(0), to, tokenId);
    }
    
    function balanceOf(address owner) public view override returns (uint256){
        uint256 tokenCount = 0;
        for (uint i=0; i<tokenCount; i++){
            if (_tokenOwners[i] == owner){
                tokenCount += 1;
            }
        }
        return tokenCount;
    }

    function ownerOf(uint256 tokenId) public view override returns (address) {
        return _tokenOwners[tokenId];
    }
    
    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {
        _tokenURIs[tokenId] = _tokenURI;
    }
    
    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {
        return _tokenURIs[tokenId];
    }

    function supportsInterface(bytes4 interfaceId) public view override returns (bool){
        return interfaceId == type(ERC721).interfaceId
            || interfaceId == type(ERC721TokenReceiver).interfaceId;
    }
}","Create a Solidity smart contract that allows token minting and tracks token count. The contract should inherit from ERC721 and include a function for minting new tokens. The function should take owner's address, token amount, and delegate's address as parameters and emit an event for tracking minting activity. Focus on implementing the necessary functions and views for token URI generation."
contract_250.sol,"pragma solidity ^0.8.0;

// SafeMath library that prevents overflow errors
library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");

        return c;
    }

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, ""SafeMath: subtraction overflow"");
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");

        return c;
    }

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, ""SafeMath: division by zero"");
    }
}

contract ERC20Basic {
    string public constant name = ""Token Name"";
    string public constant symbol = ""SYM"";
    uint8 public constant decimals = 18;  
    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed owner, address indexed spender, uint tokens);

    using SafeMath for uint;
    
    uint totalSupply_;
    mapping(address => uint) balances;
    mapping(address => mapping (address => uint)) allowed;
  
    constructor(uint total) {
        totalSupply_ = total;
        balances[msg.sender] = totalSupply_;
    }

    function totalSupply() public view returns (uint) {
        return totalSupply_;
    }

    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }

    function transfer(address receiver, uint numTokens) public returns (bool) {
        require(numTokens <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(numTokens);
        balances[receiver] = balances[receiver].add(numTokens);
        emit Transfer(msg.sender, receiver, numTokens);
        return true;
    }

    function approve(address delegate, uint numTokens) public returns (bool) {
        allowed[msg.sender][delegate] = numTokens;
        emit Approval(msg.sender, delegate, numTokens);
        return true;
    }

    function allowance(address owner, address delegate) public view returns (uint) {
        return allowed[owner][delegate];
    }

    function transferFrom(address owner, address buyer, uint numTokens) public returns (bool) {
        require(numTokens <= balances[owner]);    
        require(numTokens <= allowed[owner][msg.sender]);

        balances[owner] = balances[owner].sub(numTokens);
        allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);
        balances[buyer] = balances[buyer].add(numTokens);
        emit Transfer(owner, buyer, numTokens);
        return true;
    }
}","Create a smart contract that follows the ERC20 token standard, allowing for token transfers, approvals, and allowance management. Use the SafeMath library for mathematical operations. Implement data structures to track token balances, ownership, and allowance details within the contract. Focus on ensuring the functionality and security of the contract."
contract_86.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name;
    string public symbol;
    uint8 public decimals;

    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;
    address public owner;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor (string memory _name, string memory _symbol, uint8 _decimals, uint256 initialSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        owner = msg.sender;
        _totalSupply = initialSupply * 10 ** uint256(decimals);
        _balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        require(msg.sender == owner);
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _balances[msg.sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);

        return true;
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function increaseApproval(address spender, uint addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }

    function decreaseApproval(address spender, uint subtractedValue) public returns (bool) {
        uint256 oldValue = _allowances[msg.sender][spender];
        if (subtractedValue >= oldValue) {
            _allowances[msg.sender][spender] = 0;
        } else {
            _allowances[msg.sender][spender] = oldValue - subtractedValue;
        }
        emit Approval(msg.sender, spender, _allowances[msg.sender][spender]);
        return true;
    }

    function burn(uint256 amount) public {
        require(msg.sender == owner);
        _burn(msg.sender, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _burn(address account, uint256 amount) internal {
        require(account != address(0), ""ERC20: burn from the zero address"");
        require(_balances[account] >= amount, ""ERC20: burn amount exceeds balance"");
        _balances[account] -= amount;
        _totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }
}","Create a smart contract that allows for minting of a new token, with specific name, symbol, and decimals. The contract should also enable token transfer, allow for approval and increase/decrease approval, and implement burn functionality. Ownership is also important, ensuring that only the owner can transfer tokens."
contract_8.sol,"pragma solidity ^0.8.0;
    
contract DividendBank {
    struct Investor {
        uint balance;
        uint lastDividends;
    }

    mapping(address => Investor) public investors;
    uint public totalInvestors;
    uint public totalInvested;
    uint public totalDividends;
    uint public fees;
        
    event Withdrawn(address indexed user, uint amount);
        
    function deposit() public payable {
        require(msg.value > 0, ""Deposit value must be higher than zero"");
        
        if (investors[msg.sender].balance == 0) {
            totalInvestors += 1;
        }
        
        investors[msg.sender].balance += msg.value;
        totalInvested += msg.value;
    }
        
    function withdraw(uint amount) public {
        require(investors[msg.sender].balance >= amount, ""Insufficient balance."");
        
        investors[msg.sender].balance -= amount;
        totalInvested -= amount;
        
        payable(msg.sender).transfer(amount);
        
        emit Withdrawn(msg.sender, amount);
    }

    function transfer(address receiver, uint amount) public {
        require(investors[msg.sender].balance >= amount, ""Insufficient balance."");
        
        investors[msg.sender].balance -= amount;
        investors[receiver].balance += amount;
    }

    function calculateDividends() public {
        uint dividends = address(this).balance - totalInvested - fees;
        
        totalDividends = dividends;

        if (totalInvestors > 0) {
            uint dividendPerInvestor = dividends / totalInvestors;

            for (uint i=0; i<totalInvestors; i++) {
                investors[msg.sender].lastDividends = dividendPerInvestor;
                investors[msg.sender].balance += dividendPerInvestor;
                totalInvested += dividendPerInvestor;
            }
        }
    }

    function balanceOf() public view returns (uint) {
        return investors[msg.sender].balance;
    }
    
    function dividendsOf() public view returns (uint) {
        return investors[msg.sender].lastDividends;
    }
}","Create a smart contract that manages user deposits, calculates dividends, and handles fees. The contract should include functions for depositing, withdrawing, and transferring funds. Implement a mapping to store user information. Develop an event handler for withdrawing funds. Implement a calculation function for dividend distribution and inflation handling."
contract_210.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract FreezableToken {
    mapping (address => uint256) private _balances;
    mapping (address => bool) private _frozenAccounts;
    mapping (address => mapping (address => uint256)) private _allowances;
    uint256 private _totalSupply;
    address private _owner;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event FrozenAccounts(address target, bool frozen);
    event Burn(address indexed from, uint256 value);

    constructor(uint256 initialSupply) {
        _totalSupply = initialSupply;
        _balances[msg.sender] = initialSupply;
        _owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == _owner, ""Only owner can call this function."");
        _;
    }

    modifier notFrozen {
        require(!_frozenAccounts[msg.sender], ""Account is frozen."");
        _;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public notFrozen returns (bool) {
        require(recipient != address(0), ""Transfer to the zero address"");
        require(_balances[msg.sender] >= amount, ""Insufficient balance."");

        _balances[msg.sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public notFrozen returns (bool) {
        require(spender != address(0), ""Approval to the zero address"");

        _allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public notFrozen returns (bool) {
        require(sender != address(0), ""Transfer from the zero address"");
        require(recipient != address(0), ""Transfer to the zero address"");
        require(_balances[sender] >= amount, ""Insufficient balance."");
        require(_allowances[sender][msg.sender] >= amount, ""Transfer amount exceeds allowance"");

        _balances[sender] -= amount;
        _balances[recipient] += amount;
        _allowances[sender][msg.sender] -= amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }

    function freezeAccount(address target) public onlyOwner {
        _frozenAccounts[target] = true;
        emit FrozenAccounts(target, true);
    }

    function unfreezeAccount(address target) public onlyOwner {
        _frozenAccounts[target] = false;
        emit FrozenAccounts(target, false);
    }

    function burn(uint256 amount) public onlyOwner returns (bool success) {
        require(_balances[msg.sender] >= amount, ""Insufficient balance."");
        _balances[msg.sender] -= amount;
        _totalSupply -= amount;
        emit Burn(msg.sender, amount);
        return true;
    }
}","Create a smart contract that represents a token, enabling users to transfer tokens, freeze/unfreeze accounts, and manage token supply. The contract should include functions for calculating total supply, checking account balances, and managing allowances. Include modifiers to restrict access to certain functions, such as pausing/unpausing token transfers. Ensure the contract is secure, with error handling for invalid mathematical operations, and includes necessary events for auditing and tracking changes."
contract_107.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC165 {
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

interface IERC721 is IERC165 {
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function balanceOf(address owner) external view returns (uint256 balance);
    function ownerOf(uint256 tokenId) external view returns (address owner);
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    function transferFrom(address from, address to, uint256 tokenId) external;
    function approve(address to, uint256 tokenId) external;
    function getApproved(uint256 tokenId) external view returns (address operator);
    function setApprovalForAll(address operator, bool _approved) external;
    function isApprovedForAll(address owner, address operator) external view returns (bool);
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
}

interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}

contract MyERC721Token is IERC721 {

    address private _contractOwner;
    uint256 private _totalTokens;
    string private _tokenName;
    string private _tokenSymbol;
    
    mapping(uint256 => address) private _tokenOwners;
    mapping(address => mapping (address => bool)) private _operatorApprovals;
    mapping(address => uint256) private _ownedTokensCount;

    constructor(string memory name, string memory symbol) {
        _contractOwner = msg.sender;
        _tokenName = name;
        _tokenSymbol = symbol;
    }
    
    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {
        return interfaceId == this.supportsInterface.selector;
    }

    function balanceOf(address owner) public view override returns (uint256) {
        require(owner != address(0), ""ERC721: balance query for the zero address"");
        return _ownedTokensCount[owner];
    }

    function ownerOf(uint256 tokenId) public view override returns (address) {
        address owner = _tokenOwners[tokenId];
        require(owner != address(0), ""ERC721: owner query for nonexistent token"");
        return owner;
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) public override {
        this.safeTransferFrom(from, to, tokenId, """");
    }

    function transferFrom(address from, address to, uint256 tokenId) public override {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _transfer(from, to, tokenId);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public override {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _transfer(from, to, tokenId);
        
        require(_checkOnERC721Received(from, to, tokenId, data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function approve(address to, uint256 tokenId) public override {
        address owner = ownerOf(tokenId);
        require(to != owner, ""ERC721: approval to current owner"");
        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), ""ERC721: approve caller is not owner nor approved for all"");
        
        _operatorApprovals[owner][to] = true;
        emit Approval(ownerOf(tokenId), to, tokenId);
    }

    function setApprovalForAll(address to, bool approved) public override {
        require(to != msg.sender, ""ERC721: approve to caller"");
        
        _operatorApprovals[msg.sender][to] = approved;
        emit ApprovalForAll(msg.sender, to, approved);
    }

    function getApproved(uint256 tokenId) public view override returns (address) {
        require(_exists(tokenId), ""ERC721: approved query for nonexistent token"");
        
        return _operatorApprovals[_contractOwner][msg.sender];
    }

    function isApprovedForAll(address owner, address operator) public view override returns (bool) {
        return _operatorApprovals[owner][operator];
    }
    
    function _exists(uint256 tokenId) internal view returns (bool) {
        return _tokenOwners[tokenId] != address(0);
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    function _safeMint(address to, uint256 tokenId) internal virtual {
        _safeMint(to, tokenId, """");
    }

    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {
        _mint(to, tokenId);
        require(_checkOnERC721Received(address(0), to, tokenId, _data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _mint(address to, uint256 tokenId) internal virtual {
        require(to != address(0), ""ERC721: mint to the zero address"");
        require(!_exists(tokenId), ""ERC721: token already minted"");
        _beforeTokenTransfer(address(0), to, tokenId);
        _totalTokens += 1;
        _tokenOwners[tokenId] = to;
        _ownedTokensCount[to] += 1;
        emit Transfer(address(0), to, tokenId);
    }

    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)
        internal returns (bool)
    {
        if (!to.isContract()) {
            return true;
        }
        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);
        return (retval == _ERC721_RECEIVED);
    }
    
    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }

    function _transfer(address from, address to, uint256 tokenId) private {
        require(ownerOf(tokenId) == from, ""ERC721: transfer of token that is not own"");
        require(to != address(0), ""ERC721: transfer to the zero address"");

        _ownedTokensCount[from] -= 1;
        _ownedTokensCount[to] += 1;

        _tokenOwners[tokenId] = to;

        emit Transfer(from, to, tokenId);
    }

    function _burn(uint256 tokenId) internal virtual {
        address owner = ownerOf(tokenId);

        _beforeTokenTransfer(owner, address(0), tokenId);

        // Clear approvals
        _approve(address(0), tokenId);

        _ownedTokensCount[owner] -= 1;
        _totalTokens -= 1;
        delete _tokenOwners[tokenId];

        emit Transfer(owner, address(0), tokenId);
    }

    function _approve(address to, uint256 tokenId) private {
        _tokenApprovals[tokenId] = to;
        emit Approval(ownerOf(tokenId), to, tokenId);
    }
    
    function renameToken(string memory newName) external {
        require(msg.sender == _contractOwner, ""Only contract owner can rename token"");
        _tokenName = newName;
    }
}","Develop a smart contract that follows the IERC721 standard for managing unique digital assets. The contract should include functions for transferring ownership, approving operators, and querying token balances. Implement methods for setting and retrieving token metadata, such as token names and symbols. Include support for ERC721Receiver events and consider adding features for token burning, conversion, or renaming. Structure the contract with clear and readable code, and include basic documentation for the contract's variables, functions, and events."
contract_231.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

library SafeMath {
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a, ""SafeMath: addition overflow"");
    return c;
  }
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    return sub(a, b, ""SafeMath: subtraction overflow"");
  }
  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
    require(b <= a, errorMessage);
    uint256 c = a - b;
    return c;
  }
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    require(c / a == b, ""SafeMath: multiplication overflow"");
    return c;
  }
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    return div(a, b, ""SafeMath: division overflow"");
  }
  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
    require(b > 0, errorMessage);
    uint256 c = a / b;
    return c;
  }
}

contract ERC20 is Context, IERC20 {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;

    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;
    address private _newContract;

    constructor (uint256 initialSupply) {
        _mint(_msgSender(), initialSupply);
    }

    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view virtual override returns (uint256) {
        if (_newContract != address(0)) {
            return IERC20(_newContract).balanceOf(account);
        } else {
            return _balances[account];
        }
    }

    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        require(_newContract == address(0), ""Please migrate to the new contract"");

        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        require(_newContract == address(0), ""Please migrate to the new contract"");

        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, ""ERC20: transfer amount exceeds allowance""));
        return true;
    }

    function migrateTo(address newAddress) public {
        require(_msgSender() == _newContract || _newContract == address(0), ""Only the new contract can set the target address"");

        _newContract = newAddress;
    }

    function airdrop(address[] memory recipients, uint256[] memory values) public {
        require(_newContract == address(0));
        require(recipients.length == values.length, ""Arrays must be of the same length"");

        for (uint256 i = 0; i < recipients.length; i++) {
            _transfer(_msgSender(), recipients[i], values[i]);
        }
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _balances[sender] = _balances[sender].sub(amount, ""ERC20: transfer amount exceeds balance"");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}","Create a simple ERC20 token contract with basic functionality, including token transfers, approvals, and balance queries. Include a migration feature to allow tokens to be transferred to a new version of the contract. The contract should allow for token airdrops and support for older contract versions. The code should be easy to understand and follow best practices for Solidity smart contract development."
contract_144.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

abstract contract InterestRateModel {

    function isInterestRateModel() external virtual pure returns (bool) {
        return false;
    }

    function getBorrowRate(uint cash, uint borrows, uint reserves) external virtual pure returns (bool, uint);
}

contract ExtendedInterestRateModel is InterestRateModel {
    uint public baseRatePerYear;
    uint public multiplierPerYear;

    constructor(uint baseRatePerYear_, uint multiplierPerYear_) {
        baseRatePerYear = baseRatePerYear_;
        multiplierPerYear = multiplierPerYear_;
    }

    function isInterestRateModel() external pure override returns (bool) {
        return true;
    }

    function getBorrowRate(uint cash, uint borrows, uint reserves) external pure override returns (bool, uint) {
        uint utilizationRate = (borrows * 1e18) / (cash + borrows - reserves);

        if (utilizationRate > 0.9 ether)
            return (false, 0);

        uint normalRate = (baseRatePerYear + utilizationRate * multiplierPerYear) / 1e18;

        return (true, normalRate);
    }
}","Create a smart contract that extends the InterestRateModel contract. The contract should have a function that calculates the interest rate for borrowing based on the amount of cash, borrows, and reserves. The rate calculation should be influenced by the amount of borrows. The function should return a success flag and the calculated rate. A separate function should be added to verify if the contract is an InterestRateModel."
contract_22.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract ERC20Base is IERC20 {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public _totalSupply;
    mapping (address => uint256) public _balances;
    mapping (address => mapping (address => uint256)) public _allowances;

    constructor(string memory tokenName, string memory tokenSymbol, uint8 decimalUnits, uint256 initialSupply) {
        name = tokenName;
        symbol = tokenSymbol;
        decimals = decimalUnits;
        _totalSupply = initialSupply * 10**uint256(decimals);
        _balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) internal {
        require(account != address(0), ""ERC20: burn from the zero address"");

        _balances[account] -= amount;
        _totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _msgSender() internal view returns (address payable) {
        return payable(msg.sender);
    }
}


contract ERC20Mintable is ERC20Base {
    constructor(string memory name, string memory symbol, uint8 decimals, uint256 initialSupply)
        ERC20Base(name, symbol, decimals, initialSupply) {}

    function mint(address account, uint256 amount) public {
        _mint(account, amount);
    }

    function burn(address account, uint256 amount) public {
        _burn(account, amount);
    }
}","Create a smart contract that allows for token minting and burning, with approval and allowance management. The contract should include functions for getting the token name, symbol, decimal precision, total supply, and balance. Implement a system for transferring tokens between addresses, with allowance management for approving and revoking spending limits. Ensure the contract has a clear and consistent interface for users."
contract_53.sol,"pragma solidity ^0.8.0;

contract SimpleERC20Token {
    string public constant name = ""SimpleERC20"";
    string public constant symbol = ""SERC20"";
    uint8 public constant decimals = 18;

    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    event Transfer(address indexed from, address indexed to, uint tokens);

    mapping(address => uint256) balances;
    mapping(address => mapping (address => uint256)) allowed;
    uint256 totalSupply_ = 10**6 * 10**uint(decimals);

    using SafeMath for uint256;

    constructor() {
        balances[msg.sender] = totalSupply_;
    }

    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }

    function balanceOf(address tokenOwner) public view returns (uint256) {
        return balances[tokenOwner];
    }

    function transfer(address receiver, uint256 numTokens) public returns (bool) {
        require(numTokens <= balances[msg.sender], ""Insufficient Balance"");
        balances[msg.sender] = balances[msg.sender].sub(numTokens);
        balances[receiver] = balances[receiver].add(numTokens);
        emit Transfer(msg.sender, receiver, numTokens);
        return true;
    }

    function approve(address delegate, uint256 numTokens) public returns (bool) {
        require(numTokens <= balances[msg.sender], ""Insufficient Balance"");
        allowed[msg.sender][delegate] = numTokens;
        emit Approval(msg.sender, delegate, numTokens);
        return true;
    }

    function allowance(address owner, address delegate) public view returns (uint) {
        return allowed[owner][delegate];
    }

    function transferFrom(address owner, address buyer, uint256 numTokens) public returns (bool) {
        require(numTokens <= balances[owner], ""Insufficient Balance"");    
        require(numTokens <= allowed[owner][msg.sender], ""Insufficient Allowance"");
        
        balances[owner] = balances[owner].sub(numTokens);
        allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);
        balances[buyer] = balances[buyer].add(numTokens);
        emit Transfer(owner, buyer, numTokens);
        return true;
    }
}

library SafeMath {
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
      assert(b <= a);
      return a - b;
    }
    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
      uint256 c = a + b;
      assert(c >= a);
      return c;
    }
}

contract ModuleSystem {

    mapping (string => Module) public modules;

    struct Module {
        bool exists;
        address moduleAddress;
    }

    function addModule(string memory moduleName, address moduleAddress) public {
        modules[moduleName] = Module(true, moduleAddress);
    }
    
    function removeModule(string memory moduleName) public {
        delete modules[moduleName];
    }
}","Create a smart contract that interacts with the provided ERC20 token. The contract should allow token transfers and update the allowance for the token owner. Implement a system for adding and removing modules, and enable static calls. Include functions for calculating the total supply of the token and querying the balance of a specific token owner. Focus on functionality and ease of use, ensuring that the contract can handle a large number of token owners. Do not worry about optimization for scalability."
contract_33.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Base {
    
    string internal internalStateVariable = ""Internal State Variable"";
    string public publicStateVariable = ""Public State Variable"";

    function privateFunction() private pure returns(string memory) {
        return ""Private Function Executed"";
    }

    function internalFunction() internal pure returns(string memory) {
        return ""Internal Function Executed"";
    }
    
    function publicFunction() public pure returns(string memory) {
        return ""Public Function Executed"";
    }

    function testPrivateFunction() public pure returns(string memory) {
        //uncommenting this would result in an error, as private functions can't be accessed outside the contract
        //return privateFunction();
    }

    function testInternalFunction() public pure returns(string memory) {
        //uncommenting this would work, as this function exists inside the same contract
        //return internalFunction();
    }

    function testPublicFunction() public pure returns(string memory) {
        return publicFunction();
    }
}

contract Child is Base {

    function overrideInternalFunction() internal pure override returns(string memory) {
        return ""Overridden Internal Function Executed"";
    }
    
    function testOverriddenInternalFunction() public pure returns(string memory) {
        //uncommenting this would work, as this function is callable in this contract
        //return overrideInternalFunction();
    }

    function testInheritedPublicFunction() public pure returns(string memory) {
        return publicFunction();
    }
}","Create a smart contract that demonstrates inheritance and function visibility. The contract should have a base contract (Base) that defines private, internal, and public functions. The child contract should override internal functions and call them. Ensure that private functions are inaccessible outside the contract. The contract should also include public and internal state variables. Write test functions to demonstrate the functionality of each type of function."
contract_124.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        return a - b;
    }
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        return a / b;
    }
}

contract Token {
    using SafeMath for uint256;

    string public constant name = ""MyToken"";
    string public constant symbol = ""MYT"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balances;
    mapping(address => mapping (address => uint256)) private _allowances;

    constructor(uint256 initialSupply) {
        balances[msg.sender] = initialSupply;
        totalSupply = initialSupply;
        emit Transfer(address(0), msg.sender, initialSupply);
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""Transfer from the zero address"");
        require(recipient != address(0), ""Transfer to the zero address"");
        balances[sender] = balances[sender].sub(amount);
        balances[recipient] = balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""Approve from the zero address"");
        require(spender != address(0), ""Approve to the zero address"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}","Create a token contract that enables token transfer between addresses, approves external transactions, and tracks token balances. The contract should provide functions for allowing and withdrawing token approvals. Implement arithmetic operations using the SafeMath library to ensure security. Include a constructor to set the initial token supply and owner."
contract_142.sol,"pragma solidity ^0.8.0;

contract ValueSet {

    struct Set {
        uint256[] list;
        mapping(uint256 => bool) map;
    }
    
    Set private valueSet;

    function addValue(uint256 _value) public {
        require(!valueSet.map[_value], ""Value already present in Set"");
        valueSet.map[_value] = true;
        valueSet.list.push(_value);
    }

    function removeValue(uint256 _value) public {
        require(valueSet.map[_value], ""Value not present in Set"");
        for (uint256 i = 0; i < valueSet.list.length; i++) {
            if (valueSet.list[i] == _value) {
                valueSet.list[i] = valueSet.list[valueSet.list.length - 1];
                valueSet.list.pop();
                break;
            }
        }
        valueSet.map[_value] = false;
    }

    function isValuePresent(uint256 _value) public view returns (bool){
        return valueSet.map[_value];
    }

    function getSetSize() public view returns (uint256) {
        return valueSet.list.length;
    }

    function getValueAt(uint256 _index) public view returns (uint256) {
        require(_index < valueSet.list.length, ""Index out of bounds"");
        return valueSet.list[_index];
    }
}","Develop a smart contract that provides a data structure for storing and managing a set of values. This set should allow for efficient addition, removal, and membership checking. Implement the necessary logic for maintaining the set's storage and indexing. Include functions for setting and getting the set's length and individual values. Ensure the contract is well-structured and follows best practices in Solidity syntax and organization."
contract_230.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GameContract {
    struct Player {
        uint id;
        string name;
        uint stage;
    }

    struct Stage {
        uint id;
        string name;
        uint reward;
    }

    mapping(address => Player) private players;
    mapping(uint => Stage) private stages;
    uint private stageCounter = 0;
    uint private playerCount = 0;

    event PlayerAdvancedStage(address indexed playerAddress, uint currentStage, uint reward);

    constructor() {
        _addNewStage(""Stage 1"", 50);
        _addNewStage(""Stage 2"", 100);
        _addNewStage(""Stage 3"", 200);
    }

    function joinGame(string memory _name) public {
        require(players[msg.sender].id == 0, ""You have already joined"");
        playerCount++;
        players[msg.sender] = Player(playerCount, _name, 0);
    }

    function advanceStage() public {
        require(players[msg.sender].id != 0, ""You haven't joined the game"");
        require(players[msg.sender].stage < stageCounter, ""You have already completed all stages"");
        
        uint randomNum = _getRandomNumber();
        if(randomNum > 50) {
            players[msg.sender].stage++;
            uint reward = stages[players[msg.sender].stage].reward;
            payable(msg.sender).transfer(reward);
            emit PlayerAdvancedStage(msg.sender, players[msg.sender].stage, reward);
        }
    }

    function getCurrentPlayerStage() public view returns (uint) {
        return players[msg.sender].stage;
    }

    function _addNewStage(string memory _name, uint _reward) private {
        stageCounter++;
        stages[stageCounter] = Stage(stageCounter, _name, _reward);
    }

    function _getRandomNumber() private view returns (uint) {
        return uint(keccak256(abi.encodePacked(block.timestamp, block.difficulty))) % 100;
    }

    receive() external payable {}
}","Create a smart contract that manages a game with multiple stages, where players can participate and receive rewards. The contract should include functions for initializing game stages, tracking player progress, and distributing rewards. Implement a random number generator to determine game outcomes and ensure fairness. Consider incorporating data structures and algorithms to optimize performance."
contract_21.sol,"pragma solidity ^0.8.0;

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;

        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;

        return c;
    }
}

contract Logarithm {
    using SafeMath for uint256;

    uint256 private constant LOG_BASE = 10000;

    function logarithm(uint256 value) public pure returns (uint256) {
        require(value > 0, ""Logarithm: invalid input"");

        uint256 log;
        while (value >= LOG_BASE) {
            value = value.div(LOG_BASE);
            log = log.add(LOG_BASE);
        }

        for (uint256 i = LOG_BASE.div(2); i > 0; i = i.div(2)) {
            if (value >= LOG_BASE.add(i)) {
                value = value.mul(LOG_BASE).div(LOG_BASE.add(i));
                log = log.add(i);
            }
        }

        return log;
    }
}",Create a smart contract that accurately calculates logarithmic values for specific input values. Utilize the provided table of constants and implement a function that takes an unsigned integer as input and returns the corresponding logarithmic value. Ensure that the implementation seamlessly integrates with the existing code and utilizes safe arithmetic operations. Include relevant documentation comments and provide examples of how to use the contract.
contract_69.sol,"pragma solidity ^0.8.0;

contract FacetBase {
    event DiamondCut(bytes[] _diamondCut, address[] _newFacets, bytes32 _selectorPositions);
}

struct Facet {
    address facetAddress;
    bytes4[] functionSelectors;
}

contract Diamond {

    mapping(bytes4 => address) public facetAddress;
    mapping(address => Facet) public facet;
    bytes4[] functionSelectors;

    function diamondCut(Facet[] memory _facets) public {
        for(uint i = 0; i < _facets.length; i++) {
            facet[_facets[i].facetAddress] = _facets[i];
            for(uint j = 0; j < _facets[i].functionSelectors.length; j++) {
                facetAddress[_facets[i].functionSelectors[j]] = _facets[i].facetAddress;
                functionSelectors.push(_facets[i].functionSelectors[j]);
            }
        }
        emit DiamondCut(functionSelectors, _facets.facetAddress, bytes32(functionSelectors.length));
    }

    fallback() external payable {
        address targetFacetAddress = facetAddress[msg.sig];
        require(targetFacetAddress != address(0), ""Function does not exist."");
        assembly {
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(gas(), targetFacetAddress, 0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())
            switch result
            case 0 { revert(0, returndatasize()) }
            default { return(0, returndatasize()) }
        }
    }
}","Develop a Solidity smart contract that provides a diamond cut facet. The contract should enable users to add, replace, or remove functions from facets and execute functions with delegatecall. Consider the technical aspects of implementing this functionality, such as function selectors and facet addresses."
contract_129.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    // Mapping of address balance
    mapping (address => uint256) private _balances;

    // Mapping of approvals
    mapping (address => mapping (address => uint256)) private _allowances;

    // Token Details
    uint256 private _totalSupply;
    string private _name;
    string private _symbol;
    address private _owner;

    // Events
    event Transfer(address indexed sender, address indexed recipient, uint256 amount);
    event Approval(address indexed owner, address indexed spender, uint256 amount);

    constructor(string memory name_, string memory symbol_, uint256 totalSupply_) {
        _name = name_;
        _symbol = symbol_;
        _totalSupply = totalSupply_;
        _balances[msg.sender] = _totalSupply;
        _owner = msg.sender;
    }

    // Return name of token
    function name() public view returns (string memory) {
        return _name;
    }

    // Return symbol of token
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    // Return total supply of token
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    // Return balance of given address
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    // Transfer token to a specific address
    function transfer(address recipient, uint256 amount) public returns (bool) {
        require(msg.sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");
        require(_balances[msg.sender] >= amount, ""ERC20: transfer amount exceeds balance"");
 
        _balances[msg.sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);

        return true;
    }

    // Allow spender to withdraw from your account
    function approve(address spender, uint256 amount) public returns (bool) {
        require(spender != address(0), ""ERC20: approval to the zero address"");

        _allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    // Return allowance of spender
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    // Transfer with approval
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public returns (bool) {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");
        require(_balances[sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        require(_allowances[sender][msg.sender] >= amount, ""ERC20: transfer amount exceeds allowance"");

        _balances[sender] -= amount;
        _allowances[sender][msg.sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);

        return true;
    }    
}","Create a smart contract that is similar to an existing one, but with some modifications. The contract should be based on the provided code and should implement a new token with its own symbol, name, and contract owner. The contract should allow for token transfers and approvals, and should emit events when such actions occur. Include a constructor to initialize the contract's main variables."
contract_232.sol,"pragma solidity ^0.8.0;

// Interfaces and Libraries

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

interface IERC721 {
    function ownerOf(uint256 tokenId) external view returns (address owner);
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;

        return c;
    }
}

// Main Contract

contract NFTMarketplaceWithStaking {
    using SafeMath for uint256;

    struct NFT {
        address contractAddress; 
        uint256 id;
        uint256 price;
        address payable owner;
        uint256 royalties;
    }

    mapping(uint256 => NFT) public NFTs;
    uint256 public nftCount;
    
    address public tokenAddress;

    constructor (address _tokenAddress) {
        tokenAddress = _tokenAddress;
    }

    function mintToken(uint256 price, uint256 royalties, address contractAddress, uint256 id) external {
        require(IERC721(contractAddress).isApprovedForAll(msg.sender, address(this)), ""Contract not approved"");
        
        NFTs[nftCount] = NFT(contractAddress, id, price, payable(msg.sender), royalties);
        nftCount = nftCount.add(1);
    }

    function buyToken(uint256 _nftId) external {
        require(IERC20(tokenAddress).transferFrom(msg.sender, NFTs[_nftId].owner, NFTs[_nftId].price), ""Transfer failed"");

        uint256 royalties = NFTs[_nftId].price.mul(NFTs[_nftId].royalties).div(100);
        NFTs[_nftId].owner.transfer(royalties);
        NFTs[_nftId].owner = payable(msg.sender);
    }

    function stakeTokens(uint256 amount) external {
        require(IERC20(tokenAddress).transferFrom(msg.sender, address(this), amount), ""Transfer failed"");
        // Implement staking logic here
    }

    function unstakeTokens(uint256 amount) external {
        require(IERC20(tokenAddress).balanceOf(address(this)) >= amount, ""Not enough tokens staked"");
        require(IERC20(tokenAddress).transferFrom(address(this), msg.sender, amount), ""Transfer failed"");
        // Implement unstaking logic here
    }

    function getCurrentTokenSupply() external view returns(uint256) {
        return IERC20(tokenAddress).balanceOf(address(this));
    }
}","Create a smart contract that enables the creation and trading of unique tokens. The contract should allow users to mint tokens, set prices, and manage token metadata. Consider incorporating features like token attributes, royalty payments, and dynamic presale and sale activation. Pay close attention to token supply management, fund allocation, and staking mechanics. Ensure the contract handles arithmetic operations securely by utilizing SafeMath."
contract_41.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC721 {

    string public name;
    string public symbol;

    mapping(address => uint) private _balances;
    mapping(uint => address) private _owners;
    mapping(uint => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    event Transfer(address indexed from, address indexed to, uint indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    constructor(string memory _name, string memory _symbol) {
        name = _name;
        symbol = _symbol;
    }

    function balanceOf(address owner) public view returns (uint balance) {
        require(owner != address(0));
        return _balances[owner];
    }

    function ownerOf(uint tokenId) public view returns (address owner) {
        owner = _owners[tokenId];
        require(owner != address(0));
        return owner;
    }

    function safeTransferFrom(address from, address to, uint tokenId, bytes memory data) public {
        transferFrom(from, to, tokenId);
        if(to.isContract()) {
            bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data);
            require(retval == ERC721_RECEIVED);
        }
    }

    function safeTransferFrom(address from, address to, uint tokenId) public {
        safeTransferFrom(from, to, tokenId, """");
    }

    function transferFrom(address from, address to, uint tokenId) public {
        require(ownerOf(tokenId) == msg.sender || getApproved(tokenId) == msg.sender || isApprovedForAll(ownerOf(tokenId), msg.sender));
        _transfer(from, to, tokenId);
    }

    function approve(address approved, uint tokenId) public {
        require(ownerOf(tokenId) == msg.sender || isApprovedForAll(ownerOf(tokenId), msg.sender));
        _approve(approved, tokenId);
    }

    function setApprovalForAll(address operator, bool approved) public {
        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function getApproved(uint tokenId) public view returns (address operator) {
        require(_exists(tokenId));
        return _tokenApprovals[tokenId];
    }

    function isApprovedForAll(address owner, address operator) public view returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function _mint(address to, uint tokenId) internal {
        require(to != address(0));
        _balances[to]++;
        _owners[tokenId] = to;
        emit Transfer(address(0), to, tokenId);
    }

    function _burn(uint tokenId) internal {
        address owner = ownerOf(tokenId);
        _balances[owner]--;
        delete _owners[tokenId];
        emit Transfer(owner, address(0), tokenId);
    }

    function _exists(uint tokenId) internal view returns (bool) {
        return _owners[tokenId] != address(0);
    }

    function _transfer(address from, address to, uint tokenId) internal {
        require(from != address(0));
        require(to != address(0));
        _balances[from]--;
        _balances[to]++;
        _owners[tokenId] = to;
        emit Transfer(from, to, tokenId);
    }
}

interface IERC721Receiver {

    bytes4 constant ERC721_RECEIVED = 0x150b7a02;

    function onERC721Received(address operator, address from, uint tokenId, bytes calldata data) external returns (bytes4);
}","Create a smart contract for managing ERC721 tokens, including minting, transferring, and burning tokens. The contract should be pauseable and log all token events. Implement logic for handling gas costs and rejecting failed transactions. Include functions for minting and burning tokens, as well as functions for transferring and withdrawing tokens. Utilize relevant inheritances and interfaces from existing ERC721 contracts, ensuring compatibility with other ERC721 token contracts. Provide a clear and organized Solidity code structure for this contract."
contract_196.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract FeeManager {
    uint private maxAllowedRate;
    uint private takerFee;
    uint private makerFee;
    address private admin;

    constructor(uint _maxAllowedRate) {
         require(_maxAllowedRate > 0, ""Maximum rate must be greater than 0"");
         maxAllowedRate = _maxAllowedRate;
         admin = msg.sender;
    }

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can call this function."");
        _;
    }

    function setTakerFee(uint _takerFee) public onlyAdmin {
        require(_takerFee <= maxAllowedRate, ""The fee is more than the max allowed."");
        takerFee = _takerFee;
    }

    function setMakerFee(uint _makerFee) public onlyAdmin {
        require(_makerFee <= maxAllowedRate, ""The fee is more than the max allowed."");
        makerFee = _makerFee;
    }

    function getTakerFee() public view returns (uint) {
        return takerFee;
    }

    function getMakerFee() public view returns (uint) {
        return makerFee;
    }

    function getMaxAllowedRate() public view returns (uint) {
        return maxAllowedRate;
    }

    function setMaxAllowedRate(uint _maxAllowedRate) public onlyAdmin {
        require(_maxAllowedRate > 0, ""Maximum rate must be greater than 0"");
        maxAllowedRate = _maxAllowedRate;
        if(takerFee > maxAllowedRate) {
            takerFee = maxAllowedRate;
        }
        if(makerFee > maxAllowedRate) {
            makerFee = maxAllowedRate;
        }
    }
}",Design a smart contract that manages fee settings for a decentralized platform. The contract should have two main functions: one to set the fee maker's rate and another to set the fee taker's rate. The fees should be represented as uint values and be bounded by a maximum allowed rate. The contract should provide a clean and structured way to manage these settings. Provide a general overview of the contract's architecture and functionality.
contract_118.sol,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract MembershipNFT is ERC721, Ownable, ReentrancyGuard {
    using SafeMath for uint256;

    struct SubscriptionPlan {
        uint256 duration; // in days
        uint256 price; // in wei
    }

    struct UserSubscription {
        uint256 expirationDate;
        uint256 planId;
    }

    uint256 private _currentTokenId = 0; // Current Token ID
    
    uint256 private _currentPlanId = 0; // Current Plan ID

    mapping(uint256 => SubscriptionPlan) private _subscriptionPlans; // Plan ID => Plan Details
    mapping(address => UserSubscription) private _userSubscriptions; // User Address => Subscription Details
    mapping(uint256 => address) private _tokenOwners; // Token ID => Owner Address

    constructor() ERC721(""Membership NFT"", ""MNFT"") {}

    /**
     * @dev Create a new subscription plan.
     */
    function createSubscriptionPlan(uint256 duration, uint256 price)
        public
        onlyOwner
    {
        _subscriptionPlans[_currentPlanId] = SubscriptionPlan(duration, price);
        _currentPlanId++;
    }

    /**
     * @dev Subscribe the sender to a plan.
     */
    function subscribeToPlan(uint256 planId) public payable nonReentrant {
        require(
            msg.value >= _subscriptionPlans[planId].price,
            ""Insufficient funds sent""
        );
        require(
            _userSubscriptions[msg.sender].expirationDate <= block.timestamp,
            ""Existing subscription must have expired""
        );

        _userSubscriptions[msg.sender] = UserSubscription(
            block.timestamp.add(_subscriptionPlans[planId].duration * 1 days),
            planId
        );
    }

    /**
     * @dev Mint a new token to the sender.
     */
    function mintToken() public {
        require(
            _userSubscriptions[msg.sender].expirationDate >= block.timestamp,
            ""Subscription must be active""
        );

        _mint(msg.sender, _currentTokenId);
        _tokenOwners[_currentTokenId] = msg.sender;
        _currentTokenId++;
    }

    /**
     * @dev Get the details of the sender's subscription.
     */
    function getUserSubscriptionDetails(address userAddress)
        public
        view
        returns (UserSubscription memory)
    {
        return _userSubscriptions[userAddress];
    }

    /**
     * @dev Return the owner of a token.
     */
    function ownerOf(uint256 tokenId) public view 
        override returns (address) 
    {
        address owner = _tokenOwners[tokenId];
        require(owner != address(0), ""Nonexistent token"");

        return owner;
    }
}","Create a smart contract that implements a subscription-based membership system for an NFT collection. The contract should allow users to subscribe to different plans, which specify the subscription duration and price. Develop functions to manage subscription plans, mint tokens, and track user subscriptions. Include checks for valid inputs and handle exceptions for invalid requests. Prioritize maintainability and scalability for future updates."
contract_20.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// Defining contract of ERC20 token
contract Token {
    mapping(address => uint) public balances;
    mapping(address => mapping(address => uint)) public allowance;
    uint public totalSupply = 1000000 * 10 ** 18;
    string public name = ""New Token"";
    string public symbol = ""NT"";
    uint public decimals = 18;

    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);

    constructor() {
        balances[msg.sender] = totalSupply;
    }

    function balanceOf(address owner) public view returns(uint) {
        return balances[owner];
    }

    function transfer(address to, uint value) public returns(bool) {
        require(balanceOf(msg.sender) >= value, 'balance too low');
        balances[to] += value;
        balances[msg.sender] -= value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint value) public returns(bool) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint value) public returns(bool) {
        require(balanceOf(from) >= value, 'balance too low');
        require(allowance[from][msg.sender] >= value, 'allowance too low');
        balances[to] += value;
        balances[from] -= value;
        emit Transfer(from, to, value);
        return true;
    }
}

// Liquidity provider contract
contract LiquidityProvider {
    Token private token;
    address public admin;
    uint public providerFee;
    uint public balance;
    uint public liquidity;

    constructor(Token _token, uint _providerFee) {
        token = _token;
        admin = msg.sender;
        providerFee = _providerFee;
    }

    function provideLiquidity(uint _liquidity) public {
        uint fee = (_liquidity * providerFee) / 100;
        require(token.transferFrom(msg.sender, address(this), _liquidity + fee), ""transfer from failed"");
        liquidity += _liquidity;
        balance += fee;
    }

    function removeLiquidity(uint _liquidity) public {
        require(liquidity >= _liquidity, 'Not enough liquidity');
        require(token.transfer(msg.sender, _liquidity), ""transfer failed"");
        liquidity -= _liquidity;
    }

    function swapTokens(address _to, uint _amount) public {
        require(_amount <= liquidity, 'Not enough liquidity');
        require(token.transfer(_to, _amount), ""transfer failed"");
        liquidity -= _amount;
    }

    function claimFees() public {
        require(msg.sender == admin, 'only admin');
        require(token.transfer(admin, balance), ""transfer failed"");
        balance = 0;
    }
}","Create a smart contract that allows for the management of tokens, enables the addition and removal of liquidity, and manages token swapping, admin fees, and LP earnings. Focus on implementing these functions in a logical and efficient manner."
contract_215.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

abstract contract ERC1155 {
    function balanceOf(address _owner, uint256 _id) virtual public view returns (uint256);
    function balanceOfBatch(address[] memory _owners, uint256[] memory _ids) virtual public view returns (uint256[] memory);
    function setApprovalForAll(address _operator, bool _approved) virtual public;
    function isApprovedForAll(address _owner, address _operator) virtual public view returns (bool);
    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes memory _data) virtual public;
    function safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _values, bytes memory _data) virtual public;
}

contract MyERC1155Token is ERC1155 {
    mapping (address => mapping(uint256 => uint256)) private balances;
    mapping (address => mapping(address => bool)) private operatorApprovals;

    function balanceOf(address _owner, uint256 _id) override public view returns (uint256) {
        return balances[_owner][_id];
    }

    function balanceOfBatch(address[] memory _owners, uint256[] memory _ids) override public view returns (uint256[] memory) {
        uint256[] memory batchBalances = new uint256[](_owners.length);

        for (uint256 i = 0; i < _owners.length; ++i) {
            batchBalances[i] = balances[_owners[i]][_ids[i]];
        }

        return batchBalances;
    }

    function setApprovalForAll(address _operator, bool _approved) override public {
        operatorApprovals[msg.sender][_operator] = _approved;
    }

    function isApprovedForAll(address _owner, address _operator) override public view returns (bool) {
        return operatorApprovals[_owner][_operator];
    }

    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes memory _data) override public {
        require(balances[_from][_id] >= _value, ""Insufficient balance"");
        balances[_from][_id] -= _value;
        balances[_to][_id] += _value;
    }

    function safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _values, bytes memory _data) override public {
        for(uint256 i = 0; i < _ids.length; i++) {
            require(balances[_from][_ids[i]] >= _values[i], ""Insufficient balance"");
            balances[_from][_ids[i]] -= _values[i];
            balances[_to][_ids[i]] += _values[i];
        }
    }
}","Create an ERC1155-compliant token standard that allows for flexible token management. The contract should enable token transfers, balance inquiries, and operator approval management. Implement the necessary functions, such as balanceOf, balanceOfBatch, setApprovalForAll, isApprovedForAll, safeTransferFrom, and safeBatchTransferFrom. Consider using mapping data structures to efficiently manage token balances and operator approvals. Write clear, concise documentation explaining the contract's functionality and technical implementation."
contract_98.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DeclarationOfDecentralization {
    address public admin;
    string public declaration;
    mapping(address => bool) public signatories;
    uint256 public signatoryCount;

    constructor(address _admin, string memory _declaration) {
        require(_admin != address(0), ""Invalid address"");
        admin = _admin;
        declaration = _declaration;
    }

    function addSignatory(address _signatory) public {
        require(msg.sender == admin, ""Only admin can add signatories"");
        require(_signatory != address(0), ""Invalid address"");
        require(!signatories[_signatory], ""Signatory already added"");

        signatories[_signatory] = true;
        signatoryCount += 1;
    }

    function sign() public {
        require(signatories[msg.sender], ""Only authorized signatories can sign"");
        
        signatories[msg.sender] = false;
        signatoryCount -= 1;
    }

    function modifyDeclaration(string memory _declaration) public {
        require(msg.sender == admin, ""Only admin can modify declaration"");
        declaration = _declaration;
    }
}",Create a smart contract to manage the Declaration of Decentralization (DoD). The contract should store the DoD text and allow signing by designated parties. Implement validation logic to ensure only authorized parties can modify the contract state. Incorporate a constructor to initialize the debot's address and the DoD text.
contract_39.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    event Transfer(address indexed from, address indexed to, uint256 value);
}

interface IStaking {
    function stake(uint256 amount) external;
}

contract StakingWarmUp {
    address public immutable stakingAddress;
    IERC20 public immutable sOHM;

    event Staked(address indexed staker, uint256 amount, uint256 timestamp);

    constructor(address _stakingAddress, address _sOHMAddress) {
        require(_stakingAddress != address(0), 'Staking address cannot be a zero address');
        require(_sOHMAddress != address(0), 'SOHM address cannot be a zero address');
        stakingAddress = _stakingAddress;
        sOHM = IERC20(_sOHMAddress);
    }

    function retrieve(uint256 _amount) external {
        require(msg.sender == stakingAddress, 'Only staking address is allowed to retrieve');
        uint256 sOHMBalance = sOHM.balanceOf(address(this));
        require(_amount <= sOHMBalance, 'Not enough SOHM in contract');
        sOHM.transferFrom(address(this), stakingAddress, _amount);
        emit Staked(stakingAddress, _amount, block.timestamp);
    }
}",Develop a Solidity smart contract that enables a staking warm-up mechanism. The contract should include: (1) Immutable addresses for staking and SOHM; (2) A constructor to initialize these addresses; (3) A retrieve function accessible only to the staking address; (4) This function should distribute specified amounts from SOHM to authorized stakers; and (5) Emit a transfer event for the transferred amount. The contract should adhere to standard best practices and follow proper smart contract development guidelines.
contract_55.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract AccessControl {
    mapping(address => bool) public accessRegistry;
    mapping(address => mapping(string => bool)) public permissionRegistry;

    event AccessGranted(address indexed user);
    event AccessRevoked(address indexed user);

    event PermissionGranted(address indexed user, string permission);
    event PermissionRevoked(address indexed user, string permission);

    address public admin;
    
    constructor() {
        admin = msg.sender;
    }

    modifier onlyAdmin {
        require(msg.sender == admin, ""Caller is not an admin"");
        _;
    }

    function grantAccess(address user) public onlyAdmin {
        accessRegistry[user] = true;
        emit AccessGranted(user);
    }

    function revokeAccess(address user) public onlyAdmin {
        accessRegistry[user] = false;
        emit AccessRevoked(user);
    }

    function batchGrantAccess(address[] memory users) public onlyAdmin {
        for (uint i = 0; i < users.length; i++) {
            grantAccess(users[i]);
        }
    }

    function batchRevokeAccess(address[] memory users) public onlyAdmin {
        for (uint i = 0; i < users.length; i++) {
            revokeAccess(users[i]);
        }
    }

    function grantPermission(address user, string memory permission) public onlyAdmin {
        permissionRegistry[user][permission] = true;
        emit PermissionGranted(user, permission);
    }

    function revokePermission(address user, string memory permission) public onlyAdmin {
        permissionRegistry[user][permission] = false;
        emit PermissionRevoked(user, permission);
    }

    function batchGrantPermission(address[] memory users, string memory permission) public onlyAdmin {
        for (uint i = 0; i < users.length; i++) {
            grantPermission(users[i], permission);
        }
    }

    function batchRevokePermission(address[] memory users, string memory permission) public onlyAdmin {
        for (uint i = 0; i < users.length; i++) {
            revokePermission(users[i], permission);
        }
    }

    function checkAccess(address user) public view returns(bool) {
        return accessRegistry[user];
    }

    function checkPermission(address user, string memory permission) public view returns(bool) {
        return permissionRegistry[user][permission];
    }

}","Create a smart contract that manages access control for a system. The contract should allow for the modification of public access and call permissions, including support for batch updates. Implement functions for checking access and permission status, and consider incorporating events for notification purposes."
contract_180.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ModularLongGame {
    struct PlayerData {
        uint256 investedAmount;
        uint256 affiliateReward;
        uint256 lastInvestmentTime;
    }

    mapping(address => PlayerData) public players;
    uint256 public totalInvested;
    uint256 public gameStartTime;

    event PlayerRegistered(address player);
    event GameTimerUpdated(uint256 newStartTime);
    event AffiliatePayout(address affiliate, uint256 payout);

    constructor() {
        gameStartTime = block.timestamp;
    }

    function register() external payable returns(bool) {
        require(msg.value > 0, ""Invest at least a positive value"");

        PlayerData storage player = players[msg.sender];
        player.investedAmount += msg.value;
        player.lastInvestmentTime = block.timestamp;

        totalInvested += msg.value;

        emit PlayerRegistered(msg.sender);
        return true;
    }

    function getInvestedAmount(address _player) external view returns(uint256) {
        return players[_player].investedAmount;
    }

    function getTotalInvested() external view returns(uint256) {
        return totalInvested;
    }

    function getTimeInvested(address _player) external view returns(uint256) {
        return block.timestamp - players[_player].lastInvestmentTime;
    }

    function getAllPlayerData(address _player) external view returns(uint256, uint256, uint256) {
        return (players[_player].investedAmount, players[_player].affiliateReward, players[_player].lastInvestmentTime);
    }

    function updateGameStartTime() external returns(bool) {
        gameStartTime = block.timestamp;
        emit GameTimerUpdated(gameStartTime);
        return true;
    }

    function getTimeSinceGameStarted() external view returns(uint256) {
        return block.timestamp - gameStartTime;
    }

    function payoutAffiliateReward(address payable affiliate, uint256 _payout) external returns(bool) {
        require(players[affiliate].affiliateReward >= _payout, ""Not enough rewards to payout"");

        players[affiliate].affiliateReward -= _payout;
        (bool success, ) = affiliate.call{value: _payout}("""");
        require(success, ""Transfer failed"");

        emit AffiliatePayout(affiliate, _payout);
        return success;
    }

    function addAffiliateReward(address _affiliate, uint256 _reward) external returns(bool) {
        players[_affiliate].affiliateReward += _reward;
        return true;
    }
}","Develop a smart contract that simulates the modularLong contract's structure and functionality. Incorporate event triggers for player registration, game timers, and affiliate payouts. Include functions for calculating game metrics and managing player data. Ensure the smart contract is well-organized, readable, and follows conventional coding practices."
contract_67.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract ManagedContract is Ownable {
    mapping(address => bool) private _isWhitelisted;
    mapping(address => bool) private _isFundingOperator;
    mapping(address => bool) private _isFundsUnlocker;

    event Whitelisted(address indexed account);
    event FundingOperatorUpdated(address indexed account, bool status);
    event FundsUnlockerUpdated(address indexed account, bool status);

    modifier onlyWhitelisted() {
        require(isWhitelisted(msg.sender), ""ManagedContract: caller is not whitelisted"");
        _;
    }

    modifier onlyFundsUnlocker() {
        require(isFundsUnlocker(msg.sender), ""ManagedContract: caller is not Funds Unlocker"");
        _;
    }

    modifier onlyFundingOperator() {
        require(isFundingOperator(msg.sender), ""ManagedContract: caller is not Funding Operator"");
        _;
    }

    function isWhitelisted(address account) public view returns (bool) {
        return _isWhitelisted[account];
    }

    function isFundingOperator(address account) public view returns (bool) {
        return _isFundingOperator[account];
    }

    function isFundsUnlocker(address account) public view returns (bool) {
        return _isFundsUnlocker[account];
    }

    function addWhitelist(address account) public onlyOwner {
        _isWhitelisted[account] = true;
        emit Whitelisted(account);
    }

    function removeWhitelist(address account) public onlyOwner {
        _isWhitelisted[account] = false;
    }

    function setFundingOperator(address account, bool status) public onlyOwner {
        _isFundingOperator[account] = status;
        emit FundingOperatorUpdated(account, status);
    }

    function setFundsUnlocker(address account, bool status) public onlyOwner {
        _isFundsUnlocker[account] = status;
        emit FundsUnlockerUpdated(account, status);
    }
}","Create a smart contract that builds upon the provided Ownable contract and adds features to manage whitelisted addresses, funding managers/operators, and funds unlocker managers/operators. The contract should include functions to add/remove addresses, check role membership, and allow the owner to transfer ownership. Focus on implementing the logic and functions defined in the provided code fragment."
contract_80.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract Pausable is Ownable {
    bool private _paused;

    event Paused(address account);
    event Unpaused(address account);

    constructor() {
        _paused = false;
    }

    function paused() public view virtual returns (bool) {
        return _paused;
    }

    modifier whenNotPaused() {
        require(!paused(), ""Pausable: paused"");
        _;
    }

    modifier whenPaused() {
        require(paused(), ""Pausable: not paused"");
        _;
    }

    function pause() public virtual onlyOwner whenNotPaused {
        _paused = true;
        emit Paused(_msgSender());
    }

    function unpause() public virtual onlyOwner whenPaused {
        _paused = false;
        emit Unpaused(_msgSender());
    }  
}

contract ERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool) {}
    function balanceOf(address account) public view virtual returns (uint256) {}
}

contract StakingContract is Ownable, Pausable {
    struct UserInfo {
        uint256 amount;    
        uint256 rewardDebt; 
    }

    struct PoolInfo {
        ERC20 token;
        uint256 allocPoint;       
        uint256 lastRewardBlock;  
        uint256 accRwardPerShare; 
    }

    ERC20 public rewardToken;  
    
    uint256 public rewardPerBlock;

    PoolInfo[] public poolInfo;
   
    mapping (uint256 => mapping (address => UserInfo)) private _userInfo;
    
    uint256 public totalAllocPoint = 0;
    
    uint256 public startBlock;
    
    uint256 public bonusEndBlock;
    
    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);
    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);
    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);
    
    constructor(
        ERC20 _rewardToken,
        uint256 _rewardPerBlock,
        uint256 _startBlock,
        uint256 _bonusEndBlock
    ) {
        rewardToken = _rewardToken;
        rewardPerBlock = _rewardPerBlock;
        startBlock = _startBlock;
        bonusEndBlock = _bonusEndBlock;
    }
    
    function addPool(uint256 _allocPoint, ERC20 _token, bool _withUpdate) public whenNotPaused onlyOwner {
        if (_withUpdate) {
            massUpdatePools();
        }
        totalAllocPoint = totalAllocPoint + _allocPoint;
        poolInfo.push(PoolInfo({
            token: _token,
            allocPoint: _allocPoint,
            lastRewardBlock: block.number > startBlock ? block.number : startBlock,
            accRwardPerShare: 0
        }));
    }

    function updatePool(uint256 _pid) public whenNotPaused {
        PoolInfo storage pool = poolInfo[_pid];
        if (block.number <= pool.lastRewardBlock) {
            return;
        }
        uint256 tokenSupply = pool.token.balanceOf(address(this));
        if (tokenSupply == 0) {
            pool.lastRewardBlock = block.number;
            return;
        }
        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);
        uint256 reward = multiplier * rewardPerBlock * pool.allocPoint / totalAllocPoint;
        pool.accRwardPerShare = pool.accRwardPerShare + (reward * 1e12 / tokenSupply);
        pool.lastRewardBlock = block.number;
    }

    function deposit(uint256 _pid, uint256 _amount) public whenNotPaused {
        require(_pid < poolInfo.length, 'deposit: invalid pid');
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = _userInfo[_pid][msg.sender];
        updatePool(_pid);
        if (user.amount > 0) {
            uint256 pending = user.amount * pool.accRwardPerShare / 1e12 - user.rewardDebt;
            if(pending > 0) {
                safeRewardTransfer(msg.sender, pending);
            }
        }
        if (_amount > 0) {
            pool.token.transferFrom(address(msg.sender), address(this), _amount);
            user.amount = user.amount + _amount;
        }
        user.rewardDebt = user.amount * pool.accRwardPerShare / 1e12;
        emit Deposit(msg.sender, _pid, _amount);
    }

    function safeRewardTransfer(address _to, uint256 _amount) internal {
        uint256 balance = rewardToken.balanceOf(address(this));
        if (_amount > balance) {
            rewardToken.transferFrom(address(this), _to, balance);
        } else {
            rewardToken.transferFrom(address(this), _to, _amount);
        }
    }
    
    function getMultiplier(uint256 _from, uint256 _to) public view whenNotPaused returns (uint256) {
        if (_to <= bonusEndBlock) {
            return _to - _from;
        } else if (_from >= bonusEndBlock) {
            return _to - _from;
        } else {
            return bonusEndBlock - _from;
        }
    }
    
    function massUpdatePools() public {
        uint256 length = poolInfo.length;
        for (uint256 pid = 0; pid < length; ++pid) {
            updatePool(pid);
        }
    }
}","Create a smart contract that allows users to stake, update, and claim rewards for a specific token. The contract should enable users to create pools with varying allocation points and manage staking and unstaking of tokens. Implement functions for creating, updating, and maintaining pools, as well as handling staking, unstaking, emergency unstaking, claiming, and tier obtaining. Utilize the OpenZeppelin library for Ownable and Pausable features. Ensure that the contract tracks the total allocation points and service balance. Include event logs for each action."
contract_167.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MyERC20Token {
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply;
        balanceOf[msg.sender] = totalSupply;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from]);
        require(_value <= allowance[_from][msg.sender]);

        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;

        emit Transfer(_from, _to, _value);

        return true;
    }
}","Design a smart contract that conforms to the ERC20 token standard, enabling token transfers, setting Allowance levels, and emitting events for transfers and approvals. Ensure the contract includes variables for storing token balances and allowance amounts, as well as event emissions for transfer and approval operations."
contract_143.sol,"pragma solidity ^0.8.0;

contract ERC721 {
    string public name;
    string public symbol;

    mapping(address => uint) private _balances;
    mapping(uint => address) private _owners;
    mapping(uint => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;
    uint private _totalSupply;

    event Transfer(address indexed from, address indexed to, uint indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint indexed tokenId);

    constructor(string memory _name, string memory _symbol) {
        name = _name;
        symbol = _symbol;
    }

    function balanceOf(address owner) public view returns (uint balance) {
        return _balances[owner];
    }

    function ownerOf(uint tokenId) public view returns (address owner) {
        return _owners[tokenId];
    }

    function approve(address to, uint tokenId) public {
        require(ownerOf(tokenId) == msg.sender);
        _tokenApprovals[tokenId] = to;
        emit Approval(msg.sender, to, tokenId);
    }

    function getApproved(uint tokenId) public view returns (address operator) {
        return _tokenApprovals[tokenId];
    }

    function transferFrom(address from, address to, uint tokenId) public {
        require(to != address(0));
        require(ownerOf(tokenId) == from);
        require(msg.sender == from || getApproved(tokenId) == msg.sender);
        
        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;
        emit Transfer(from, to, tokenId);
    }

    function mint(address to, uint tokenId) public {
        _balances[to] += 1;
        _owners[tokenId] = to;
        _totalSupply += 1;
        emit Transfer(address(0), to, tokenId);
    }

    function totalSupply() public view returns (uint total) {
        return _totalSupply;
    }
}","Create an ERC721 token contract that allows for the minting, transfer, approval, and ownership of tokens. The contract should include functions for querying the total supply of tokens, the balance of tokens for each owner, and the ownership of each token. The transfer function should enable the transfer of tokens between owners, the approve function should enable approval of a third party to manage tokens on behalf of the owner, and the takeOwnership function should enable the owner of a token to transfer ownership of the token to another address."
contract_51.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;
    address private _pendingOwner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _setOwner(msg.sender);
    }
    
    function owner() public view returns (address) {
        return _owner;
    }

    function pendingOwner() public view returns (address) {
        return _pendingOwner;
    }

    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0),""Ownable: new owner is the zero address"");
        _setPendingOwner(newOwner);
    }

    function claimOwnership() public {
        require(msg.sender == _pendingOwner, ""Ownable: caller is not the pending owner"");
        _setOwner(_pendingOwner);
        _pendingOwner = address(0);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }

    function _setPendingOwner(address newOwner) private {
        _pendingOwner = newOwner;
    }
}","Create a smart contract that allows single ownership and transferable management. The contract should have a specific default owner and implement a function to obtain the current owner. Further, it should provide the capability to transfer ownership to a new address, pushing ownership to a new address, and pulling ownership to the new address from the owner. Finally, ensure that only the current owner can execute certain actions."
contract_127.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

abstract contract AccessControl {
    function _setupRole(bytes32 role, address account) internal virtual { }
    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual { }
    function _hasRole(bytes32 role, address account) internal view virtual returns (bool) { }
    function _grantRole(bytes32 role, address account) internal virtual { }
    function _revokeRole(bytes32 role, address account) internal virtual { }
    function _renounceRole(bytes32 role, address account) internal virtual { }
}

contract RoleBasedAccessControl is AccessControl {
    bytes32 public constant USER_ROLE = keccak256(""USER_ROLE"");
    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");

    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    modifier onlyAdmin() {
        require(_hasRole(ADMIN_ROLE, msg.sender), ""Caller is not an admin"");
        _;
    }

    constructor() {
        _setupRole(ADMIN_ROLE, msg.sender);
        _setRoleAdmin(USER_ROLE, ADMIN_ROLE);
    }

    function grantRole(bytes32 role, address account) public onlyAdmin {
        _grantRole(role, account);
        emit RoleGranted(role, account, msg.sender);
    }

    function revokeRole(bytes32 role, address account) public onlyAdmin {
        _revokeRole(role, account);
        emit RoleRevoked(role, account, msg.sender);
    }

    function checkRole(bytes32 role, address account) public view returns (bool) {
        return _hasRole(role, account);
    }
}",Create a smart contract that uses the OpenZeppelin's AccessControl contract and implements a simple role-based access control system. The contract should allow users to grant and revoke roles for addresses and check if a specific role is held by an address. Provide a detailed description of the required functionality and include specific Solidity functions and variables as necessary. The contract should adhere to the IAccessControl interface and emit relevant events.
contract_70.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract StandardToken {

    uint256 public totalSupply;
    mapping(address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowed;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function transfer(address _to, uint256 _amount) public returns (bool success) {
        require(balances[msg.sender] >= _amount);
        balances[msg.sender] -= _amount;
        balances[_to] += _amount;
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _amount && allowance >= _amount);
        balances[_to] += _amount;
        balances[_from] -= _amount;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _amount;
        }
        emit Transfer(_from, _to, _amount);
        return true;
    }

    function approve(address _spender, uint256 _amount) public returns (bool success) {
    allowed[msg.sender][_spender] = _amount;
    emit Approval(msg.sender, _spender, _amount);
    return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
    return allowed[_owner][_spender];
}


}","Write a Solidity smart contract that allows for token transfers between users, implements approval and allowance functions for spending tokens, and includes emission of events for successful transfers and approvals. The contract should be an extension of the StandardToken contract and have variables for the total supply, balance, and approved addresses. Token transfers and approvals should be implemented."
contract_121.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Buffer {
    struct buffer {
        bytes buf;
        uint capacity;
    }

    function init(buffer memory buf, uint _capacity) internal pure {
        if(_capacity%32 != 0) _capacity += 32 - (_capacity%32);
        // Allocate space for the buffer data
        buf.capacity = _capacity;
        assembly { mstore(buf, _capacity) }
    }

    function resize(buffer memory buf, uint _capacity) pure private {
        if(_capacity%32 != 0) _capacity += 32 - (_capacity%32);
        // Allocate space for the new buffer
        bytes memory newbuf = new bytes(_capacity);
        // Copy buffer to the new buffer
        for(uint i = 0; i < buf.capacity; i++) {
            newbuf[i] = buf.buf[i];
        }
        buf.buf = newbuf;
        buf.capacity = _capacity;
    }

    function append(buffer memory buf, bytes memory data) internal pure {
        if (data.length + buf.buf.length > buf.capacity) {
            resize(buf, max(buf.capacity, data.length) * 2);
        }
        uint dest;
        uint src;
        assembly {
            dest := add(add(buf, 32), mload(buf))
            src := add(data, 32)
        }
        memcpy(dest,src, data.length);
        assembly { mstore(buf, add(mload(buf), mload(data))) }
    }

    function memcpy(uint _dest, uint _src, uint _len) pure private {
        // Copy word-length chunks while possible
        for(; _len >= 32; _len -= 32) {
            assembly {
                mstore(_dest, mload(_src))
            }
            _dest += 32;
            _src += 32;
        }
        // Copy remaining bytes
        uint mask = 256 ** (32 - _len) - 1;
        assembly {
            let srcpart := and(mload(_src), not(mask))
            let destpart := and(mload(_dest), mask)
            mstore(_dest, or(destpart, srcpart))
        }
    }

    function max(uint a, uint b) internal pure returns(uint) {
        if(a > b) {
            return a;
        } else {
            return b;
        }
    }
}

library CBOR {
    using Buffer for Buffer.buffer;

    function encodeType(Buffer.buffer memory buf, uint8 major, uint value) internal pure {
        if(value <= 23) {
            buf.append(byte(bytes1(uint8((major << 5) | value))));
        } else if(value <= 0xFF) {
            buf.append(byte(bytes1(uint8((major << 5) | 24))));
            buf.append(byte(bytes1(uint8(value))));
        } else if(value <= 0xFFFF) {
            buf.append(byte(bytes1(uint8((major << 5) | 25))));
            buf.append(abi.encodePacked(uint16(value)));
        } else if(value <= 0xFFFFFFFF) {
            buf.append(byte(bytes1(uint8((major << 5) | 26))));
            buf.append(abi.encodePacked(uint32(value)));
        } else if(value <= 0xFFFFFFFFFFFFFFFF) {
            buf.append(byte(bytes1(uint8((major << 5) | 27))));
            buf.append(abi.encodePacked(uint64(value)));
        }
    }

    function encodeIndefiniteLengthType(Buffer.buffer memory buf, uint8 major) internal pure {
        buf.append(byte(bytes1(uint8((major << 5) | 31))));
    }

    function encodeUInt(Buffer.buffer memory buf, uint value) internal pure {
        encodeType(buf, 0, value);
    }

    function encodeInt(Buffer.buffer memory buf, int value) internal pure {
        if(value < -0x10000000000000000) {
            encodeType(buf, 1, uint(-value));
        } else {
            encodeType(buf, 0, uint(value));
        }
    }

    function encodeBytes(Buffer.buffer memory buf, bytes memory value) internal pure {
        encodeType(buf, 2, value.length);
        buf.append(value);
    }

    function encodeString(Buffer.buffer memory buf, string memory value) internal pure {
        encodeType(buf, 3, bytes(value).length);
        buf.append(bytes(value));
    }
}

interface OraclizeI {

    function proofType_NONE()
    pure external returns (byte);
    function proofType_TLSNotary()
    pure external returns (byte);
    function proofType_Android()
    pure external returns (byte);
    function proofStorage_IPFS()
    pure external returns (byte);

    function query(uint _timestamp, string calldata _datasource, string calldata _arg)
    external payable returns (bytes32 _id);

} 

contract OraclizeIExtended is OraclizeI{

    event LogNewOraclizeQuery(bytes32 indexed queryId, string datasource);
    event LogNewQueryResult(bytes32 indexed queryId, string result);

    mapping(string => uint) private gasPrices;
    mapping(bytes32 => string) public queries;

    function setGasPrice(string memory datasource, uint price) public {
        gasPrices[datasource] = price;
    }

    function getGasPrice(string memory datasource) public view returns (uint) {
        return gasPrices[datasource];
    }

    function proofType_NONE()
    pure public override returns (byte) {return 0x00;}
    function proofType_TLSNotary()
    pure public override returns (byte) {return 0x10;}
    function proofType_Android()
    pure public override returns (byte) {return 0x20;}
    function proofStorage_IPFS()
    pure public override returns (byte) {return 0x01;}

    function query(uint _timestamp, string memory _datasource, string memory _arg) 
    public payable override returns (bytes32 _id) {
        Buffer.buffer memory buffer;
        Buffer.init(buffer, _arg.length + 64);
        CBOR.encodeString(buffer, _datasource);
        CBOR.encodeString(buffer, _arg);
        bytes32 queryId = keccak256(buffer.buf);
        queries[queryId] = _datasource;
        emit LogNewOraclizeQuery(queryId, _datasource);

        return queryId;
    }

    function setQueryResult(bytes32 queryId, string memory result) public {
        require(bytes(queries[queryId]).length != 0, ""OraclizeIExtended: query does not exist"");

        emit LogNewQueryResult(queryId, result);
    }

}","Create a smart contract that builds upon the OraclizeI contract by introducing a mechanism to manage data sources. Develop functions to set and retrieve data sources, and include a mapping to track gas prices. Utilize the Buffer and CBOR libraries in your implementation. Ensure the contract is well-structured and correctly implemented."
contract_42.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract NonStopTRX {
    address private contractOwner;
    
    struct User {
        bool isRegistered;
        uint weeklyReferralsCount;
        bool isInCyclePool;
    }

    mapping(address => User) private users;

    modifier onlyOwner() {
        require(msg.sender == contractOwner, ""Not contract owner"");
        _;
    }

    constructor() {
        contractOwner = msg.sender;
    }

    function registerUser(address _user) private onlyOwner {
        require(!users[_user].isRegistered, ""Already registered"");
        users[_user] = User(true, 0, false);
    }

    function updateWeeklyReferrals(address _user, uint _count) private onlyOwner {
        require(users[_user].isRegistered, ""Not registered"");
        users[_user].weeklyReferralsCount += _count;
    }

    function enterCyclePool(address _user) private onlyOwner {
        require(users[_user].isRegistered, ""Not registered"");
        users[_user].isInCyclePool = true;
    }
}","Create a Solidity smart contract for a NonStopTRX system that allows users to register, update weekly referral counts, and enter the cycle pool. The contract should have modifiers for the contract owner and owner. Define private functions for registering users, updating weekly referrals, and entering the cycle pool. Implement the logic for these functions using the provided contract code as a reference. Focus on implementing the necessary data structures and variables to store user information and track weekly referrals."
contract_59.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract FeesAndReservesAdaptor {
    struct FeesAndReserves {
        // example var, replace with your own
        uint256 variable; 
    }

    function feesAndReserves() public virtual view returns (FeesAndReserves memory) {
        // sample data, replace with your own logic
        FeesAndReserves memory data = FeesAndReserves({variable: 1});
        return data;
    }
}

contract MyContract is FeesAndReservesAdaptor {
    uint256 constant MY_FEE = 5; 
    uint256 constant MY_RESERVE = 7;

    function feesAndReserves() public override view returns (FeesAndReserves memory) {
        FeesAndReserves memory data = FeesAndReserves({variable: MY_FEE + MY_RESERVE});
        return data;
    }
}",Create a Solidity smart contract that adapts fees and reserves. The contract should inherit from the FeesAndReservesAdaptor class and override the `feesAndReserves` function to return a FeesAndReserves object. The FeesAndReservesAdaptor class will be imported from the specified location. The contract should be implemented using Solidity version 0.8.16 and include necessary license information.
contract_24.sol,"// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

contract PausableOwnable {
    address private _owner;
    bool private _paused;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event Paused(address account);
    event Unpaused(address account);

    constructor () {
        _paused = false;
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    modifier onlyOwner() {
        require(_owner == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    modifier whenNotPaused() {
        require(!_paused, ""Pausable: paused"");
        _;
    }

    modifier whenPaused() {
        require(_paused, ""Pausable: not paused"");
        _;
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }

    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function pause() public virtual onlyOwner whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    function unpause() public virtual onlyOwner whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    function paused() public view virtual returns (bool) {
        return _paused;
    }
}","Create a smart contract that provides functionality similar to OpenZeppelin's Pausable and Ownable contracts. The contract should include functions to Pause/Unpause the contract, TransferOwnership, and RenounceOwnership. Implement all necessary variables and modifiers. Provide a general overview of how the contract's functionality works."
contract_145.sol,"pragma solidity ^0.8.0;

interface IERC20Upgradeable {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}
```

The second piece is `IStakingThales` interface, that handles stakes.

```
interface IStakingThales {
    function stake(uint256 amount) external;
    function withdraw(uint256 amount) external;
    function getReward() external;
    function stakeForOther(address other, uint256 amount) external;
    function getStakingAmount(address account) external view returns (uint256);
}
```

Now, let's create our main contract.

```
contract SportsAMM {
    IERC20Upgradeable public token;
    IStakingThales public staking;

    struct Bet {
        address bettor;
        uint256 amount;
        bool outcome;
    }

    struct Game {
        string name;
        mapping(bool => Bet[]) bets; // mapping outcome to bets
        bool outcome;
        bool finished;
    }

    uint256 public gameId = 0;
    mapping(uint256 => Game) public games;

    constructor(address _token, address _staking) {
        token = IERC20Upgradeable(_token);
        staking = IStakingThales(_staking);
    }

    function createGame(string memory _name) public {
        games[gameId] = Game(_name, false, false);
        gameId += 1;
    }

    function placeBet(uint256 _gameId, bool _outcome, uint256 _amount) public {
        require(games[_gameId].finished == false, ""Game finished"");
        require(token.balanceOf(msg.sender) >= _amount, ""Insufficient balance"");
        require(token.allowance(msg.sender, address(this)) >= _amount, ""Allowance too low"");

        token.transferFrom(msg.sender, address(this), _amount);
        staking.stakeForOther(msg.sender, _amount);
        
        games[_gameId].bets[_outcome].push(Bet(msg.sender, _amount, _outcome));
    }

    function settleBet(uint256 _gameId, bool _outcome) public {
        require(games[_gameId].finished == false, ""Game finished"");
        games[_gameId].outcome = _outcome;
        games[_gameId].finished = true;

        for(uint256 i=0; i<games[_gameId].bets[_outcome].length; i++) {
            staking.withdraw(games[_gameId].bets[_outcome][i].amount);
            if(token.balanceOf(address(this)) >= games[_gameId].bets[_outcome][i].amount) {
                token.transfer(games[_gameId].bets[_outcome][i].bettor, games[_gameId].bets[_outcome][i].amount);
            }
        }
    }
}","Create a smart contract that simulates a sports AMM, allowing users to place bets on sports games. The contract should support bet creation, bet settlement, and payment processing. Implement logic for calculating odds and handling multiple collateral tokens. Integrate with interfaces like IERC20Upgradeable and IStakingThales."
contract_111.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IOutbox {
    function l2ToL1Sender() external view returns (address);
}

contract CrossChainEnabled {
    IOutbox public immutable bridge;

    modifier onlyL2Bridge {
        require(msg.sender == address(bridge), ""ONLY_BRIDGE"");
        _;
    }

    constructor(address _bridge) {
        bridge = IOutbox(_bridge);
    }

    function crossDomainSend(address _l1Target, bytes memory _data) internal {
        // Placeholder function to be overridden in inherited contracts.
    }

    function crossDomainReceiveMessage() external onlyL2Bridge {
        // Placeholder function to be overridden in inherited contracts.
    }
}

library LibArbitrumL1 {
    function l2ToL1Sender(IOutbox _bridge) internal view returns (address) {
        return _bridge.l2ToL1Sender();
    }
}

contract MyContract is CrossChainEnabled {

    using LibArbitrumL1 for IOutbox;

    constructor(address _bridge) CrossChainEnabled(_bridge) { }

    function getCrossChainStatus() public view returns (bool) {
        address sender = bridge.l2ToL1Sender();
        return sender != address(0);
    }

    function getCrossChainSender() public view returns (address) {
        return bridge.l2ToL1Sender();
    }

    function crossDomainSend(address _l1Target, bytes memory _data) internal override {
        bridge.l2ToL1Sender(); // Use the library method to handle cross-chain send
    }

    function crossDomainReceiveMessage() external override onlyL2Bridge {
        // Placeholder function to be overridden in inherited contracts.
    }
}","Create a Solidity smart contract that inherits from CrossChainEnabled and uses the LibArbitrumL1 library to manage cross-chain interactions. The contract should store an immutable bridge address, implement methods for determining cross-chain status and retrieving the cross-chain sender's address, and integrate with the provided library for smooth interactions."
contract_104.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }
}

abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () {
        _owner = _msgSender();
    }

    modifier onlySuper() {
        require(isSuperUser(), ""Ownable: caller is not the super user"");
        _;
    }
    
    function isSuperUser() public view returns(bool) {
        return _msgSender() == _owner;
    }

    function transferOwnership(address newOwner) public virtual onlySuper {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract ERC20 is Context, Ownable {
    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;
    uint256 private _unLockTime;
    uint256 private _burnAmount;

    string private _name;
    string private _symbol;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor (string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public virtual returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view virtual returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public virtual returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool) {
        _transfer(sender, recipient, amount);

        uint256 currentAllowance = _allowances[sender][_msgSender()];
        _approve(sender, _msgSender(), currentAllowance - amount);

        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        uint256 currentAllowance = _allowances[_msgSender()][spender];
        _approve(_msgSender(), spender, currentAllowance - subtractedValue);
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        uint256 senderBalance = _balances[sender];
        require(senderBalance >= amount, ""ERC20: transfer amount exceeds balance"");

        _balances[sender] = senderBalance - amount;
        _balances[recipient] += amount;

        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal virtual onlySuper {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _totalSupply += amount;
        _balances[account] += amount;
        
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) internal virtual onlySuper {
        require(account != address(0), ""ERC20: burn from the zero address"");

        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, ""ERC20: burn amount exceeds balance"");

        _balances[account] = accountBalance - amount;
        _totalSupply -= amount;
        _burnAmount += amount;

        emit Transfer(account, address(0), amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function UnLockTime() public view returns (uint256) {
        return _unLockTime;
    }

    function setUnLockTime(uint256 unLockTime_) external onlySuper {
        _unLockTime = unLockTime_;
    }

    function BurnAmount() public view returns (uint256) {
        return _burnAmount;
    }
}","Create a smart contract for an ERC20 token with the following requirements: manage token balances, approve transfers, and burn tokens. The contract should include functions for token transfer, approval, and transfer from. Additionally, consider implementing private modifier onlySuper and public view functions for token total supply, unLock time, and burn amount."
contract_81.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");

        return c;
    }
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, ""SafeMath: subtraction overflow"");
    }
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");

        return c;
    }
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, ""SafeMath: division by zero"");
    }
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;

        return c;
    }
}

contract TaxOffice {
    using SafeMath for uint256;

    address public pumpkin;
    address public wftm;
    address public uniRouter;
    mapping(address => bool) public taxExclusions;
    mapping(address => uint256) public taxTiers;

    address private owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Caller is not the owner"");
        _;
    }

    constructor(address _pumpkin, address _wftm, address _uniRouter) {
        owner = msg.sender;
        pumpkin = _pumpkin;
        wftm = _wftm;
        uniRouter = _uniRouter;
    }

    function setTaxExclusion(address account, bool state) external onlyOwner {
        taxExclusions[account] = state;
    }

    function setTaxTier(address account, uint256 tier) external onlyOwner {
        taxTiers[account] = tier;
    }

}","Create a smart contract that implements a tax office with the ability to set tax tiers and enable or disable tax exclusions for certain addresses. The contract should also store addresses for pumpkin, wftm, and uniRouter. Include a function to set tax tiers via TWAP and ensure only authorized operators can perform this action. Utilize the SafeMath library for mathematical operations."
contract_93.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Talentum {

    //Token details
    string public name = ""TalentumToken"";
    string public symbol = ""TTK"";
    uint256 public totalSupply = 1000000;
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowance;

    // Structure for Bible Entry
    struct BibleEntry {
       string text;
       address writer;
    }

    BibleEntry[] public bibleEntries;
    mapping(address => bool) public writers;
    mapping(string => bool) public adminSetCountryCodes;
    mapping(address => uint256) public donatedAmount;

    uint256 donateStep1 = 50;
    uint256 donateStep2 = 100;
    uint256 donateStep3 = 500;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event BibleEntryAdded(uint256 id, address writer, string text);
    event DonationReceived(address from, uint256 amount);

    constructor() {
        balances[msg.sender] = totalSupply;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value, 'Balance not sufficient');
        require(_to != address(0), 'Invalid address');

        balances[msg.sender] -= _value;
        balances[_to] += _value;

        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        require(_spender != address(0), 'Invalid address');
        require(balances[msg.sender] >= _value, 'Balance not sufficient');

        allowance[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0), 'Invalid address');
        require(balances[_from] >= _value, 'Balance not sufficient');

        balances[_from] -= _value;
        balances[_to] += _value;

        emit Transfer(_from, _to, _value);
        return true;
    }

    function writeBibleEntry(string memory _text) public returns (bool success) {
        require(writers[msg.sender], 'You are not allowed to write');
        bibleEntries.push(BibleEntry({text: _text, writer: msg.sender}));
        emit BibleEntryAdded(bibleEntries.length - 1, msg.sender, _text);
        return true;
    }

    function readBibleEntry(uint256 _id) public view returns (string memory text, address writer) {
        return (bibleEntries[_id].text, bibleEntries[_id].writer);
    }

    function setWriter(address _writer, bool _status) public returns (bool success) {
        writers[_writer] = _status;
        return true;
    }

    function setCountryCode(string memory _code, bool _status) public returns (bool success) {
        adminSetCountryCodes[_code] = _status;
        return true;
    }

    function donate(uint256 _amount) public returns (bool success) {
        require(balances[msg.sender] >= _amount, 'Balance not sufficient');
        require(_amount >= donateStep1, 'Minimum donation is 50 TTK');

        balances[msg.sender] -= _amount;
        balances[address(this)] += _amount;

        // Assigning tier status based on donation levels
        if(_amount >= donateStep3) {
            donatedAmount[msg.sender] = 3;
        }
        else if(_amount >= donateStep2) {
            donatedAmount[msg.sender] = 2;
        }
        else {
            donatedAmount[msg.sender] = 1;
        }

        emit DonationReceived(msg.sender, _amount);
        return true;
    }

}","Create a smart contract using Solidity that represents a Talentum token. The token should have a name, symbol, and total supply. Implement functions for transferring tokens, approving transfers, and allow-listed transfers. The contract should also include features for writers to write in the Holy Bible, readers to read the Holy Bible, and administrators to set writers and country codes. Include a donation mechanic with different price tiers based on the donate step."
contract_217.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;
    uint256 public totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Burn(address indexed from, uint256 value);

    bool private locked = false;

    modifier noReentrancy() {
        require(!locked, ""Reentrant call"");
        locked = true;
        _;
        locked = false;
    }

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply;
        balanceOf[msg.sender] = totalSupply;
    }

    function transfer(address to, uint256 value) public noReentrancy returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public noReentrancy returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public noReentrancy returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Insufficient allowance"");

        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;

        emit Transfer(from, to, value);
        return true;
    }

    function burn(uint256 value) public noReentrancy returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        totalSupply -= value;
        balanceOf[msg.sender] -= value;
        emit Burn(msg.sender, value);
        return true;
    }
}","Create a smart contract that represents a token, allowing users to transfer tokens between accounts. Implement functions for sending, approving, and burning tokens. Use a constructor to initialize the total token supply and distribute the initial tokens to the contract creator. Consider implementing reentrancy protection and ensuring accurate token balance updates."
contract_84.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract AccessControl {
    
    struct RoleData {
        mapping (address => bool) members;
        address adminRole;
    }

    mapping (bytes32 => RoleData) private _roles;

    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    modifier onlyRole(bytes32 role) {
        _checkRole(role, _msgSender());
        _;
    }

    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {
        _grantRole(role, account);
    }

    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {
        _revokeRole(role, account);
    }

    function renounceRole(bytes32 role, address account) public virtual {
        require(account == _msgSender(), ""AccessControl: can only renounce roles for self"");
        _revokeRole(role, account);
    }

    function getRoleAdmin(bytes32 role) public view returns (bytes32) {
        return _roles[role].adminRole;
    }

    function hasRole(bytes32 role, address account) public view returns (bool) {
        return _roles[role].members[account];
    }

    function _setupRole(bytes32 role, address account) internal virtual {
        _grantRole(role, account);
    }

    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);
        _roles[role].adminRole = adminRole;
    }

    function _grantRole(bytes32 role, address account) private {
        if (!hasRole(role, account)) {
            _roles[role].members[account] = true;
            emit RoleGranted(role, account, _msgSender());
        }
    }

    function _revokeRole(bytes32 role, address account) private {
        if (hasRole(role, account)) {
            _roles[role].members[account] = false;
            emit RoleRevoked(role, account, _msgSender());
        }
    }

    function _msgSender() private view returns (address) {
        return msg.sender;
    }
}

library String {
    function fromAddress(address _addr) public pure returns(string memory) {
        bytes32 value = bytes32(uint256(uint160(_addr)));
        bytes memory alphabet = ""0123456789abcdef"";

        bytes memory str = new bytes(42);
        str[0] = '0';
        str[1] = 'x';
        for (uint256 i = 0; i < 20; i++) {
            str[2+i*2] = alphabet[uint8(value[i + 12] >> 4)];
            str[3+i*2] = alphabet[uint8(value[i + 12] & 0x0f)];
        }
        return string(str);
    }

    function fromBytes32(bytes32 _value) public pure returns(string memory) {
        bytes memory alphabet = ""0123456789abcdef"";

        bytes memory str = new bytes(66);
        str[0] = '0';
        str[1] = 'x';
        for (uint256 i = 0; i < 32; i++) {
            str[2+i*2] = alphabet[uint8(_value[i] >> 4)];
            str[3+i*2] = alphabet[uint8(_value[i] & 0x0f)];
        }
        return string(str);
    }
}","Develop a smart contract that controls access to specific roles within a decentralized application. The contract should include functionality for creating and managing roles, assigning roles to accounts, and revoking roles. It should also include a mechanism to enforce role-based access control. Provide functions for retrieving role admins and checking role membership. Implement string library functions for address and hexadecimal conversions. Focus on ensuring the contract meets the requirements outlined in the IAccessControl interface."
contract_227.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    string public name;
    string public symbol;
    uint256 public decimals;
    uint256 public totalSupply;
    
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    
    constructor(string memory _name, string memory _symbol, uint256 _decimals, uint256 _totalSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply;
        balanceOf[msg.sender] = _totalSupply;
    }
    
    function transfer(address _to, uint256 _value) external returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        // SafeMath.sub will throw if there is not enough balance
        balanceOf[msg.sender] -= _value; 
        balanceOf[_to] += _value; 
        emit Transfer(msg.sender, _to, _value);
        return true;
    }
    
    function approve(address _spender, uint256 _value) external returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {
        require(balanceOf[_from] >= _value, ""Insufficient balance"");
        require(allowance[_from][msg.sender] >= _value, ""Insufficient allowance"");
        
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }
}","Create a smart contract that allows users to transfer and manage an ERC20 token. Include functions for transferring tokens, checking token balances, and approving and checking allowance. The contract should also emit events for token transfers and approvals. Consider implementing safety features to prevent common smart contract vulnerabilities."
contract_139.sol,"pragma solidity ^0.8.0;

contract DisputeManager {

    struct Item {
        string name;
        address owner;
        bool isBlacklisted;
        bool isWhiteListed;
        uint disputeCount;
    }

    mapping (bytes32 => Item) public items;
    mapping (bytes32 => bool) blacklist;
    mapping (bytes32 => bool) public whitelist;

    event ItemSubmitted(bytes32 indexed itemId, string name, address indexed owner);
    event ItemCleared(bytes32 indexed itemId, string name, address indexed owner);
    event ItemChallenged(bytes32 indexed itemId, string name, address indexed owner);
    event DisputeResolved(bytes32 indexed itemId, string name, address indexed owner, bool isBlacklisted, bool isWhiteListed);

    function submitItem(string memory _name) public {
        bytes32 itemId = keccak256(abi.encodePacked(_name, msg.sender));
        require(items[itemId].owner == address(0), ""Item already exists"");
        
        items[itemId].name = _name;
        items[itemId].owner = msg.sender;

        emit ItemSubmitted(itemId, _name, msg.sender);
    }

    function clearItem(string memory _name) public {
        bytes32 itemId = keccak256(abi.encodePacked(_name, msg.sender));
        require(items[itemId].owner == msg.sender, ""Only the owner can clear this item"");

        items[itemId].isBlacklisted = false;
        items[itemId].isWhiteListed = false;
        items[itemId].disputeCount = 0;

        emit ItemCleared(itemId, _name, msg.sender);
    }

    function challengeItem(string memory _name, address _owner) public {
        bytes32 itemId = keccak256(abi.encodePacked(_name, _owner));
        require(items[itemId].owner == _owner, ""This item does not exist"");

        items[itemId].disputeCount += 1;

        emit ItemChallenged(itemId, _name, _owner);
    }

    function resolveDispute(string memory _name, address _owner, bool _blacklistFlag) public {
        bytes32 itemId = keccak256(abi.encodePacked(_name, _owner));
        require(items[itemId].owner == _owner, ""This item does not exist"");

        items[itemId].isBlacklisted = _blacklistFlag;
        items[itemId].isWhiteListed = !_blacklistFlag;

        emit DisputeResolved(itemId, _name, _owner, _blacklistFlag, !_blacklistFlag);
    }
}","Create a smart contract that manages a permission list for disputable items. The contract should allow users to submit, clear, or challenge items, as well as resolve disputes. Consider implementing lists for item submission and clearing requests, as well as a system to manage dispute resolution. Ensure that the contract has the ability to flag items as blacklisted or whitelisted, depending on the 'blacklist' variable. Include functions for submitting, clearing, and challenging items, as well as resolving disputes."
contract_193.sol,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/Counters.sol"";

contract MyNFT is ERC721, Ownable {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;

    uint256 public maxSupply;
    uint256 public cost;

    string public baseTokenURI;
    string public baseTokenExtension;
    
    constructor(
        string memory name,
        string memory symbol,
        string memory _baseTokenURI, 
        string memory _baseTokenExtension,
        uint256 _cost, 
        uint256 _maxSupply
    ) ERC721(name, symbol) {
        baseTokenURI = _baseTokenURI;
        baseTokenExtension = _baseTokenExtension;
        cost = _cost;
        maxSupply = _maxSupply;
    }

    function mint(address to) public payable {
        require(msg.value >= cost, ""Not enough Ether to mint the token."");
        require(_tokenIds.current() < maxSupply, ""Max supply reached."");
        
        _tokenIds.increment();

        uint256 newTokenId = _tokenIds.current();
        _mint(to, newTokenId);
    }

    function setBaseURI(string memory _baseTokenURI) public onlyOwner {
        baseTokenURI = _baseTokenURI;
    }

    function setBaseExtension(string memory _baseTokenExtension) public onlyOwner {
        baseTokenExtension = _baseTokenExtension;
    }

    function setCost(uint256 _cost) public onlyOwner {
        cost = _cost;
    }

    function setMaxSupply(uint256 _maxSupply) public onlyOwner {
        maxSupply = _maxSupply;
    }
    
    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        require(_exists(tokenId), ""ERC721Metadata: URI query for nonexistent token"");

        string memory baseURI = baseTokenURI;
        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), baseTokenExtension)) : """";
    }

}",Create a Solidity smart contract that can be used to mint a limited number of NFTs. The contract should have a way to set the base URI and base extension. It should also allow the owner to set the cost and maximum supply of NFTs. The contract should include a minting function that checks if the total supply is below the maximum supply and if the sender has sufficient Ether to cover the cost. Implement a way to retrieve the token URI using the token ID.
contract_13.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

interface IUniswapV2Router {
    function addLiquidity(address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline)
    external
    returns (uint amountA, uint amountB, uint liquidity);
}

interface IMasterChef {
    function deposit(uint256 _pid, uint256 _amount) external;
    function withdraw(uint256 _pid, uint256 _amount) external;
    function userInfo(uint256, address) external view returns (uint256, uint256);
}

contract MyDeFiProtocol {
    address private rewardToken;
    address private lpToken;
    address private masterchef;
    IUniswapV2Router public unirouter;

    constructor(address _rewardToken, address _lpToken, address _unirouter, address _masterchef) {
        rewardToken = _rewardToken;
        lpToken = _lpToken;
        unirouter = IUniswapV2Router(_unirouter);
        masterchef = _masterchef;
    }

    function deposit(uint256 _pid, uint256 _amount) public {
        IERC20(lpToken).transferFrom(msg.sender, address(this), _amount);
        IMasterChef(masterchef).deposit(_pid, _amount);
    }

    // Function to harvest the earned rewards from the MasterChef contract
    function harvest(uint256 _pid) public {
        IMasterChef(masterchef).withdraw(_pid, 0);
    }

    function previewDeposit(uint256 _pid) public view returns (uint256, uint256) {
        (uint256 amount, ) = IMasterChef(masterchef).userInfo(_pid, address(this));
        return (IERC20(lpToken).balanceOf(address(this)), amount);
    }

    function totalAssets() public view returns (uint256) {
        return IERC20(lpToken).balanceOf(address(this));
    }
}","Create a Solidity smart contract that integrates with the MasterChef and Uniswap protocols to manage rewards and LP tokens. The contract should have functions for harvesting rewards, depositing, and preview depositing. Handle address variables for the reward token, unirouter, and masterchef. Calculate LP token amounts and total assets accurately. Implement error handling as needed."
contract_110.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        return a - b;
    }
}

contract Token {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Mint(address indexed to, uint256 amount);
    event Burn(address indexed from, uint256 amount);

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function mint(address account, uint256 amount) public {
        _mint(account, amount);
    }

    function burn(uint256 amount) public {
        _burn(msg.sender, amount);
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""Token: transfer from the zero address"");
        require(recipient != address(0), ""Token: transfer to the zero address"");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal {
        require(account != address(0), ""Token: mint to the zero address"");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Mint(account, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""Token: approve from the zero address"");
        require(spender != address(0), ""Token: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _burn(address account, uint256 amount) internal {
        require(account != address(0), ""Token: burn from the zero address"");

        _balances[account] = _balances[account].sub(amount);
        _totalSupply = _totalSupply.sub(amount);
        emit Burn(account, amount);
    }
}","Create a smart contract that allows for the transfer of tokens, checking of balances, and management of allowances. The contract should include functions for minting and burning tokens, as well as event emissions for transparency. Use the SafeMath library for reliable calculations. The contract should also include correct handling and validation of edge cases."
contract_201.sol,"pragma solidity ^0.8.0;

contract TriggerOrderManager {

    address public router;
    uint256 public nextTriggerOrderId = 1;

    mapping(uint256 => TriggerOrder) public triggerOrders;

    struct TriggerOrder {
        address user;
        bool active;
        uint256 price;
        uint256 amount;
    }

    event RouterSet(address indexed user, address indexed router);
    event TriggerOrderExecuted(uint256 indexed orderId, address indexed user, uint256 price, uint256 amount);
    event TriggerOrderCanceled(uint256 indexed orderId, address indexed user);

    modifier onlyRouter() {
        require(msg.sender == router, ""Caller is not the router"");
        _;
    }

    modifier onlyOrderOwner(uint256 _orderId) {
        require(msg.sender == triggerOrders[_orderId].user, ""Caller is not the order owner"");
        _;
    }

    function setRouter(address _router) external onlyRouter {
        router = _router;

        emit RouterSet(msg.sender, _router);
    }

    function triggerPosition(uint256 _price, uint256 _amount) external returns (uint256) {
        triggerOrders[nextTriggerOrderId] = TriggerOrder(msg.sender, true, _price, _amount);

        return nextTriggerOrderId++;
    }

    function cancelTriggerOrder(uint256 _orderId) external onlyOrderOwner(_orderId) {
        require(triggerOrders[_orderId].active == true, ""Order is already inactive"");

        triggerOrders[_orderId].active = false;

        emit TriggerOrderCanceled(_orderId, msg.sender);
    }

    function executeTriggerOrder(uint256 _orderId) external onlyRouter {
        require(triggerOrders[_orderId].active == true, ""Order is inactive"");

        triggerOrders[_orderId].active = false;

        emit TriggerOrderExecuted(_orderId, triggerOrders[_orderId].user, triggerOrders[_orderId].price, triggerOrders[_orderId].amount);
    }
}","Create a smart contract that mimics the functionality of the provided TriggerOrderManager contract. The contract should have functions for setting the router, triggering positions, canceling trigger orders, and executing trigger orders. Include events for when the router is set or trigger orders are executed. The contract should also have modifiers for restricting access to certain functions. Focus on creating a clean and readable code structure."
contract_202.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract IERC20 {
    function totalSupply() public view virtual returns (uint256);
    function balanceOf(address account) public view virtual returns (uint256);
    function transfer(address recipient, uint256 amount) public virtual returns (bool);
    function allowance(address owner, address spender) public view virtual returns (uint256);
    function approve(address spender, uint256 amount) public virtual returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        return a - b;
    }
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        return a / b;
    }
}

contract ERC20Basic is IERC20 {
    using SafeMath for uint256;
    string public constant name = ""ERC20Basic"";
    string public constant symbol = ""BSC"";
    uint8 public constant decimals = 18; // standard decimal adjustment
    uint public _totalSupply = 100 * 10**6 * 10**18; // total supply is 100 million tokens
    address public _owner;

    mapping(address => uint256) balances;
    mapping(address => mapping (address => uint256)) allowed;

    constructor() {
        _owner = msg.sender;
        balances[msg.sender] = _totalSupply;
    }

    function totalSupply() public view override returns (uint256) {
       return _totalSupply;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return balances[account];
    }

    function allowance(address owner, address spender) public view override returns (uint256) {
       return allowed[owner][spender];
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
       require(amount <= balances[msg.sender]);
       balances[msg.sender] = balances[msg.sender].sub(amount);
       balances[recipient] = balances[recipient].add(amount);
       emit Transfer(msg.sender, recipient, amount);
       return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        require(amount <= balances[sender]);
        require(amount <= allowed[sender][msg.sender]);
        balances[sender] = balances[sender].sub(amount);
        balances[recipient] = balances[recipient].add(amount);
        allowed[sender][msg.sender] = allowed[sender][msg.sender].sub(amount);
        emit Transfer(sender, recipient, amount);
        return true;
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        allowed[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function mint(address account, uint256 amount) public returns (bool) {
        require(msg.sender == _owner, ""Only owner can mint"");
        require(_totalSupply.add(amount) <= 100000000 * 10**18, ""Can't exceed total supply"");
        _totalSupply = _totalSupply.add(amount);
        balances[account] = balances[account].add(amount);
        emit Transfer(address(0), account, amount);
        return true;
    }

    function burn(uint256 amount) public returns (bool) {
        require(msg.sender == _owner, ""Only owner can burn"");
        require(balances[msg.sender] >= amount, ""Not enough balance to burn"");
        _totalSupply = _totalSupply.sub(amount);
        balances[msg.sender] = balances[msg.sender].sub(amount);
        emit Transfer(msg.sender, address(0), amount);
        return true;
    }

    function transferOwnership(address newOwner) public returns (bool) {
        require(msg.sender == _owner, ""Only owner can transfer ownership"");
        _owner = newOwner;
        return true;
    }
}","Create a token smart contract that allows the owner to transfer ownership to another address. The contract should include functions to mint and burn tokens. Ensure that the total supply of tokens does not exceed 100 million. Utilize the OpenZeppelin's SafeMath library to prevent arithmetic overflow. Define the token's total supply, balance, and allowance functions using the IERC20 interface. Implement a transfer function that logs the transfer event."
contract_119.sol,"pragma solidity ^0.8.0;

contract LiquidityPool {
    
    event Deposit(address indexed sender, uint amount, uint balance, uint totalSupply);
    event Withdrawal(address indexed sender, uint amount, uint balance, uint totalSupply);
    event NewAdmin(address indexed newAdmin);
    
    mapping(address => uint) private balances; // Track user balances
    mapping(address => bool) private admins; // Track admin addresses
    uint private totalSupply; // Total token supply
    
    constructor() {
        admins[msg.sender] = true; // Owner is automatically an admin
    }
    
    // Modifier to allow only admin users to call certain functions
    modifier onlyAdmin() {
        require(admins[msg.sender], ""Only admin can perform this action"");
        _;
    }
      
    // this function allows admins to add new admins
    function setAdmin(address account) public onlyAdmin {
        admins[account] = true;
        emit NewAdmin(account);
    }
    
    // this function allows users(non-admins) to deposit into the smart contract
    function deposit() public payable {
        balances[msg.sender] += msg.value;
        totalSupply += msg.value;

        emit Deposit(msg.sender, msg.value, balances[msg.sender], totalSupply);
    }
    
    // this function allows users (non-admins) to withdraw from the smart contract
    function withdraw(uint amount) public {
        require(amount <= balances[msg.sender], ""Insufficient balance"");
        
        balances[msg.sender] -= amount;
        totalSupply -= amount;
        payable(msg.sender).transfer(amount);
        
        emit Withdrawal(msg.sender, amount, balances[msg.sender], totalSupply);
    }
    
    // this function allows fetching the balance of a user
    function getBalance(address account) public view returns (uint) {
        return balances[account];
    }
    
    // this function allows fetching the total supply of the tokens
    function getTotalSupply() public view returns (uint) {
        return totalSupply;
    }

    // this function allows checking if an account is an admin
    function isAdmin(address account) public view returns (bool) {
        return admins[account];
    }
}","Create a smart contract that enables liquidity pool management, including deposit and withdrawal functionality, and administrator control. The contract should use mappings to track pool balances and total supply, and include functions for depositing and withdrawing tokens, setting administrators, and emitting events."
contract_195.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

abstract contract ERC165 {
    function supportsInterface(bytes4 interfaceId) virtual public view returns (bool);
}

abstract contract ERC721 is ERC165 {
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function balanceOf(address owner) virtual public view returns (uint256 balance);
    function ownerOf(uint256 tokenId) virtual public view returns (address owner);

    function approve(address to, uint256 tokenId) virtual public;
    function getApproved(uint256 tokenId) virtual public view returns (address operator);

    function setApprovalForAll(address operator, bool _approved) virtual public;
    function isApprovedForAll(address owner, address operator) virtual public view returns (bool);

    function transferFrom(address from, address to, uint256 tokenId) virtual public;
    function safeTransferFrom(address from, address to, uint256 tokenId) virtual public;
}

abstract contract ERC721Metadata is ERC721 {
    function name() virtual public view returns (string memory _name);
    function symbol() virtual public view returns (string memory _symbol);
    function tokenURI(uint256 tokenId) virtual public view returns (string memory);
}

contract MyNFT is ERC721, ERC721Metadata {

    string private _name = ""My NFT"";
    string private _symbol = ""MNFT"";
    address private _owner;
    mapping (uint256 => address) private _tokenOwners;
    mapping (address => uint256) private _balances;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => mapping (address => bool)) private _operatorApprovals;
    mapping (uint256 => string) private _tokenURIs;

    constructor() {
        _owner = msg.sender;
    }

    function supportsInterface(bytes4 interfaceId) override public view returns (bool) {
        return interfaceId == type(ERC721).interfaceId || interfaceId == type(ERC721Metadata).interfaceId;
    }

    function name() override public view returns (string memory) {
        return _name;
    }

    function symbol() override public view returns (string memory) {
        return _symbol;
    }

    function balanceOf(address owner) override public view returns (uint256) {
        require(owner != address(0));
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) override public view returns (address) {
        address owner = _tokenOwners[tokenId];
        require(owner != address(0));
        return owner;
    }

    function approve(address to, uint256 tokenId) override public {
        address owner = ownerOf(tokenId);
        require(to != owner);
        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));

        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    function getApproved(uint256 tokenId) override public view returns (address) {
        return _tokenApprovals[tokenId];
    }

    function setApprovalForAll(address operator, bool approved) override public {
        require(operator != msg.sender);

        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function isApprovedForAll(address owner, address operator) override public view returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function transferFrom(address from, address to, uint256 tokenId) override public {
        require(ownerOf(tokenId) == from);
        require(_isApprovedOrOwner(msg.sender, tokenId));
        require(to != address(0));
        
        _transfer(from, to, tokenId);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) override public {
        transferFrom(from, to, tokenId);
    }

    function mint(address to, uint256 tokenId) public {
        require(to != address(0), ""ERC721: mint to the zero address"");
        require(!_exists(tokenId), ""ERC721: token already minted"");

        _balances[to] += 1;
        _tokenOwners[tokenId] = to;

        emit Transfer(address(0), to, tokenId);
    }

    function tokenURI(uint256 tokenId) override public view returns (string memory) {
        require(_exists(tokenId), ""URI query for nonexistent token"");
        return _tokenURIs[tokenId];
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return _tokenOwners[tokenId] != address(0);
    }

    function _isApprovedOrOwner(address submitter, uint256 tokenId) internal view returns (bool) {
        address owner = ownerOf(tokenId);
        return (submitter == owner || getApproved(tokenId) == submitter || isApprovedForAll(owner, submitter));
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        _balances[from] -= 1;
        _balances[to] += 1;

        delete _tokenApprovals[tokenId];

        _tokenOwners[tokenId] = to;

        emit Transfer(from, to, tokenId);
    }
}","Create a basic smart contract for managing digital assets with owner and operator approvals, implementing ERC721 and ERC721Metadata functionality, while allowing for token minting and transferring, with approval and operator approval management."
contract_120.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string public name;
    string public symbol;
    uint8 public decimals;

    constructor (string memory tokenName, string memory tokenSymbol, uint256 initialSupply) {
        name = tokenName;
        symbol = tokenSymbol;
        decimals = 18;
        _totalSupply = initialSupply * 10 ** uint256(decimals);
        _balances[msg.sender] = _totalSupply;

        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        require(recipient != address(0), ""ERC20: transfer to the zero address"");
        require(_balances[msg.sender] >= amount, ""ERC20: transfer amount exceeds balance"");

        _balances[msg.sender] = _balances[msg.sender] - amount;
        _balances[recipient] = _balances[recipient] + amount;

        emit Transfer(msg.sender, recipient, amount);

        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _allowances[msg.sender][spender] = amount;

        emit Approval(msg.sender, spender, amount);

        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");
        require(_balances[sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        require(_allowances[sender][msg.sender] >= amount, ""ERC20: transfer amount exceeds allowance"");

        _balances[sender] = _balances[sender] - amount;
        _balances[recipient] = _balances[recipient] + amount;
        _allowances[sender][msg.sender] = _allowances[sender][msg.sender] - amount;

        emit Transfer(sender, recipient, amount);

        return true;
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}","Implement a smart contract for a token that is compatible with the IERC20 interface. The contract should include functions for transferring tokens, approving transfers, and emitting events for transaction records. It should also include variables for keeping track of token balances and allowances. The SafeMath library should be used for arithmetic operations."
contract_23.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// ""npm install @openzeppelin/contracts""
// Import OpenZeppelin's contracts
// import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

interface IAdminFacet {
    function getLenderAddress() external view returns (address);
}

interface ILendingFacet {
    function deposit(uint256 amount) external;
    function withdraw(uint256 amount) external;
}

contract LendingContract is ReentrancyGuardUpgradeable {
    mapping (address => uint256) private _balances;
    address private _lender;

    function initialize(address lender) public {
        _lender = lender;
        __ReentrancyGuard_init();
    }

    function getBalance(address account) public view returns (uint256) {
        return _balances[account];
    }

    function deposit(uint256 amount) public nonReentrant {
        _balances[msg.sender] += amount;
    }

    function withdraw(uint256 amount) public nonReentrant {
        require(_balances[msg.sender] >= amount, ""Not enough balance"");
        _balances[msg.sender] -= amount;
    }

    function getLenderAddress() public view returns (address) {
        return _lender;
    }
}",Create a smart contract for managing lending and withdrawing tokens. The contract should have separate functions for depositing and withdrawing tokens. Implement a mechanism to prevent reentrancy attacks. Utilize Openzeppelin's libraries for proxy and clone contracts. Include interfaces for lending and admin facets. Ensure the contract follows best practices for coding and security.
contract_32.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    constructor() {
        _transferOwnership(msg.sender);
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) private {
        require(
            newOwner != address(0),
            ""Ownable: new owner is the zero address""
        );
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}


contract SafeERC20 {
    function safeTransfer(
        IERC20 token,
        address to,
        uint256 value
    ) internal {
        callOptionalReturn(
            token,
            abi.encodeWithSelector(token.transfer.selector, to, value)
        );
    }

    function callOptionalReturn(
        IERC20 token,
        bytes memory data
    ) private {
        bytes memory returndata = address(token).functionCall(
            data,
            ""SafeERC20: low-level call failed""
        );
    }
}

interface IERC20 {
    function transfer(address recipient, uint256 amount)
        external
        returns (bool);

    function balanceOf(address account) external view returns (uint256);
}

contract TokenPermissionedTransfer is Ownable, SafeERC20 {
    mapping(address => bool) private _permissibleAddress;

    function permit(address holder) public onlyOwner {
        _permissibleAddress[holder] = true;
    }

    function revoke(address holder) public onlyOwner {
        _permissibleAddress[holder] = false;
    }

    function isPermissible(address holder) public view returns (bool) {
        return _permissibleAddress[holder];
    }

    function transferToken(
        IERC20 token,
        address to,
        uint256 amount
    ) public {
        require(
            isPermissible(msg.sender),
            ""caller does not have permission to transfer""
        );
        safeTransfer(token, to, amount);
    }
}","Create a smart contract that allows for ownership transfer and token permissioned transfer. The contract should inherit from OpenZeppelin's owned base contract, with functions for transferring ownership and permitting token transfers. The contract should include logic for checking both ownership and permit permissions. Utilize the SafeERC20 library for ensuring safe token transfers."
contract_136.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract Token is Context, IERC20 {
    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;

    constructor(string memory name_, string memory symbol_, uint256 totalSupply_) {
        _name = name_;
        _symbol = symbol_;
        _totalSupply = totalSupply_;
        _balances[_msgSender()] = totalSupply_;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _transfer(sender, recipient, amount);

        _approve(sender, _msgSender(), _allowances[sender][_msgSender()]-amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        uint256 currentAllowance = _allowances[_msgSender()][spender];
        require(currentAllowance >= subtractedValue, ""ERC20: decreased allowance below zero"");
        _approve(_msgSender(), spender, currentAllowance - subtractedValue);
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}","Create a new token contract based on the OpenZeppelin ERC-20 implementation, specifying the token's name, symbol, and total supply. Implement increase and decrease allowance functionality, transfer capabilities, and event triggers for token transfers. Utilize OpenZeppelin's Context and IERC20 contracts as a foundation for the new token. Use mapping variables to track token balances, allowance, and global token supply, and incorporate robust exception handling to ensure secure and reliable token operations."
contract_99.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _setOwner(_msgSender());
    }

    function owner() public view returns (address) {
        return _owner;
    }
    
    modifier onlyOwner() {
        require(_msgSender() == _owner, ""Ownable: caller is not the owner"");
        _;
    }

    function renounceOwnership() public onlyOwner {
        _setOwner(address(0));
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }

    function _msgSender() internal view virtual returns (address payable) {
        return payable(msg.sender);
    }
}","Create a smart contract that allows for basic ownership management. The contract should have a way to initialize the owner and register feature functions, as well as a function to transfer ownership and a function to migrate the contract. Make sure to include error handling in case of unexpected inputs. The contract should also include a way to retrieve the current owner."
contract_212.sol,"pragma solidity ^0.8.0;

contract Token {
    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;
    
    string  private _name;
    string  private _symbol;
    uint8   private _decimals;
    uint256 private _totalSupply;
    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    
    constructor(string memory name_, string memory symbol_, uint8 decimals_) {
        _name = name_;
        _symbol = symbol_;
        _decimals = decimals_;
    }
    
    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

     function allowance(address owner, address spender) public view returns (uint256) {
      return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
      _approve(msg.sender, spender, amount);
      return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
      _transfer(sender, recipient, amount);
      _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
      return true;
    }

    function mint(address account, uint256 amount) public returns (bool) {
      _mint(account, amount);
      return true;
    }

    function burn(address account, uint256 amount) public returns (bool) {
      _burn(account, amount);
      return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");
        require(_balances[sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        
        _balances[sender] -= amount;
        _balances[recipient] += amount;
        
        emit Transfer(sender, recipient, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _mint(address account, uint256 amount) internal {
        require(account != address(0), ""ERC20: mint to the zero address"");
        
        _totalSupply += amount;
        _balances[account] += amount;
        
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) internal {
        require(account != address(0), ""ERC20: burn from the zero address"");
        require(_balances[account] >= amount, ""ERC20: burn amount exceeds balance"");

        _balances[account] -= amount;
        _totalSupply -= amount;

        emit Transfer(account, address(0), amount);
    }
}","Create a Solidity smart contract that allows for the creation, transfer, and management of tokens. The contract should include functions for basic token operations such as totalSupply(), balanceOf(), transfer(), and allowance(). The contract should also include a constructor that allows for the initialization of the token's name, symbol, and decimal places. Include a method to mint new tokens and a method to burn existing tokens."
contract_38.sol,"pragma solidity ^0.8.0;

library SafeMath {

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, ""SafeMath: subtraction overflow"");
    }

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        return a - b;
    }
}

library AddressUtils {

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}

contract ERC721 {

    using SafeMath for uint256;
    using AddressUtils for address;
    
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _owners;
    mapping(uint256 => address) private _tokenApprovals;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    modifier onlyOwnerOf(uint256 tokenId) {
        require(ownerOf(tokenId) == msg.sender, ""ERC721: caller is not owner"");
        _;
    }

    function balanceOf(address owner) public view returns (uint256) {
        require(owner != address(0), ""ERC721: balance query for the zero address"");
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) public view returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), ""ERC721: owner query for nonexistent token"");
        return owner;
    }

    function approve(address to, uint256 tokenId) public onlyOwnerOf(tokenId) {
        _tokenApprovals[tokenId] = to;
        emit Approval(msg.sender, to, tokenId);
    }

    function setApprovalForAll(address operator, bool approved) public {
        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function transferFrom(address from, address to, uint256 tokenId) public {
        require( _isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        
        _transfer(from, to, tokenId);
    }
    
    function _transfer(address from, address to, uint256 tokenId) internal {
        _balances[from] = _balances[from].sub(1);
        _balances[to] = _balances[to].add(1);
        
        delete _tokenApprovals[tokenId];
        
        _owners[tokenId] = to;
        
        emit Transfer(from, to, tokenId);
    }
    
    function _exists(uint256 tokenId) internal view returns (bool) {
        return _owners[tokenId] != address(0);
    }
    
    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    function getApproved(uint256 tokenId) public view returns (address) {
        require(_exists(tokenId), ""ERC721: approved query for nonexistent token"");
        return _tokenApprovals[tokenId];
    }
    
    function isApprovedForAll(address owner, address operator) public view returns (bool) {
        return _operatorApprovals[owner][operator];
    }
}","Create a smart contract that follows the ERC721 standard. The contract should have functions to retrieve the balance of an owner, check if a token exists, approve an operator, and transfer a token. The contract should also have a mapping to store the owner of each token. The contract should use the SafeMath library for arithmetic operations and the AddressUtils library for address utilities. The contract should have a modifier to check if the sender is the owner of the token."
contract_29.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Timelock {
    address public admin;
    address public pendingAdmin;
    uint public delay;

    mapping(bytes32 => bool) public queuedTransactions;

    event NewPendingAdmin(address indexed newAdmin);
    event SetDelay(uint delay);
    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);
    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);
    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);

    constructor(address admin_, uint delay_) {
        require(delay_ >= 0, ""Timelock::constructor: Delay must not be negative"");
        admin = admin_;
        delay = delay_;
    }

    function setDelay(uint delay_) public {
        require(msg.sender == address(this), ""Timelock::setDelay: Only callable by self"");
        require(delay_ >= 0, ""Timelock::setDelay: Delay must not be negative"");
        delay = delay_;

        emit SetDelay(delay);
    }

    function acceptAdmin() public {
        require(msg.sender == pendingAdmin, ""Timelock::acceptAdmin: Acceptance can only be done by pending admin"");
        admin = msg.sender;
        pendingAdmin = address(0);
    }

    function setPendingAdmin(address pendingAdmin_) public {
        require(msg.sender == address(this), ""Timelock::setPendingAdmin: Only callable by self"");
        pendingAdmin = pendingAdmin_;

        emit NewPendingAdmin(pendingAdmin);
    }

    function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {
        require(msg.sender == admin, ""Timelock::queueTransaction: Only callable by admin"");
        require(eta >= block.timestamp + delay, ""Timelock::queueTransaction: ETA too soon"");

        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));
        queuedTransactions[txHash] = true;

        emit QueueTransaction(txHash, target, value, signature, data, eta);
        return txHash;
    }

    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public {
        require(msg.sender == admin, ""Timelock::cancelTransaction: Only callable by admin"");

        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));
        queuedTransactions[txHash] = false;

        emit CancelTransaction(txHash, target, value, signature, data, eta);
    }

    function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bool) {
        require(msg.sender == admin, ""Timelock::executeTransaction: Only callable by admin"");

        // Hash values to get unique identifier for queued transaction
        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));
        require(queuedTransactions[txHash], ""Timelock::executeTransaction: Transaction hasn't been queued."");
        require(block.timestamp >= eta, ""Timelock::executeTransaction: Transaction hasn't surpassed time lock."");
        require(block.timestamp <= eta + delay, ""Timelock::executeTransaction: Transaction is stale."");

        queuedTransactions[txHash] = false;

        bool success = false;
        // solium-disable-next-line security/no-call-value
        (success, data) = target.call{value: value}(abi.encodeWithSignature(signature, data));
        require(success, ""Timelock::executeTransaction: Transaction execution unsuccessful."");

        emit ExecuteTransaction(txHash, target, value, signature, data, eta);

        return success;
    }
}","Create a timelock smart contract that enables scheduling of transactions at a specific delay. The contract should include features for setting an admin, pending admin, and delay. Implement methods for queuing and canceling transactions, as well as functions for administering the admin and pending admin roles. The contract should restrict access to specific functions, ensuring that only authorized users can initiate actions."
contract_140.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;

        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;

        return c;
    }
}


contract IBitGuildToken {
    function balanceOf(address who) public view virtual returns(uint256);
    function transfer(address to, uint256 value) public virtual returns(bool);
    function approve(address spender, uint256 value) public virtual returns(bool);
    function transferFrom(address from, address to, uint256 value) public virtual returns(bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract IAgonFight {
    function createFight(uint256, address) public virtual returns(bool);
    function cancelFight(uint256) public virtual returns(bool);
    function challengeFight(uint256, address) public virtual returns(bool);
    function resolveFight(uint256) public virtual returns(bool);
    event FightCreated(uint256 indexed fightId);
    event FightCancelled(uint256 indexed fightId);
    event FightChallenged(uint256 indexed fightId, address challenger);
    event FightResolved(uint256 indexed fightId, address winner);
}


contract ServiceAdmin {
    using SafeMath for uint256;

    address private admin;
    uint256 private maxAgonCount;
    IAgonFight private agonFightContract;

    modifier onlyAdmin() {
        require(msg.sender == admin, 'Only Admin can perform this');
        _;
    }

    constructor(uint256 _maxAgonCount, address _agonFightContract) {
         admin = msg.sender;
         maxAgonCount = _maxAgonCount;
         agonFightContract = IAgonFight(_agonFightContract);
    }

    // Admin functions
    function setMaxAgonCount(uint256 _newCount) public onlyAdmin {
        maxAgonCount = _newCount;
    }

    function setAgonFightContract(address _newContract) public onlyAdmin {
        agonFightContract = IAgonFight(_newContract);
    }

    // Agon services
    function createAgonFight(uint256 _fightId) public onlyAdmin {
        require(agonFightContract.createFight(_fightId, msg.sender), 'Cannot create fight');
        maxAgonCount = maxAgonCount.sub(1);
    }

    function cancelAgonFight(uint256 _fightId) public onlyAdmin {
        require(agonFightContract.cancelFight(_fightId), 'Cannot cancel fight');
        maxAgonCount = maxAgonCount.add(1);
    }

    function challengeAgonFight(uint256 _fightId, address _challenger) public onlyAdmin {
        require(agonFightContract.challengeFight(_fightId, _challenger), 'Cannot challenge fight');
    }

    function resolveAgonFight(uint256 _fightId) public onlyAdmin {
        require(agonFightContract.resolveFight(_fightId), 'Cannot resolve fight');
    }
}","Create a smart contract that serves as a service administration system, providing service and finance management. The contract should include admin-only functions and modifiers. Develop a library for safe arithmetic operations and interfaces for IBitGuildToken and IAgonFight. Design a contract that manages agon fights, including functions for creating, canceling, challenging, and resolving fights. Set max agon count and agon fight contract address during deployment."
contract_2.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract BlindAuctionMarketplace {
    struct Auction {
        address owner;
        uint256 minPrice;
        uint256 maxPrice;
        uint256 terminationPeriod;
        bool closed;
    }

    struct Bid {
        address bidder;
        uint256 value;
    }

    // Mapping of auction ID to Auction struct
    mapping(uint256 => Auction) public auctions;
    
    // Mapping of auction ID to array of Bids
    mapping(uint256 => Bid[]) public bids;
 
    address public owner;
    address public salvorSigner;
    bool public isPaused;

    event AuctionSettled(uint256 indexed auctionId, address indexed winner, uint256 highestBid);
    event Withdrawal(uint256 amount, address to);
    event FailedTransfer(uint256 indexed auctionId, address to, uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function."");
        _;
    }
    
    constructor() {
        owner = msg.sender;
    }
    
    function setOwner(address _owner) external onlyOwner {
        owner = _owner;
    }

    function setPaused(bool _isPaused) external onlyOwner {
        isPaused = _isPaused;
    }
    
    function setAuctionMinPrice(uint256 auctionId, uint256 minPrice) external onlyOwner {
        auctions[auctionId].minPrice = minPrice;
    }
    
    function setAuctionTerminationPeriod(uint256 auctionId, uint256 terminationPeriod) external onlyOwner {
        auctions[auctionId].terminationPeriod = terminationPeriod;
    }

    function setAuctionMaxPrice(uint256 auctionId, uint256 maxPrice) external onlyOwner {
        auctions[auctionId].maxPrice = maxPrice;
    }

    function createAuction(uint256 minPrice, uint256 maxPrice, uint256 terminationPeriod) external {
        require(!isPaused, ""Contract is paused."");
        uint256 auctionId = uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender)));
        auctions[auctionId] = Auction(msg.sender, minPrice, maxPrice, terminationPeriod, false);
    }
    
    function bid(uint256 auctionId) external payable {
        require(!isPaused, ""Contract is paused."");
        require(!auctions[auctionId].closed, ""Auction is closed."");
        require(msg.value >= auctions[auctionId].minPrice, ""Bid is below the minimum price."");

        bids[auctionId].push(Bid(msg.sender, msg.value));
    }

    function closeAuction(uint256 auctionId) external onlyOwner {
        require(!auctions[auctionId].closed, ""Auction is already closed."");

        Bid[] memory auctionBids = bids[auctionId];
        Bid memory highestBid;
        for (uint256 i = 0; i < auctionBids.length; i++) {
            if (auctionBids[i].value > highestBid.value) {
                highestBid = auctionBids[i];
            }
        }
        
        if (highestBid.value == 0) {
            auctions[auctionId].closed = true;
            return;
        }

        (bool transferSuccess, ) = auctions[auctionId].owner.call{ value: highestBid.value }("""");
        if (!transferSuccess) {
            emit FailedTransfer(auctionId, auctions[auctionId].owner, highestBid.value);
        } else {
            emit AuctionSettled(auctionId, highestBid.bidder, highestBid.value);
        }

        auctions[auctionId].closed = true;
    }

    function withdraw() external {
        require(msg.sender == salvorSigner, ""Only authorized salvor can withdraw."");

        uint256 balance = address(this).balance;
        
        (bool success, ) = salvorSigner.call{ value: balance }("""");
        if (!success) {
            revert(""Withdrawal failed"");
        } else {
            emit Withdrawal(balance, salvorSigner);
        }
    }
}","Create a smart contract for a BlindAuctionMarketplace that allows users to create auctions with various settings. Include features for users to make offers, fill orders, and withdraw funds. Provide functions for setting auction minimum price limits, required termination periods, and maximum price percentages. The contract should have specific events for auction settlement, withdrawal, and failed transfers. Allow contract owners to update settings and control the salvorSigner and pause state."
contract_50.sol,"pragma solidity ^0.8.0;

contract IERC20 {
    function totalSupply() public view virtual returns (uint256);

    function balanceOf(address account) public view virtual returns (uint256);

    function transfer(address recipient, uint256 amount) public virtual returns (bool);

    function allowance(address owner, address spender) public view virtual returns (uint256);

    function approve(address spender, uint256 amount) public virtual returns (bool);

    function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed owner, address indexed spender, uint256 value);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;

        return c;
    }
}

contract MyToken is IERC20 {
    string public constant name = ""MyToken"";
    string public constant symbol = ""MTK"";
    uint8 public constant decimals = 18;

    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    event Transfer(address indexed from, address indexed to, uint tokens);

    mapping(address => uint256) balances;
    mapping(address => mapping (address => uint256)) allowed;

    using SafeMath for uint256;
    uint256 totalSupply_;

    constructor(uint256 total) {
        totalSupply_ = total;
        balances[msg.sender] = totalSupply_;
    }

    function totalSupply() public view override returns (uint256) {
        return totalSupply_;
    }

    function balanceOf(address tokenOwner) public view override returns (uint256) {
        return balances[tokenOwner];
    }

    function transfer(address receiver, uint256 numTokens) public override returns (bool) {
        require(numTokens <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(numTokens);
        balances[receiver] = balances[receiver].add(numTokens);
        emit Transfer(msg.sender, receiver, numTokens);
        return true;
    }

    function approve(address delegate, uint256 numTokens) public override returns (bool) {
        allowed[msg.sender][delegate] = numTokens;
        emit Approval(msg.sender, delegate, numTokens);
        return true;
    }

    function allowance(address owner, address delegate) public view override returns (uint) {
        return allowed[owner][delegate];
    }

    function transferFrom(address owner, address buyer, uint numTokens) public override returns (bool) {
        require(numTokens <= balances[owner]);
        require(numTokens <= allowed[owner][msg.sender]);

        balances[owner] = balances[owner].sub(numTokens);
        balances[buyer] = balances[buyer].add(numTokens);
        allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);

        emit Transfer(owner, buyer, numTokens);
        return true;
    }
}","Create a smart contract that allows for token transfers and includes basic functionality, utilizing the IERC20 interface and SafeMath library. Implement a balance retrieval function and include event triggers for transfer and approval operations."
contract_46.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract IERC20 {
    function totalSupply() public view virtual returns (uint256) {}
    function balanceOf(address account) public view virtual returns (uint256) {}
    function transfer(address recipient, uint256 amount) public virtual returns (bool) {}
    function allowance(address owner, address spender) public view virtual returns (uint256) {}
    function approve(address spender, uint256 amount) public virtual returns (bool) {}
    function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool) {}

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

abstract contract ERC20 is Context, IERC20 {
    string private _name;
    string private _symbol;
    uint256 private _decimals;

    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint256) {
        return _decimals;
    }
}

contract YearnVault is ERC20 {
    IERC20 public token;
    uint256 public pricePerShare;

    constructor(IERC20 _token) {
        token = _token;
    }

    function deposit(uint256 _amount) external {
        token.transferFrom(msg.sender, address(this), _amount);
        
        _mint(msg.sender, _amount);
        
        // assuming price per share increases after every deposit
        pricePerShare += _amount;
    }

    function withdraw(uint256 _shares) external {
        uint256 r = (pricePerShare * _shares) / 1e18;
        
        _burn(msg.sender, _shares);

        token.transfer(msg.sender, r);
        
        // assuming price per share decreases after every withdrawal
        if (_shares < pricePerShare) {
            pricePerShare -= _shares;
        } else {
            pricePerShare = 0;
        }
    }

    function getPricePerShare() external view returns (uint256) {
        return pricePerShare;
    }

    function getToken() external view returns (IERC20) {
        return token;
    }
}","Create a Yearn V2 Vault smart contract that allows users to deposit and withdraw tokens, obtain the current price per share, and retrieve the underlying token address. The contract should inherit from IERC20 and conform to the OpenZeppelin ERC20 standard."
contract_216.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        return a - b;
    }
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        return a / b;
    }
}

contract ERC20Token {
    using SafeMath for uint256;

    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalSupply, address _reserveAddress) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply;
        balanceOf[msg.sender] = totalSupply.div(2);
        balanceOf[_reserveAddress] = totalSupply.div(2);
        emit Transfer(address(0), msg.sender, totalSupply.div(2));
        emit Transfer(address(0), _reserveAddress, totalSupply.div(2));
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance."");
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], ""Insufficient Balance"");
        require(_value <= allowance[_from][msg.sender], ""Insufficient Allowance"");
        balanceOf[_from] = balanceOf[_from].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }
}","Design a smart contract that complies with the ERC20 standard, focusing on token transfer, approval, and ownership management. Implement a token supply of 1,000,000, with half of the initial distribution going to the owner and the remaining half to a reserve address. Use the SafeMath library for arithmetical operations. Concentrate on creating secure and well-maintained code. Note that this prompt is designed for users with some knowledge of smart contract development and programming languages like Solidity."
contract_3.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

// Basic token interface.
interface IERC20 {
 function totalSupply() external view returns (uint256);
 function balanceOf(address tokenOwner) external view returns (uint256 balance);
 function allowance(address tokenOwner, address spender) external view returns (uint256 remaining);
 function transfer(address to, uint256 tokens) external returns (bool success);
 function approve(address spender, uint256 tokens) external returns (bool success);
 function transferFrom(address from, address to, uint256 tokens) external returns (bool success);
}

interface IJoeRouter {
 function swapExactTokensForTokens(
  uint amountIn,
  uint amountOutMin,
  address[] calldata path,
  address to,
  uint deadline
 ) external returns (uint[] memory amounts);
}

interface IAave {
 // Add Aave related methods here
}

interface IAaveV3 {
 // Add Aave V3 related methods here
}

contract LeverageVoting {
 address public owner;
 address public lever;
 address public joeRouter;
 address public aave;
 address public aaveV3;
 mapping (address => bool) public isApprovedToken;

 modifier onlyOwner(){
  require(msg.sender == owner);
  _;
 }

 constructor() {
  owner = msg.sender;
 }

 function setApprovers(address _token, bool _value) public onlyOwner {
  isApprovedToken[_token] = _value;
 }

 function setLever(address _lever) public onlyOwner {
  lever = _lever;
 }

 function setJoeRouter(address _joeRouter) public onlyOwner {
  joeRouter = _joeRouter;
 }

 function setAaveAddresses(address _aave, address _aaveV3) public onlyOwner {
  aave = _aave;
  aaveV3 = _aaveV3;
 }

 function deposit(address _token, uint256 _amount) public {
  require(isApprovedToken[_token],""Not an approved token"");
  IERC20(_token).transferFrom(msg.sender, address(this), _amount);
 }

 function withdraw(address _token, uint256 _amount) public onlyOwner {
  IERC20(_token).transfer(msg.sender, _amount);
 }

 // Placeholder for example, implement as per the business logic.
 function testVanillaJoeSwapFork() public onlyOwner {
  //Logic for testVanillaJoeSwapFork
 }
 
 // Placeholder for example, implement as per the business logic.
 function testVanillaJLPinFork() public onlyOwner {
  //Logic for JLPinFork
 }

 // Placeholder for example, implement as per the business logic.
 function testVanillaJLPinOutFork() public onlyOwner {
  //Logic for VanillaJLPinOutFork
 }
}","Create a smart contract that allows for basic withdraw and deposit functionality, token transfer/approval, and proportional distribution when new underlying tokens are minted to vault. The contract should include functions that perform the following: set approvers for specific tokens, initialize Lever, set JoeRouter, Aave, and Aave V3 addresses, and have test functions for vanilla Joe swap fork, vanilla JLP in fork, and vanilla JLP in out fork."
contract_62.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// SafeMath library to perform safe arithmetic operations
library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;

        return c;
    }
}

// Enumerating for the enumerable set
enum Set {NONE, FIRST_VALUE, SECOND_VALUE, THIRD_VALUE} 

// Main contract
contract Counter {
    using SafeMath for uint256;

    uint256 private _counter;
    Set[] private _enumSet;
    mapping(uint256 => Set) private _enumMapping;

    function increment() public {
        _counter = _counter.add(1);
    }

    function decrement() public {
        require(_counter > 0, ""Counter: decrement overflow"");
        _counter = _counter.sub(1);
    }

    function reset() public {
        _counter = 0;
    }

    function getCounter() public view returns (uint256) {
        return _counter;
    }

    function addToSet(Set _set) public {
        _enumSet.push(_set);
        _enumMapping[_enumSet.length - 1] = _set;
    }

    function getFromSet(uint256 _index) public view returns (Set) {
        require(_index < _enumSet.length, ""Counter: index out of bounds"");
        return _enumMapping[_index];
    }

    function sizeOfSet() public view returns (uint256) {
        return _enumSet.length;
    }
}","Create a smart contract that uses the OpenZeppelin libraries to manage arithmetic operations and a counter variable. The contract should have functions to increment, decrement, and reset the counter. It should also include a mapping to store and retrieve values from an enumerable set. The contract should be structured in a way that is easy to understand and maintain."
contract_146.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
    
contract NFKeyStaking {
    address public NFKeyAddress;
    mapping(address => bool) public admins;
    
    struct staker {
        uint256 tokenId;
        uint256 tokenIndex;
        uint256 rewardsEarned;
        uint256 rewardsReleased;
        uint256 treasureUnlockTime;
    }

    IERC721 public nft;
    mapping (address => staker) public stakers;
    mapping (uint256 => address) public tokenStakedBy;

    event Emission(address indexed staker, uint256 rewardAmount);
    event ChestTierUpdated(uint256 tokenId, uint256 oldTier, uint256 newTier);
    event TokenStaked(address indexed staker, uint256 tokenId);
    event TokenUnstaked(address indexed staker, uint256 tokenId);

    constructor(address _NFKeyAddress) {
        NFKeyAddress = _NFKeyAddress;
        nft = IERC721(_NFKeyAddress);
    }

    modifier onlyAdmin() {
        require(admins[msg.sender], ""only admin"");
        _;
    }

    function addAdmin(address admin) public onlyAdmin {
        admins[admin] = true;
    }

    function removeAdmin(address admin) public onlyAdmin {
        admins[admin] = false;
    }

    function stake(uint256 tokenId) external {
        require(nft.ownerOf(tokenId) == msg.sender, ""not token owner"");
        nft.transferFrom(msg.sender, address(this), tokenId);
       
        stakers[msg.sender].tokenId = tokenId;
        stakers[msg.sender].tokenIndex = nft.tokenByIndex(tokenId);
        
        emit TokenStaked(msg.sender, tokenId);
    }

    function unstake(uint256 tokenId) external {
        require(stakers[msg.sender].tokenId == tokenId, ""not staker of token"");
        nft.transferFrom(address(this), msg.sender, tokenId);

        stakers[msg.sender].tokenId = 0;
        stakers[msg.sender].tokenIndex = 0;
        
        emit TokenUnstaked(msg.sender, tokenId);
    }

    function getTreasureUnlockTime(uint256 tokenId) public view returns(uint256) {
        return stakers[tokenStakedBy[tokenId]].treasureUnlockTime;
    }

    function updateTreasureUnlockTime(uint256 tokenId, uint256 newTreasureUnlockTime) external onlyAdmin {
        require(stakers[tokenStakedBy[tokenId]].tokenId == tokenId, ""token not staked"");
        stakers[tokenStakedBy[tokenId]].treasureUnlockTime = newTreasureUnlockTime;
    }

    function getRewards(address stakerAddress) public view returns(uint256, uint256) {
        return (stakers[stakerAddress].rewardsEarned, stakers[stakerAddress].rewardsReleased);
    }

    function updateRewards(address stakerAddress, uint256 rewardsEarned, uint256 rewardsReleased) external onlyAdmin {
        stakers[stakerAddress].rewardsEarned = rewardsEarned;
        stakers[stakerAddress].rewardsReleased = rewardsReleased;
        
        emit Emission(stakerAddress, rewardsEarned);
    }

    function getStakedTokens() public view returns(uint256[] memory) {
        uint256 counter = 0;
        for (uint256 i = 0; i < nft.totalSupply(); i++) {
            if (tokenStakedBy[nft.tokenByIndex(i)] != address(0)) {
                counter++;
            }
        }
        
        uint256[] memory tokenIds = new uint256[](counter);
        counter = 0;
        for (uint256 i = 0; i < nft.totalSupply(); i++) {
            uint256 tokenId = nft.tokenByIndex(i);
            if (tokenStakedBy[tokenId] != address(0)) {
                tokenIds[counter] = tokenId;
                counter++;
            }
        }
        
        return tokenIds;
    }
}","Create a Smart Contract that implements NFKeyStaking functionality, including a constructor to set the NFKey address. The contract should have an admin feature with a mapping to store admin addresses, add, and remove admin capabilities. Define a staker struct with properties for token ID, token index, rewards earned, and rewards released. Implement functions for staking, unstaking, and updating treasure reward times. Include getter functions for staked tokens, rewards count, and treasure unlock times. Make sure the contract includes logging for emissions, chest tiers, and token IDs."
contract_205.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/main/contracts/src/v0.6/VRFConsumerBase.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/utils/Initializable.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol"";


contract HealingRequest is VRFConsumerBase, Ownable, Initializable, Pausable {
    uint256 public healPrice;
    uint256 public tokenIndex;

    bytes32 internal keyHash;
    uint256 internal fee;

    struct HealRequest {
        address requester;
        bool isFulfilled;
        uint256 healingAmount;
        uint256 tokenID;
    }

    mapping(bytes32 => HealRequest) public healRequests;
    mapping(uint256 => bytes32) public tokenIdToRequestId;

    event ReceivedHealRequest(bytes32 indexed requestId, address indexed requester, uint256 tokenID);
    event FulfilledHealRequest(bytes32 indexed requestId, uint256 healingAmount);

    constructor(address _VRFCoordinator, address _LinkToken, bytes32 _keyHash) 
        VRFConsumerBase(_VRFCoordinator, _LinkToken) {
        keyHash = _keyHash;
        fee = 0.1 * 10 ** 18; // 0.1 LINK
        healPrice = 1 ether;
    }

    function initialize(address owner) public initializer {
        _transferOwnership(owner);
    }

    function requestHealing() public payable whenNotPaused {
        require(msg.value >= healPrice, 'Not enough Ether for healing request.');

        bytes32 requestId = requestRandomness(keyHash, fee);
        uint256 tokenID = tokenIndex++;

        HealRequest storage newRequest = healRequests[requestId];
        newRequest.requester = msg.sender;
        newRequest.isFulfilled = false;
        newRequest.tokenID = tokenID;

        tokenIdToRequestId[tokenID] = requestId;

        emit ReceivedHealRequest(requestId, msg.sender, tokenID);
    }

    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
        HealRequest storage hr = healRequests[requestId];
        hr.isFulfilled = true;
        hr.healingAmount = randomness % 100;

        emit FulfilledHealRequest(requestId, hr.healingAmount);
    }

    function getHealing(uint256 tokenId) public view returns(uint256 healingAmount) {
        bytes32 requestId = tokenIdToRequestId[tokenId];
        require(healRequests[requestId].isFulfilled, 'Healing request is not fulfilled yet.');
        
        return healRequests[requestId].healingAmount;
    }

    function setHealingPrice(uint256 _healPrice) public onlyOwner {
        healPrice = _healPrice;
    }

    function withdraw() public onlyOwner {
        uint256 balance = address(this).balance;
        require(balance > 0, 'Balance is 0');
      
        payable(owner()).transfer(balance);
    }

    function pauseContract() public onlyOwner {
        _pause();
    }

    function unpauseContract() public onlyOwner {
        _unpause();
    }
}","Develop a smart contract that allows users to request and fulfill healing requests, implementing a pending heal system, managing token IDs, and utilizing Chainlink VRF for random number generation. Consider pausing/unpausing the contract and maintaining upgradeability. Ensure smart contract logic is reasonable and efficient."
contract_182.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TokenContract {

  string public constant name = ""MyToken"";
  string public constant symbol = ""MT"";
  uint8 public constant decimals = 18;

  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
  event Transfer(address indexed from, address indexed to, uint tokens);

  mapping(address => uint256) balances;
  mapping(address => mapping (address => uint256)) allowed;
  
  uint256 totalSupply_;
  bool public paused = false;

  using SafeMath for uint256;

  constructor(uint256 total) {
    totalSupply_ = total;
    balances[msg.sender] = totalSupply_;
  }

  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  function balanceOf(address tokenOwner) public view returns (uint256) {
    return balances[tokenOwner];
  }

  function transfer(address receiver, uint256 numTokens) public returns (bool) {
    require(!paused);
    require(numTokens <= balances[msg.sender]);
    balances[msg.sender] = balances[msg.sender].sub(numTokens);
    balances[receiver] = balances[receiver].add(numTokens);
    emit Transfer(msg.sender, receiver, numTokens);
    return true;
  }

  function approve(address delegate, uint256 numTokens) public returns (bool) {
    require(!paused);
    allowed[msg.sender][delegate] = numTokens;
    emit Approval(msg.sender, delegate, numTokens);
    return true;
  }

  function allowance(address owner, address delegate) public view returns (uint) {
    return allowed[owner][delegate];
  }

  function transferFrom(address owner, address buyer, uint256 numTokens) public returns (bool) {
    require(!paused);
    require(numTokens <= balances[owner]);    
    require(numTokens <= allowed[owner][msg.sender]);
    
    balances[owner] = balances[owner].sub(numTokens);
    allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);
    balances[buyer] = balances[buyer].add(numTokens);
    
    emit Transfer(owner, buyer, numTokens);
    return true;
  }

  function pause() public {
    paused = true;
  }

  function unpause() public {
    paused = false;
  }

}

library SafeMath {

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
  
}","Create a token contract that allows users to transfer tokens, track balances, and grant approvals. The contract should include features for pausing and unpausing token transfers. Implement the total supply tracking and provide functions for users to check their balances and approve token transfers."
contract_35.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint public totalSupply;
    
    mapping (address => uint) public balanceOf;
    mapping (address => mapping (address => uint)) public allowance;

    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint _totalSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply;
        balanceOf[msg.sender] = totalSupply;
    }

    function transfer(address _to, uint _value) external returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint _value) external returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint _value) external returns (bool success) {
        require(balanceOf[_from] >= _value);
        require(allowance[_from][msg.sender] >= _value);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }
}","Create a smart contract that represents an ERC20 token. The contract should manage token balances and allow for the transfer of tokens. Users should be able to query the balance of their account and approve or disapprove specific amounts for spending. Implement event listeners for token transfers and approvals. Consider implementing features for token creation, naming, and tracking of supply."
contract_181.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;

        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;

        return c;
    }
}

contract DigitalEntertainmentToken {
    using SafeMath for uint256;

    mapping(address => uint256) private _balances;

    mapping(address => mapping(address => uint256)) private _allowed;

    uint256 private _totalSupply;
    
    address private _owner;

    string private _name;
    string private _symbol;
    uint8 private _decimals;

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory name, string memory symbol, uint8 decimals, uint256 totalSupply) {
        _name = name;
        _symbol = symbol;
        _decimals = decimals;
        _totalSupply = totalSupply;
        _balances[msg.sender] = _totalSupply;
        _owner = msg.sender;
    }
    
    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }

    function transfer(address to, uint256 value) public returns (bool) {
        require(value <= _balances[msg.sender], ""Insufficient balance"");
        require(to != address(0), ""Cannot transfer to the zero address"");

        _balances[msg.sender] = _balances[msg.sender].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool) {
        require(spender != address(0), ""Cannot approve to the zero address"");

        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        require(value <= _balances[from], ""Insufficient balance"");
        require(value <= _allowed[from][msg.sender], ""Insufficient allowance"");
        require(to != address(0), ""Cannot transfer to the zero address"");

        _balances[from] = _balances[from].sub(value);
        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
        return true;
    }
}","Design a smart contract to manage a token for digital entertainment. The contract should include features for owner transfer, approval, and token transfer. Implement a system for tracking token balances and allowed transactions. Emit events for transfer and approval. Build upon a library that provides safe arithmetic operations. Keep in mind the specific functionality demonstrated in the provided code snippet."
contract_83.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    mapping(address => uint) public balances;
    mapping(address => mapping(address => uint)) public allowance;
    uint public totalSupply;
    string public name;
    string public symbol;
    uint public decimal;
    address public owner;

    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);

    constructor(string memory _name, string memory _symbol, uint _decimal, uint _totalSupply) {
        name = _name;
        symbol = _symbol;
        decimal = _decimal;
        totalSupply = _totalSupply;
        balances[msg.sender] = _totalSupply;
        owner = msg.sender;
    }

    function balanceOf(address _owner) public view returns (uint balance) {
        return balances[_owner];
    }

    function transfer(address _to, uint _value) public returns(bool success) {
        require(balances[msg.sender] >= _value, 'balance too low');
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint _value) public returns(bool success) {
        require(balances[_from] >= _value, 'balance too low');
        require(allowance[_from][msg.sender] >= _value, 'allowance too low');
        balances[_to] += _value;
        balances[_from] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint _value) public returns(bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}

contract TransferETH {

    Token public token;
    event Sent(address from, address to, uint amount);

    constructor(Token _token) {
        token = _token;
    }

    function sendETH(address payable _to) public payable {
        require(msg.value > 0, ""Amount must be greater than 0"");
        _to.transfer(msg.value);
        emit Sent(msg.sender, _to, msg.value);
    }
}","Create a smart contract that enables the transfer of tokens, approval of allowance, and transfer of ETH. The contract should include functions for safe transfer from, safe transfer, safe approve, and safe transfer ETH. Implement basic error handling and logging. Ensure the contract's functionality is structured and readable."
contract_36.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.5;

contract PancakePairMock {
    address public token0;
    address public token1;
    uint public reserve0;
    uint public reserve1;

    event Mint(address indexed sender, uint amount0, uint amount1);
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint reserve0, uint reserve1);

    constructor() public {
        token0 = address(1); 
        token1 = address(2); 
    }

    function mint(address to) external payable returns (uint liquidity) {
        uint balance0 = IERC20(token0).balanceOf(address(this));
        uint balance1 = IERC20(token1).balanceOf(address(this));
        uint amount0 = balance0 - reserve0;
        uint amount1 = balance1 - reserve1;

        reserve0 = balance0;
        reserve1 = balance1;
        emit Mint(msg.sender, amount0, amount1);
    }

    function burn(address to) external returns (uint amount0, uint amount1) {
        uint balance0 = IERC20(token0).balanceOf(address(this));
        uint balance1 = IERC20(token1).balanceOf(address(this));

        reserve0 = balance0;
        reserve1 = balance1;
        emit Burn(msg.sender, amount0, amount1, to);
    }

    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external {
        uint balance0;
        uint balance1;
        { 
            balance0 = IERC20(token0).balanceOf(address(this));
            balance1 = IERC20(token1).balanceOf(address(this));
        }
        require(balance0 >= amount0Out, 'Pancake: INSUFFICIENT_A_AMOUNT');
        require(balance1 >= amount1Out, 'Pancake: INSUFFICIENT_B_AMOUNT');

        emit Swap(msg.sender, amount0Out, amount1Out, to);
    }

    function skim(address to) external {
        
    }

    function sync() external {
        reserve0 = IERC20(token0).balanceOf(address(this));
        reserve1 = IERC20(token1).balanceOf(address(this));
        emit Sync(reserve0, reserve1);
    }
}

interface IERC20{
    function balanceOf(address account) external view returns(uint);
}","Develop a smart contract that mimics the behavior of the IPancakePair interface. This contract should be able to handle token minting, burning, swapping, and syncing. Ensure the contract accurately manages the token reserves and pricing information. Include basic input validation and error handling."
contract_249.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol"";

contract MarketPositioning is Initializable, ReentrancyGuardUpgradeable, OwnableUpgradeable, PausableUpgradeable {
    struct Position {
        uint amount;
        uint price;
    }

    mapping(address => Position) private positions;
    mapping(address => uint) private fundingRates;
    address public feeReceiver;
    uint public indexPrice;

    function initialize() public initializer {
        __ReentrancyGuard_init();
        __Ownable_init();
        __Pausable_init();
    }

    function updatePosition(address trader, uint amount, uint price) external onlyOwner whenNotPaused {
        positions[trader] = Position(amount, price);
    }

    function settleFunding(address trader) external onlyOwner {
        uint fundingPaid = positions[trader].amount * fundingRates[trader] / 1e18;
        positions[trader].amount -= fundingPaid;
        payable(feeReceiver).transfer(fundingPaid);
    }

    function setDefaultFeeReceiver(address _feeReceiver) external onlyOwner {
        feeReceiver = _feeReceiver;
    }

    function updateIndexPrice(uint _indexPrice) external onlyOwner whenNotPaused {
        indexPrice = _indexPrice;
    }

    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }
}","Develop a smart contract that enables market positioning, funding rate management, and liquidator control. The contract should include functions to settle funding for traders, set default fee receivers, and update index price oracles. Implement pausability and reentrancy protection. Use upgradeable contracts from OpenZeppelin to ensure security and maintainability. Focus on providing a robust and secure foundation for managing market positions and funding rates."
contract_248.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SafeMath {
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }

    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a); 
        c = a - b; 
    } 

    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    } 

    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}

contract MyToken is SafeMath {

    string public constant name = ""MyToken"";
    string public constant symbol = ""MYT"";
    uint8 public constant decimals = 18;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    mapping(address => uint256) balances;
    mapping(address => mapping (address => uint256)) allowed;

    uint256 totalSupply;

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply;
        balances[msg.sender] = initialSupply;
        emit Transfer(address(0), msg.sender, initialSupply);
    }

    function total_supply() public view returns (uint256) {
        return totalSupply;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function transfer(address _to, uint256 _amount) public returns (bool success) {
        require(balances[msg.sender] >= _amount);
        balances[msg.sender] = safeSub(balances[msg.sender], _amount);
        balances[_to] = safeAdd(balances[_to], _amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {
        require(balances[_from] >= _amount);
        require(allowed[_from][msg.sender] >= _amount);

        balances[_from] = safeSub(balances[_from], _amount);
        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _amount);
        balances[_to] = safeAdd(balances[_to], _amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }

    function approve(address _spender, uint256 _amount) public returns (bool success) {
        allowed[msg.sender][_spender] = _amount;
        emit Approval(msg.sender, _spender, _amount);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}","Create a token-based smart contract that allows for token transfer, approval, and balance inquiry. Implement functions for token transfer, approval, and total supply. Utilize the SafeMath library for secure arithmetic operations. Incorporate event triggers for token transfer and approval. Consider the smart contract code provided and modify it to fit your requirements."
contract_43.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// Basic ERC20 Interface
interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address tokenOwner) external view returns (uint256 balance);
    function allowance(address tokenOwner, address spender) external view returns (uint256 remaining);
    function transfer(address to, uint256 tokens) external returns (bool success);
    function approve(address spender, uint256 tokens) external returns (bool success);
    function transferFrom(address from, address to, uint256 tokens) external returns (bool success);
}

//Contract that interacts with ERC20 Tokens
contract TokenInteractor {
    IERC20 erc20Instance;

    //Set the token address
    function setToken(address _token) public {
        erc20Instance = IERC20(_token);
    }

    //Check balance of the contract
    function checkBalance() public view returns (uint256) {
        return erc20Instance.balanceOf(address(this));
    }

    //Check allowance
    function checkAllowance(address _owner, address _spender) public view returns (uint256) {
        return erc20Instance.allowance(_owner, _spender);
    }

    //Approve token transfer
    function approve(address _spender, uint256 _value) public returns (bool) {
        return erc20Instance.approve(_spender, _value);
    }

    //Transfer tokens from the Contract's balance
    function transfer(address _to, uint256 _value) public returns (bool) {
        return erc20Instance.transfer(_to, _value);
    }

    //Transfer tokens from one address to another
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        return erc20Instance.transferFrom(_from, _to, _value);
    }
}","Create a smart contract that interacts with various interfaces to enable approval, allowance, and utility methods. The contract should be modular and well-documented. Focus on implementing the key functions and modules outlined in the provided code fragment."
contract_87.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MLM {

    struct Investor {
        bool active;
        uint totalInvested;
        uint totalWithdrawn; 
        uint totalIncome;
        uint depositTime;
        uint investmentsCount;
        mapping(uint => Investment) investments;
    }

    struct Investment {
        uint amount;
        uint at;
    }

    uint public totalInvestors;
    uint public totalInvested;
    uint public totalWithdrew;
    mapping(address => Investor) public investors;

    event NewDeposit(address indexed investor, uint amount);
    event NewWithdrawal(address indexed investor, uint amount);

    function deposit() public payable {
        require(msg.value > 0, ""Investment can't be zero"");

        Investor storage investor = investors[msg.sender];
        if (!investor.active) {
            investor.active = true;
            totalInvestors++;
        }

        investor.depositTime = block.timestamp;
        investor.totalInvested += msg.value;
        investor.investments[investor.investmentsCount++] = Investment(msg.value, block.timestamp);
        totalInvested += msg.value;

        emit NewDeposit(msg.sender, msg.value);
    }

    function withdraw(uint amount) public {
        require(amount > 0, ""Withdrawal can't be zero"");

        Investor storage investor = investors[msg.sender];
        require(investor.totalIncome + amount <= investor.totalInvested * 1.5, ""Can't withdraw more than 150%"");

        _payout(msg.sender);
        require(amount <= investor.totalIncome, ""Insufficient funds"");

        investor.totalIncome -= amount;
        investor.totalWithdrawn += amount;
        totalWithdrew += amount;
        payable(msg.sender).transfer(amount);

        emit NewWithdrawal(msg.sender, amount);
    }

    function _payout(address _addr) internal {
        Investor storage investor = investors[_addr];

        for (uint i = 0; i < investor.investmentsCount; i++) {
            uint timeEnd = investor.investments[i].at + 600;
            uint period = block.timestamp < timeEnd ? block.timestamp : timeEnd;
            uint p = (period - investor.depositTime) / 1 days;
            investor.totalIncome += p * investor.investments[i].amount;
            investor.depositTime += p * 1 days;
        }
    }

    function calculateIncome(address _addr) public view returns(uint) {
        Investor storage investor = investors[_addr];
        uint totalIncome = investor.totalIncome;
        for (uint i = 0; i < investor.investmentsCount; i++) {
            uint timeEnd = investor.investments[i].at + 600;
            uint period = block.timestamp < timeEnd ? block.timestamp : timeEnd;

            if (investor.depositTime < period) {
                uint p = (period - investor.depositTime) / 1 days;
                totalIncome += p * investor.investments[i].amount;
            }
        }

        return totalIncome;
    }
}","Create a smart contract that implements a revenue sharing model for a multi-level marketing organization. The contract should allow investors to deposit funds, make investments, and withdraw funds. It should also track deposits and withdrawals, and calculate daily income and commission distributions. The contract should include variables for storing investor information and investment records, and has internal functions for processing deposits and withdrawals. Externally, allow users to deposit and withdraw funds. Include modifiers for restricting access to certain functions based on user roles."
contract_222.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    string public name;
    string public symbol;
    uint256 public totalSupply;
    address public owner;

    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowed;

    constructor(string memory _name, string memory _symbol) {
        name = _name;
        symbol = _symbol;
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner, ""Only owner can perform this action"");
        _;
    }

    function setTokenDetail(string memory _name, string memory _symbol) public onlyOwner {
        name = _name;
        symbol = _symbol;
    }

    function setOwner(address _newOwner) public onlyOwner {
        owner = _newOwner;
    }

    function mint(address _to, uint256 _value) public onlyOwner {
        require(totalSupply + _value >= totalSupply, ""Overflow error"");

        totalSupply += _value;
        balances[_to] += _value;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value, ""Insufficient balance"");

        balances[msg.sender] -= _value;
        balances[_to] += _value;

        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;

        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(balances[_from] >= _value, ""Insufficient balance"");
        require(allowed[_from][msg.sender] >= _value, ""Not authorized"");

        balances[_from] -= _value;
        balances[_to] += _value;
        allowed[_from][msg.sender] -= _value;

        return true;
    }
}","Create a smart contract that allows for the transfer of tokens between addresses, including the option to approve spending by other contracts. The contract should include functions to set the token name, symbol, and owner, as well as methods for transferring tokens, approving spending, and minting new tokens. Focus on the functional aspects of the contract, ensuring that tokens can be transferred and balances updated correctly."
contract_197.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Basic {
    function totalSupply() public view virtual returns (uint256);
    function balanceOf(address who) public view virtual returns (uint256);
    function transfer(address to, uint256 value) public virtual returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
}

contract ERC20 is ERC20Basic {
    function allowance(address owner, address spender) public view virtual returns (uint256);
    function transferFrom(address from, address to, uint256 value) public virtual returns (bool);
    function approve(address spender, uint256 value) public virtual returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract ERC223Basic {
    uint public totalSupply;
    function balanceOf(address who) public view returns (uint);
    function transfer(address to, uint value) public;
    function transfer(address to, uint value, bytes memory data) public;
    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);
}

contract ERC223ReceivingContract {
    function tokenFallback(address _from, uint _value, bytes memory _data) public;
}

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(isOwner(), ""Ownable: caller is not the owner"");
        _;
    }

    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract TenXAminToken is Ownable, ERC223Basic, ERC20 {
    string public name = ""10xAmin Token"";
    string public symbol = ""10xAMIN"";
    uint8 public decimals = 18;
    uint256 totalSupply_;

    mapping(address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;

    constructor(uint256 total) {
        totalSupply_ = total;
        balances[msg.sender] = totalSupply_;
    }

    function totalSupply() public view override returns (uint256) {
        return totalSupply_;
    }

    function balanceOf(address _owner) public view override(ERC20Basic, ERC223Basic) returns (uint256 balance) {
        return balances[_owner];
    }

    function transfer(address _to, uint _value, bytes memory _data) public override {
        _transfer(msg.sender, _to, _value, _data);
    }

    function _transfer(address _from, address _to, uint _value, bytes memory _data) internal {
        require(_to != address(0));
        require(balances[_from] >= _value);
        balances[_from] = balances[_from] - _value;
        balances[_to] = balances[_to] + _value;
        if(isContract(_to)) {
            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
            receiver.tokenFallback(_from, _value, _data);
        }
        emit Transfer(_from, _to, _value, _data);
    }

    function isContract(address _addr) private view returns (bool) {
        uint length;
        assembly {
            length := extcodesize(_addr)
        }
        return (length > 0);
    }

    function allowance(address _owner, address _spender) public view override returns (uint256) {
        return allowed[_owner][_spender];
    }

    function approve(address _spender, uint256 _value) public override returns (bool) {
        require(_spender != address(0));
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool) {
        require(_to != address(0));
        require(_value <= balanceOf(_from));
        require(_value <= allowed[_from][msg.sender]);
        balances[_from] = balances[_from] - _value;
        balances[_to] = balances[_to] + _value;
        allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    function mint(uint256 amount) public onlyOwner {
        totalSupply_ = totalSupply_ + amount;
        balances[owner()] = balances[owner()] + amount;
        emit Transfer(address(0), owner(), amount);
    }
}","Create a Solidity smart contract for the '10xAmin Token'. The contract should allow for token transfers, approvals, and minting capabilities. Implement the ERC223 and ERC20 standards. Define the token's name, symbol, and decimal places. Include functionality for owner-only access to certain functions and implement modifiers as necessary."
contract_171.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

abstract contract Pausable {
    event Paused(address account);
    event Unpaused(address account);

    bool private _paused;

    constructor () {
        _paused = false;
    }

    function pause() public virtual {
        _paused = true;
        emit Paused(msg.sender);
    }

    function unpause() public virtual {
        _paused = false;
        emit Unpaused(msg.sender);
    }

    function paused() public view virtual returns (bool) {
        return _paused;
    }

    modifier whenNotPaused() {
        require(!paused(), ""Pausable: paused"");
        _;
    }

    modifier whenPaused() {
        require(paused(), ""Pausable: not paused"");
        _;
    }
}

interface IAccounting {
    function transferToContract(address asset, uint256 amount) external;
    function transferFromContract(address asset, uint256 amount) external;
}

interface AggregatorV3Interface {
    function latestRoundData() external view returns (uint256, int256, uint256, uint256, uint80);
}

interface IHedgingReactor {
    function deltaHedge() external;
}

contract hedgingContract is Pausable {
    IAccounting public accounting;
    AggregatorV3Interface public priceFeed;
    IHedgingReactor public hedgingReactor;
  
    event DeltaHedged(address indexed _sender);
    event AssetWithdrawn(address indexed _receiver, uint256 _amount);
    event AssetReceived(address indexed _sender, uint256 _amount);

    constructor(address _accounting, address _priceFeed, address _hedgingReactor) {
        accounting = IAccounting(_accounting);
        priceFeed = AggregatorV3Interface(_priceFeed);
        hedgingReactor = IHedgingReactor(_hedgingReactor);
    }
    
    function receiveAsset(address asset, uint256 amount) external whenNotPaused {
        accounting.transferToContract(asset, amount);
        emit AssetReceived(msg.sender, amount);
    }

    function withdrawAsset(address asset, uint256 amount) external whenPaused {
        accounting.transferFromContract(asset, amount);
        emit AssetWithdrawn(msg.sender, amount);
    }

    function deltaHedge() external whenNotPaused {
        hedgingReactor.deltaHedge();
        emit DeltaHedged(msg.sender);
    }
}","Create a Solidity smart contract that allows for pausing and unpausing of smart contract functionality, utilizing the Pausable abstract contract. Implement interfaces for receiving IAccounting, AggregatorV3Interface, and IHedgingReactor, integrating them to facilitate delta hedging, collateralling, and withdrawals. Utilize state variables and modifiers to restrict functionality when paused or unpaused. Include functions for interacting with above interfaces and emitting events during significant transactions."
contract_184.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

library SafeMath {
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a, ""SafeMath: addition overflow"");

    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    return sub(a, b, ""SafeMath: subtraction overflow"");
  }

  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
    require(b <= a, errorMessage);
    uint256 c = a - b;

    return c;
  }

  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }

    uint256 c = a * b;
    require(c / a == b, ""SafeMath: multiplication overflow"");

    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    return div(a, b, ""SafeMath: division by zero"");
  }

  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
    // Solidity only automatically asserts when dividing by 0
    require(b > 0, errorMessage);
    uint256 c = a / b;

    return c;
  }
}

contract ERC20 {
    using SafeMath for uint256;

    string public constant name = ""ERC20Basic"";
    string public constant symbol = ""BSC"";
    uint8 public constant decimals = 8;
    uint256 public _totalSupply = 500000000 * (10 ** uint256(decimals));
    
    mapping(address => uint256) balances;
    mapping(address => mapping (address => uint256)) allowed;
    
    constructor() {
        balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address tokenOwner) public view returns (uint256) {
        return balances[tokenOwner];
    }

    function transfer(address receiver, uint256 numTokens) public returns (bool) {
        require(numTokens <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(numTokens);
        balances[receiver] = balances[receiver].add(numTokens);
        emit Transfer(msg.sender, receiver, numTokens);
        return true;
    }

    function approve(address delegate, uint256 numTokens) public returns (bool) {
        allowed[msg.sender][delegate] = numTokens;
        emit Approval(msg.sender, delegate, numTokens);
        return true;
    }

    function allowance(address owner, address delegate) public view returns (uint) {
        return allowed[owner][delegate];
    }

    function transferFrom(address owner, address buyer, uint256 numTokens) public returns (bool) {
        require(numTokens <= balances[owner]);    
        require(numTokens <= allowed[owner][msg.sender]);

        balances[owner] = balances[owner].sub(numTokens);
        allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);
        balances[buyer] = balances[buyer].add(numTokens);
        emit Transfer(owner, buyer, numTokens);
        return true;
    }

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}","Create a smart contract that enables the creation of a basic ERC20 token. The token should have a total supply of 500 million and 8 decimal places. Include functionality for transferring tokens, approving allowances, and checking remaining balances. Utilize the SafeMath library for arithmetic operations. Pay attention to event emissions and ensure that the contract is compliant with the ERC20 standard."
contract_52.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract LendingPoolParameters {

    struct Parameters {
        uint256 optimalUtilizationRate;
        uint256 baseVariableBorrowRate;
        uint256 variableRateSlope1;
        uint256 variableRateSlope2;
    }

    address public owner;

    Parameters public liveParameters;
    Parameters public stagedParameters;

    uint256 public stageTimestamp;
    uint256 public delayDuration = 24 hours;
    
    constructor(uint256 _optimalUtilizationRate,
                uint256 _baseVariableBorrowRate,
                uint256 _variableRateSlope1,
                uint256 _variableRateSlope2) {
        owner = msg.sender;
        
        liveParameters = Parameters({
            optimalUtilizationRate: _optimalUtilizationRate,
            baseVariableBorrowRate: _baseVariableBorrowRate,
            variableRateSlope1: _variableRateSlope1,
            variableRateSlope2: _variableRateSlope2
        });
    }
    
    function stageParameters(uint256 _optimalUtilizationRate,
                             uint256 _baseVariableBorrowRate,
                             uint256 _variableRateSlope1,
                             uint256 _variableRateSlope2) public {
        require(msg.sender == owner, ""Caller is not the owner"");
        
        stagedParameters = Parameters({
            optimalUtilizationRate: _optimalUtilizationRate,
            baseVariableBorrowRate: _baseVariableBorrowRate,
            variableRateSlope1: _variableRateSlope1,
            variableRateSlope2: _variableRateSlope2
        });

        stageTimestamp = block.timestamp;
    }

    function commitParameters() public {
        require(msg.sender == owner, ""Caller is not the owner"");
        require(block.timestamp >= stageTimestamp + delayDuration, ""Not eligible to commit changes yet"");

        liveParameters = stagedParameters;
    }
}","Create a smart contract that allows for staging and committing delayed protocol parameters, leveraging the Aave LendingPool. Implement functions for delaying parameter updates and commit logic, ensuring timestamp validation and access control. Consider integrating the contract with external systems and incorporate best practices for smart contract development."
contract_10.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ReentrancyGuard {
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;
    uint256 private _status;

    constructor () {
        _status = _NOT_ENTERED;
    }

    modifier nonReentrant() {
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");
        _status = _ENTERED;
        _;
        _status = _NOT_ENTERED;
    }
}

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract TokenGuard is Ownable, ReentrancyGuard {
    struct Deposit {
        uint256 amount;
        uint256 unlockDate;
    }

    mapping (address => Deposit) private _balances;

    event DepositMade(address indexed depositor, uint256 amount, uint256 unlockDate);
    event WithdrawalMade(address indexed depositor, uint256 amount);

    function deposit(uint256 amount, uint256 unlockDate) public nonReentrant {
        require(amount > 0, ""Cannot deposit 0"");
        require(unlockDate > block.timestamp, ""Unlock date is not in the future"");

        _balances[msg.sender].amount += amount;
        _balances[msg.sender].unlockDate = unlockDate;

        emit DepositMade(msg.sender, amount, unlockDate);
    }

    function withdraw() public nonReentrant {
        require(block.timestamp >= _balances[msg.sender].unlockDate, ""Not yet unlocked"");

        uint256 amount = _balances[msg.sender].amount;
        _balances[msg.sender].amount = 0;
        _balances[msg.sender].unlockDate = 0;

        payable(msg.sender).transfer(amount);
        emit WithdrawalMade(msg.sender, amount);
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account].amount;
    }
}","Create a smart contract that safely manages token balances and transfer, implementing ReentrancyGuard and Ownable contracts from OpenZeppelin. Include deposit, withdraw, and balance functions, considering timestamp-based unlocking. Make sure the contract is compatible with Solidity 0.8.0."
contract_234.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract E4Token {

    // track token balances
    mapping (address => uint256) private balances;
    mapping (address => mapping(address => uint256)) private allowed;
    uint256 private totalSupply;
    
    // track dividends
    mapping (address => uint256) private dividends;

    string public constant name = ""E4Token"";
    string public constant symbol = ""E4T"";
    uint8 public constant decimals = 18;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    //modifiers
    modifier onlyValidAddress(address account){
        require(account != address(0), 'Invalid address');
        _;
    }

    function mint(address account, uint256 amount) external onlyValidAddress(account) {
        totalSupply += amount;
        balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function burn(address account, uint256 amount) external onlyValidAddress(account) {
        require(balances[account] >= amount, 'Insufficient balance');
        totalSupply -= amount;
        balances[account] -= amount;
        emit Transfer(account, address(0), amount);
    }

     function totalSupply() public view returns (uint256) {
        return totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        require(balances[msg.sender] >= amount, 'Insufficient balance');
        balances[msg.sender] -= amount;
        balances[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return allowed[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        allowed[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        require(amount <= balances[sender], 'Insufficient balance');
        require(amount <= allowed[sender][msg.sender], 'Insufficient allowance');
        
        balances[sender] -= amount;
        balances[recipient] += amount;
        allowed[sender][msg.sender] -= amount;
        
        emit Transfer(sender, recipient, amount);
        return true;
    }

    function dividendsOf(address account) public view returns (uint256) {
        return dividends[account];
    }

    function withdrawDividends(address account) public returns (bool) {
        require(dividends[account] > 0, 'No dividends available to withdraw');
        
        uint256 amount = dividends[account];
        dividends[account] = 0;
        
        payable(account).transfer(amount);
        return true;
    }

}","Create a smart contract for the E4Token that allows for token transactions, including minting, transferring, and approving tokens. The contract should include a mapping to track token balances and allow holders to withdraw dividends. Implement functions for token transfers, approvals, and allowance tracking. Ensure the contract includes events for token transfers and approvals. Consider implementing modifiers and functions to govern token minting and burning. Develop a comprehensive and understandable smart contract that implements the E4Token functionality."
contract_26.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract RestrictedAccess {

    address private _operator;
    mapping(address => uint8) private _operators;

    event OperatorTransferred(address indexed previousOperator, address indexed newOperator);
    event Action(string details, address indexed operator);

    modifier onlyOperator() {
        require(_operators[msg.sender] > 0, ""RestrictedAccess: caller is not the operator"");
        _;
    }

    constructor(address initialOperator) {
        require(initialOperator != address(0), ""RestrictedAccess: invalid address"");
        _operator = initialOperator;
        _operators[initialOperator] = 1;

        emit OperatorTransferred(address(0), initialOperator);
    }

    function operator() public view returns (address) {
        return _operator;
    }

    function isOperator(address operatorAddress) public view returns (bool) {
        return _operators[operatorAddress] > 0;
    }

    function transferOperator(address newOperator) public onlyOperator {
        require(newOperator != address(0), ""RestrictedAccess: invalid address"");
        _operators[_operator] = 0;
        _operator = newOperator;
        _operators[newOperator] = 1;

        emit OperatorTransferred(_operator, newOperator);
    }

    function action(string memory details) public onlyOperator {
        emit Action(details, msg.sender);
    }
}",Create a smart contract that restricts access to certain functions based on the operator's role. The contract should have an `operator` variable and an `operator` function that returns the current operator. Implement a function to transfer the operator role to a new address and another function to check if a user is the current operator. The contract should also have events for operator changes and notifications for certain actions.
contract_137.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

abstract contract ERC721 {
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual;

    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory tokenIds
    ) public virtual;

    function balanceOf(address owner) public view virtual returns (uint256 balance);
}

contract DepositWithdraw {
    mapping(address => mapping(uint256 => bool)) public deposits;

    event Deposited(address indexed user, uint256 indexed tokenId, address indexed contractAddress);
    event BatchDeposited(address indexed user, uint256[] indexed tokens, address indexed contractAddress);
    event Withdrawn(address indexed user, uint256 indexed tokenId, address indexed contractAddress);
    event BatchWithdrawn(address indexed user, uint256[] indexed tokens, address indexed contractAddress);

    function depositSingle(address tokenAddress, uint256 tokenId) public {
        ERC721(tokenAddress).safeTransferFrom(msg.sender, address(this), tokenId);
        deposits[tokenAddress][tokenId] = true;
        emit Deposited(msg.sender, tokenId, tokenAddress);
    }

    function depositBatch(address tokenAddress, uint256[] calldata tokenIds) public {
        for(uint i=0; i<tokenIds.length; i++){
            this.depositSingle(tokenAddress, tokenIds[i]);
        }
        emit BatchDeposited(msg.sender, tokenIds, tokenAddress);
    }

    function withdrawSingle(address tokenAddress, uint256 tokenId) public {
        require(deposits[tokenAddress][tokenId] == true, ""Token not deposited in contract"");
        deposits[tokenAddress][tokenId] = false;
        ERC721(tokenAddress).safeTransferFrom(address(this), msg.sender, tokenId);
        emit Withdrawn(msg.sender, tokenId, tokenAddress);
    }

    function withdrawBatch(address tokenAddress, uint256[] calldata tokenIds) public {
        for(uint i=0; i<tokenIds.length; i++){
            this.withdrawSingle(tokenAddress, tokenIds[i]);
        }
        emit BatchWithdrawn(msg.sender, tokenIds, tokenAddress);
    }
}","Create a smart contract that allows users to deposit and withdraw ERC721 tokens. The contract should support single and batch transactions. The deposit function should handle single and batch deposits, while the withdraw and withdrawBatch functions should handle single and batch withdrawals. The contract should also have role-based access control and emit events for withdrawn batches."
contract_115.sol,"pragma solidity ^0.8.0;

contract ERC20 {
    //Variables for token name, symbol and decimals
    string public  name;
    string public symbol;
    uint8 public decimals;

    uint256 public totalSupply;

    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    //Events for transfer and approvals
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _initialSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _initialSupply;
        balanceOf[msg.sender] = _initialSupply;
        emit Transfer(address(0), msg.sender, _initialSupply);
    }

    //Transfer function
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    //Approve function
    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value; 
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
      
    //TransferFrom function
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(allowance[_from][msg.sender] >= _value, ""Not allowed to transfer this amount"");
        require(balanceOf[_from] >= _value, ""Insufficient balance"");

        balanceOf[_from] -= _value; 
        balanceOf[_to] += _value; 
        allowance[_from][msg.sender] -= _value;

        emit Transfer(_from, _to, _value);
        return true;
    }

    function mint(address account, uint256 amount) public {
        totalSupply += amount;
        balanceOf[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function burn(address account, uint256 amount) public {
        require(balanceOf[account] >= amount, ""Insufficient balance to burn"");
        totalSupply -= amount;
        balanceOf[account] -= amount;
        // emit Transfer(account, address(0), amount);
    }
}","Develop a smart contract that follows the ERC20 token standard. The contract should manage token balances and allowance values for each address. Implement transfer, approve, and transferFrom functions. Ensure minting and burning tokens are supported. Include a constructor for initializing the token's name, symbol, and decimals."
contract_34.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract FeesManager {
    struct Fees {
        uint256 buyFee;
        uint256 sellFee;
        uint256 transferFee;
        uint256 gameFee;
    }

    uint256 public constant  maxTotalFee = 100; 
    Fees public fees;
    uint256 public revision = 0;

    event FeesChanged(uint256 revision, uint256 buyFee, uint256 sellFee, uint256 transferFee, uint256 gameFee);

    constructor(uint256 _buyFee, uint256 _sellFee, uint256 _transferFee, uint256 _gameFee) {
        require(_buyFee + _sellFee + _transferFee <= maxTotalFee, ""Total fees should not exceed 100"");
        fees = Fees({buyFee: _buyFee, sellFee: _sellFee, transferFee: _transferFee, gameFee: _gameFee});
    }

    function setFees(uint256 _buyFee, uint256 _sellFee, uint256 _transferFee, uint256 _gameFee) external {
        require(_buyFee + _sellFee + _transferFee <= maxTotalFee, ""Total fees should not exceed 100"");
        fees.buyFee = _buyFee;
        fees.sellFee = _sellFee;
        fees.transferFee = _transferFee;
        fees.gameFee = _gameFee;
        revision += 1;
        emit FeesChanged(revision, _buyFee, _sellFee, _transferFee, _gameFee);
    }

    function getFees() external view returns(uint256, uint256, uint256, uint256) {
        return (fees.buyFee, fees.sellFee, fees.transferFee, fees.gameFee);
    }
}","Create a smart contract that manages buy, sell, transfer, and game fees, with the ability to set and retrieve these fees. The contract should use a counter to track revisions and emit events when fees are updated. It should also enforce limits on total fees for buy, sell, and transfer operations."
contract_65.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, ""SafeMath: subtraction overflow"");
    }

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, ""SafeMath: division by zero"");
    }

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;

        return c;
    }
}

contract ERC20Token {
    using SafeMath for uint256;

    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    mapping (address => uint256) internal balances;
    mapping (address => mapping (address => uint256)) internal allowed;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply;
        balances[msg.sender] = _totalSupply;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);

        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

        emit Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}","Create a smart contract that represents a token with the following properties: a limited supply of tokens, the ability to transfer tokens between addresses, and support for approving and allowing of token spend. Implement functions to manage token balances, allow and disallow token transfer, and record transactions. Use Solidity and the SafeMath library to ensure accurate and secure arithmetic operations."
contract_44.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    
    function totalSupply() external view returns (uint256);
    
    function balanceOf(address account) external view returns (uint256);
   
    function transfer(address recipient, uint256 amount) external returns (bool);
  
    function allowance(address owner, address spender) external view returns (uint256);
 
    function approve(address spender, uint256 amount) external returns (bool);
   
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    
    event Transfer(address indexed from, address indexed to, uint256 value);
 
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = _msgSender();
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(_owner == _msgSender(), ""Ownable: caller is not the owner"");
        _;
    }
}

library SafeMath {
    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;

        return c;
    }

 
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
       
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;

        return c;
    }
}

contract ERC20 is Context, IERC20 {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;

    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;
 
    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, ""ERC20: transfer amount exceeds allowance""));
        _transfer(sender, recipient, amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, ""ERC20: decreased allowance below zero""));
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _balances[sender] = _balances[sender].sub(amount, ""ERC20: transfer amount exceeds balance"");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: burn from the zero address"");

        _balances[account] = _balances[account].sub(amount, ""ERC20: burn amount exceeds balance"");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}

contract DerivativeInvestmentPlatform is Ownable, ERC20 {
    using SafeMath for uint256;

    uint256 public derivativeStatus;

    constructor() ERC20(""Derivative Token"", ""DT"") {}

    function invest(uint256 amount) public {
        _transfer(msg.sender, address(this), amount);
        _mint(msg.sender, amount);
    }

    function withdraw(uint256 amount) public {
        _burn(msg.sender, amount);
        _transfer(address(this), msg.sender, amount);
    }

    function updateDerivativeStatus(uint256 newStatus) public onlyOwner {
        derivativeStatus = newStatus;
    }
}","Develop a smart contract for a derivative investment platform that allows users to invest and withdraw funds. The contract should inherit from ERC20Extended and Ownable. Implement functions for investing, withdrawing, and updating the derivative status. Incorporate modifiers for ownership and access control. Utilize the SafeMath library for arithmetic operations."
contract_47.sol,"// SPDX-License-Identifier: MIT
pragma solidity >=0.7.0 <0.9.0;

interface IERC20 {
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);
}

interface IUniswapV2Router01 {
    function factory() external view returns (address);
    function WETH() external view returns (address);
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
}

interface IUniswapV2Router02 is IUniswapV2Router01 {
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);
    function getReserves(address factory, address tokenA, address tokenB) external view returns (uint reserveA, uint reserveB);
}

contract UniswapV2Router is IUniswapV2Router02 {
    function factory() public override view returns (address) {
        // To be implemented
    }

    function WETH() public override view returns (address) {
        // To be implemented
    }

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) public override returns (uint amountA, uint amountB, uint liquidity) {
        // To be implemented
    }

    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] memory path,
        address to,
        uint deadline
    ) public override returns (uint[] memory amounts) {
        // To be implemented
    }

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) public override returns (uint amountA, uint amountB) {
        // To be implemented
    }

    function getReserves(address factory, address tokenA, address tokenB) public override view returns (uint reserveA, uint reserveB) {
        // To be implemented
    }
}","Create a contract that allows users to swap tokens, add/remove liquidity, and query reserves. Based on the IUniswapV2Router01 and IUniswapV2Router02 interfaces, implement the necessary functions without getting into the low-level implementation details. Provide general comments explaining the functionality."
contract_90.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
      uint256 c = a + b;
      require(c >= a, ""SafeMath: addition overflow"");

      return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
      require(b <= a, ""SafeMath: subtraction overflow"");
      uint256 c = a - b;

      return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
      if (a == 0) {
        return 0;
      }

      uint256 c = a * b;
      require(c / a == b, ""SafeMath: multiplication overflow"");

      return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
      require(b > 0, ""SafeMath: division by zero"");
      uint256 c = a / b;

      return c;
    }
}

contract Auth {
  address public owner;
  
  constructor(address _owner) {
    owner = _owner;
  }

  modifier onlyOwner() {
    require(msg.sender == owner, ""Only owner can execute this"");
    _;
  }

  function changeOwner(address newOwner) public onlyOwner {
   owner = newOwner;
  }
}

interface IDEXFactory {
    function createPair(address tokenA, address tokenB) external returns (address pair);
}

interface IDEXRouter {
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
}


contract IntegrationContract is Auth {
  using SafeMath for uint256;
  IDEXRouter public idexRouter;
  IDEXFactory public idexFactory;

  constructor(address _router, address _factory, address _owner) Auth(_owner) {
    idexRouter = IDEXRouter(_router);
    idexFactory = IDEXFactory(_factory);
  }

  function addLiquidity(
      address tokenA,
      address tokenB,
      uint256 amountADesired,
      uint256 amountBDesired,
      uint256 amountAMin,
      uint256 amountBMin,
      address to,
      uint256 deadline
  ) public onlyOwner returns(uint256 amountA, uint256 amountB, uint256 liquidity) {
    return idexRouter.addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin, to, deadline);
  } 
}","Create a smart contract that builds upon the SafeMath library and incorporates authorization mechanisms using the Auth contract. The contract should interact with IDEXFactory and IDEXRouter interfaces for integration with decentralized exchanges. Provide high-level descriptions for each function, focusing on the desired functionality and technical implementation."
contract_159.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        return msg.data;
    }
}

interface IERC165 {
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

abstract contract ERC165 is IERC165 {
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}

abstract contract AccessControl is Context, ERC165 {
    struct RoleData {
        mapping (address => bool) members;
        bytes32 adminRole;
    }

    mapping (bytes32 => RoleData) private _roles;

    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(AccessControl).interfaceId
            || super.supportsInterface(interfaceId);
    }

    function hasRole(bytes32 role, address account) public view returns (bool) {
        return _roles[role].members[account];
    }

    function getRoleAdmin(bytes32 role) public view returns (bytes32) {
        return _roles[role].adminRole;
    }

    function grantRole(bytes32 role, address account) public virtual {
        require(hasRole(_roles[role].adminRole, _msgSender()), ""AccessControl: sender must be an admin to grant"");

        _grantRole(role, account);
    }

    function revokeRole(bytes32 role, address account) public virtual {
        require(hasRole(_roles[role].adminRole, _msgSender()), ""AccessControl: sender must be an admin to revoke"");

        _revokeRole(role, account);
    }

    function renounceRole(bytes32 role, address account) public virtual {
        require(account == _msgSender(), ""AccessControl: can only renounce roles for self"");

        _revokeRole(role, account);
    }

    function _setupRole(bytes32 role, address account) internal virtual {
        _grantRole(role, account);
    }

    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);
        _roles[role].adminRole = adminRole;
    }

    function _grantRole(bytes32 role, address account) private {
        if (!hasRole(role, account)) {
            _roles[role].members[account] = true;
            emit RoleGranted(role, account, _msgSender());
        }
    }

    function _revokeRole(bytes32 role, address account) private {
        if (hasRole(role, account)) {
            _roles[role].members[account] = false;
            emit RoleRevoked(role, account, _msgSender());
        }
    }
}","Create a smart contract that allows for role-based access control. The contract should be based on OpenZeppelin's AccessControl contract and include functions for managing roles, such as granting, revoking, and renouncing roles. The contract should also track role changes and notify relevant parties. The implementation should be efficient, secure, and follow industry best practices."
contract_28.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract EtherCartel {
    uint256 constant public PAYOUT_INTERVAL = 1 hours;
    uint256 constant public DRUGS_TO_PRODUCE_1KILO = 100 ether;
    uint256 constant public STARTING_KILOS = 300;

    uint256 public kilosToProduce = 0;
    uint256 public claimedKilos = 0;

    uint256 public marketDrugs;
    uint256 public totalDrugs;

    mapping (address => uint256) public kilos;
    mapping (address => uint256) public claimedDrugs;
    mapping (address => uint256) public lastUpdate;

    function drugsProduced(address _customer) public view returns (uint256) {
        return kilos[_customer] * (block.timestamp - lastUpdate[_customer]) / PAYOUT_INTERVAL;
    }

    function myDrugs() public view returns (uint256) {
        return drugsProduced(msg.sender) + claimedDrugs[msg.sender];
    }

    function sellDrugs(uint256 _amount) public {
        uint256 drugs = myDrugs();
        require(_amount <= drugs, ""Not enough drugs to sell"");

        marketDrugs += _amount;
        totalDrugs += _amount;
        claimedDrugs[msg.sender] += _amount - drugs;

        lastUpdate[msg.sender] = block.timestamp;
    }

    function buyDrugs(uint256 _amount) public payable {
        require(_amount <= marketDrugs, ""Not enough drugs in market"");

        uint256 drugsCost = calculateDrugCost(_amount);
        require(msg.value >= drugsCost, ""Not enough Ether sent"");

        if (msg.value > drugsCost) {
            msg.sender.transfer(msg.value - drugsCost);
        }

        claimedDrugs[msg.sender] -= _amount;
        marketDrugs -= _amount;
    }

    function collectDrugs(address _referrer) public {
        uint256 kilosUsed = getKilosForDrugs(1 ether);
        require(myDrugs() >= kilosUsed, ""Not enough drugs"");

        lastUpdate[msg.sender] = block.timestamp;
        claimedDrugs[msg.sender] -= kilosUsed;
        kilos[_referrer] += kilosUsed / 3;
        claimedKilos += kilosUsed;

        kilosToProduce += kilosUsed;
    }

    function seedMarket(uint256 _kilos) public {
        kilosToProduce += _kilos;
        claimedKilos += _kilos;
        kilos[msg.sender] += _kilos;
    }

    function calculateDrugCost(uint256 _amount) public view returns (uint256) {
        return DRUGS_TO_PRODUCE_1KILO * _amount / marketDrugs;
    }

    function getKilosForDrugs(uint256 _drugs) public view returns (uint256) {
        return _drugs * totalDrugs / marketDrugs;
    }

    function kilosToCollect() public view returns (uint256) {
        uint256 drugs = myDrugs();
        return getKilosForDrugs(drugs);
    }
}","Create a smart contract that builds upon the EtherCartel example code. The new contract should allow users to collect and sell drugs, buy drugs, and manage their kilos. The contract should also include a function to seed the market with a specified number of drugs. The contract should handle funds transferred and include logic to calculate revenue shares and referral rewards."
contract_244.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory tokenName, string memory tokenSymbol, uint8 tokenDecimals) {
        name = tokenName;
        symbol = tokenSymbol;
        decimals = tokenDecimals;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }
    
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");
        require(_balances[sender] >= amount, ""ERC20: transfer amount exceeds balance"");

        _balances[sender] -= amount;
        _balances[recipient] += amount;

        emit Transfer(sender, recipient, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);
    }

    function mint(address account, uint256 amount) public {
        require(account != address(0), ""ERC20: mint to the zero address"");

        totalSupply += amount;
        _balances[account] += amount;

        emit Transfer(address(0), account, amount);
    }

    function burn(address account, uint256 amount) public {
        require(account != address(0), ""ERC20: burn from the zero address"");
        require(_balances[account] >= amount, ""ERC20: burn amount exceeds balance"");

        _balances[account] -= amount;
        totalSupply -= amount;

        emit Transfer(account, address(0), amount);
    }
}","Create a Solidity smart contract that implements the ERC20 standard. The contract should allow token transfers, approve and track allowances for token transfers, mint and burn tokens, and retrieve token balances and allowances. The contract should also keep track of the token's name, symbol, and decimals. Structure the contract in a logical and readable manner."
contract_225.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

library SafeMath {

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        uint256 c = a - b;
        return c;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}

contract MyToken {

    using SafeMath for uint256;

    string public constant name = ""MyToken"";
    string public constant symbol = ""MTK"";
    uint8 public constant decimals = 18;
    
    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);
    event Transfer(address indexed from, address indexed to, uint256 tokens);

    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowed;

    uint256 private _totalSupply;

    constructor(uint256 total) {
        _totalSupply = total;
        _balances[msg.sender] = _totalSupply;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address tokenOwner) public view returns (uint256) {
        return _balances[tokenOwner];
    }

    function transfer(address receiver, uint256 numTokens) public returns (bool) {
        require(numTokens <= _balances[msg.sender]);
        _balances[msg.sender] = _balances[msg.sender].sub(numTokens);
        _balances[receiver] = _balances[receiver].add(numTokens);
        emit Transfer(msg.sender, receiver, numTokens);
        return true;
    }

    function approve(address delegate, uint256 numTokens) public returns (bool) {
        require(numTokens <= _balances[msg.sender]);
        _allowed[msg.sender][delegate] = numTokens;
        emit Approval(msg.sender, delegate, numTokens);
        return true;
    }

    function allowance(address owner, address delegate) public view returns (uint) {
        return _allowed[owner][delegate];
    }

    function transferFrom(address owner, address buyer, uint numTokens) public returns (bool) {
        require(numTokens <= _balances[owner]);    
        require(numTokens <= _allowed[owner][msg.sender]);
    
        _balances[owner] = _balances[owner].sub(numTokens);
        _allowed[owner][msg.sender] = _allowed[owner][msg.sender].sub(numTokens);
        
        _balances[buyer] = _balances[buyer].add(numTokens);
        emit Transfer(owner, buyer, numTokens);
        return true;
    }

    function mint(address account, uint256 amount) public {
        require(account != address(0), ""Zero address"");
        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    function burn(address account, uint256 amount) public {
        require(account != address(0), ""Zero address"");
        require(amount <= _balances[account]);

        _totalSupply = _totalSupply.sub(amount);
        _balances[account] = _balances[account].sub(amount);
        emit Transfer(account, address(0), amount);
    }
}","Create a smart contract that enables the transfer of tokens, allowing users to approve and revoke spending limits for other accounts. The contract should support minting and burning tokens. Utilize the SafeMath library for arithmetic operations. Implement event emissions for notable actions."
contract_224.sol,"pragma solidity ^0.8.0;

contract Owned {
    address private owner;
    
    constructor() {
        owner = msg.sender;
    }
    
    modifier onlyOwner {
        require(msg.sender == owner, ""You are not authorized"");
        _;
    }
    
    function transferOwnership(address newOwner) public onlyOwner {
        if(newOwner != address(0)){
            owner = newOwner;
        }
    }
    
    function getOwner() public view returns (address) {
        return owner;
    }
}

contract Pausable is Owned {
    event Paused();
    event Unpaused();
    bool private paused;
    
    constructor() {
        paused = false;
    }
    
    modifier whenNotPaused {
        require(!paused,""Smart Contract Paused"");
        _;
    }

    modifier whenPaused {
        require(paused,""Smart Contract not paused"");
        _;
    }

    function pause() onlyOwner whenNotPaused public {
        paused = true;
        emit Paused();
    }

    function unpause() onlyOwner whenPaused public {
        paused = false;
        emit Unpaused();
    }
}

contract AssetTransfer is Pausable {
    mapping(address => uint256) private balances;
    event Deposit(address indexed depositor, uint256 amount);
    event Withdrawal(address indexed withdrawer, uint256 amount);
    event Transfer(address indexed from, address indexed to, uint256 amount);

    function deposit() public payable whenNotPaused {
        balances[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }
    
    function withdraw(uint256 amount) public whenNotPaused {
        require(amount <= balances[msg.sender], ""Insufficient balance"");
        balances[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);
        emit Withdrawal(msg.sender, amount);
    }
    
    function transfer(address to, uint256 amount) public whenNotPaused {
        require(amount <= balances[msg.sender], ""Insufficient balance"");
        
        balances[msg.sender] -= amount;
        balances[to] += amount;
        emit Transfer(msg.sender, to, amount);
    }
    
    function getBalance(address addr) public view returns (uint256) {
        return balances[addr];
    }
}","Create a smart contract that allows for the creation of a basic decentralized asset transfer system. Utilize the Owned contract to manage ownership and provide a way to transfer ownership. Implement a simple halt mechanism to pause or resume the contract's execution. The contract should also use the Proxy mechanism to enable efficient transactions. Include functions for depositing, withdrawing, and transferring assets. Make sure to include logging and monitoring functionality for auditing and tracking purposes."
contract_45.sol,"pragma solidity ^0.8.0;

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount)
        external
        returns (bool);
}

contract TokenMarket {

    struct Trade {
        address trader;
        address token;
        uint256 amount;
        uint256 price;
    }

    Trade[] public trades;

    function addTrade(address _token, uint256 _amount, uint256 _price) external {
        trades.push(Trade(msg.sender, _token, _amount, _price));
    }

    function removeTrade(uint256 _tradeId) external {
        require(msg.sender == trades[_tradeId].trader, ""Only the trader can remove this trade"");
        delete trades[_tradeId];
    }

    function modifyTrade(uint256 _tradeId, uint256 _amount, uint256 _price) external {
        require(msg.sender == trades[_tradeId].trader, ""Only the trader can modify this trade"");
        trades[_tradeId].amount = _amount;
        trades[_tradeId].price = _price;
    }

    function executeTrade(uint256 _tradeId) external {
        Trade memory trade = trades[_tradeId];
        require(IERC20(trade.token).transferFrom(trade.trader, msg.sender, trade.amount), ""Token transfer failed"");
        require(payable(trade.trader).send(trade.price * trade.amount), ""Eth transfer failed"");
        removeTrade(_tradeId);
    }
}","Implement a smart contract that allows for the creation and management of token markets. The contract should include features for adding, removing, and modifying tokens, as well as allowing traders to trade tokens. The contract should also include mechanisms for validating transactions and ensuring the integrity of the markets."
contract_66.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract PIVOTCHAIN {
    string public constant symbol = ""PVT"";
    string public constant name = ""PIVOTCHAIN Token"";
    uint8 public constant decimals = 18;
    
    uint256 public constant _totalSupply = 1000000 * 10**uint256(decimals);
    uint256 public constant _buyPrice = 1 ether;
    mapping(address => uint256) private _balances;
    address private _creator;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Contribution(address indexed _contributor, uint256 _value);

    constructor() {
        _creator = msg.sender;
        _balances[_creator] = _totalSupply;
        emit Transfer(address(0),_creator, _totalSupply);
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return _balances[_owner];
    }

    function transfer(address _to, uint256 _amount) public returns (bool success) {
        require(_balances[msg.sender] >= _amount, ""Insufficient balance."");
        _balances[msg.sender] -= _amount;
        _balances[_to] += _amount;
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }

    function buy() public payable returns (bool success){
        require(msg.value > 0, ""You need to send some Ether"");
        require(_buyPrice * (msg.value/1 ether) <= _balances[_creator], ""Not enough tokens in the reserve"");
        uint256 amount = (msg.value / 1 ether) * _buyPrice;
        _balances[msg.sender] += amount;
        _balances[_creator] -= amount;
        emit Contribution(msg.sender, amount);
        emit Transfer(_creator, msg.sender, amount);
        return true;
    }
}","Create a smart contract for the PIVOTCHAIN token that allows users to buy and sell tokens, with a fixed total supply, and a specified buy price. Implement functions for users to contribute ether to receive tokens, while keeping track of the creator's balance. Include event logs for transfers and contributions. Make sure to include error checking to prevent token overflows and ensure a fair transfer."
contract_214.sol,"pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;
    address private _pendingOwner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    function pendingOwner() public view returns (address) {
        return _pendingOwner;
    }

    modifier onlyOwner() {
        require(isOwner(), ""Ownable: caller is not the owner"");
        _;
    }

    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        _pendingOwner = newOwner;
    }

    function claimOwnership() public {
        require(msg.sender == _pendingOwner, ""Ownable: caller is not the pending owner"");
        emit OwnershipTransferred(_owner, _pendingOwner);
        _owner = _pendingOwner;
        _pendingOwner = address(0);
    }
}

contract MyContract is Ownable {
    // MyContract logic goes here.
}","Create a smart contract that allows for ownership transfer, allowing either direct transfer to a new address or pending transfer followed by a claim by the new owner. Implement inheritance from the Ownable contract, with a constructor that sets the owner to the message sender. Include a function for transferring ownership, using either direct transfer or pending transfer. Ensure that the owner function can only be called by the current owner. Include modifier onlyOwner that checks the sender for the current owner."
contract_166.sol,"pragma solidity ^0.8.0;

// Mock token contract to be used in the money market
contract Token {
    mapping(address => uint256) private balances;
    
    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        require(balances[sender] >= amount, ""Not enough balance"");
        balances[sender] -= amount;
        balances[recipient] += amount;
        return true;
    }
}

contract MoneyMarket {
    struct Loan {
        address borrower;
        Token token;
        uint256 amountBorrowed;
        uint256 interest;
        bool isRepaid;
    }

    Loan[] public loans;

    function borrow(Token token, uint256 amountToBorrow) public {
        Loan memory newLoan;
        newLoan.borrower = msg.sender;
        newLoan.token = token;
        newLoan.amountBorrowed = amountToBorrow;
        newLoan.interest = calculateInterest(amountToBorrow);
        newLoan.isRepaid = false;

        loans.push(newLoan);
        token.transferFrom(msg.sender, address(this), amountToBorrow);
    }

    function repay(Loan loan, uint256 amountToRepay) public {
        require(!loan.isRepaid, ""Loan already repaid"");
        require(amountToRepay >= (loan.amountBorrowed + loan.interest), ""Amount is not enough to repay the loan"");

        loan.token.transferFrom(msg.sender, address(this), amountToRepay);
        loan.isRepaid = true;
    }

    function liquidate(Loan loan) public {
        require(!loan.isRepaid, ""Loan already repaid"");

        uint256 amountToLiquidate = loan.amountBorrowed + loan.interest;
        loan.token.transferFrom(address(this), msg.sender, amountToLiquidate);
        loan.isRepaid = true;
    }

    function calculateInterest(uint256 amount) private pure returns (uint256) {
        return (amount * 10) / 100;
    }
}","Create a Solidity smart contract that deploys a money market with various facets, including functions for lending, borrowing, and liquidation. The contract should utilize a library to deploy the money market diamond and retrieve facet addresses. Implement functions to serialize and write JSON data for the money market and facet addresses. Design the contract to provide flexibility in managing the money market and its facets."
contract_141.sol,"// SPDX-License-Identifier: MIT 
pragma solidity ^0.8.0;

contract ERC721Enumerable {
    mapping(address => uint256) private _ownedTokensCount;
    mapping(uint256 => address) private _tokenOwner;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping (address => bool)) private _operatorApprovals;
    string private _name;
    string private _symbol;

    function balanceOf(address owner) public view virtual returns (uint256);
    function ownerOf(uint256 tokenId) public view virtual returns (address);
    function approve(address to, uint256 tokenId) public virtual;
    function getApproved(uint256 tokenId) public view virtual returns (address);
    function setApprovalForAll(address operator, bool _approved) public virtual;
    function isApprovedForAll(address owner, address operator) public view virtual returns (bool);
    function transferFrom(address from, address to, uint256 tokenId) public virtual;
    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual;
    function totalSupply() public view virtual returns (uint256);
    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual returns (uint256 tokenId);
    function tokenByIndex(uint256 index) public view virtual returns (uint256);
}

contract Ownable {
    address private _owner;

    function owner() public view virtual returns (address);
    function isOwner() public view virtual returns (bool);
    function renounceOwnership() public virtual;
    function transferOwnership(address newOwner) public virtual;
}

contract AirdropItem is ERC721Enumerable, Ownable {
  mapping (uint256 => string) private _tokenURIs;
  uint256 public MAX_MINT = 10;
  uint256 public COST = 0.05 ether;
  string public NOT_REVEAL_URI = '';
  uint256 public REVEAL_TIMESTAMP;
  string public BASE_URI = '';
  uint256 public totalSupply = 0;

  event Minted(address indexed minter, uint256 indexed count);
  event Reveal();

  function mint(uint256 count) public payable {
    require(totalSupply + count <= MAX_MINT, 'Exceeds the maximum mint number');
    require(msg.value >= COST * count, 'Not enough Ether to mint');
    for (uint256 i = 0; i < count; i++) {
      _mint(msg.sender, totalSupply++);
    }
    emit Minted(msg.sender, count);
  }

  function _mint(address to, uint256 tokenId) private {
    // compelete your mint logic
  }

  function tokensOfOwner(address owner) public view returns (uint256[] memory ownerTokens){
    // your logic here
  }

  function tokenURI(uint256 tokenId) public view returns (string memory){
    // your logic here
  }

  function reveal() external onlyOwner {
    REVEAL_TIMESTAMP = block.timestamp;
    emit Reveal();
  }

  function setCost(uint256 cost) external onlyOwner {
    COST = cost;
  }

  function setMaxMint(uint256 maxMint) external onlyOwner {
    MAX_MINT = maxMint;
  }

  function setNotRevealUri(string calldata notRevealUri) external onlyOwner {
    NOT_REVEAL_URI = notRevealUri;
  }

  function setBaseUri(string calldata baseUri) external onlyOwner {
    BASE_URI = baseUri;
  }
}","Create a Solidity smart contract that allows for airdrops of items. The contract should include functions for minting new items, retrieving the items held by an owner, and retrieving the URI of an item. Implement the ERC721Enumerable and Ownable contracts from OpenZeppelin to enable access controls and enumeration of items. Include functions for setting the cost of new item minting, maximum mint amount, not revealed URI, and base URI. Add event logs for the mint function and reveal function."
contract_148.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract ERC20Basic is IERC20 {
    string public constant name = ""ERC20Basic"";
    string public constant symbol = ""ERCB"";
    uint8 public constant decimals = 18;
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowed;
    uint256 private _totalSupply;

    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }
    
    function increaseTotalSupply(uint _amount) public {
        _totalSupply += _amount;
    }

    function balanceOf(address owner) public view override returns (uint256) {
        return _balances[owner];
    }

    function allowance(address owner, address spender) public view override returns (uint256) {
        return _allowed[owner][spender];
    }

    function transfer(address to, uint256 value) public override returns (bool) {
        require(value <= _balances[msg.sender]);
        require(to != address(0));

        _balances[msg.sender] = _balances[msg.sender] - value;
        _balances[to] = _balances[to] + value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public override returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public override returns (bool) {
        require(value <= _balances[from]);
        require(value <= _allowed[from][msg.sender]);
        require(to != address(0));

        _balances[from] = _balances[from] - value;
        _balances[to] = _balances[to] + value;
        _allowed[from][msg.sender] = _allowed[from][msg.sender] - value;
        emit Transfer(from, to, value);
        return true;
    }
}","Create a Smart Contract that implements the IERC20 standard, allowing users to transfer tokens and manage their balances. The contract should have a function to calculate the total supply of tokens, and update the total supply. Include an event for token transfers and a function to approve and transfer tokens. The contract should be compatible with the IERC20 standard and follow best practices for smart contract development."
contract_82.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {

    string public name;
    string public symbol;
    uint256 public decimals;
    uint256 public totalSupply;

    address public feeRecipient;
    uint256 public transferFee = 1;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    constructor(string memory _name, string memory _symbol, uint256 _decimals, uint256 _totalSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply;
        balanceOf[msg.sender] = _totalSupply;
    }

    function _transfer(address _from, address _to, uint256 _value) private {
        require(balanceOf[_from] >= _value, ""Insufficient balance"");
        require(balanceOf[_to] + _value > balanceOf[_to], ""Overflow error"");

        uint256 fee = (_value * transferFee) / 100;
        uint256 sendAmount = _value - fee;

        balanceOf[_from] -= _value;
        balanceOf[_to] += sendAmount;
        balanceOf[feeRecipient] += fee;

        emit Transfer(_from, _to, sendAmount);
    }
    
    function setFeeRecipient(address _feeRecipient) external {
        feeRecipient = _feeRecipient;
    }
    
    function setTransferFee(uint256 _transferFee) external {
        transferFee = _transferFee;
    }

    function transfer(address _to, uint256 _value) external returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) external returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {
        require(allowance[_from][msg.sender] >= _value, ""Insufficient allowance"");

        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}","Create a smart contract that follows the ERC-20 token standard, with functions for managing token supply, balances, and transfers. The contract should include a mechanism for setting a fee recipient and distributing transfer fees. Additionally, provide functions for approving and managing token allowance for spending and transferring. Note: ensure the contract uses safe arithmetic operations and follows best practices for secure coding."
contract_218.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

abstract contract Context {
    
    function _msgSender() internal view virtual returns (address payable) {
        return payable(msg.sender);
    }
    
    function _msgData() internal view virtual returns (bytes memory) {
        this;
        return msg.data;
    }
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
   
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

library SafeMath {
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        uint256 c = a + b;
        if (c < a) return (false, 0);
        return (true, c);
    }
   
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }
   
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b > a) return (false, 0);
        return (true, a - b);
    }
   
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b;
    }
   
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (a == 0) return (true, 0);
        uint256 c = a * b;
        if (c / a != b) return (false, 0);
        return (true, c);
    }
   
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
       return a * b;
    }
   
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b == 0) return (false, 0);
        return (true, a / b);
    }
   
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }
}

contract ERC20 is Context, IERC20 {
    using SafeMath for uint256;
    
    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;
    
    uint256 private _totalSupply;
    string private _name;
    string private _symbol;
    uint8 private _decimals;
    
    constructor (string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
        _decimals = 18;
    }
    
    function name() public view virtual returns (string memory) {
        return _name;
    }
    
    function symbol() public view virtual returns (string memory) {
        return _symbol;
    }
    
    function decimals() public view virtual returns (uint8) {
        return _decimals;
    }
    
    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }
    
    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }
    
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }
    
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }
    
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }
    
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        if (_allowances[sender][_msgSender()] != type(uint256).max) {
            _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount));
        }
        return true;
    }
    
    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");
        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }
    
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: mint to the zero address"");
        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }
    
    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
    
}

contract MyToken is ERC20 {
    constructor() ERC20(""My Token"", ""MYT"") {
        _mint(_msgSender(), 1156789000 * (10 ** uint256(decimals())));
    }
}","Create a smart contract that implements an ERC-20 token. The contract should have the ability to transfer tokens between addresses, allow for token approvals, and have events for token transfers and approvals. The contract should also have a total supply of 1,156,789,000 tokens and a fixed precision of 18 decimals."
contract_223.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

abstract contract IGovernor {
    enum ProposalState {
        Pending,
        Active,
        Canceled,
        Defeated,
        Succeeded,
        Queued,
        Expired,
        Executed
    }

    function proposalCount() public view virtual returns (uint256);
    function proposalDeadline(uint256 proposalId) public view virtual returns (uint256);
    function getVotes(address account, uint256 blockNumber) public view virtual returns (uint256 votes);
    function proposalState(uint256 proposalId) public view virtual returns (ProposalState);
    function propose(address[] memory targets, uint256[] memory values, bytes[] memory calldatas, string memory description) public virtual returns (uint256);
    function vote(uint256 proposalId, uint8 support, string memory reason) public virtual returns (uint256 votes);
    function cancel(uint256 proposalId) public virtual;
}

abstract contract IERC20 {
    function totalSupply() public view virtual returns (uint256);
    function balanceOf(address account) public view virtual returns (uint256);
    function transfer(address recipient, uint256 amount) public virtual returns (bool);
    function approve(address spender, uint256 amount) public virtual returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

abstract contract Governor is IGovernor {
    IERC20 public votingToken;

    constructor(IERC20 _votingToken) {
        votingToken = _votingToken;
    }

    function votingDelay() public view virtual returns (uint256);
    function votingPeriod() public view virtual returns (uint256);
    function proposalThreshold() public view virtual returns (uint256) {
        return (votingToken.totalSupply() * 1) / 100;
    }

    function getVotes(address account, uint256 blockNumber) public view virtual override returns (uint256 votes) {
        return votingToken.balanceOf(account);
    }

}
  
abstract contract GovernorSettings is Governor {

    uint256 private _votingPeriod;
    uint256 private _votingDelay;
    uint256 private _proposalThreshold;

    constructor(IERC20 votingToken, uint256 votingDelay, uint256 votingPeriod, uint256 proposalThreshold) Governor(votingToken) {
        _setVotingDelay(votingDelay);
        _setVotingPeriod(votingPeriod);
        _setProposalThreshold(proposalThreshold);
    }

    function votingDelay() public view override returns (uint256) {
        return _votingDelay;
    }

    function _setVotingDelay(uint256 newVotingDelay) internal {
        _votingDelay = newVotingDelay;
    }

    function votingPeriod() public view override returns (uint256) {
        return _votingPeriod;
    }

    function _setVotingPeriod(uint256 newVotingPeriod) internal {
        _votingPeriod = newVotingPeriod;
    }

    function proposalThreshold() public view override returns (uint256) {
        return _proposalThreshold;
    }

    function _setProposalThreshold(uint256 newProposalThreshold) internal {
        _proposalThreshold = newProposalThreshold;
    }
}","Develop a smart contract for a governance system that enables proposals, vote counting, and quorum checking. The contract should include functionality for proposal creation, voting, and state evaluation. Utilize OpenZeppelin's Governor and GovernorSettings modules. Implement basic functions for voting delay, voting period, proposal threshold, quorum calculation, and proposal state evaluation. "
contract_191.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20 {
    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;
    uint256 private _totalSupply;
    string private _name;
    string private _symbol;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor (string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }
    
    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}
contract MyERC20Token is ERC20 {
    address public owner;

    constructor (string memory name_, string memory symbol_) ERC20(name_, symbol_) {
        owner = msg.sender;
    }

    function mint(address account, uint256 amount) public {
        require(msg.sender == owner, ""only owner can mint"");
        _mint(account, amount);
    }

    function burn(address account, uint256 amount) public {
        require(msg.sender == owner, ""only owner can burn"");
        _burn(account, amount);
    }

    function _mint(address account, uint256 amount) internal {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) internal {
        require(account != address(0), ""ERC20: burn from the zero address"");

        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, ""ERC20: burn amount exceeds balance"");
        
        _balances[account] -= amount;
        _totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }   
}","Create a Solidity smart contract that extends the provided 'ERC20' contract to implement a basic token. The contract should allow for setting the token name and symbol. Implement functions for minting and burning tokens. Also, add a function to set the allowance for a spender account. Consider implementing a pending transaction signature verification mechanism. Focus on creating a functional smart contract that fulfills the provided contract's requirements."
contract_226.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface GeneScience {
    function isGeneScience() external pure returns (bool);
    function mixGenes(uint256 genes1, uint256 genes2, uint256 targetBlock) external returns (uint256);
}

interface PuppySports {
    function playGame(uint256 puppyId, uint256 betAmount) external;
}

contract PuppyAccessControl {
    address public ceoAddress;
    address public cfoAddress;
    address public cooAddress;

    constructor() {
        ceoAddress = msg.sender;
        cooAddress = msg.sender;
        cfoAddress = msg.sender;
    }

    modifier onlyCEO() {
        require(msg.sender == ceoAddress);
        _;
    }

    modifier onlyCFO() {
        require(msg.sender == cfoAddress);
        _;
    }   

    modifier onlyCOO() {
        require(msg.sender == cooAddress);
        _;
    }

    function setCEO(address _newCEO) external onlyCEO {
        require(_newCEO != address(0));
        ceoAddress = _newCEO;
    }

    function setCFO(address _newCFO) external onlyCEO {
        require(_newCFO != address(0));
        cfoAddress = _newCFO;
    }

    function setCOO(address _newCOO) external onlyCEO {
        require(_newCOO != address(0));
        cooAddress = _newCOO;
    }
}

contract CryptoPuppies is PuppyAccessControl {
    struct Puppy {
        uint256 genes;
        uint64 birthTime;
    }

    Puppy[] public puppies;

    GeneScience public geneScience;
    PuppySports public puppySports;

    event NewPuppy(uint256 indexed puppyId, uint256 genes);
    event PuppyGamePlayed(uint256 indexed puppyId, uint256 betAmount);

    constructor() PuppyAccessControl() {}

    function setGeneScienceAddress(address _address) external onlyCEO {
        GeneScience candidateContract = GeneScience(_address);
        require(candidateContract.isGeneScience());
        geneScience = candidateContract;
    }

    function setPuppySportsAddress(address _address) external onlyCEO {
        PuppySports candidateContract = PuppySports(_address);
        require(candidateContract != PuppySports(address(0x0)));
        puppySports = candidateContract;
    }

    function createPuppy(uint256 _genes) external onlyCOO {
        uint256 newPuppyId = puppies.length;
        puppies.push(Puppy(_genes, uint64(block.timestamp)));
        emit NewPuppy(newPuppyId, _genes);
    }

    function mixGenes(uint256 _puppyId1, uint256 _puppyId2) external onlyCOO {
        Puppy storage puppy1 = puppies[_puppyId1];
        Puppy storage puppy2 = puppies[_puppyId2];
        uint256 newGenes = geneScience.mixGenes(puppy1.genes, puppy2.genes, block.number);
        createPuppy(newGenes);
    }

    function playGame(uint256 _puppyId, uint256 _betAmount) external onlyCOO {
        puppySports.playGame(_puppyId, _betAmount);
        emit PuppyGamePlayed(_puppyId, _betAmount);
    }
}","Create a smart contract that manages CryptoPuppies, allowing for gene mixing and gaming. Implement functions to mix genes, play games, and manage access control for CEO, CFO, and COO roles. The contract should also include events and logging mechanisms for auditing purposes. Reference the provided code fragment for implementation details, specifically the GeneScience, PuppySports, and PuppyAccessControl contracts."
contract_114.sol,"pragma solidity ^0.8.0;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

interface IERC165 {
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

interface IERC721 is IERC165 {
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
    function balanceOf(address owner) external view returns (uint256 balance);
    function ownerOf(uint256 tokenId) external view returns (address owner);
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    function transferFrom(address from, address to, uint256 tokenId) external;
    function approve(address to, uint256 tokenId) external;
    function getApproved(uint256 tokenId) external view returns (address operator);
    function setApprovalForAll(address operator, bool _approved) external;
    function isApprovedForAll(address owner, address operator) external view returns (bool);
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
}
interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}

library Strings {
    function toString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return ""0"";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }
}

abstract contract Pausable is Context {
    event Paused(address account);
    event Unpaused(address account);
    private bool private _paused;
    constructor () {
        _paused = false;
    }
    function paused() public view virtual returns (bool) {
        return _paused;
    }
    modifier whenNotPaused() {
        require(!paused(), ""Pausable: paused"");
        _;
    }
    modifier whenPaused() {
        require(paused(), ""Pausable: not paused"");
        _;
    }
    function _pause() internal virtual whenNotPaused {
        _paused = true;
        emit Paused(_msgSender());
    }
    function _unpause() internal virtual whenPaused {
        _paused = false;
        emit Unpaused(_msgSender());
    }
}

contract ERC721Token is Context, IERC165, IERC721, Pausable {
    using Strings for uint256;
    string private _baseURI;
    string private _name;
    uint256 private _counter;
    uint256 private _tokenCap;
    mapping (uint256 => address) private _owners;
    mapping (address => uint256) private _balances;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => mapping (address => bool)) private _operatorApprovals;
    constructor (string memory name_, string memory baseURI_, uint256 tokenCap_) {
        _name = name_;
        _baseURI = baseURI_;
        _tokenCap = tokenCap_;
    }
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC721).interfaceId || interfaceId == type(IERC165).interfaceId;
    }
    function balanceOf(address owner) public view virtual override returns (uint256) {
        require(owner != address(0), ""ERC721: balance query for the zero address"");
        return _balances[owner];
    }
    function ownerOf(uint256 tokenId) public view virtual override returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), ""ERC721: owner query for nonexistent token"");
        return owner;
    }
    function name() public view returns (string memory) {
        return _name;
    }
    function tokenCap() public view returns (uint256) {
        return _tokenCap;
    }
    function _baseURI() internal view returns (string memory) {
        return _baseURI;
    }
    function approve(address to, uint256 tokenId) public virtual override {
        address owner = ownerOf(tokenId);
        require(to != owner, ""ERC721: approval to current owner"");
        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()), ""ERC721: approve caller is not owner nor approved for all"");
        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }
    function getApproved(uint256 tokenId) public view virtual override returns (address) {
        require(_exists(tokenId), ""ERC721: approved query for nonexistent token"");
        return _tokenApprovals[tokenId];
    }
    function setApprovalForAll(address operator, bool approved) public virtual override {
        require(operator != _msgSender(), ""ERC721: approve to caller"");
        _operatorApprovals[_msgSender()][operator] = approved;
        emit ApprovalForAll(_msgSender(), operator, approved);
    }
    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
        return _operatorApprovals[owner][operator];
    }
    function transferFrom(address from, address to, uint256 tokenId) public virtual override whenNotPaused {
        require(_isApprovedOrOwner(_msgSender(), tokenId), ""ERC721: transfer caller is not owner nor approved"");
        require(to != address(0), ""ERC721: transfer to the zero address"");
        require(from != to, ""ERC721: transfer to same address"");
        
        _approve(address(0), tokenId);
        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(from, to, tokenId);
    }
    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override whenNotPaused {
        safeTransferFrom(from, to, tokenId, """");
    }
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override whenNotPaused {
        require(_isApprovedOrOwner(_msgSender(), tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _safeTransfer(from, to, tokenId, _data);
    }
    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {
        transferFrom(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }
    function _exists(uint256 tokenId) internal view returns (bool) {
        return _owners[tokenId] != address(0);
    }
    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }
    function mint() public whenNotPaused {
        require(_counter < _tokenCap, ""ERC721: token cap exceeded"");
        _mint(_msgSender(), _counter);
    }
    function burn(uint256 tokenId) public whenNotPaused {
        require(_isApprovedOrOwner(_msgSender(), tokenId), ""ERC721: burn caller is not owner nor approved"");
        _burn(tokenId); 
    }
    function _mint(address to_, uint256 tokenId) internal virtual {
        require(to_ != address(0), ""ERC721: mint to the zero address"");
        _balances[to_] += 1;
        _owners[tokenId] = to_;
        emit Transfer(address(0), to_, tokenId);
        _counter += 1;
    }
    function _burn(uint256 tokenId) internal virtual {
        address owner = ownerOf(tokenId);
        _approve(address(0), tokenId);
        if (balanceOf(owner) > 0) {
            _balances[owner] -= 1;
        }
        delete _owners[tokenId];
        emit Transfer(owner, address(0), tokenId);
    }
    function _approve(address to, uint256 tokenId) internal virtual {
        _tokenApprovals[tokenId] = to;
    }
    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) private returns (bool) {
        if (to.isContract()) {
            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
                return retval == IERC721Receiver(to).onERC721Received.selector;
            } catch (bytes memory reason) {
                if (reason.length == 0) {
                    revert(""ERC721: transfer to non ERC721Receiver implementer"");
                } else {
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        } else {
            return true;
        }
    }
    function pause() public virtual whenNotPaused {
        _pause();
    }
    function unpause() public virtual whenPaused {
        _unpause();
    }
}","Create a smart contract that allows users to mint, transfer, and burn NFTs. Implement a token cap and royalty mechanism. The contract should be pausable and have a base URI for token metadata. Organize your code following best practices and use OpenZeppelin's pre-written contracts for compatibility and security."
contract_172.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

interface IPoseidonHasher {
    function poseidon(uint[] calldata elements) external pure returns (uint);
}

contract PoseidonHashStorage {

    address private hasherAddress;
    mapping(uint256 => uint256) private hashStorage;

    constructor(address _hasherAddress) {
        hasherAddress = _hasherAddress;
    }

    function registerHash(uint[] calldata elements) external {
        IPoseidonHasher hasher = IPoseidonHasher(hasherAddress);
        uint256 hash = hasher.poseidon(elements);
        hashStorage[hash] = 1;
    }

    function getHash(uint[] calldata elements) external view returns (uint256) {
        IPoseidonHasher hasher = IPoseidonHasher(hasherAddress);
        uint256 hash = hasher.poseidon(elements);
        require(hashStorage[hash] == 1, ""Hash not registered"");
        return hash;
    }

    function setHasherAddress(address _hasherAddress) internal {
        hasherAddress = _hasherAddress;
    }
}",Create a smart contract that utilizes the IPoseidonHasher interface to compute the poseidon hash of a given input vector. The contract should include a function to register a new poseidon hash and retrieve the poseidon hash of a given input. Take into consideration the technical requirements outlined in the provided code and ensure the contract is well-structured and maintainable.
contract_133.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// Simplified ERC20 interface
interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
}

contract PaymentSplitter {
    address[] private _payees;
    mapping(address => uint256) private _shares;
    mapping(address => uint256) private _released;
    uint256 private _totalShares;
    uint256 private _totalReleased;
   
    constructor(address[] memory payees, uint256[] memory shares_) {
        require(payees.length == shares_.length, ""PaymentSplitter: payees and shares length mismatch"");
        require(payees.length > 0, ""PaymentSplitter: no payees"");

        for (uint256 i = 0; i < payees.length; i++) {
            address payee = payees[i];
            uint256 shares = shares_[i];
            _addPayee(payee, shares);
        }
    }

    receive() external payable {
        uint256 balance = address(this).balance;
        for (uint256 i = 0; i < _payees.length; i++) {
            uint256 payment = (balance * _shares[_payees[i]]) / _totalShares;
            _released[_payees[i]] += payment;
            _totalReleased += payment;
            payable(_payees[i]).transfer(payment);
        }
    }
   
    function releaseERC20(IERC20 token) public {
        uint256 balance = token.balanceOf(address(this));
        for (uint256 i = 0; i < _payees.length; i++) {
            uint256 payment = (balance * _shares[_payees[i]]) / _totalShares;
            _released[_payees[i]] += payment;
            _totalReleased += payment;
            token.transfer(_payees[i], payment);
        }
    }

    function totalShares() public view returns (uint256) {
        return _totalShares;
    }

    function shares(address account) public view returns (uint256) {
        return _shares[account];
    }

    function released(address account) public view returns (uint256) {
        return _released[account];
    }

    function totalReleased() public view returns (uint256) {
        return _totalReleased;
    }

    function payees(uint256 index) public view returns (address) {
        return _payees[index];
    }

    function _addPayee(address account, uint256 shares_) private {
        require(account != address(0), ""PaymentSplitter: account is the zero address"");
        require(shares_ > 0, ""PaymentSplitter: shares are 0"");
        require(_shares[account] == 0, ""PaymentSpitter: account already has shares"");

        _payees.push(account);
        _shares[account] = shares_;
        _totalShares += shares_;
    }
}",Develop a smart contract that splits payments to multiple recipients based on their shares. The contract should have a constructor that initializes the payees and their shares. Implement functions to release payments to payees and track the total amount released. The contract should also release ERC20 tokens to payees. Include descriptive comments to explain the logic and error handling mechanisms.
contract_213.sol,"pragma solidity ^0.8.0;

contract MyContract {

    function f(bytes memory _bytesArray, bytes calldata _bytesCalldata, uint[] memory _uintArray) public pure returns(bytes memory, bytes memory, uint, bytes memory, bytes memory, uint) {
        //Performing operations and assigning values based on some arbitrary logic. These operations and assignments can be based on specific business logic.
        bytes memory bytesRetVal1 = _bytesArray;
        bytes memory bytesRetVal2 = _bytesCalldata;
        uint uintRetVal = _uintArray.length;
        
        return (bytesRetVal1, bytesRetVal2, uintRetVal, bytesRetVal1, bytesRetVal2, uintRetVal);
    }

    function g() public pure returns(bytes memory, bytes memory, uint, bytes memory, bytes memory, uint) {
        bytes memory bytesData = ""Bytes data for function f"";
        uint[] memory uintArray = [1, 2, 3];
        
        //Calling function 'f' with predefined inputs
        return f(bytesData, bytesData, uintArray);
    }
}","Develop a smart contract that has two functions: 'f' and 'g'. Function 'f' should accept three parameters: a bytes array, a bytes calldata, and a uint array. It should return six values. Function 'g' should call function 'f' with predefined input. Explain the basic logic and structure of the contract without delving into minute technical details."
contract_95.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Delegator {

    uint256 public num;
    address public addr;

    event UpdatedNum(address indexed _from, uint256 _num);
    event UpdatedAddr(address indexed _from, address _addr);

    function setNum(address _delegate, uint256 _num) public {

        (bool success,) = _delegate.delegatecall(abi.encodeWithSignature(""setNum(uint256)"", _num));

        require(success, ""delegatecall failed"");

        emit UpdatedNum(msg.sender, _num);
    }

    function setAddr(address _delegate, address _addr) public {

        (bool success,) = _delegate.delegatecall(abi.encodeWithSignature(""setAddr(address)"", _addr));

        require(success, ""delegatecall failed"");

        emit UpdatedAddr(msg.sender, _addr);
    }
}


contract Delegate {

    uint256 public num;
    address public addr;

    function setNum(uint256 _num) public {
        num = _num;
    }

    function setAddr(address _addr) public {
        addr = _addr;
    }
}","Create a smart contract that enables the delegation of function calls to another contract. The contract should have the ability to set various variables, including uint256 values and addresses, using a delegatecall mechanism. Implement functions for setting the num and value variables, and utilize encoding and encoding signatures to ensure proper delegation and validation."
contract_208.sol,"pragma solidity ^0.8.0;

contract Leb128 {
    function leb128Encode(uint64 value) public pure returns (bytes memory) {
        bytes memory result = new bytes(10);
        uint8 length = 0;
        
        while (value != 0) {
            uint8 byteValue = uint8(value & 0x7F);
            value >>= 7;
            
            if (value != 0) {
                byteValue |= 0x80;
            }
            
            result[length++] = bytes1(byteValue);
        }
        
        bytes memory finalResult = new bytes(length);
        for (uint8 i = 0; i < length; i++) {
            finalResult[i] = result[i];
        }
        return finalResult;
    }

    function leb128Decode(bytes memory data) public pure returns (uint64) {
        uint64 result = 0;
        uint8 shift = 0;
        
        for (uint8 i = 0; i < data.length; i++) {
            uint64 byteValue = uint64(uint8(data[i]));
            result |= (byteValue & 0x7F) << shift;
            if ((byteValue & 0x80) == 0) {
                break;
            }
            shift += 7;
        }
        
        return result;
    }
}","Create a smart contract that can encode and decode Leb128 integers. The contract should have methods for encoding and decoding unsigned integers with Leb128. The encoding methods should take uint64 values as input and output the encoded byte arrays. The decoding methods should take encoded byte arrays as input and output the decoded uint64 values. Use the Buffer library to implement the Leb128 encoding and decoding logic, ensuring accurate results."
contract_5.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ARMOR {
    // Variables
    string public constant name = ""ARMOR Token"";
    string public constant symbol = ""ARMOR"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;
    address public owner;

    // Mapping will hold the balance of the addresses
    mapping(address => uint256) public balanceOf;
    // Mapping will hold the allowance of spender allowed by token holder
    mapping(address => mapping(address => uint256)) public allowance;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    // Initializer
    constructor(uint256 total) {
        totalSupply = total;
        owner = msg.sender;
        balanceOf[owner] = totalSupply * 10 / 100;
        balanceOf[address(this)] = totalSupply * 90 / 100;
    }

    // Function to transfer tokens
    function transfer(address _to, uint256 _value) external returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    // Function to approve spender by token holder
    function approve(address _spender, uint256 _value) external returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    // Function that is called when spender transfers tokens on token holder's behalf
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {
        require(balanceOf[_from] >= _value, ""Insufficient balance"");
        require(allowance[_from][msg.sender] >= _value, ""Not allowed to transfer this much amount"");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    // Function to accept Ether
    receive() external payable {
        require(msg.sender != address(0), ""Invalid sender address"");
        uint256 tokenAmount = msg.value;
        require(balanceOf[address(this)] >= tokenAmount, ""Insufficient token supply"");
        balanceOf[address(this)] -= tokenAmount;
        balanceOf[msg.sender] += tokenAmount;
        emit Transfer(address(this), msg.sender, tokenAmount);
    }

    // Function to withdraw funds to owner's account
    function withdrawFunds() external {
        require(msg.sender == owner, ""Only owner can withdraw"");

        uint256 balance = address(this).balance;
        require(balance > 0, ""No funds available"");

        address payable payableOwner = payable(owner);
        payableOwner.transfer(balance);
    }

    // Function to kill contract
    function killContract() external {
        require(msg.sender == owner, ""Only owner can kill the contract"");
        selfdestruct(payable(owner));
    }
}","Create a smart contract that allows for a cryptocurrency crowdsale, mimicking the ARMOR token. This contract should have a constructor that sets the total token supply, allocating 90% for public sale and 10% for the owner. Implement a function to accept Ether, approve token ownership, and transfer tokens. Include decimal precision for the token. Lastly, add features for withdrawing funds and killing the contract."
contract_100.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return payable(msg.sender);
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this;
        return msg.data;
    }
}

interface IERC20 {
    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function transfer(address recipient, uint256 amount) external returns (bool);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract Electrocoin is Context, IERC20 {
    mapping(address => uint256) private _balances;

    mapping(address => mapping(address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;
    uint8 private _decimals;

    constructor(
        string memory name_,
        string memory symbol_,
        uint8 decimals_,
        uint256 totalSupply_
    ) {
        _name = name_;
        _symbol = symbol_;
        _decimals = decimals_;
        _totalSupply = totalSupply_;
        _balances[_msgSender()] = totalSupply_;
        emit Transfer(address(0), _msgSender(), totalSupply_);
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function totalSupply() public override view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public override view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        require(recipient != address(0), ""ERC20: transfer to the zero address"");
        require(_balances[_msgSender()] >= amount, ""ERC20: transfer amount exceeds balance"");
        
        _balances[_msgSender()] -= amount;
        _balances[recipient] += amount;
        emit Transfer(_msgSender(), recipient, amount);

        return true;
    }

    function allowance(address owner, address spender) public override view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        require(spender != address(0), ""ERC20: approve to the zero address"");
        
        _allowances[_msgSender()][spender] = amount;
        emit Approval(_msgSender(), spender, amount);

        return true;
    }

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public override returns (bool) {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");
        require(_balances[sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        require(_allowances[sender][_msgSender()] >= amount, ""ERC20: transfer amount exceeds allowance"");

        _balances[sender] -= amount;
        _balances[recipient] += amount;
        _allowances[sender][_msgSender()] -= amount;
        
        emit Transfer(sender, recipient, amount);

        return true;
    }
}","Develop a Solidity smart contract that replicates the functionality of the Electrocoin token. This contract should include key functions like `distr`, `transfer`, and `approve`, while adhering to the ERC20 standard. The contract should also incorporate necessary modifiers and events. Pay attention to the logical flow and technical aspects, ensuring that the contract is structured correctly and follows best practices in Smart Contract development."
contract_200.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

abstract contract ERC20 {
    function totalSupply() public view virtual returns (uint256);
    function balanceOf(address account) public view virtual returns (uint256);
    function transfer(address recipient, uint256 amount) public virtual returns (bool);
    function allowance(address owner, address spender) public view virtual returns (uint256);
    function approve(address spender, uint256 amount) public virtual returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract KoalaToken is ERC20 {
    string public constant name = 'KoalaToken';
    string public constant symbol = 'KLA';
    uint8 public constant decimals = 18;
    uint256 public constant maxSupply = 400000000 * 10 ** uint(decimals);

    mapping(address => uint256) _balances;
    mapping(address => mapping(address => uint256)) _allowances;
    uint256 _totalSupply;
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can perform this action"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address _owner, address spender) public view override returns (uint256) {
        return _allowances[_owner][spender];
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""ERC20: transfer from zero address"");
        require(recipient != address(0), ""ERC20: transfer to zero address"");
        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""ERC20: approve from zero address"");
        require(spender != address(0), ""ERC20: approve to zero address"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function mint(address to, uint256 amount) public onlyOwner {
        require(to != address(0), ""ERC20: mint to zero address"");
        require(_totalSupply + amount <= maxSupply, ""ERC20: mint amount exceeds maximum total supply"");
        _totalSupply += amount;
        _balances[to] += amount;
        emit Transfer(address(0), to, amount);
    }
}","Create a smart contract that allows for the creation of a KoalaToken. The token should be mintable with a maximum total supply of 400 million tokens. Implement a mint function that allows authorized addresses to mint new tokens to a specified recipient address. Ensure that the contract checks for invalid recipient addresses and excess token minting. For development, utilize the provided ERC20 contract as a base and build upon its functionality."
contract_56.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// ERC20 Interface
abstract contract ERC20Interface {
    function totalSupply() public view virtual returns (uint);
    function balanceOf(address tokenOwner) public view virtual returns (uint balance);
    function allowance(address tokenOwner, address spender) public view virtual returns (uint remaining);
    function transfer(address to, uint tokens) public virtual returns (bool success);
    function approve(address spender, uint tokens) public virtual returns (bool success);
    function transferFrom(address from, address to, uint tokens) public virtual returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}

contract BasicAttentionToken is ERC20Interface {
    string public symbol;
    string public  name;
    uint8 public decimals;
    uint _totalSupply;
    uint public cap;

    mapping(address => uint) balances;
    mapping(address => mapping(address => uint)) allowed;
    
    address owner;
    
    modifier onlyOwner() {
        require(msg.sender == owner, ""Caller is not owner"");
        _;
    }

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint _cap) {
        owner = msg.sender;
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        _totalSupply = 0;
        cap = _cap;
    }

    function totalSupply() public view override returns (uint) {
        return _totalSupply;
    }

    function balanceOf(address tokenOwner) public view override returns (uint balance) {
        return balances[tokenOwner];
    }

    function allowance(address tokenOwner, address spender) public view override returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }

    function createToken(uint tokens) public onlyOwner {
        require(_totalSupply + tokens <= cap, ""Creation would exceed token cap"");
        _totalSupply = _totalSupply + tokens;
        balances[owner] = balances[owner] + tokens;
        emit Transfer(address(0), owner, tokens);
    } 

    function transfer(address to, uint tokens) public override returns (bool success) {
        require(balances[msg.sender] >= tokens, ""Insufficient balance"");
        balances[msg.sender] = balances[msg.sender] - tokens;
        balances[to] = balances[to] + tokens;
        emit Transfer(msg.sender, to, tokens);
        return true;
    }

    function approve(address spender, uint tokens) public override returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    function transferFrom(address from, address to, uint tokens) public override returns (bool success) {
        require(balances[from] >= tokens, ""Insufficient balance"");
        require(allowed[from][msg.sender] >= tokens, ""Insufficient allowance"");
        
        balances[from] = balances[from] - tokens;
        allowed[from][msg.sender] = allowed[from][msg.sender] - tokens;
        
        balances[to] = balances[to] + tokens;
        emit Transfer(from, to, tokens);
        return true;
    }

    function refund(address payable to, uint tokens) public onlyOwner {
        require(balances[to] >= tokens, ""Insufficient balance"");
        _totalSupply = _totalSupply - tokens;
        balances[to] = balances[to] - tokens;
        to.transfer(tokens);
        emit Transfer(to, address(0), tokens);
    }
}","Design a smart contract to handle the creation and transfer of a Basic Attention Token (BAT). The contract should include functions for creating, transferring, and approving tokens, as well as allowing users to retrieve their token balance. Ensure the contract has logic to prevent token supply from exceeding a set cap. Include modifiers to control the token distribution and refund any remaining funds. The contract should utilize the Solidity programming language and be compatible with the Ethereum blockchain."
contract_6.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// Contract: SafeMath
contract SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;

        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;

        return c;
    }
}

// Contract: ERC20
contract ERC20 {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;
    string private _name;
    string private _symbol;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor (string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, ""ERC20: transfer amount exceeds allowance""));
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _balances[sender] = _balances[sender].sub(amount, ""ERC20: transfer amount exceeds balance"");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _msgSender() internal view returns (address) {
        return msg.sender;
    }

    function _mint(address account, uint256 amount) internal {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}

// Contract: TokenVesting
contract TokenVesting {
    using SafeMath for uint256;

    ERC20 public token;
    mapping(address => uint256) public released;
    mapping(address => bool) public isInvestor;
    bytes32 public merkleRoot;
    uint256 public tgeTimestamp;

    event TokenClaimed(address investor, uint256 amount);
    event VestingStepClaimed(address investor, uint256 step);
    event TGEOccurred(uint256 tgeTimestamp);

    constructor(address tokenAddress, bytes32 _merkleRoot) {
        token = ERC20(tokenAddress);
        merkleRoot = _merkleRoot;
    }

    function claim(bytes32[] memory proof, uint256 reward) public {
        require(isInvestor[msg.sender], 'Investor not recognized');

        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, reward));
        require(verify(proof, leaf), 'Invalid proof');

        token.transfer(msg.sender, reward);

        emit TokenClaimed(msg.sender, reward);
    }

    function proveInvestor(bytes32[] memory proof) public{
        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));
        require(verify(proof, leaf), 'Invalid proof');

        isInvestor[msg.sender] = true;
    }

    function startTGE() public {
        tgeTimestamp = block.timestamp;

        emit TGEOccurred(tgeTimestamp);
    }

    function verify(bytes32[] memory proof, bytes32 leaf) private view returns (bool) {
        bytes32 computedHash = leaf;
        
        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];
            
            if (computedHash <= proofElement) {
                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));
            } else {
                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));
            }
        }
        
        return computedHash == merkleRoot;
    }
}","Design a smart contract that distributes tokens based on a time-vesting model with multiple claimable steps and a TGE event. The contract should allow users to claim tokens based on their proof of ownership and meet specific eligibility criteria. Incorporate a token, Merkle root, and TGE timestamp. Implement functions for checking and claiming tokens, utilizing import statements for OpenZeppelin libraries. Ensure events are triggered for claim, TGE, and step claim. The contract should have mappings for investors, categories, and claim states."
contract_96.sol,"pragma solidity ^0.8.0;

contract DepositAndInvestmentSystem {
    struct User {
        string name;
        address userAddress;
        uint256 balance;
    }

    mapping(address => User) public users;
    address public owner;

    uint256 public minDeposit;
    uint256 public returnRate;
    event LogDeposit(address indexed user, uint256 amount);
    event LogInvestment(address indexed user, uint256 amount);
    event LogWithdrawal(address indexed user, uint256 amount);
    event LogProductPurchase(address indexed user, address indexed product, uint256 amount);

    constructor(uint256 _minDeposit, uint256 _returnRate) {
        owner = msg.sender;
        minDeposit = _minDeposit;
        returnRate = _returnRate;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can perform this operation"");
        _;
    }

    modifier isRegistered() {
        require(bytes(users[msg.sender].name).length != 0, ""User not registered"");
        _;
    }

    modifier hasMinimumBalance() {
        require(users[msg.sender].balance >= minDeposit, ""Not enough balance to perform this operation"");
        _;
    }

    function registerUser(string memory _name) public {
        require(bytes(_name).length != 0, ""Invalid user name"");
        require(bytes(users[msg.sender].name).length == 0, ""User already registered"");

        users[msg.sender] = User({
            name: _name,
            userAddress: msg.sender,
            balance: 0
        });
    }

    function deposit() public payable isRegistered {
        require(msg.value >= minDeposit, ""Deposited amount is less than the minimum deposit requirement"");

        users[msg.sender].balance += msg.value;

        emit LogDeposit(msg.sender, msg.value);
    }

    function invest(uint256 _amount) public isRegistered hasMinimumBalance {
        require(_amount <= users[msg.sender].balance, ""Not enough balance to invest this amount"");

        users[msg.sender].balance -= _amount;

        emit LogInvestment(msg.sender, _amount);
    }

    function withdraw(uint256 _amount) public isRegistered hasMinimumBalance {
        require(_amount <= users[msg.sender].balance, ""Not enough balance to withdraw this amount"");

        users[msg.sender].balance -= _amount;

        payable(msg.sender).transfer(_amount);

        emit LogWithdrawal(msg.sender, _amount);
    }

    function purchaseProduct(address _product, uint256 _amount) public isRegistered hasMinimumBalance {
        require(_amount <= users[msg.sender].balance, ""Not enough balance to purchase this product"");

        users[msg.sender].balance -= _amount;

        emit LogProductPurchase(msg.sender, _product, _amount);
    }

    function setMinDeposit(uint256 _minDeposit) public onlyOwner {
        minDeposit = _minDeposit;
    }

    function setReturnRate(uint256 _returnRate) public onlyOwner {
        returnRate = _returnRate;
    }
}","Create a smart contract that enables users to deposit and withdraw funds, with specific minimums and return rates. Design a system for deposit returns and product purchases. Implement functions for user registration, deposit, investment, and withdrawal. Incorporate modifiers for authorized access and log events for auditing purposes."
contract_128.sol,"pragma solidity ^0.8.0;

abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return payable(msg.sender);
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this;
        return msg.data;
    }
}

interface IERC20 {
    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function transfer(address recipient, uint256 amount) external returns (bool);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract AnySwapUSDCv5 is Context, IERC20 {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    uint256 private _totalSupply;

    string private _name = 'AnySwapUSDCv5';
    string private _symbol = 'AUSDCv5';
    
    function name() public view virtual returns (string memory) {
        return _name;
    }

    function symbol() public view virtual returns (string memory) {
        return _symbol;
    }

    function decimals() public view virtual returns (uint8) {
        return 18;
    }

    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }
    
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
:
        uint256 currentAllowance = _allowances[sender][_msgSender()];
        require(currentAllowance >= amount, ""ERC20: transfer amount exceeds allowance"");
        _approve(sender, _msgSender(), currentAllowance - amount);

        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        uint256 senderBalance = _balances[sender];
        require(senderBalance >= amount, ""ERC20: transfer amount exceeds balance"");
        _balances[sender] = senderBalance - amount;
        _balances[recipient] += amount;

        emit Transfer(sender, recipient, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}","Create a smart contract that implements the Anyswap USDC v5 ERC20 standard. The contract should allow for token transfers, approve and call other contracts, and permit-based approvals. Include a function for token approval and another for token transfer. Utilize the SafeERC20 library for secure and efficient token handling. Implement necessary logic for managing token balances and allowances. Focus on ensuring the contract adheres to common ERC20 and EIP-677 standards."
contract_37.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Context {
    function _msgSender() internal view returns (address) {
        return msg.sender;
    }

    function _msgData() internal view returns (bytes calldata) {
        return msg.data;
    }
}    

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;

        return c;
    }
}

library Address {
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, ""Address: insufficient amount"");

        (bool success, ) = recipient.call{value: amount}("""");
        require(success, ""Address: unable to send value, recipient may have reverted"");
    }

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, ""Address: function call failed"");
    }

    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        require(isContract(target), ""Address: function call to non-contract"");

        (bool success, bytes memory returndata) = target.call(data);
        require(success, errorMessage);

        return returndata;
    }

   function isContract(address account) internal view returns (bool) {
        uint256 size;

        assembly { size := extcodesize(account) }
        return size > 0;
    }
}

contract Token is Context, IERC20 {
    using SafeMath for uint256;
    using Address for address;

    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;

    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount));
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");
        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
    }
}","Create a smart contract that allows users to transfer a token, check their balance, and approve token transfers. The contract should utilize the IERC20 interface and inherit from OpenZeppelin's Context contract. The implementation should include SafeMath library functions for arithmetic operations and Address library functions for sending values and making function calls. Consider potential reentrancy attacks and optimize for gas efficiency."
contract_147.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC721Basic {
    // Events
    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);
    
    // Functions
    function totalSupply() public view returns (uint256 _totalSupply);
    function balanceOf(address _owner) public view returns (uint256 _balance);
    function ownerOf(uint256 _tokenId) public view returns (address _owner);
    function approve(address _to, uint256 _tokenId) public;
    function getApproved(uint256 _tokenId) public view returns (address _operator);
    function transferFrom(address _from, address _to, uint256 _tokenId) public;
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) public;
}

contract ERC721TokenReceiver {
    // Events
    event Received(operator, from, tokenId, data);
    
    // Functions
    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes memory _data) public returns(bytes4);
}

contract ERC721BasicToken is ERC721Basic {
    uint256 internal totalTokenSupply;
    mapping(address => uint256) internal balances;
    mapping(uint256 => address) internal tokenOwners;
    mapping(uint256 => address) internal tokenApprovals;

    function mint(address _to) public {
        uint256 newTokenId = totalTokenSupply;
        totalTokenSupply++;
        balances[_to]++;
        tokenOwners[newTokenId] = _to;
        emit Transfer(address(0), _to, newTokenId);
    }

    function totalSupply() public view override returns (uint256) {
        return totalTokenSupply;
    }

    function balanceOf(address _owner) public view override returns (uint256) {
        return balances[_owner];
    }

    function ownerOf(uint256 _tokenId) public view override returns (address) {
        return tokenOwners[_tokenId];
    }

    function approve(address _to, uint256 _tokenId) public override {
        tokenApprovals[_tokenId] = _to;
    }

    function getApproved(uint256 _tokenId) public view override returns (address) {
        return tokenApprovals[_tokenId];
    }

    function transferFrom(address _from, address _to, uint256 _tokenId) public override {
        require(tokenOwners[_tokenId] == _from, ""Function called for unowned token."");
        require(_to != address(0), ""0x0 address not permitted for transfer."");
    
        tokenOwners[_tokenId] = _to;
        balances[_from]--;
        balances[_to]++;
        emit Transfer(_from, _to, _tokenId);
    }

    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public override {
        safeTransferFrom(_from, _to, _tokenId, """");
    }

    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) public override {
        transferFrom(_from, _to, _tokenId);

        if (isContract(_to)) {
            bytes4 response = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);
            require(response == bytes4(0x150b7a02), ""Transfer to non ERC721Receiver contract."");
        }
    }

    function isContract(address _address) private view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(_address) }
        return size > 0;
    }
}

contract ERC721Receiver is ERC721TokenReceiver {
    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes memory _data) public override
        returns(bytes4) {
        emit Received(_operator, _from, _tokenId, _data);
        return this.onERC721Received.selector;
    }
}","Develop a Solidity smart contract that tests the receipt of ERC721 tokens. The contract should include a function to mint and transfer a mock ERC721 token, and another function to test token reception with varying amounts."
contract_199.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface AggregatorV3Interface {
    function latestRoundData() external view returns (
        uint80 roundID, 
        int price,
        uint startedAt,
        uint timeStamp,
        uint80 answeredInRound
    );
}

interface IERC20 {
    function totalSupply() external view returns (uint);
    function balanceOf(address account) external view returns (uint);
    function transfer(address recipient, uint amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint);
    function approve(address spender, uint amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);
}

library SafeERC20 {
    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function callOptionalReturn(IERC20 token, bytes memory data) private {
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, ""SafeERC20: low-level call failed"");

        if (returndata.length > 0) { 
            require(abi.decode(returndata, (bool)), ""SafeERC20: ERC20 operation did not succeed"");
        }
    }
}

contract YourContract {
    using SafeERC20 for IERC20;

    mapping(address => uint) nonces;
    bytes32 public constant PERMIT_TYPEHASH = keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");

    address public immutable owner;
    AggregatorV3Interface internal priceFeed;

    constructor (address aggregator_) {
        owner = msg.sender;
        
        priceFeed = AggregatorV3Interface(aggregator_);
    }

    function latestPrice() public view returns (int) {
        (,int price,,,) = priceFeed.latestRoundData();
        return price;
    }

    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {
        bytes32 digest = keccak256(
            abi.encodePacked(
                ""\x19\x01"",
                block.chainid,
                blockhash(block.number - 1),
                PERMIT_TYPEHASH,
                owner,
                spender,
                value,
                nonces[owner]++,
                deadline
            )
        );
        address recoveredAddress = ecrecover(digest, v, r, s);
        require(recoveredAddress != address(0) && recoveredAddress == owner, ""YourContract::permit: signature does not match"");
        _approve(owner, spender, value);
    }
   
    function _approve(address owner, address spender, uint amount) internal {
        require(owner != address(0), ""YourContract: approve from the zero address"");
        require(spender != address(0), ""YourContract: approve to the zero address"");

        IERC20(owner).approve(spender, amount);
        emit Approval(owner, spender, amount);
    }

    event Approval(address indexed owner, address indexed spender, uint value);
}","Create a smart contract that utilizes the AggregatorV3Interface to retrieve current prices and IERC20 interface for token management. Implement functions for permit, nonce, DOMAIN_SEPARATOR, totalSupply, balanceOf, transfer, allowance, and approve to manage token ownership and transfer. Utilize the SafeERC20 library to ensure secure token transfers. Consider implementing re-entrancy protection and handling potential errors."
contract_130.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

library Address {
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, ""Address: insufficient balance"");
        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
        (bool success, ) = recipient.call{ value: amount }("""");
        require(success, ""Address: Unable to send value, recipient may have reverted"");
    }
}

contract Initializable {
    address public initializer;
    uint256 public initializationBlock;

    modifier initializer() {
        require(initializer == address(0), ""already initialized"");
        initializer = msg.sender;
        initializationBlock = block.number;
        _;
    }

    modifier reinitializer() {
        require(initializer != address(0), ""not initialized yet"");
        require(initializationBlock < block.number, ""reinitialization not possible in same block"");
        _;
    }

    function getInitializer() public view returns (address) {
        return initializer;
    }

    function getInitializationBlock() public view returns (uint256) {
        return initializationBlock;
    }

    function initialize() public initializer {
    }

    function reinitialize() public reinitializer {
        initializer = msg.sender;
        initializationBlock = block.number;
    }
}",Create a smart contract that allows for initialization and reinitialization to a specific version. Use modifiers to control the initialization process. Implement functions to manage initialization and reinitialization. Incorporate a library that enables contract interaction and value sending. Make sure the contract complies with the MIT license. Keep in mind the need for flexibility in initializable contracts.
contract_108.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// IERC20 Interface
contract IERC20 {
    function totalSupply() public view returns (uint256);
    function balanceOf(address account) public view returns (uint256);
    function transfer(address recipient, uint256 amount) public returns (bool);
    function allowance(address owner, address spender) public view returns (uint256);
    function approve(address spender, uint256 amount) public returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

// REDTOKEN Contract inheriting the IERC20 Interface
contract REDToken is IERC20 {
    string public constant name = ""RED Token"";
    string public constant symbol = ""RED"";
    uint8 public constant decimals = 18;
    
    mapping(address => uint256) private _balances;
    mapping(address => mapping (address => uint256)) private _allowances;
    uint256 private _totalSupply;
    
    constructor(uint256 initialSupply) {
        _totalSupply = initialSupply;
        _balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }
    
    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        require(recipient != address(0), ""ERC20: transfer to the zero address"");
        require(_balances[msg.sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        _balances[msg.sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }
    
    function allowance(address owner, address spender) public view override returns (uint256) {
        return _allowances[owner][spender];
    }
    
    function approve(address spender, uint256 amount) public override returns (bool) {
        require(spender != address(0), ""ERC20: approve to the zero address"");
        _allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
    
    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");
        require(_balances[sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        require(_allowances[sender][msg.sender] >= amount, ""ERC20: transfer amount exceeds allowance"");
        _balances[sender] -= amount;
        _balances[recipient] += amount;
        _allowances[sender][msg.sender] -= amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }
}","Create a smart contract for the RED token, implementing the ERC20 standard. The contract should include functions for managing the token supply, balance, and transfer. Initialize the token supply in the constructor. Implement a function for transferring tokens from one address to another. Include a function for approving a spender. Handle events for token transfer and approval. Focus on implementing the core functionality of the contract, using built-in Solidity features and libraries where possible."
contract_220.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract usingOraclize {
    uint public price;
    bool public priceUpdated;
    bytes32 public oraclizeId;
    address public oraclizeAddr;
    
    event newOraclizeQuery(string description);
    event newCryptoPrice(string price);

    modifier oraclizeAPI {
        require(msg.sender == oraclizeAddr, ""Only oraclize API can call this function"");
        _;
    }

    function __callback(bytes32 _oraclizeId, string memory _result) public oraclizeAPI {
        require(oraclizeId == _oraclizeId, ""Invalid oraclize id"");
        price = parseInt(_result, 2);
        priceUpdated = true;
        emit newCryptoPrice(_result);
    }

    function updatePrice() public payable {
        if (oraclize_getPrice(""URL"") > address(this).balance) {
            emit newOraclizeQuery(""Oraclize query was NOT sent, please add some ETH to cover for the query fee"");
        } else {
            emit newOraclizeQuery(""Oraclize query was sent, standing by for the answer.."");
            oraclizeId = oraclize_query(""URL"", 
                ""json(https://api.pro.coinbase.com/products/ETH-USD/ticker).price"");
        }
    }

    // Query a given URL and expect a number as result
    function oraclize_query(string memory datasource, string memory arg) public payable returns (bytes32 id);

    // Query a given URL at a specific timestamp and expect a number as result
    function oraclize_query(uint timestamp, string memory datasource, string memory arg) public payable returns (bytes32 id);

    // Query a given URL at a specific timestamp and with specific gas price and gas limit, and expect a number as result
    function oraclize_query(uint timestamp, string memory datasource, string memory arg, uint gaslimit) public payable returns (bytes32 id);

    // Get the price of the specified datasource
    function oraclize_getPrice(string calldata datasource) public view returns (uint);

    // Return the address of the OraclizeAddrResolverI instance
    function oraclize_setCustomGasPrice(uint _gasPrice) external;
    
    // Parse Int Function
    function parseInt(string memory _a, uint _b) public pure returns (uint);
}","Create a Solidity smart contract that allows users to query external APIs using the Oraclize API. The contract should include functions for querying data, managing network connections, and handling gas limits. The contract should support querying data using different timestamps, data sources, and query limits. Make sure to include error handling and customizable gas prices."
contract_203.sol,"pragma solidity ^0.8.0;

// SafeMath library
library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) { 
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }
}

// ERC20 Basic Interface
contract ERC20Basic {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory name_, string memory symbol_, uint8 decimals_) {
        _name = name_;
        _symbol = symbol_;
        _decimals = decimals_;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public virtual returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view virtual returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public virtual returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _beforeTokenTransfer(sender, recipient, amount);

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }
}

// Voken contract
contract Voken is ERC20Basic {
    constructor() ERC20Basic(""Voken"", ""VKN"", 18) {}
  
    function mint(address to, uint256 amount) public {
        _mint(to, amount);
    }
}","Create a smart contract in Solidity that implements the ERC-20 token standard for the Voken token, utilizing the SafeMath library for basic arithmetic operations. Ensure the contract includes necessary functions for minting, transferring, and approving token transfers. Don't forget to implement necessary security measures and logging for debugging purposes."
contract_102.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

abstract contract PRBProxyPlugin {
    function supportsInterface(bytes4 _interfaceID) external pure virtual returns (bool);
}

interface TargetChangeOwner {
    function changeOwner(address newOwner) external;
    function getOwner() external view returns (address);
}

contract ManageTargetOwnership is PRBProxyPlugin, TargetChangeOwner {
    address private _targetOwner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor(address initialOwner){
        _targetOwner = initialOwner;
    }
    
    modifier onlyOwner() {
        require(isOwner(), ""ManageTargetOwnership: caller is not the owner"");
        _;
    }

    function supportsInterface(bytes4 _interfaceID) external pure override returns (bool) {
        return _interfaceID == type(TargetChangeOwner).interfaceId;
    }

    function isOwner() public view returns (bool) {
        return (msg.sender == _targetOwner);
    }

    function getOwner() public view override returns (address) {
        return _targetOwner;
    }

    function changeOwner(address newOwner) public override onlyOwner {
        require(newOwner != address(0), ""ManageTargetOwnership: new owner is the zero address"");
        emit OwnershipTransferred(_targetOwner, newOwner);
        _targetOwner = newOwner;
    }
}",Design a smart contract for managing ownership of a target. The contract should inherit from a parent contract (PRBProxyPlugin) and implement a specific interface (TargetChangeOwner). The contract should provide two functions: one to change the owner of the target and another to retrieve the current owner. The implementation should be suitable for a real-world use case and include necessary functions and variables.
contract_105.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

contract AccessControl is Context {
    mapping (address => uint8) private _roles;

    uint8 constant ROLE_DAO_ADMIN = 1;
    uint8 constant ROLE_OPERATOR = 2;
    uint8 constant ROLE_CALLER = 3;
    uint8 constant ROLE_CALLEE = 4;

    event RoleGranted(address indexed account, uint8 role);
    event RoleRevoked(address indexed account, uint8 role);

    constructor () {
        _setRole(_msgSender(), ROLE_DAO_ADMIN);
    }

    modifier onlyDAOAdmin() {
        require(_roles[_msgSender()] == ROLE_DAO_ADMIN, ""AccessControl: not a DAO admin"");
        _;
    }

    modifier onlyOperator() {
        require(_roles[_msgSender()] == ROLE_OPERATOR, ""AccessControl: not an operator"");
        _;
    }

    modifier onlyCaller() {
        require(_roles[_msgSender()] == ROLE_CALLER, ""AccessControl: not a caller"");
        _;
    }

    modifier onlyCallee() {
        require(_roles[_msgSender()] == ROLE_CALLEE, ""AccessControl: not a callee"");
        _;
    }

    function grantRole(address account, uint8 role) public onlyDAOAdmin {
        _setRole(account, role);
    }

    function revokeRole(address account, uint8 role) public onlyDAOAdmin {
        require(_roles[account] == role, ""AccessControl: target does not have role"");
        delete _roles[account];
        emit RoleRevoked(account, role);
    }

    function _setRole(address account, uint8 role) internal {
        _roles[account] = role;
        emit RoleGranted(account, role);
    }
}","Create a smart contract that restricts access to certain functions based on specific roles. The contract should have four roles: DAO_ADMIN, OPERATOR, CALLER, and CALLEE. Each role should have specific privileges, such as DAO_ADMIN being able to set up initial administrators. The contract should include modifier functions for each role to control access to specific functions. Use Solidity 0.8.10 and include necessary import statements."
contract_1.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract WETHOmnibridgeRouter {
    address public immutable mediatorContractOnOtherSide;
    address payable public immutable wethContract;

    constructor(address _mediatorContractOnOtherSide, address payable _wethContract) {
        mediatorContractOnOtherSide = _mediatorContractOnOtherSide;
        wethContract = _wethContract;
    }

    function relayTokens(uint256 _value) public payable {
        require(msg.value > 0 && _value > 0, ""Invalid values provided"");
        
        wethContract.transfer(msg.value);

        bytes4 methodSelector = IERC20(wethContract).approve.selector;
        bytes memory data = abi.encodeWithSelector(methodSelector, mediatorContractOnOtherSide, _value);
        (bool success,) = wethContract.call(data);
        require(success, ""Cannot approve"");

        methodSelector = ITokenMediator(mediatorContractOnOtherSide).relayTokens.selector;
        data = abi.encodeWithSelector(methodSelector, wethContract, msg.sender, _value, new bytes(0));
        
        (success,) = mediatorContractOnOtherSide.call(data);
        require(success, ""Relay failed"");

        emit RelayTokens(msg.sender, _value);
    }

    event RelayTokens(address indexed sender, uint256 value);
}

interface IERC20 {
    function approve(address spender, uint256 value) external returns (bool);
}

interface ITokenMediator {
    function relayTokens(address token, address _receiver, uint256 _value, bytes calldata _data) external;
}","Create a smart contract that builds upon the WETHOmnibridgeRouter contract by adding features for account registration, token wrapping, and relay. The contract should integrate with the Omnibridge and WETH contracts. Include methods for registering and wrapping tokens, as well as functionality for relaying tokens to specific recipients. The contract should emit events upon successful token wrapping and relaying. Consider implementing  error handling and validation checks for user input."
contract_73.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// SafeMath library
library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");

        return c;
    }
    function sub(uint256 a, uint256 b, string calldata errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }
}

// Address library
library Address {
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, ""Address: insufficient balance"");
        (bool success, ) = recipient.call{ value: amount }("""");
        require(success, ""Address: unable to send value, recipient may have reverted"");
    }
}

contract Token is IERC20 {
    using SafeMath for uint256;
    using Address for address;
    
    string private _name;
    string private _symbol;
    uint256 private _totalSupply;
    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;

    constructor (string memory name_, string memory symbol_)  {
        _name = name_;
        _symbol = symbol_;
        _totalSupply = 1000000 * (10 ** uint256(18));
        _balances[msg.sender] = _totalSupply;

        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function name() public view virtual override returns (string memory) {
        return _name;
    }

    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""Б20: transfer from the zero address"");
        require(recipient != address(0), ""Б20: transfer to the zero address"");
        _balances[sender] = _balances[sender].sub(amount, ""Б20: transfer amount exceeds balance"");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""Б20: approve from the zero address"");
        require(spender != address(0), ""Б20: approve to the zero address"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}","Create a smart contract that follows the IERC20 token standard. It should include functions for total supply, balance checking, sending tokens, approving transfers, and handling transfer requests. Utilize the SafeMath and Address libraries to ensure accurate calculations and efficient interaction. Focus on a clean and readable code structure."
contract_125.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface ISwapper {
    function swapTokens(address tokenA, address tokenB, uint256 amount) external;
}

contract PucieToken is IERC20 {
    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;
    mapping (address => bool) private _isExcludedFromFees;
    uint256 private _totalSupply;
    string private _name;
    string private _symbol;
    uint256 private _taxFee;
    address private _feeRecipient;
    ISwapper private _swapper;

    constructor(address swapper, address feeRecipient, uint256 taxFee) {
        _name = 'PucieToken';
        _symbol = 'PTK';
        _swapper = ISwapper(swapper);
        _feeRecipient = feeRecipient;
        _taxFee = taxFee;
    }

    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _transfer(sender, recipient, amount);
        uint256 currentAllowance = _allowances[sender][msg.sender];
        require(currentAllowance >= amount, ""ERC20: transfer amount exceeds allowance"");
        _approve(sender, msg.sender, currentAllowance - amount);
        return true; 
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");
        require(_balances[sender] >= amount, ""ERC20: transfer amount exceeds balance"");

        uint256 taxAmount = 0;
        if (!_isExcludedFromFees[sender]) {
            taxAmount = amount * _taxFee / 100;
            _balances[_feeRecipient] += taxAmount;
            emit Transfer(sender, _feeRecipient, taxAmount);
        }

        _balances[sender] -= amount;
        _balances[recipient] += amount - taxAmount;
        emit Transfer(sender, recipient, amount - taxAmount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function swapTokens(address tokenA, address tokenB, uint256 amount) public {
        require(_balances[msg.sender] >= amount, ""ERC20: swap amount exceeds balance"");
        
        _balances[msg.sender] -= amount;
        _swapper.swapTokens(tokenA, tokenB, amount);
    }

    function excludeFromFees(address account) public {
        _isExcludedFromFees[account] = true;
    }
}","Create a token contract called 'PucieToken' that provides basic token functionality and advanced features. The contract should allow users to transfer tokens, approve transfers, and retrieve token balances. It should also include taxation on transfers, fee exemption, and integration with a swapper interface. The taxation mechanism should deduct fees from the transfer amount and allocate them to a designated recipient. Fee exemption should enable specific addresses to be exempt from paying fees. The swapper interface should enable token transfer between PucieToken and other tokens. Implement the contract with thorough testing and good documentation."
contract_173.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;

        return c;
    }
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

interface IERC223 {
    function transfer(address to, uint value, bytes calldata data) external returns (bool);
}

interface IERC223Recipient {
    function tokenFallback(address _from, uint _value, bytes calldata _data) external;
}

contract ERC20ERC223Token is IERC20, IERC223 {
    using SafeMath for uint256;

    string private _name;
    string private _symbol;
    uint256 private _totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    constructor(string memory name_, string memory symbol_, uint256 totalSupply_) {
        _name = name_;
        _symbol = symbol_;
        _totalSupply = totalSupply_;
        _balances[msg.sender] = totalSupply_;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function totalSupply() public override view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public override view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function transfer(address to, uint value, bytes memory data) public override returns (bool) {
        uint codeLength;
        
        assembly {
            codeLength := extcodesize(to)
        }
        
        _balances[msg.sender] = _balances[msg.sender].sub(value);
        
        if (codeLength > 0) {
            IERC223Recipient recipient = IERC223Recipient(to);
            recipient.tokenFallback(msg.sender, value, data);
            
            emit Transfer(msg.sender, to, value, data);
        } else {
            _balances[to] = _balances[to].add(value);
            
            emit Transfer(msg.sender, to, value, '');
        }
        
        return true;
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function allowance(address owner, address spender) public override view returns (uint256) {
        return _allowances[owner][spender];
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }
    
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");
        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount, '');
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    event Transfer(address indexed from, address indexed to, uint value, bytes data);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}","Create a token contract that supports both ERC20 and ERC223 standards. The contract should allow for token transfers, balance checks, and allowance management. Implement the necessary logic for token transfers, including balance checks and transfer notifications. Make use of the SafeMath library to ensure secure arithmetic operations. Include variables for the token's name, symbol, and total supply. Implement methods for getting the token name, symbol, and total supply. The contract should be compatible with both ERC20 and ERC223 standards."
contract_71.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC20Burnable.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol"";

contract TokenAllocation is ERC20Burnable, Ownable, Pausable {
    address public treasury;
    address public devFund;

    uint256 public treasuryPercent;
    uint256 public devFundPercent;

    uint256 public rewardRate;
    uint256 public rewardInterval = 86400; // 1 day in seconds

    uint256 public lastRewardTimestamp;

    mapping(address => uint256) public lastClaim;

    event RewardClaimed(address indexed user, uint256 amount);
    event TreasurySet(address indexed newTreasury);
    event DevFundSet(address indexed newDevFund);

    constructor(
        string memory name,
        string memory symbol,
        address _treasury,
        uint256 _treasuryPercent,
        address _devFund,
        uint256 _devFundPercent,
        uint256 _rewardRate
    ) ERC20(name, symbol) {
        require(_treasuryPercent <= 100, ""Invalid treasury percent"");
        require(_devFundPercent <= 100, ""Invalid dev fund percent"");
        require((_treasuryPercent + _devFundPercent) <= 100, ""Total percent more than 100"");

        treasury = _treasury;
        treasuryPercent = _treasuryPercent;

        devFund = _devFund;
        devFundPercent = _devFundPercent;

        rewardRate = _rewardRate;
    }

    function mint(address to, uint256 amount) external onlyOwner {
        _mint(to, amount);
        lastRewardTimestamp = block.timestamp;
    }

    function setTreasury(address _treasury, uint256 _percent) external onlyOwner {
        require(_percent <= 100, ""Invalid percent"");
        require((_percent + devFundPercent) <= 100, ""Total percent more than 100"");

        treasury = _treasury;
        treasuryPercent = _percent;

        emit TreasurySet(_treasury);
    }

    function setDevFund(address _devFund, uint256 _percent) external onlyOwner {
        require(_percent <= 100, ""Invalid percent"");
        require((_percent + treasuryPercent) <= 100, ""Total percent more than 100"");

        devFund = _devFund;
        devFundPercent = _percent;

        emit DevFundSet(_devFund);
    }

    function distributeIncentives(uint256 amount) external onlyOwner {
        uint256 incentive = amount - (getTreasuryCut(amount) + getDevFundCut(amount));
        _mint(msg.sender, incentive);
    }

    function getTreasuryCut(uint256 amount) public view returns(uint256) {
        return (amount * treasuryPercent) / 100;
    }

    function getDevFundCut(uint256 amount) public view returns(uint256) {
        return (amount * devFundPercent) / 100;
    }

    function claimReward() external {
        require(block.timestamp >= lastClaim[msg.sender] + rewardInterval, ""Too Early To Claim Reward"");
        uint256 rewardAmount = balanceOf(msg.sender) * rewardRate / 100;

        _mint(msg.sender, rewardAmount);

        lastClaim[msg.sender] = block.timestamp;

        emit RewardClaimed(msg.sender, rewardAmount);
    }

    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }

    function _beforeTokenTransfer(address from, address to, uint256 amount) internal whenNotPaused override {
        super._beforeTokenTransfer(from, to, amount);
    }
}","Create a smart contract that manages token allocation and distribution. The contract should enable users to mint and burn tokens, as well as claim rewards from the community fund and dev fund. The contract should also have a vesting period for token distribution and a reward rate calculation. The contract should include a function for setting the treasury fund and dev fund, as well as a function to distribute farming incentives. Ensure that the contract includes the necessary logic for token distribution and implementation of the OpenZeppelin contracts."
contract_11.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

interface IOptionMarket {
    function mintOptions(address receiver, uint256 amount) external returns (bool);
    function burnOptions(address from, uint256 amount) external returns (bool);
}

interface IOptionToken {
    function mint(address receiver, uint256 amount) external returns (bool);
    function burn(address from, uint256 amount) external returns (bool);
}

interface ISynthetixAdapter {
    function getCollateral(address account) external view returns (uint256);
}

contract OptionCollateralManager {
    address public quoteCollateral;
    address public baseCollateral;
    ISynthetixAdapter public synthetixAdapter;
    IOptionMarket public optionMarket;
    IOptionToken public optionToken;

    constructor(address _quoteCollateral, address _baseCollateral, ISynthetixAdapter _synthetixAdapter, IOptionMarket _optionMarket, IOptionToken _optionToken) {
        require(_quoteCollateral != address(0), ""_quoteCollateral address cannot be 0"");
        require(_baseCollateral != address(0), ""_baseCollateral address cannot be 0"");
        quoteCollateral = _quoteCollateral;
        baseCollateral = _baseCollateral;
        synthetixAdapter = _synthetixAdapter;
        optionMarket = _optionMarket;
        optionToken = _optionToken;
    }

    function sendBaseCollateral(address _to, uint256 _amount) public {
        IERC20(baseCollateral).transfer(_to, _amount);
    }

    function sendQuoteCollateral(address _to, uint256 _amount) public {
        IERC20(quoteCollateral).transfer(_to, _amount);
    }

    function liquidatePosition(address account) public {
        uint256 amountToLiquidate = ISynthetixAdapter(synthetixAdapter).getCollateral(account);
        if (amountToLiquidate > 0) {
            IOptionMarket(optionMarket).burnOptions(account, amountToLiquidate);
            IOptionToken(optionToken).burn(account, amountToLiquidate);
        }
    }

    function settleOptions(address account, uint256 amount) public {
        IOptionMarket(optionMarket).mintOptions(account, amount);
        IOptionToken(optionToken).mint(account, amount);
    }
}","Create a smart contract that manages collateral and liquidation for options market. The contract should include functionality for sending quote and base collateral, liquidating positions, and settling options. Implement interfaces for OpenZeppelin's ERC20 and interfaces for synthetix adapter, option market, and option token. Include initialization functions for setting up the contract's variables."
contract_165.sol,"pragma solidity ^0.8.0;

library IncrementalMerkleTree {
    struct Data {
        uint256 depth;
        uint256[] leaves;
        uint256[] tree;
    }

    function insert(Data storage self, uint256 item) internal {
        self.leaves.push(item);
        if(self.leaves.length > (2 ** self.depth)){
            revert(""Merkle Tree is full"");
        }
        self.tree[0] = item;
        for(uint256 i = 0; i < self.depth; i++) {
            self.tree[i + 1] = uint256(keccak256(abi.encodePacked(self.tree[i], self.tree[i])));
        }
    }
}

contract MerkleManager {
    using IncrementalMerkleTree for IncrementalMerkleTree.Data;
    IncrementalMerkleTree.Data private merkleTree;

    constructor(uint256 depth) {
        merkleTree.depth = depth;
        merkleTree.leaves = new uint256[](0);
        merkleTree.tree = new uint256[](depth);
    }

    function insert(uint256 item) public {
        merkleTree.insert(item);
    }
}","Create a smart contract that builds upon the IncrementalMerkleTree library by introducing a constructor that initializes the tree's structure with customizable parameters and a reusable function for inserting new leaves, focusing on facilitating the management of large datasets within the Ethereum network."
contract_157.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(isOwner(), ""Ownable: caller is not the owner"");
        _;
    }

    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract Router is Ownable {
    address public immutable factory;
    address public immutable WETH;
  
    constructor(address _factory, address _WETH) {
        factory = _factory;
        WETH = _WETH;
    }
  
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) public returns (uint amountA, uint amountB, uint liquidity) {
        // Implementation of addLiquidity code goes here...
    }
  
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) public returns (uint amountA, uint amountB) {
        // Implementation of removeLiquidity code goes here...
    }
}","Develop a smart contract that mimics the PancakeSwap router, allowing users to add and remove liquidity. The contract should include a constructor that sets the factory and WETH addresses. The addLiquidity function should calculate the amount of tokens to add, and the removeLiquidity function should calculate the amount of liquidity to remove. Include the necessary logic for ownership transfer and locking/unlocking. Use the provided code as a reference for the Ownable and Context contract structures."
contract_85.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyNFT is ERC721Enumerable, Ownable {
    uint256 public MAX_SUPPLY;
    uint256 public PRESALE_PRICE;
    uint256 public PUBLIC_PRICE;
    uint256 public PRESALE_MINT_LIMIT;
    uint256 public PUBLIC_MINT_LIMIT;
    bool public presaleIsActive = false;
    bool public publicSaleIsActive = false;

    constructor(
        string memory name,
        string memory symbol,
        uint256 maxSupply,
        uint256 presalePrice,
        uint256 publicPrice,
        uint256 presaleLimit,
        uint256 publicLimit
    ) ERC721(name, symbol) {
        MAX_SUPPLY = maxSupply;
        PRESALE_PRICE = presalePrice;
        PUBLIC_PRICE = publicPrice;
        PRESALE_MINT_LIMIT = presaleLimit;
        PUBLIC_MINT_LIMIT = publicLimit;
    }

    function mintPublic(uint256 num) public payable {
        uint256 supply = totalSupply();
        require(publicSaleIsActive, ""Sale is not active currently"");
        require(num < PUBLIC_MINT_LIMIT, ""You can mint maximum PUBLIC_MINT_LIMIT"");
        require(supply + num < MAX_SUPPLY, ""Exceeds MAX_SUPPLY"");
        require(msg.value >= PUBLIC_PRICE * num, ""Ether value sent is below the price"");

        for(uint256 i; i < num; i++){
            _safeMint(msg.sender, supply + i);
        }
    }

    function mintPresale(uint256 num) public payable {
        uint256 supply = totalSupply();
        require(presaleIsActive, ""Presale is not active currently"");
        require(num < PRESALE_MINT_LIMIT, ""You can mint maximum PRESALE_MINT_LIMIT"");
        require(supply + num < MAX_SUPPLY, ""Exceeds MAX_SUPPLY"");
        require(msg.value >= PRESALE_PRICE * num, ""Ether value sent is below the price"");

        for (uint256 i; i < num; i++) {
            _safeMint(msg.sender, supply + i);
        }
    }
    
    function setPresaleIsActive(bool _presaleIsActive) public onlyOwner {
        presaleIsActive = _presaleIsActive;
    }
    
    function setPublicSaleIsActive(bool _publicSaleIsActive) public onlyOwner {
        publicSaleIsActive = _publicSaleIsActive;
    }

    function withdraw() public payable onlyOwner {
        uint256 balance = address(this).balance;
        payable(msg.sender).transfer(balance);
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) 
        internal 
        override(ERC721Enumerable) 
    {
        super._beforeTokenTransfer(from, to, tokenId);
    }

    function supportsInterface(bytes4 interfaceId) 
        public 
        view 
        override(ERC721Enumerable) 
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}","Create a Solidity contract that allows for the minting of tokens. The contract should have functions for presale and public minting, and include variables for maximum supply, public and presale prices, and allowed mint limits. The contract should also have functions for withdrawing funds and setting the merkle root. Implement a constructor that initializes the contract name and symbol."
contract_207.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }
}

contract Token {
    using SafeMath for uint256;
    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;
    uint256 totalSupply;
    address public tokenWallet;

    constructor(uint256 initialSupply, address initialTokenWallet) {
        totalSupply  = initialSupply;
        tokenWallet = initialTokenWallet;
        balances[tokenWallet] = initialSupply;
    }

    function totalSupply() public view returns (uint256) {
        return totalSupply;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value, ""Insufficient balance"");
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}","Create a token distribution smart contract that uses the provided SafeMath library for arithmetic operations. Include functions for token transfer, balance retrieval, allowance setting, and approval. Initialize the token supply and set the token wallet in the constructor."
contract_240.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/// @title Permissioned Access Control and EntryPoint Contract in Solidity

contract AccessControl {

    struct Operator {
        address operatorAddress;
        bool hasPermission;
    }
    
    struct FeesAndValues {
        uint256 remainingFee;
        uint256 remainingValue;
    }

    mapping(address => Operator) public operators;
    
    mapping(address => FeesAndValues) public feesAndValues;

    bytes32 public DOMAIN_SEPARATOR;
    string public NAME;
    string public VERSION;
    
    bytes32 constant EIP712DOMAIN_TYPEHASH = keccak256(
        ""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""
    );
    
    constructor (string memory name_, string memory version_) {
        NAME = name_;
        VERSION = version_;
        
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                EIP712DOMAIN_TYPEHASH,
                keccak256(bytes(NAME)),
                keccak256(bytes(VERSION)),
                block.chainid,
                address(this)
            )
        );
    }

    function setPermissions(address operatorAddress, bool hasPermission) public {
        Operator memory operator;
        operator.operatorAddress = operatorAddress;
        operator.hasPermission = hasPermission;
        operators[operatorAddress] = operator;
    }

    function checkPermission(address operatorAddress) public view returns(bool) {
        return operators[operatorAddress].hasPermission;
    }
    
    function setFeesAndValues(address userAddress, uint256 remainingFee, uint256 remainingValue) public {
        FeesAndValues memory data;
        data.remainingFee = remainingFee;
        data.remainingValue = remainingValue;
        
        feesAndValues[userAddress] = data;
    }

    function isValidSignature(
        bytes32 hash,
        bytes memory signature
    ) public view returns(bool) {
        address recoveredAddress = recover(hash, signature);

        return operators[recoveredAddress].hasPermission;
    }
    
    // ECDSA recovery function
    function recover(bytes32 hash, bytes memory signature)
        private
        pure
        returns (address)
    {
        if (signature.length != 65) {
            revert();
        }
        
        bytes32 r;
        bytes32 s;
        uint8 v;
        
        assembly {
            r := mload(add(signature, 0x20))
            s := mload(add(signature, 0x40))
            v := byte(0, mload(add(signature, 0x60)))
        }

        if (v < 27) {
            v += 27;
        }

        if (v != 27 && v != 28) {
            return (address(0));
        } else {
            return ecrecover(hash, v, r, s);
        }
    }
}","Design a smart contract that allows for permission-based access control and integrates with an EntryPoint. The contract should have functions for initializing the contract, setting operator permissions, and validating user operations. Include data structures for storing operator permissions, remaining fees, and remaining values. Consider implementing EIP712 and ECDSA signature verification. The contract should be compatible with OpenZeppelin contracts and EIP712 specifications."
contract_16.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract PausableTokenContract {

    mapping(address => uint) private _balances;
    mapping(address => bool) private _pausableAddresses;
    bool private _paused;

    event Transfer(address indexed from, address indexed to, uint value);
    event Pause(address indexed account);
    event Unpause(address indexed account);

    modifier whenNotPaused() {
        require(!_paused, ""Pausable: paused""); 
        _;
    }

    modifier whenPaused() {
        require(_paused, ""Pausable: not paused"");
        _;
    }

    function pause() public whenNotPaused {
        _paused = true;
        emit Pause(msg.sender);
    }

    function unpause() public whenPaused {
        _paused = false;
        emit Unpause(msg.sender);
    }

    function pauseStatus() public view returns (bool) {
        return _paused;
    }

    function isPausable(address addr) public view returns (bool) {
        return _pausableAddresses[addr];
    }

    function setPausable(address addr) public {
        _pausableAddresses[addr] = true;
    }

    function removePausable(address addr) public {
        _pausableAddresses[addr] = false;
    }

    function transfer(address recipient, uint amount) public whenNotPaused {
        require(_pausableAddresses[msg.sender] == false, ""Pausable: This address is pausable and the contract is paused.""); 
        require(amount <= _balances[msg.sender], ""Insufficient balance."");
        _balances[msg.sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
    }
}","Design a contract that allows for the pause and resumption of transfer operations. The contract should allow users to set an address as pausable, check if an address is pausable, and transfer tokens. The transfer function should fail if the transfer is paused. The contract should also include a function to get the current pause status."
contract_78.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// Copied from OpenZeppelin library
abstract contract Initializable {

    bool private _initialized;

    bool private _initializing;

    modifier initializer() {
        require(_initializing || _isConstructor() || !_initialized, ""Contract instance has already been initialized"");
        bool isTopLevelCall = !_initializing;
        if (isTopLevelCall) {
            _initializing = true;
            _initialized = true;
        }

        _;

        if (isTopLevelCall) {
            _initializing = false;
        }
    }

    function _isConstructor() private view returns (bool) {
        return !address(this).getCodeSize() > 0;
    }
}

// Copied from OpenZeppelin library
library AddressUpgradeable {

    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}

contract Wallet is Initializable {
    using AddressUpgradeable for address;
    mapping(address => uint256) private _balances;

    function initialize() public initializer {
        _balances[msg.sender] = 10000; //for testing, it assigns an initial balance of 10k to the contract deployer
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function isContract(address account) public view returns (bool) {
        return account.isContract();
    }

    function sendMoney(address recipient, uint256 amount)
        public
        returns (bool)
    {
        require(!isContract(recipient), ""Wallet: contract address provided instead of wallet address"");
        require(_balances[msg.sender] >= amount, ""Wallet: insufficient balance for transaction"");
        require(recipient != address(0), ""Wallet: transfer to the zero address"");

        _balances[msg.sender] -= amount;
        _balances[recipient] += amount;

        return true;
    }
}","Develop a smart contract that allows for wallet address balance increases, utilizes a specific function to perform the transfer, and includes error handling for insufficient balance and invalid target addresses. The contract should be structured to utilize OpenZeppelin's Initializable contract and AddressUpgradeable library. Implement a user-friendly interface for sending the specified amount to the target address."
contract_237.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

contract BananaNFT is ERC721, Ownable, Pausable {
    uint256 public bananaPrice = 0.05 ether;
    uint256 public maxPurchase = 20;
    uint256 public MAX_BANANAS = 10000;
    bool public saleIsActive = false;
    mapping(address => bool) public whitelistAddresses;

    constructor() ERC721(""SuperBanana"", ""BNN"") {}

    function withdraw() public onlyOwner {
        uint256 balance = address(this).balance;
        payable(owner()).transfer(balance);
    }

    function mintBanana(address _to, uint256 _count) public payable whenNotPaused {
        uint256 total = totalSupply();
        require(total + _count <= MAX_BANANAS, ""Max limit"");
        require(total <= MAX_BANANAS, ""Sale end"");
        require(_count <= maxPurchase, ""Exceeds maxPurchase"");
        require(bananaPrice * _count <= msg.value, ""Value below price"");

        for(uint256 i = 0; i < _count; i++){
            _safeMint(_to, total + i);
        }
    }

    function whitelistMintBanana(address _to, uint256 _count) public payable whenNotPaused {
        require(whitelistAddresses[msg.sender], ""You are not on the whitelist"");
        uint256 total = totalSupply();
        require(total + _count <= MAX_BANANAS, ""Max limit"");
        require(total <= MAX_BANANAS, ""Sale end"");
        require(_count <= maxPurchase, ""Exceeds maxPurchase"");
        require(bananaPrice * _count <= msg.value, ""Value below price"");

        for(uint256 i = 0; i < _count; i++){
            _safeMint(_to, total + i);
        }
    }

    function setSaleState(bool _value) public onlyOwner {
        saleIsActive = _value;
        if(_value == false){
            _pause();
        } else {
            _unpause();
        }
    }
    
    function setBananaPrice(uint256 _newPrice) public onlyOwner {
        bananaPrice = _newPrice;
    }

    function setMaxPurchase(uint256 _newMaxPurchase) public onlyOwner {
        maxPurchase = _newMaxPurchase;
    }

    function setMaxBananas(uint256 _newMaxBananas) public onlyOwner {
        MAX_BANANAS = _newMaxBananas;
    }
    
    function setWhitelistAddress(address _address, bool _whitelist) public onlyOwner {
        whitelistAddresses[_address] = _whitelist;
    }
    
    function checkIfClaimed(uint256 _tokenId) public view returns (bool) {
        return _exists(_tokenId);
    }

    function burn(uint256 _tokenId) public {
        require(_isApprovedOrOwner(_msgSender(), _tokenId), ""Caller is not owner nor approved"");
        _burn(_tokenId);
    }
}","Create a Solidity smart contract that manages a banana-based NFT system, featuring whitelist sales and public mints. The contract should include mechanisms for NFT ownership tracking, minting limits, and SuperBanana address management. Ensure that only the owner can pause and resume sales and withdraw funds. Implement functions for checking claimed bananas and burning NFTs"
contract_88.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract AssetTransfer {
    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;

    event Transfer(address indexed sender, address indexed recipient, uint256 amount);
    event Approval(address indexed owner, address indexed spender, uint256 amount);

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }
    
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");
        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }
    
    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}","Create a smart contract that supports asset transfer between addresses. The contract should allow for basic operations like withdraw, balance check, and allowance setting. Include event emitters for key actions like transfer, approve, and transferFrom. Implement necessary error handling for arithmetic operations."
contract_63.sol,"pragma solidity ^0.8.0;

contract Gamble {

    address public owner;
    uint public maxBet; // Maximum Bet Amount
    uint public feePercent; // Percentage Fee
    uint public bankRoll; // Bank Roll

    struct Bet {
        uint amount;
        uint prediction;
        address player;
    }

    mapping(address => Bet) public bets;

    constructor(uint _maxBet, uint _feePercent) {
        require(_maxBet > 0, ""Max Bet should be positive"");
        require(_feePercent > 0 && _feePercent < 100, ""Fee should be between 0 and 100"");

        owner = msg.sender;
        maxBet = _maxBet;
        feePercent = _feePercent;
    }

    modifier onlyOwner {
        require(msg.sender == owner, ""Only owner can perform this action"");
        _;
    }

    function changeSettings(uint _maxBet, uint _feePercent) public onlyOwner {
        maxBet = _maxBet;
        feePercent = _feePercent;
    }

    function addToBankRoll() public payable onlyOwner {
        bankRoll += msg.value;
    }

    function placeBet(uint _prediction) public payable {
        require(msg.value <= maxBet, ""Exceeds maximum bet"");
        require(bankRoll >= msg.value, ""Bankroll is not sufficient for this bet"");

        Bet storage bet = bets[msg.sender];
        bet.amount = msg.value;
        bet.prediction = _prediction;
        bet.player = msg.sender;

        bankRoll -= msg.value;
    }

    function resolveBet(address _player) public onlyOwner {
        Bet storage bet = bets[_player];

        require(bet.amount > 0, ""No active bet for this player"");

        uint outcome = uint(keccak256(abi.encodePacked(block.timestamp, block.number))) % 10;
        if(bet.prediction == outcome) {
            // Player Wins
            uint winnings = bet.amount + (bet.amount * (100 - feePercent) / 100);
            payable(_player).transfer(winnings);
            bankRoll -= winnings;
        } else {
            // House Wins
            bankRoll += bet.amount;
        }

        // Clear the bet
        bets[_player].amount = 0;
        bets[_player].prediction = 0;
    }
}","Create a Solidity smart contract called 'Gamble' that enables users to make predictions on the outcome of a random event. The contract should have variables to store the maximum bet amount, percentage fee, and bank roll. Write functions to update settings, initialize the bank roll, and place bets. Design a system to determine the winner of a bet and award the winnings."
contract_132.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SafeMath {
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}

contract Token is SafeMath {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint public _totalSupply;
 
    mapping(address => uint) balances;
    mapping(address => mapping(address => uint)) allowed;
    mapping(address => bool) public frozenAccount;

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    event Burn(address indexed from, uint256 value);
    event FrozenFunds(address target, bool frozen);

    constructor() {
        name = ""MyToken"";
        symbol = ""MTK"";
        decimals = 18;
        _totalSupply = 600000000000000000000000000000;   // 600 billion tokens
        balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function totalSupply() public view returns (uint) {
        return _totalSupply - balances[address(0)];
    }

    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }

    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }

    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    function transfer(address to, uint tokens) public returns (bool success) {
        require(!frozenAccount[msg.sender]);
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }

    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        require(!frozenAccount[msg.sender]);
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }

    function burn(uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] = SafeMath.safeSub(balances[msg.sender], _value);
        _totalSupply = SafeMath.safeSub(_totalSupply, _value);
        emit Burn(msg.sender, _value);
        return true;
    }

    function freezeAccount(address target, bool freeze) public {
        frozenAccount[target] = freeze;
        emit FrozenFunds(target, freeze);
    }
}","Develop a smart contract that implements a token with a maximum supply of 600 Billion tokens. The token should have a pre-minted balance of 600 Billion tokens. The contract should allow for token transfers between accounts, approve spending of tokens, and enable or disable transfer of frozen accounts. Include a function to burn tokens. Implement safe math operations and ensure proper permissions checks."
contract_94.sol,"pragma solidity ^0.8.0;

abstract contract ERC20Basic {
    uint256 public totalSupply;
    function balanceOf(address who) public view virtual returns (uint256);
    function transfer(address to, uint256 value) public virtual;
    event Transfer(address indexed from, address indexed to, uint256 value);
} 

contract GoldContract is ERC20Basic {
    mapping(address => uint256) balances;

    function transfer(address _to, uint256 _value) public virtual override {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender] - _value;
        balances[_to] = balances[_to] + _value;
        emit Transfer(msg.sender, _to, _value);
    }

    function balanceOf(address _owner) public view virtual override returns (uint256 balance) {
        return balances[_owner];
    }
}

contract CacheContract {
    GoldContract public goldContract;
    mapping(address => uint256) public lockedBalances;

    constructor(GoldContract _goldContract) {
        goldContract = _goldContract;
    }

    function lockGold(uint256 _amount) public {
        require(goldContract.balanceOf(msg.sender) >= _amount, ""Not enough gold to lock"");
        goldContract.transfer(address(this), _amount);
        lockedBalances[msg.sender] += _amount;
    }

    function unlockGold(uint256 _amount) public {
        require(lockedBalances[msg.sender] >= _amount, ""Not enough gold locked"");
        lockedBalances[msg.sender] -= _amount;
        goldContract.transfer(msg.sender, _amount);
    }

    function getLockedBalance(address _owner) public view returns (uint256) {
        return lockedBalances[_owner];
    }
}","Create a smart contract that allows for locking and unlocking of gold, with a cache contract to manage the locked gold and a separate contract for managing the gold, implementing basic token-like functionality with supply, balance, and allowance tracking."
contract_30.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Context {
    function _msgSender() internal view returns (address) {
        return msg.sender;
    }
    
    function _msgData() internal view returns (bytes calldata) {
        return msg.data;
    }
}

abstract contract Ownable is Context {
    address private _owner;
    
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = _msgSender();
        emit OwnershipTransferred(address(0), _owner);
    }
    
    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(_owner == _msgSender(), ""Ownable: caller is not the owner"");
        _;
    }
    
    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract ERC20 is Context, Ownable {
    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;
    
    string private _name;
    string private _symbol;
    
    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }
    
    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);

        uint256 currentAllowance = _allowances[sender][_msgSender()];
        require(currentAllowance >= amount, ""ERC20: transfer amount exceeds allowance"");
        unchecked {
            _approve(sender, _msgSender(), currentAllowance - amount);
        }

        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        uint256 currentAllowance = _allowances[_msgSender()][spender];
        require(currentAllowance >= subtractedValue, ""ERC20: decreased allowance below zero"");
        unchecked {
            _approve(_msgSender(), spender, currentAllowance - subtractedValue);
        }

        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        uint256 senderBalance = _balances[sender];
        require(senderBalance >= amount, ""ERC20: transfer amount exceeds balance"");
        unchecked {
            _balances[sender] = senderBalance - amount;
        }
        _balances[recipient] += amount;

        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) internal {
        require(account != address(0), ""ERC20: burn from the zero address"");

        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, ""ERC20: burn amount exceeds balance"");
        unchecked {
            _balances[account] = accountBalance - amount;
        }
        _totalSupply -= amount;

        emit Transfer(account, address(0), amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
    
    function _setupDecimals(uint8 decimals_) internal {
        _decimals = decimals_;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }
    uint8 private _decimals;
}

contract MyToken is ERC20 {
    constructor(uint256 initialSupply) ERC20(""MyToken"", ""MTK"") {
        _mint(msg.sender, initialSupply);
    }
}","Develop a smart contract that implements an ERC20 token with an owner. The contract should have a name and symbol, and have the ability to transfer tokens. Include a functionality to approve and increase allowance for other accounts. Implement token transfer, approval, and disapproval logic. The contract should be inheritable from OpenZeppelin's ERC20 and Ownable contracts."
contract_229.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

contract NameRegistry {
    mapping(bytes32 => address) public nameToAddress;
    bool public unlocked = true;

    modifier onlyWhenUnlocked() {
        require(unlocked, ""The system is currently locked."");
        _;
    }
    
    function registerName(bytes32 name) public onlyWhenUnlocked {
        require(nameToAddress[name] == address(0), ""This name is already taken."");

        nameToAddress[name] = msg.sender;
    }

    function resolveToAddress(bytes32 name) public view returns (address) {
        require(nameToAddress[name] != address(0), ""This name is not registered."");

        return nameToAddress[name];
    }
    
    function setLock(bool lock) public {
        unlocked = lock;
    }
}",Create a solidity smart contract that allows users to register names in a locked system. The contract should have a boolean variable 'unlocked' that determines whether new name registrations are allowed. The contract should also store name registrations in a mapping structure and allow users to resolve hashes to addresses. Implement a function that allows users to register new names. Make sure the contract is secure and follows best practices.
contract_168.sol,"pragma solidity ^0.8.0;

contract InvestmentPortfolio{

    struct Investor{
        uint time;
        uint balance;
    }

    uint public interestRate = 5;
    mapping(address => Investor) investors;

    function deposit() public payable {
        require(msg.value > 0, ""Invalid amount"");

        // If this is the first time the investor has invested, then initialize them
        if(investors[msg.sender].time == 0){
            investors[msg.sender].time = block.timestamp;
        }

        investors[msg.sender].balance += msg.value;
    }
    
    function estimateReturn() public view returns(uint){
        if(investors[msg.sender].time == 0) return 0;

        uint timeElapsed = block.timestamp - investors[msg.sender].time;

        // Assume interest compounds every second. A more realistic scenario would be to compound annually or monthly
        return investors[msg.sender].balance * (1 + interestRate/100)**timeElapsed - investors[msg.sender].balance;
    }

    function withdraw() public {
        uint amount = investors[msg.sender].balance * (1 + interestRate/100)**(block.timestamp - investors[msg.sender].time);
        require(amount <= address(this).balance, ""Not enough balance in contract"");
        
        investors[msg.sender].time = 0;
        investors[msg.sender].balance = 0;

        payable(msg.sender).transfer(amount);
    }

}","Create a smart contract that allows users to invest in a smart contract-based investment portfolio. The contract should enable users to deposit and withdraw funds, calculate investment returns based on block time, and allow for secure withdrawal of earnings. Focus on implementing the logic and structure for this functionality, without delving into low-level details."
contract_169.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");

        return c;
    }
  
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, ""SafeMath: subtraction overflow"");
    }
  
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }
}

contract ProfitTracker {
    using SafeMath for uint256;

    mapping (address => uint256) private _deposits;
    mapping (address => uint256) private _profits;

    address private _owner;
    address private _F1;
    address private _network;

    constructor() {
        _owner = msg.sender;
    }
  
    modifier onlyOwner(){
        require(msg.sender == _owner, ""Only for contract's owner!"");
        _;
    }
  
    modifier onlyF1(){
        require(msg.sender == _F1, ""Only for F1!"");
        _;
    }
  
    modifier onlyNetwork(){
        require(msg.sender == _network, ""Only for network!"");
        _;
    }
  
    function setF1(address newF1) public onlyOwner {
        _F1 = newF1;
    }
  
    function setNetwork(address newNetwork) public onlyOwner {
        _network = newNetwork;
    }

    function addDeposit(uint256 amount) public {
        require(amount > 0, ""Deposit must be a positive number!"");
        _deposits[msg.sender] = _deposits[msg.sender].add(amount);
    }

    function addF1Deposit(uint256 amount) public onlyF1 {
        require(amount > 0, ""Deposit must be a positive number!"");
        _deposits[msg.sender] = _deposits[msg.sender].add(amount);
    }

    function addNetworkDeposit(uint256 amount) public onlyNetwork {
        require(amount > 0, ""Deposit must be a positive number!"");
        _deposits[msg.sender] = _deposits[msg.sender].add(amount);
    }

    function retrieveDeposits() public view returns (uint256) {
        return _deposits[msg.sender];
    }

    function totalDeposits() public view returns (uint256) {
        uint256 total;
        for (uint256 i = 0; i < _deposits.length; i++) {
            total = total.add(_deposits[i]);
        }
        return total;
    }

    function addProfits(uint256 profit) public onlyOwner {
        require(profit > 0, ""Profit must be a positive number!"");
        _profits[msg.sender] = _profits[msg.sender].add(profit);
    }

    function retrieveProfits() public view returns (uint256) {
        return _profits[msg.sender];
    }

    function totalProfits() public view returns (uint256) {
        uint256 total;
        for (uint256 i = 0; i < _profits.length; i++) {
            total = total.add(_profits[i]);
        }
        return total;
    }
}","Create a Smart Contract that allows users to deposit funds and track their profits. Implement functions to add F1 and network deposits, retrieve deposited amounts, and display overall deposited amounts. Include modifiers to restrict access to certain functions based on user roles. Ensure accurate decimal calculations using the SafeMath library. Focus on simplicity and modularity in the contract structure."
contract_179.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// OpenZeppelin's Pausable contract
abstract contract Pausable {
    event Paused(address account);
    event Unpaused(address account);

    bool private _paused;

    constructor () {
        _paused = false;
    }

    function paused() public view virtual returns (bool) {
        return _paused;
    }

    modifier whenNotPaused() {
        require(!paused(), ""Pausable: paused"");
        _;
    }

    modifier whenPaused() {
        require(paused(), ""Pausable: not paused"");
        _;
    }

    function _pause() internal virtual whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    function _unpause() internal virtual whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}

// OpenZeppelin's Ownable contract
abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract LiquidityRouter is Pausable, Ownable {
    mapping(address => mapping(address => uint256)) public reserves;

    event AddLiquidity(address indexed tokenA, address indexed tokenB, uint256 amount);
    event RemoveLiquidity(address indexed tokenA, address indexed tokenB, uint256 amount);
    event Swap(address indexed tokenIn, address indexed tokenOut, uint256 amountIn, uint256 amountOut);

    // Add liquidity to a token pair
    function addLiquidity(address tokenA, address tokenB, uint256 amount) public whenNotPaused onlyOwner {
        // Update the reserves
        reserves[tokenA][tokenB] += amount;
        reserves[tokenB][tokenA] += amount;
        
        // Emit event
        emit AddLiquidity(tokenA, tokenB, amount);
    }

    // Remove liquidity from a token pair
    function removeLiquidity(address tokenA, address tokenB, uint256 amount) public whenNotPaused onlyOwner {
        // Check the reserves
        require(reserves[tokenA][tokenB] >= amount && reserves[tokenB][tokenA] >= amount, ""Not enough liquidity"");

        // Update the reserves
        reserves[tokenA][tokenB] -= amount;
        reserves[tokenB][tokenA] -= amount;
        
        // Emit event
        emit RemoveLiquidity(tokenA, tokenB, amount);
    }

    // Swap tokens
    function swap(address tokenIn, address tokenOut, uint256 amountIn) public whenNotPaused returns (uint256) {
        // Check the reserves
        require(reserves[tokenIn][tokenOut] >= amountIn, ""Not enough liquidity"");

        // Calculate the amount out using a simple equation (amountIn / reserveIn) * reserveOut
        uint256 amountOut = (amountIn / reserves[tokenIn][tokenOut]) * reserves[tokenOut][tokenIn];

        // Update the reserves
        reserves[tokenIn][tokenOut] -= amountIn;
        reserves[tokenOut][tokenIn] += amountOut;
        
        // Emit event
        emit Swap(tokenIn, tokenOut, amountIn, amountOut);

        return amountOut;
    }

    // Get the amount of tokens out given the amount in
    function getAmountOut(address tokenIn, address tokenOut, uint256 amountIn) public view returns (uint256) {
        // Check the reserves
        require(reserves[tokenIn][tokenOut] >= amountIn, ""Not enough liquidity"");

        // Calculate the amount out using a simple equation (amountIn / reserveIn) * reserveOut
        uint256 amountOut = (amountIn / reserves[tokenIn][tokenOut]) * reserves[tokenOut][tokenIn];

        return amountOut;
    }

    // Pause contract
    function pause() public onlyOwner {
        _pause();
    }

    // Unpause contract
    function unpause() public onlyOwner {
        _unpause();
    }
}","Create a smart contract that defines a router for equalizing liquidity. The contract should have functions for adding and removing liquidity, swapping tokens, and getting the amount of tokens out given the amount in. Implement the logic for these functions, including checks and error handling. Ensure that the contract inherits from OpenZeppelin's Pausable and Ownable contracts."
contract_12.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MerkleVerifier {
    
    function merkleVerify(bytes32 root, bytes32 leaf, bytes32[] memory proof) public pure returns (bool valid) {

        bytes32 computedHash = leaf;

        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];

            if (computedHash < proofElement) {
                // Hash(current computed hash + current element of the proof)
                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));
            } else {
                // Hash(current element of the proof + current computed hash)
                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));
            }
        }

        // Check if the computed hash (root) is equal to the provided root
        return computedHash == root;
    }

    function getRoot(bytes32 leaf, bytes32[] memory proof) public pure returns (bytes32) {
        
        bytes32 computedHash = leaf;

        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];

            if (computedHash < proofElement) {
                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));
            } else {
                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));
            }
        }

        return computedHash;
    }

    function checkConsistency(bytes32 root, bytes32[] memory proof) public view returns (bool) {
        // Check if each proof element is hashed to derive the root
        bytes32 computedHash = root;
        
        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];

            // Check consistency of each proof element
            if (keccak256(abi.encodePacked(proofElement, computedHash)) != root ||
                keccak256(abi.encodePacked(computedHash, proofElement)) != root) {
                return false;
            }
            computedHash = keccak256(abi.encodePacked(proofElement, computedHash));
        }

        return true;
    }

}",Develop a smart contract that verifies the existence or non-existence of a key-value pair in a Merkle tree. The contract should include functions to validate the commitment root and leaf node of the Merkle tree. Implement a way to check against a specification to ensure the internal consistency of the Merkle tree. Your solution should handle common error cases and provide clear documentation of the contract's functionality.
contract_175.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Ownable {
    
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _setOwner(_msgSender());
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(owner() == _msgSender(), ""Ownable: caller is not the owner"");
        _;
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        _owner = newOwner;
    }

    function _msgSender() internal view virtual returns (address payable) {
        return payable(msg.sender);
    }
}","Create a smart contract that allows for ownership management, including the ability to initialize and transfer ownership. The contract should include functions for transferring ownership and retrieving the current owner. Use the provided code as a reference. Modify the code to fit the required functionality and include necessary variables and modifiers."
contract_156.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Operable {
    struct Operation {
        address proposer;
        string description;
        bool executed;
        uint256 timestamp;
    }

    mapping(uint256 => Operation) private operations;
    uint256 public operationIndex;
    uint256 public delayPeriod;

    modifier onlyProposer(uint256 _operationId) {
        require(msg.sender == operations[_operationId].proposer, ""Not operation's proposer"");
        _;
    }

    modifier notExecuted(uint256 _operationId) {
        require(operations[_operationId].executed == false, ""Already executed"");
        _;
    }

    modifier delayed(uint256 _operationId) {
        require(block.timestamp >= operations[_operationId].timestamp + delayPeriod, ""Operation in delay period"");
        _;
    }

    event OperationProposed(uint256 operationId, address proposer, string description);
    event OperationExecuted(uint256 operationId);

    constructor(uint256 _delayPeriod) {
        operationIndex = 1;
        delayPeriod = _delayPeriod;
    }

    function proposeOperation(string memory _description) public returns(uint256) {
        operations[operationIndex] = Operation(msg.sender, _description, false, block.timestamp);
        emit OperationProposed(operationIndex, msg.sender, _description);
        operationIndex += 1;
        return operationIndex - 1;
    }

    function executeOperation(uint256 _operationId) public onlyProposer(_operationId) notExecuted(_operationId) delayed(_operationId) {
        operations[_operationId].executed = true;
        emit OperationExecuted(_operationId);
    }

    function getOperationDetails(uint256 _operationId) public view returns(address, string memory, bool, uint256) {
        return (operations[_operationId].proposer, operations[_operationId].description, operations[_operationId].executed, operations[_operationId].timestamp);
    }
}","Design a smart contract to manage scheduled operations, allowing authorized proposers to submit tasks, tracked by unique identifiers. Implement delay periods, block and execute operations based on timestamp checks."
contract_233.sol,"pragma solidity ^0.8.0;

contract Referral {
    struct User {
        bool isRegistered;
        address referrer;
        uint balance;
    }

    mapping(address => User) public users;
    event Registered(address indexed user, address indexed referrer);
    event Deposited(address indexed user, uint amount);
    event Withdrawn(address indexed user, uint amount);
    
    function register(address referrer) public {
        require(!users[msg.sender].isRegistered, ""User is already registered."");
        require(users[referrer].isRegistered || referrer == address(0), ""Referrer not exists."");
        
        users[msg.sender] = User({
            isRegistered: true,
            referrer: referrer,
            balance: 0
        });

        emit Registered(msg.sender, referrer);
    }
    
    function deposit() public payable {
        require(users[msg.sender].isRegistered, ""User is not registered."");

        users[msg.sender].balance += msg.value;

        emit Deposited(msg.sender, msg.value);
    }

    function withdraw(uint amount) public {
        require(users[msg.sender].balance >= amount, ""Insufficient balance."");

        users[msg.sender].balance -= amount;
        payable(msg.sender).transfer(amount);

        emit Withdrawn(msg.sender, amount);
    }

    function getContractBalance() public view returns (uint) {
        return address(this).balance;
    }
}","Create a Tron-based smart contract that manages user referrals and allows users to deposit and withdraw funds. The contract should include functions for setting up user referral networks, tracking user deposits and withdrawals, and managing the contract balance. The contract should also include event handling for tracking user activities."
contract_170.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

library SafeMath {
    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");

        return c;
    }
    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;

        return c;
    }
}

library NameFilter {
    
    function nameFilter (string calldata _input) internal pure returns (string memory _output) {
        bytes memory _temp = bytes(_input);
        require(_temp.length <= 15, ""Name too long"");
        for(uint i = 0; i<_temp.length; i++) {
            require(_temp[i] >= 'a' && _temp[i] <= 'z', ""Invalid Characters!"");
        }
        return _input;
    }
    
}

contract PlayerContract {

    using SafeMath for uint256;
    struct Player {
        address walletAddress;
        string name;
        uint256 referralCount;
    }

    mapping(address => Player) public players;
    mapping(string => bool) private nameExists;
    
    address public admin;
    uint256 public nameRegistrationFee;

    event PlayerRegistered(address indexed playerAddress, string playerName);

    constructor(uint256 _nameRegistrationFee) {
        require(_nameRegistrationFee > 0, ""Registration fee should be more than 0"");
        admin = msg.sender;
        nameRegistrationFee = _nameRegistrationFee;
    }
    
    modifier onlyAdmin() {
        require(msg.sender == admin, 'Admin access required');
        _;
    }

    function registerPlayer(string calldata _name) external payable {
        require(msg.value == nameRegistrationFee, ""Registration fee required"");
        _name = NameFilter.nameFilter(_name);
        require(!nameExists[_name], ""Name already exists"");
        
        players[msg.sender] = Player(msg.sender, _name, 0);
        nameExists[_name] = true;

        emit PlayerRegistered(msg.sender, _name);
    }

    function increasePlayerReferralCount(address _player) external onlyAdmin {
        players[_player].referralCount = players[_player].referralCount.add(1);
    }

    function updateRegistrationFee(uint256 _newFee) external onlyAdmin {
        nameRegistrationFee = _newFee;
    }

}","Create a smart contract that allows users to register names, track player information, and incentivize affiliate referrals. Ensure the contract includes a fee structure for registering names and validation for preventing duplicates. Include a simple constructor for initializing the contract and basic controls for moderation. Utilize the provided NameFilter and SafeMath libraries for additional functionality. Focus on creating a user-friendly and scalable solution."
contract_235.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract NotDelegateCall {
    address public owner;
    int public tickCumulative;
    uint256 public secondsPerLiquidityCumulative;
    
    modifier onlyOwner {
        require(msg.sender == owner, ""Only owner can call this function."");
        _;
    }

    modifier noDelegateCall {
        require(msg.sender == tx.origin, ""No delegate calls."");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function observe() public view returns (int, uint256) {
        return (tickCumulative, secondsPerLiquidityCumulative);
    }

    function updateTickCum(int _tickCumulative, uint256 _secondsPerLiquidityCumulative) public onlyOwner noDelegateCall {
        tickCumulative = _tickCumulative;
        secondsPerLiquidityCumulative = _secondsPerLiquidityCumulative;
    }
}","Design a smart contract that prevents delegate calls. The contract should have two key functions: observe and updateTickCum. Observe will allow for reading tick cumulative values and seconds per liquidity cumulative values, while updateTickCum will update these values. The contract should also have a constructor to initialize the contract owner, and include modifiers to restrict the owner's updates."
contract_58.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""@openzeppelin/contracts/access/AccessControl.sol"";

// Start of ERC721DAOToken contract
contract ERC721DAOToken is ERC721, Pausable, AccessControl {
    bytes32 public constant PAUSER_ROLE = keccak256(""PAUSER_ROLE"");

    constructor(string memory name, string memory symbol) ERC721(name, symbol) {
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setupRole(PAUSER_ROLE, _msgSender());
    }

    function mint(address to, uint256 tokenId) public virtual {
        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), ""ERC721DAOToken: must have admin role to mint"");
        _mint(to, tokenId);
    }

    function pause() public virtual {
        require(hasRole(PAUSER_ROLE, _msgSender()), ""ERC721DAOToken: must have pauser role to pause"");
        _pause();
    }

    function unpause() public virtual {
        require(hasRole(PAUSER_ROLE, _msgSender()), ""ERC721DAOToken: must have pauser role to unpause"");
        _unpause();
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override {
        super._beforeTokenTransfer(from, to, tokenId);

        require(!paused(), ""ERC721DAOToken: token transfer while paused"");
    }
}
// End of ERC721DAOToken contract

// Start of ERC721Timelock contract
contract ERC721Timelock {
    uint256 public lockTime;
    ERC721DAOToken public token;

    constructor (ERC721DAOToken _token, uint256 _lockTime) {
        token = _token;
        lockTime = _lockTime;
    }

    function lockToken(uint256 _tokenId) public {
        require(token.ownerOf(_tokenId) == msg.sender, ""Not token owner"");

        // Transfer token to this contract
        token.safeTransferFrom(msg.sender, address(this), _tokenId);

        //set locked till timestamp for this token
        lockTime = block.timestamp + lockTime;
    }

    function unlockToken(uint256 _tokenId) public {
        require(token.ownerOf(_tokenId) == msg.sender, ""Not token owner"");
        require(block.timestamp > lockTime, ""Token is still locked"");

        // Transfer token back to owner
        token.safeTransferFrom(address(this), msg.sender, _tokenId);
    }
}
// End of ERC721Timelock contract

// Start of ERC721Governor contract
contract ERC721Governor {
    ERC721DAOToken public token;
    mapping(address => uint) public governors;

    constructor (ERC721DAOToken _token) {
        token = _token;
    }

    function addGovernor(address _newGovernor) public {
        governors[_newGovernor] = 1;
    }

    function removeGovernor(address _governor) public {
        governors[_governor] = 0;
    }

    function mintToken(address _to, uint256 _tokenId) public {
        require(governors[msg.sender] == 1, ""Not a governor"");
        token.mint(_to, _tokenId);
    }
}","Create a Solidity smart contract that enables the deployment and management of ERC721DAOToken, ERC721Timelock, and ERC721Governor contracts, allowing for easy minting, cloning, and initialization of new instances. The contract should provide a basic framework for governance and management of each instance."
contract_150.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TransparentUpgradeableProxy {
    bytes32 private constant _ADMIN_SLOT = 0xb1f109e973300cf66f8b24f15326f30fc6e2e36b7c0e8e02e9c25d9d60584e93;
    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

    event Upgraded(address indexed implementation);

    constructor(address _logic, address admin_) payable {
        assert(_ADMIN_SLOT == keccak256(""eip1967.proxy.admin""));
        assert(_IMPLEMENTATION_SLOT == keccak256(""eip1967.proxy.implementation""));
        _setImplementation(_logic);
        _setAdmin(admin_);
    }

    function _implementation() public view returns (address impl) {
        bytes32 slot = _IMPLEMENTATION_SLOT;
        assembly {
            impl := sload(slot)
        }
    }

    function _admin() public view returns (address admin) {
        bytes32 slot = _ADMIN_SLOT;
        assembly {
            admin := sload(slot)
        }
    }

    function _setImplementation(address newImplementation) internal {
        bytes32 slot = _IMPLEMENTATION_SLOT;

        assembly {
            sstore(slot, newImplementation)
        }
    }

    function _setAdmin(address newAdmin) internal {
        bytes32 slot = _ADMIN_SLOT;

        assembly {
            sstore(slot, newAdmin)
        }
    }

    function upgradeTo(address newImplementation) public {
        require(msg.sender == _admin());
        require(newImplementation != _implementation(), 'Cannot upgrade to the same implementation');
        _setImplementation(newImplementation);
        emit Upgraded(newImplementation);
    }

    function changeAdmin(address newAdmin) public {
        require(msg.sender == _admin());
        require(newAdmin != _admin(), 'New admin is the current admin');
        _setAdmin(newAdmin);
    }
    
    fallback() external payable {
        address _impl = _implementation();
        require(_impl != address(0));

        assembly {
            let ptr := mload(0x40)
            calldatacopy(ptr, 0, calldatasize())
            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)
            let size := returndatasize()
            returndatacopy(ptr, 0, size)

            switch result
            case 0 { revert(ptr, size) }
            default { return(ptr, size) }
        }
    }
}","Develop a smart contract that can upgrade and change the admin address, implementing the TransparentUpgradeableProxy contract. Ensure the contract includes functions for the admin and implementation slots, utilizing the _admin and _implementation functions. Integrate a mechanism for handling errors and provide informative error messages."
contract_228.sol,"pragma solidity ^0.8.0;

interface Comptroller {
    function claimComp(address holder) external;
    function getCompAddress() external view returns (address);
}

contract CompoundCompClaimer {

    // Instance of the Comptroller contract
    Comptroller private comptroller;

    // To keep the address that can claim COMP
    mapping(address => bool) claimers;

    // To emit when a claimer address is added or removed
    event ClaimerAdded(address addr);
    event ClaimerRemoved(address addr);

    constructor(address _comptroller) {
        require(_comptroller != address(0), ""Invalid Comptroller address"");
        comptroller = Comptroller(_comptroller);
    }

    function addClaimer(address claimer) public {
        require(claimer != address(0), ""Invalid claimer address"");
        require(!claimers[claimer],""Address is already a claimer"");
        claimers[claimer] = true;
        emit ClaimerAdded(claimer);
    }

    function removeClaimer(address claimer) public {
        require(claimers[claimer], ""Address is not a claimer"");
        delete claimers[claimer];
        emit ClaimerRemoved(claimer);
    }
    
    function claimCOMP() public {
        require(claimers[msg.sender], ""Not authorized to claim"");
        comptroller.claimComp(msg.sender);
    }
    
    function getCOMPFeeAddress() public view returns (address) {
        return comptroller.getCompAddress();
    }
}",Create a smart contract that utilizes the Compound Comptroller interface to provide functionality for claiming COMP and retrieving the COMPFee address. The contract should ensure that only valid addresses can initiate the claim process and include basic error handling for potential exceptions. The implementation should follow established best practices for Solidity development and utilize the provided SPDX-License-Identifier: GPL-3.0-or-later.
contract_185.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract IERC721Full {

    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _owners;
    mapping(uint256 => string) private _tokenURIs;
    uint256[] private _allTokens;

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    function balanceOf(address owner) public view returns (uint256 balance) {
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) public view returns (address owner) {
        return _owners[tokenId];
    }

    function tokenURI(uint256 tokenId) public view returns (string memory) {
        return _tokenURIs[tokenId];
    }

    function totalSupply() public view returns (uint256) {
        return _allTokens.length;
    }

    function tokenByIndex(uint256 index) public view returns (uint256) {
        require(index < totalSupply());
        return _allTokens[index];
    }
 
    function mint(address to, uint256 tokenId, string memory uri) public {
        require(to != address(0), ""ERC721: mint to the zero address"");
        require(_owners[tokenId] == address(0), ""ERC721: token already minted"");

        _balances[to] += 1;
        _owners[tokenId] = to;
        _tokenURIs[tokenId] = uri;
        _allTokens.push(tokenId);

        emit Transfer(address(0), to, tokenId);
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        require(ownerOf(tokenId) == from, ""ERC721: transfer of token that is not owned"");

        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(from, to, tokenId);
    }

    function transferFrom(address from, address to, uint256 tokenId) public {
        _transfer(from, to, tokenId);
    }
    
    function updateTokenURI(uint256 tokenId, string memory newUri) public {
        require(_owners[tokenId] != address(0), ""ERC721: nonexistent token"");
        _tokenURIs[tokenId] = newUri;
    }
}","Develop a smart contract that follows the IERC721Full standard, allowing for the creation, management, and transfer of unique digital assets. The contract should include functions for token minting, updating, and querying, as well as support for token metadata and enumeration. Consider gas efficiency and error handling in your implementation."
contract_7.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SafeTransferLib { 
    function safeTransferETH(address to, uint256 value) public {
        // Transfer function here
    }
    
    function safeTransferToken(address token, address to, uint256 value) public {
        // Transfer function here
    }
}

contract StandardCReward {
    function setContributorReward(uint256 _reward) external {}
    function getReward(address _contributor) public view returns (uint256) {}
    function transferReward(address _contributor, address to, uint256 value) external {}
}

contract CAdapter {
    function getSpeeds() public view returns (uint256[] memory) {}
    function interact(address _user, bytes memory _data) external {}
}

interface IDivider {
    function divide(uint256 value, uint256 divisor) external pure returns(uint256);
}

interface IAddressBook {
    function getAddress(string memory name) external view returns (address);
}

contract CAdapters {
    CAdapter public cDAI;
    CAdapter public cETH;
    CAdapter public cUSDC;
    IDivider public divider;
    IAddressBook public addressBook;
    StandardCReward public cReward;

    constructor() {
        cDAI = new CAdapter();
        cETH = new CAdapter();
        cUSDC = new CAdapter();
        divider = IDivider(addressBook.getAddress(""IDivider""));
        cReward = new StandardCReward();
    }

    function setContributorReward(uint256 _reward) external {
        cReward.setContributorReward(_reward);
    }

    function getReward(address contribAddress) public view returns(uint256) {
        return cReward.getReward(contribAddress);
    }

    function transferReward(address contribAddress, address to, uint256 value) external {
        cReward.transferReward(contribAddress, to, value);
    }

    function getSpeeds() public view returns (uint256[] memory, uint256[] memory, uint256[] memory) {
        return (cDAI.getSpeeds(), cETH.getSpeeds(), cUSDC.getSpeeds());
    }

    function interact(string memory adapterName, address _user, bytes memory _data) external {
        CAdapter adapter;
        if (compare(adapterName, ""cDAI"")) {
            adapter = cDAI;
        } else if (compare(adapterName, ""cETH"")) {
            adapter = cETH;
        } else if (compare(adapterName, ""cUSDC"")) {
            adapter = cUSDC;
        } else {
            revert(""Invalid adapter name"");
        }
        adapter.interact(_user, _data);
    }

    function compare(string memory a, string memory b) private pure returns(bool) {
        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));
    }
}","Create a smart contract that mirrors the behavior of the provided CAdapterTestHelper contract, focusing on simulating a Compound adapter with three adapters (cDAI, cETH, and cUSDC) and integrating with a token handler, divider, and address book. Include functions for setting contributor rewards, retrieving comp speeds, and interacting with the Compound oracle. Emphasize the importance of ensuring correct transfer of funds using SafeTransferLib. Keep an eye on backwards compatibility."
contract_60.sol,"pragma solidity ^0.8.0;
    
contract Betting {
    
    struct Bet{
        address user;
        uint256 amount;
        bool won;
    }

    mapping(address => Bet[]) public betHistory;
    mapping(address => uint256) public balances;

    uint256 public constant BET_LIMIT = 10 ether;
    uint256 public constant WITHDRAW_LIMIT = 5 ether;

    event Deposit(address indexed user, uint256 amount);
    event BetPlaced(address indexed user, uint256 amount);
    event BetResult(address indexed user, uint256 amount, bool won);
    event Withdrawal(address indexed user, uint256 amount);

    function deposit() public payable {
        require(msg.value > 0, ""Deposit must be more than 0"");
        balances[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }

    function placeBet(uint256 betAmount) public {
        require(betAmount > 0, ""Bet must be more than 0"");
        require(betAmount <= BET_LIMIT, ""Bet amount exceeds limit"");
        require(balances[msg.sender] >= betAmount, ""Insufficient funds"");

        balances[msg.sender] -= betAmount;

        bool won = (block.number % 2 == 0);
        if(won){
            balances[msg.sender] += betAmount * 2;
        }

        Bet memory newBet;
        newBet.user = msg.sender;
        newBet.amount = betAmount;
        newBet.won = won;
        betHistory[msg.sender].push(newBet);

        emit BetPlaced(msg.sender, betAmount);
        emit BetResult(msg.sender, betAmount, won);
    }

    function withdraw(uint256 amount) public {
        require(amount > 0, ""Withdrawal must be more than 0"");
        require(amount <= WITHDRAW_LIMIT, ""Withdrawal amount exceeds limit"");
        require(balances[msg.sender] >= amount, ""Insufficient funds"");

        balances[msg.sender] -= amount;

        payable(msg.sender).transfer(amount);

        emit Withdrawal(msg.sender, amount);
    }

    function getBetHistory(address user) public view returns (Bet[] memory){
        return betHistory[user];
    }
}","Create a smart contract that enables a betting system for users to participate in. The contract should have functions for depositing funds, placing bets, and withdrawing winnings. Include a system for tracking user balances and betting history. Implement event tracking for deposits, bets, and withdrawals. Make sure to enforce withdrawal and betting limits. Don't forget to provide a clear description of the smart contract's functionality and structure."
contract_198.sol,"// SPDX-License-Identifier: MIT

pragma solidity >=0.5.16 <0.9.0;

contract SimpleLiquidity {

    /**
     * @dev Dictionary that maps pairs of tokens to the balance
     *      The balance represents the liquidity pool's total balance
     **/
    mapping(address => mapping(address => uint256)) public poolBalance;

    /**
     * @dev Function that adds liquidity to the pool, for the pair tokenA-tokenB
     * @param tokenA: First token of the pair
     * @param tokenB: Second token of the pair
     * @param amountA: Amount of tokenA to add
     * @param amountB: Amount of tokenB to add
     **/
    function addLiquidity(address tokenA, address tokenB, uint256 amountA, uint256 amountB) public {
        // Here you would need to interact with the token contracts themselves
        // to allow for the transfer of the tokens to the smart contract.
        // Remember, the tokens are not actually 'in' the smart contract, 
        // they are only locked by it. To simplify, I'm just going to increase the balance.

        poolBalance[tokenA][tokenB] += amountA;
        poolBalance[tokenB][tokenA] += amountB;
    }

}","Create a Solidity smart contract that mimics the Uniswap V2 router functionality. The contract should allow for adding and removing liquidity, swapping tokens, and getting quotes. Implement the most important functions such as addLiquidity and removeLiquidity. Consider the router's interaction with the factory contract, managing the pairs and fee management. Focus on robustness and simplicity, making it easy to understand and maintain. Write a brief description and documentation for each function or variable, making it easy for other developers to use the contract."
contract_27.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this;
        return msg.data;
    }
}

contract ERC20 is Context {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;

    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;

    constructor (string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public virtual returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view virtual returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public virtual returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, ""ERC20: transfer amount exceeds allowance""));
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _balances[sender] = _balances[sender].sub(amount, ""ERC20: transfer amount exceeds balance"");
        _balances[recipient] = _balances[recipient].add(amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
    }
}

library SafeMath {
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, errorMessage);

        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");

        return c;
    }

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;

        return c;
    }
}","Create a smart contract that builds upon the OpenZeppelin Context contract and integrates ERC20 token management functionality. The contract should enable token transfer, approval, and balance verification. Implement SafeMath for arithmetic operations and Address library for low-level function calls. Focus on maintainable and readable code structure."
contract_149.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;


/**************************************************
 *  ERC721 Interface
 **************************************************/
contract ERC721 {
    
    mapping (address => uint256) internal _balances;
    mapping (uint256 => address) internal _owners;
    mapping (uint256 => address) internal _tokenApprovals;
    mapping(address => mapping(address => bool)) internal _operatorApprovals;
    
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
    
    function balanceOf(address owner) external view returns (uint256 balance) {
        require(owner != address(0), ""ERC721: balance query for the zero address"");
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) external view returns (address owner) {
        address owner_ = _owners[tokenId];
        require(owner_ != address(0), ""ERC721: owner query for nonexistent token"");
        return owner_;
    }
    
    function approve(address to, uint256 tokenId) external {
        address owner = _owners[tokenId];
        require(to != owner, ""ERC721: approval to current owner"");
        require(msg.sender == owner || _operatorApprovals[owner][msg.sender], ""ERC721: approve caller is not owner nor approved for all"");

        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }
    
    function setApprovalForAll(address operator, bool _approved) external {
        require(operator != msg.sender, ""ERC721: approve to caller"");
        _operatorApprovals[msg.sender][operator] = _approved;
        emit ApprovalForAll(msg.sender, operator, _approved);
    }
    
    function getApproved(uint256 tokenId) external view returns (address operator) {
        require(_exists(tokenId), ""ERC721: approved query for nonexistent token"");
        return _tokenApprovals[tokenId];
    }
    
    function isApprovedForAll(address owner, address operator) external view returns (bool) {
        return _operatorApprovals[owner][operator];
    }
    
    function _exists(uint256 tokenId) internal view returns (bool) {
         return _owners[tokenId] != address(0);
    }
    
    function _mint(address to, uint256 tokenId) internal {
        require(to != address(0), ""ERC721: mint to the zero address"");
        require(!_exists(tokenId), ""ERC721: token already minted"");
        _balances[to] += 1;
        _owners[tokenId] = to;
        emit Transfer(address(0), to, tokenId);
    }
}


/**************************************************
 *  Collection Smart Contract
 **************************************************/
contract NFTCollection is ERC721 {
    
    uint256 public nextTokenId;
    uint256 public timeLimit = block.timestamp + 1 days;
    mapping(address => uint256) public deposit;

    function mint() external {
        require(block.timestamp <= timeLimit, ""Time limit exceeded for minting NFT"");
        _mint(msg.sender, nextTokenId);
        nextTokenId += 1;
    } 
    
    function reroll(uint256 tokenId) external {
        require(block.timestamp <= timeLimit, ""Time limit exceeded for re-rolling NFT"");
        require(ownerOf(tokenId) == msg.sender, ""Caller is not owner of this NFT"");
        _mint(msg.sender, nextTokenId);
        nextTokenId += 1;
    } 

    function depositTokens(uint amount) external {
        deposit[msg.sender] += amount;
    }

    function checkAccessibility(uint256 tokenId) external view returns (bool) {
        if(block.timestamp > timeLimit) {
            return false;
        } else {
            return (_exists(tokenId));
        }
    }
}","Create a smart contract that manages a collection of NFTs. The contract should enable users to mint NFTs, re-roll NFTs, and deposit tokens. Implement functionality for checking the accessibility of tokens within a specific time limit."
contract_192.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

contract AuctionArbitration {

    struct Auction {
        uint auctionId;
        address payable seller;
        uint startTime;
        uint endTime;
        uint highestBid;
        address payable highestBidder;
        bool active;
    }

    struct Arbiter {
        address payable addr;
        bool isArbiter;
    }

    uint public auctionCount;
    mapping(uint => Auction) public auctions;
    mapping(address => Arbiter) public arbiters;

    event AuctionInitiated(uint auctionId, address seller, uint startTime, uint endTime);
    event NewBid(uint auctionId, address bidder, uint bidAmount);
    event AuctionEnded(uint auctionId, address winner, uint winningBid);
    event RewardsAllocated(uint auctionId, address winner, uint winningBid, address arbiter, uint arbiterReward);

    modifier onlyArbiter() {
        require(arbiters[msg.sender].isArbiter == true, ""Must be an arbiter to invoke this function"");
        _;
    }

    modifier auctionExists(uint _auctionId) {
        require(auctions[_auctionId].active == true, ""Auction does not exist"");
        _;
    }

    function initiateAuction(uint _endTime) public returns(uint) {
        auctionCount++;
        auctions[auctionCount] = Auction(auctionCount, payable(msg.sender), block.timestamp, _endTime, 0, payable(address(0)), true);
        emit AuctionInitiated(auctionCount, msg.sender, block.timestamp, _endTime);
        return auctionCount;
    }

    function bid(uint _auctionId) public payable auctionExists(_auctionId){
        require(block.timestamp < auctions[_auctionId].endTime, ""Auction ended already"");
        require(msg.value > auctions[_auctionId].highestBid, ""Bid should be higher than current highest bid"");

        if(auctions[_auctionId].highestBid != 0){
            auctions[_auctionId].highestBidder.transfer(auctions[_auctionId].highestBid);
        }

        auctions[_auctionId].highestBid = msg.value;
        auctions[_auctionId].highestBidder = payable(msg.sender);
        emit NewBid(_auctionId, msg.sender, msg.value);
    }

    function endAuction(uint _auctionId) public onlyArbiter auctionExists(_auctionId) {
        require(block.timestamp >= auctions[_auctionId].endTime, ""Auction is not yet over"");
        auctions[_auctionId].active = false;
        emit AuctionEnded(_auctionId, auctions[_auctionId].highestBidder, auctions[_auctionId].highestBid);
    }

    function allocateRewards(uint _auctionId, uint _arbiterRewardPercentage) public onlyArbiter auctionExists(_auctionId) {
        require(_arbiterRewardPercentage >= 0 && _arbiterRewardPercentage <= 100, ""Invalid arbiter reward percentage"");
        require(auctions[_auctionId].active == false, ""Auction is still active, cannot calculate rewards"");

        uint arbiterReward = (auctions[_auctionId].highestBid * _arbiterRewardPercentage) / 100;
        uint sellerRevenue = auctions[_auctionId].highestBid - arbiterReward;

        auctions[_auctionId].seller.transfer(sellerRevenue);
        arbiters[msg.sender].addr.transfer(arbiterReward);

        emit RewardsAllocated(_auctionId, auctions[_auctionId].highestBidder, auctions[_auctionId].highestBid, msg.sender, arbiterReward);
    }

    function addArbiter(address _arbiterAddress) public {
        require(arbiters[_arbiterAddress].isArbiter == false, ""Address is already an arbiter"");
        arbiters[_arbiterAddress] = Arbiter(payable(_arbiterAddress), true);
    }
}","Develop a smart contract that facilitates a malt arbitration mechanism with auction features. The contract should allow users to initiate auctions, manage commitments, and allocate arbitrage rewards. Ensure efficient gas management. Implement event emissions for key functionality."
contract_19.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

abstract contract Ownable {

    address private _owner;
    
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    
    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }
    
    function owner() public view virtual returns (address) {
        return _owner;
    }
    
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }
    
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }
    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

abstract contract Pausable is Ownable {
    
    event Paused(address account);
    event Unpaused(address account);
    
    bool private _paused;

    constructor() {
        _paused = false;
    }
    
    function paused() public view virtual returns (bool) {
        return _paused;
    }
    
    modifier whenNotPaused() {
        require(!paused(), ""Pausable: paused"");
        _;
    }
    
    modifier whenPaused() {
        require(paused(), ""Pausable: not paused"");
        _;
    }
    
    function pause() public virtual onlyOwner whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }
    
    function unpause() public virtual onlyOwner whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}

contract Payable is Pausable {

    mapping(address => uint256) private _balances;

    event Withdrawn(address indexed payee, uint256 weiAmount);

    function withdraw(address payee) public onlyOwner whenNotPaused {
        uint256 payment = _balances[payee];

        _balances[payee] = 0;

        (bool success, ) = payee.call{value: payment}("""");
        require(success, ""Payable: unable to send value, included transfer failed"");
        
        emit Withdrawn(payee, payment);
    }

    function balanceOf(address payee) public view returns (uint256) {
        return _balances[payee];
    }
    
    receive () external payable {
        _balances[msg.sender] += msg.value;
    }
}","Create a smart contract that allows for ownership transfer, paused state management, and payment withdrawal. The contract should inherit from OpenZeppelin's contracts and provide clear documentation for its functions. The contract should allow the owner to renounce ownership, transfer ownership to another address, and change the paused state. The owner should be able to withdraw payments to a payee address, and the withdrawn value should be deducted from the balance of the contract."
contract_106.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    mapping (address => uint256) public balanceOf;

    function transfer(address _to, uint256 _value) public returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
}

contract StakingContract {
    Token public token;
    mapping(address => uint256) public stakers;
    uint256 public totalStaked;

    event Staked(address indexed user, uint256 amount, uint256 totalAmount);
    event Unstaked(address indexed user, uint256 amount, uint256 totalAmount);

    constructor(address _token) {
        token = Token(_token);
    }

    function stakeTokens(uint256 _amount) public {
        require(_amount > 0, ""Stake amount can't be 0"");
        require(token.transferFrom(msg.sender, address(this), _amount), ""Token transfer was unsuccessful"");
        stakers[msg.sender] += _amount;
        totalStaked += _amount;

        emit Staked(msg.sender, _amount, totalStaked);
    }

    function unstakeTokens(uint256 _amount) public {
        uint256 userStake = stakers[msg.sender];
        require(userStake >= _amount, ""You cannot unstake more tokens than you have staked"");

        stakers[msg.sender] -= _amount;
        totalStaked -= _amount;
        require(token.transfer(msg.sender, _amount), ""Unable to transfer tokens back to staker"");

        emit Unstaked(msg.sender, _amount, totalStaked);
    }

    function stakeOf(address _user) public view returns(uint256) {
        return stakers[_user];
    }

    function totalStakes() public view returns (uint256) {
        return totalStaked;
    }
}","Create a smart contract that allows users to stake and unstake tokens. The contract should keep track of total staked amounts and provide functions for staking, unstaking, and retrieving the total staked amount. Implement arithmetic operations securely using the SafeMath library. Consider the event-driven nature of the provided code snippets, such as the transfer events from IERC20. Ensure the contract is scalable and maintainable."
contract_247.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC721 {
    string private _name;
    string private _symbol;

    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _owners;
    mapping(uint256 => address) private _tokenApprovals;

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function balanceOf(address owner) public view returns (uint256) {
        require(owner != address(0), ""ERC721: balance query for the zero address"");
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) public view returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), ""ERC721: owner query for nonexistent token"");
        return owner;
    }

    function approve(address to, uint256 tokenId) public {
        require(to != _owners[tokenId], ""ERC721: approval to current owner"");
        _tokenApprovals[tokenId] = to;
        emit Approval(_owners[tokenId], to, tokenId);
    }

    function transferFrom(address from, address to, uint256 tokenId) public {
        require(_owners[tokenId] == from, ""ERC721: transfer of token that is not own"");
        require(to != address(0), ""ERC721: transfer to the zero address"");

        _approve(address(0), tokenId);

        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(from, to, tokenId);
    }

    function _mint(address to, uint256 tokenId) internal {
        require(to != address(0), ""ERC721: mint to the zero address"");
        require(_owners[tokenId] == address(0), ""ERC721: token already minted"");

        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(address(0), to, tokenId);
    }

    function _approve(address to, uint256 tokenId) private {
        _tokenApprovals[tokenId] = to;
        emit Approval(_owners[tokenId], to, tokenId);
    }
}","Create a smart contract that manages a collection of unique digital assets, allowing users to buy, sell, and transfer ownership. Include functions for token enumeration, owner lookup, and balance retrieval. Make sure the contract adheres to the IERC721 standard and includes necessary event emitters for token transfer and approval."
contract_97.sol,"pragma solidity ^0.8.0;

contract RewardMarket {
    struct Market {
        bool isListed;
        uint totalSupply;
        uint totalBorrows;
    }

    mapping(address => Market) public markets;
    mapping(address => uint) public accruedRewards;

    bool public isRewardsDistributor;
    bool public isFlywheel;

    constructor(bool _isRewardsDistributor, bool _isFlywheel) {
        isRewardsDistributor = _isRewardsDistributor;
        isFlywheel = _isFlywheel;
    }

    event MarketCreated(address asset, bool isListed);
    event RewardsAccrued(address user, uint amount);

    function addMarket(address asset) public {
        markets[asset] = Market(true, 0, 0);
        emit MarketCreated(asset, true);
    }

    function preSupplierAction(address asset, address supplier, uint amount) public {
        require(markets[asset].isListed == true, ""Market is not listed"");
        markets[asset].totalSupply += amount;
        accruedRewards[supplier] += amount;
        emit RewardsAccrued(supplier, amount);
    }

    function preBorrowerAction(address asset, address borrower, uint amount) public {
        require(markets[asset].isListed == true, ""Market is not listed"");
        markets[asset].totalBorrows += amount;
        accruedRewards[borrower] += amount;
        emit RewardsAccrued(borrower, amount);
    }

    function preTransferAction(address asset, address sender, address recipient, uint amount) public {
        require(markets[asset].isListed == true, ""Market is not listed"");
        accruedRewards[sender] += amount;
        accruedRewards[recipient] += amount;
        emit RewardsAccrued(sender, amount);
        emit RewardsAccrued(recipient, amount);
    }

    function getAccruedRewards(address user) public view returns (uint) {
        return accruedRewards[user];
    }
}","Create a smart contract that handles rewards distribution for suppliers, borrowers, and transactors. The contract should have variables indicating whether it's a rewards distributor and a flywheel. Implement functions for pre-supplier, pre-borrower, and pre-transfer actions to accrue rewards. Add a function to retrieve accrued rewards and another to add new markets for rewards accrual. The contract should allow for reading the current state of markets. Provide a clear and understandable implementation."
contract_190.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MinerEngineerGame {
    event EngineerBought(address indexed buyer, uint256 engineerId);
    event EngineerSold(address indexed seller, uint256 engineerId);
    event BoosterBought(address indexed buyer, uint256 boostId);
    event VirusTypeChanged(address indexed changer, uint256[] types);

    struct Miner {
        uint256 id;
        uint256 miningPower;
    }

    struct Boost {
        uint256 id;
        uint256 powerIncrement;
        uint256 duration;
    }

    mapping(address => Miner) public miners;
    mapping(address => Boost) public boosters;

    uint256 private engineerPrice = 1 ether;
    uint256 private boosterPrice = 0.1 ether;
    uint256[] public virusTypes = [1, 2, 3, 4, 5];
    
    function buyEngineer() public payable {
        require(msg.value >= engineerPrice, ""Insufficient funds to buy engineer."");

        uint256 newId = createMinerId();
        miners[msg.sender] = Miner(newId, 1000);

        emit EngineerBought(msg.sender, newId);
    }

    function sellEngineer() public {
        require(miners[msg.sender].id != 0, ""No engineer to sell."");

        uint256 sellId = miners[msg.sender].id;
        delete miners[msg.sender];

        payable(msg.sender).transfer(engineerPrice);
        emit EngineerSold(msg.sender, sellId);
    }

    function buyBoost() public payable {
        require(msg.value >= boosterPrice, ""Insufficient funds to buy booster."");

        uint256 newId = createBoostId();
        boosters[msg.sender] = Boost(newId, 200, 30 minutes);

        emit BoosterBought(msg.sender, newId);
    }

    // Change allowed virus types
    function changeVirusTypes(uint256[] memory types) public {
        virusTypes = types;
        emit VirusTypeChanged(msg.sender, types);
    }

    function createMinerId() private view returns (uint256) {
        return uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty)));
    }

    function createBoostId() private view returns (uint256) {
          return uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty, msg.sender)));
    }
}","Create a smart contract for a cryptocurrency-based miner engineer game. The contract should allow players to buy and sell engineer characters, buy boosters for mining, and change virus types. The contract should have an interface for mining war games and mini-games. The contract structure should include defining structs for miner and boost data, mapping player information, and implementing functions for buying and selling engineers. Implement the contract functionality by writing Solidity code that mirrors the functionality of the provided code snippet."
contract_9.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

// IERC20 interface
interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract GMTokenUnwrapper {
    mapping(address => uint256) public unwrapTimestamp;
    address public gmTokenAddress;
    bool public isUnwrapEnabled;

    // Implementing reentrancy guards
    uint256 private unlocked = 1;
    modifier lock() {
        require(unlocked == 1, 'GMTokenUnwrapper: REENTRANCY_LOCKED');
        unlocked = 0;
        _;
        unlocked = 1;
    }

    function unwrap(uint256 _amount) external lock {
        require(isUnwrapEnabled, ""GMTokenUnwrapper: The unwrap functionality is currently disabled"");
        require(IERC20(gmTokenAddress).balanceOf(msg.sender) >= _amount, ""GMTokenUnwrapper: You don't have enough tokens to unwrap"");
        require(block.timestamp > calculateMaxUnwrappedAmount(msg.sender), ""GMTokenUnwrapper: Your tokens are still locked"");
        
        IERC20(gmTokenAddress).transfer(msg.sender, _amount);
        unwrapTimestamp[msg.sender] = block.timestamp;
    }

    function toggleUnwrap(bool _value) external {
        isUnwrapEnabled = _value;
    }

    function updateGMTokenAddress(address _newAddress) external {
        gmTokenAddress = _newAddress;
    }

    function calculateMaxUnwrappedAmount(address _user) public view returns (uint256) {
        return unwrapTimestamp[_user] + 1 days;
    }
}","Create a Solidity smart contract that manages the unwrapping of GM tokens. The contract should allow users to unwrap GM tokens after a specified interval. Include functions for unwrapping, setting/unsetting a flag for unlocking/unlocking GM token unwrapping, changing the GM token address, managing the user's unwrap timestamp, and calculating the maximum unwrapped amount. Consider implementing reentrancy protection and utilizing OpenZeppelin libraries. The contract should include mapping data structures and interfaces for addressing and uint256 calculations."
contract_134.sol,"pragma solidity ^0.8.0;

contract AssertTest {
    event Log(string message);
    event Error(string message);

    // A function to be tested
    function add(uint a, uint b) public pure returns (uint) {
        uint c = a + b;
        assert(c >= a); // Test case for successful assertion
        return c;
    }
    
    // A function for testing failed assertion
    function testFailAdd(uint a, uint b) public {
        try add(a, b) {
            emit Log(""Passed"");
        } catch Error(string memory reason) {
            emit Error(reason);
        } catch (bytes memory /*lowLevelData*/) {
            emit Error(""Failed: Fallback errored"");
        }
    }

    // A function for testing successful assertion
    function testPassAdd(uint a, uint b) public {
        try add(a, b) {
            emit Log(""Passed"");
        } catch Error(string memory reason) {
            emit Error(reason);
        } catch (bytes memory /*lowLevelData*/) {
            emit Error(""Passed: Fallback errored"");
        }
    }

    // A function for testing error handling
    function testErrorHandling(uint a, uint b) public {
        try add(a, b) {
            emit Log(""Passed"");
        } catch Error(string memory reason) {
            emit Error(reason);
        } catch (bytes memory /*lowLevelData*/) {
            emit Error(""Passed: Fallback errored"");
        }
    }
}","Write a Solidity contract that includes assertion functions for boolean conditions. The contract should have three test cases: one for a successful assertion, one for a failed assertion, and one that handles errors. Use a specific function to emit logs and handle errors accordingly. Implement unit tests for these assertions, considering error handling and logging."
contract_189.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return payable(msg.sender);
    }
}

contract ERC20 is Context {

    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;
    string private _name;
    string private _symbol;

    function __ERC20_init(string memory name_, string memory symbol_) internal {
        _name = name_;
        _symbol = symbol_;
    }
    
    function name() public view virtual returns (string memory) {
        return _name;
    }

    function symbol() public view virtual returns (string memory) {
        return _symbol;
    }

    function decimals() public view virtual returns (uint8) {
        return 18;
    }
}

contract LendingContract is ERC20 {
    using SafeMath for uint256;

    mapping(address => uint256) public deposits;
    mapping(address => uint256) public borrows;
    uint256 public totalSupply;
    uint256 public totalBorrowed;
    uint256 public interestRate;

    function deposit(uint256 amount) public {
        _balanceOf[msg.sender] = _balanceOf[msg.sender].add(amount);
        totalSupply = totalSupply.add(amount);
    }

    function withdraw(uint256 amount) public {
        require(_balanceOf[msg.sender] >= amount, ""Not enough balance"");
        _balanceOf[msg.sender] = _balanceOf[msg.sender].sub(amount);
        totalSupply = totalSupply.sub(amount);
    }
    
    function borrow(uint256 amount) public {
        require(totalSupply.sub(totalBorrowed) >= amount, ""Not enough tokens in the pool"");
        borrows[msg.sender] = borrows[msg.sender].add(amount);
        totalBorrowed = totalBorrowed.add(amount);
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;

        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;

        return c;
    }
    
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, ""SafeMath: modulo by zero"");

        return a % b;
    }
}","Develop a smart contract that allows users to lend and borrow tokens. The contract should provide functionality for depositing and withdrawing tokens, as well as borrowing and repaying loans. Implement a basic interest rate system and manage borrower and lender relationships. Utilize OpenZeppelin's ERC20 and SafeMath libraries to ensure efficiency and reliability. Include simple logic for handling TryAdd, TrySub, TryMul, TryDiv, and TryMod calculations. Focus on creating a functional and secure contract, with documentation and comments to help others understand the code. Consider implementing mechanisms for borrowers to participate in lending pools and for lenders to earn interest and returns."
contract_158.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ReentrancyGuard {
    uint256 private _guardCounter;

    constructor () {
        _guardCounter = 1;
    }

    modifier nonReentrant() {
        _guardCounter += 1;
        uint256 localCounter = _guardCounter;
        _;
        require(localCounter == _guardCounter, ""Reentrant call"");
    }
}

abstract contract Pausable {
    bool private _paused;

    event Paused(address sender);

    event Unpaused(address sender);

    function _pause() internal {
        _paused = true;
        emit Paused(msg.sender);
    }

    function _unpause() internal {
        _paused = false;
        emit Unpaused(msg.sender);
    }

    modifier whenPaused() {
        require(_paused, ""Pausable: not paused"");
        _;
    }

    modifier whenNotPaused() {
        require(!_paused, ""Pausable: paused"");
        _;
    }
}

abstract contract VolumeControl is Pausable, ReentrancyGuard {
    uint256 private _maxVolume;

    constructor(uint256 maxVolume_) {
        _maxVolume = maxVolume_;
    }

    function _volumeCheck(uint256 amount) internal view {
        require(amount <= _maxVolume, ""VolumeControl: volume exceeded"");
    }

    function setMaxVolume(uint256 maxVolume_) public whenPaused {
        _maxVolume = maxVolume_;
    }

    modifier volumeControlled(uint256 amount) {
        _volumeCheck(amount);
        _;
    }
}

abstract contract DelayedTransfer is ReentrancyGuard {
    struct Transfer {
        address token;
        address recipient;
        uint256 amount;
        uint256 timestamp;
    }

    mapping(address => Transfer) private _pendingTransfers;

    function _delayTransfer(address token, address recipient, uint256 amount, uint256 delay) internal {
        Transfer memory newTransfer;
        newTransfer.token = token;
        newTransfer.recipient = recipient;
        newTransfer.amount = amount;
        newTransfer.timestamp = block.timestamp + delay;
        _pendingTransfers[msg.sender] = newTransfer;
    }

    function executeTransfer(address recipient) public nonReentrant {
        Transfer memory transfer = _pendingTransfers[recipient];
        require(block.timestamp >= transfer.timestamp , ""Transfer not yet due"");
        delete _pendingTransfers[recipient];
        // _transfer(transfer.token, transfer.recipient, transfer.amount); // This should be a function which handles the actual transfer.
    }
}

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
}

interface IWETH {
    function deposit() external payable;
    function withdraw(uint256 amount) external;
    function approve(address spender, uint256 amount) external returns (bool);
}

contract OriginalTokenVault is VolumeControl, DelayedTransfer {
    address private _sigsVerifier;
    mapping (address => uint256) private _balances;

    event Deposited(address indexed depositor, uint256 amount);
    event Withdrawn(address indexed withdrawer, uint256 amount);
    
    constructor(address sigsVerifier_) {
        _sigsVerifier = sigsVerifier_;
    }

    function deposit(address token, uint256 amount) public volumeControlled(amount) whenNotPaused nonReentrant {
        // Transfer tokens to this contract
        IERC20(token).transferFrom(msg.sender, address(this), amount);

        // Update internal balance
        _balances[msg.sender] += amount;

        emit Deposited(msg.sender, amount);
    }

    function withdraw(address token, uint256 amount) public whenNotPaused nonReentrant {
        require(_balances[msg.sender] >= amount, ""Insufficient balance"");

        // Deduct balance
        _balances[msg.sender] -= amount;

        // Schedule token withdrawal
        _delayTransfer(token, msg.sender, amount, 1 days);

        emit Withdrawn(msg.sender, amount);
    }

    function currentBalance(address token) public view returns (uint256) {
        return _balances[token];
    }

}","Design a smart contract for an Original Token Vault that manages token deposits and withdrawals. Incorporate security measures like ReentrancyGuard, Pauser, VolumeControl, and DelayedTransfer. The contract should have functions for depositing and withdrawing tokens, utilizing IERC20 and IWETH interfaces. Implement a constructor for initializing sigsVerifier. Ensure that the contract handles token safety and functionality for deposit and withdrawal events. Focus on the overall structure and functionality of the contract."
contract_161.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SevenToken {
    mapping (address => uint) private _balances;
    address private _owner;

    event Withdrew(address indexed user, uint amount);

    modifier onlyOwner () {
        require(msg.sender == _owner, ""Only owner can call this function."");
        _;
    }

    constructor() {
        _owner = msg.sender;
    }
    
    function deposit() public payable {
        _balances[msg.sender] += msg.value;
    }
    
    function withdraw(uint amount) public {
        require(_balances[msg.sender] >= amount, ""Not enough Ether for withdrawal."");
        _balances[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);
        emit Withdrew(msg.sender, amount);
    }

    function getBalance(address userAddress) public view returns(uint) {
        return _balances[userAddress];
    }

    function getTotalBalance() public view onlyOwner returns(uint) {
        return address(this).balance;
    }

    fallback() external payable {
        deposit();
    }
}",Develop a smart contract called SevenToken that enables users to deposit and withdraw Ether. The contract should keep track of user balances and allow for withdrawals. Include a feature for getting the balance of a specific address and the total balance of the owner. Implement logging for withdrawals and ensure gas fees are correctly handled. Consider potential attacks and include measures to prevent them.
contract_57.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract CollectionManager {
    struct Collection {
        string name;
        address router;
        address budgetManager;
    }

    mapping(string => Collection) public collections;
    mapping(string => string) public chainNames;
    mapping(string => address) public repositories;
    address owner;
    
    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner, ""Only Owner is allowed!"");
        _;
    }

    event CollectionCreated(string name, address router, address budgetManager);
    event RepositorySet(string chainName, address repository);
    event ChainNameSet(string chainName);
    
    function createCollection(string memory name, address router, address budgetManager) public onlyOwner {
        Collection memory newCollection = Collection(name, router, budgetManager);
        collections[name] = newCollection;

        emit CollectionCreated(name, router, budgetManager);
    }

    function setRepository(string memory chainName, address repository) public onlyOwner {
        repositories[chainName] = repository;
        emit RepositorySet(chainName, repository);
    }

    function setChainName(string memory chainName) public onlyOwner {
        chainNames[chainName] = chainName;
        emit ChainNameSet(chainName);
    }

    function depositFunds(string memory name) public payable {
        require(collections[name].router != address(0), ""Collection doesn't exists!"");
        payable(collections[name].budgetManager).transfer(msg.value);
    }

    function receiveOmnichainMessage(string memory chainName, bytes32 _message) public {
        require(repositories[chainName] != address(0), ""Repository doesn't exists!"");
        // you can do additional processing here
    }

    function changeOwner(address newOwner) public onlyOwner {
        owner = newOwner;
    }
}","Create a smart contract that facilitates creating, managing, and withdrawing redirection fees for collections. The contract should allow for setting repositories, routers, and budget managers, as well as chain names, collection creation, and omnichain message receiving. Incorporate ownership management and control for only-owner actions. Define necessary functions and variables within the Solidity contract. Consider compatibility with a blockchain ecosystem."
contract_14.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC165 {
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

abstract contract ERC165 is IERC165 {
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

contract AccessControl is Context, ERC165 {

    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;
    
    mapping (bytes32 => mapping (address => bool)) private _roles;
    
    mapping (bytes32 => bytes32) private _roleAdmins;
    
    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");
    
    modifier onlyRole(bytes32 role) {
        require(hasRole(role, _msgSender()), ""AccessControl: account does not have permission"");
        _;
    }
    
    function hasRole(bytes32 role, address account) public view returns (bool) {
        return _roles[role][account];
    }

    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {
        _grantRole(role, account);
    }
    
    function _setupRole(bytes32 role, address account) internal virtual {
        _grantRole(role, account);
    }
    
    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
        _roleAdmins[role] = adminRole;
    }

    function _grantRole(bytes32 role, address account) private {
        _roles[role][account] = true;
        emit RoleGranted(role, account, _msgSender());
    }
    
    function getRoleAdmin(bytes32 role) public view returns (bytes32) {
        return _roleAdmins[role];
    }
    
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(AccessControl).interfaceId
            || super.supportsInterface(interfaceId);
    }

    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
}

abstract contract ERC721Burnable is AccessControl  {
    function burn(uint256 tokenId) public virtual {
        //solhint-disable-next-line max-line-length
        require(_msgSender() == tokenOwner || hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), ""Must have admin role or token owner can burn"");
        _burn(tokenId);
    }

    function _burn(uint256 tokenId) internal virtual;
}

abstract contract ERC721 is AccessControl, ERC721Burnable {
    using Strings for uint256;

    string private _baseURI;
    mapping(uint256 => string) private _tokenURIs;
    mapping(uint256 => address) private _tokenOwner;

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function _baseURI() internal view virtual returns (string memory) {
        return _baseURI;
    }

    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {
        require(
            _exists(tokenId),
            ""ERC721Metadata: URI query for nonexistent token""
        );

        string memory _tokenURI = _tokenURIs[tokenId];
        string memory base = _baseURI();

        return bytes(base).length > 0 ? string(abi.encodePacked(base, _tokenURI)) : """";
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return _tokenOwner[tokenId] != address(0);
    }

    function _burn(uint256 tokenId) internal virtual override {
        if (bytes(_tokenURIs[tokenId]).length != 0) {
            delete _tokenURIs[tokenId];
        }

        delete _tokenOwner[tokenId];
    }
}

contract RandomApeNFT is ERC721 {

    constructor() ERC721(""RandomApeNFT"", ""APE""){
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setupRole(MINTER_ROLE, _msgSender());
    }

    function mint(address to) public virtual onlyRole(MINTER_ROLE) {
        _mint(to, totalSupply() + 1);
    }

    function _mint(address to, uint256 tokenId) internal virtual {
        require(to != address(0), ""ERC721: mint to the zero address"");
        _tokenOwner[tokenId] = to;
    }

    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {
        _tokenURIs[tokenId] = _tokenURI;
    }

    function setBaseURI(string memory baseURI_) external {
        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), ""Must have admin role to change base URI"");
        _baseURI = baseURI_;
    }
}",Develop a smart contract for Random APE NFTs that enables minting and burning of tokens. Utilize OpenZeppelin's ERC-721 and ERC-721Burnable contracts. Require the MINTER_ROLE for minting. Implement a constructor that initializes the contract and grants the DEFAULT_ADMIN_ROLE and MINTER_ROLE to the contract deployer. Include a function for minting a new token and provide a way to burn tokens. Consider implementing a base URI function to set the prefix for IPFS links. The contract should also support the EIP-165 interface.
contract_117.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

contract AccessControl {
    mapping (address => bool) private _admins;

    event AdminRoleAssigned(address indexed admin);
    event AdminRoleRevoked(address indexed admin);

    modifier onlyAdmin() {
        require(_admins[msg.sender], ""AccessControl: caller is not an admin"");
        _;
    }

    constructor () {
        _assignAdmin(msg.sender);
    }

    function isAdmin(address account) public view returns (bool) {
        return _admins[account];
    }

    function assignAdmin(address account) public onlyAdmin {
        _assignAdmin(account);
    }

    function revokeAdmin(address account) public onlyAdmin {
        _revokeAdmin(account);
    }

    function _assignAdmin(address account) private {
        _admins[account] = true;
        emit AdminRoleAssigned(account);
    }

    function _revokeAdmin(address account) private {
        _admins[account] = false;
        emit AdminRoleRevoked(account);
    }
}

contract ERC721 is AccessControl {

    uint256 private _tokenCounter;
    mapping(uint256 => address) private _tokenOwners;
    mapping(address => uint256) private _ownedTokensCount;
    mapping (uint256 => string) private _tokenURIs;

    event Transfer(address from, address to, uint256 tokenId);
    event TokenURIUpdated(uint256 tokenId, string uri);

    function balanceOf(address owner) public view returns (uint256) {
        return _ownedTokensCount[owner];
    }

    function ownerOf(uint256 tokenId) public view returns (address) {
        return _tokenOwners[tokenId];
    }

    function tokenURI(uint256 tokenId) public view returns (string memory) {
        return _tokenURIs[tokenId];
    }

    function mint(address to) public onlyAdmin {
        _tokenCounter++;
        uint256 newTokenId = _tokenCounter;
        _tokenOwners[newTokenId] = to;
        _ownedTokensCount[to]++;
        emit Transfer(address(0), to, newTokenId);
    }

    function setTokenURI(uint256 tokenId, string memory _tokenURI) public onlyAdmin {
        _tokenURIs[tokenId] = _tokenURI;
        emit TokenURIUpdated(tokenId, _tokenURI);
    }

    function transferFrom(address from, address to, uint256 tokenId) public {
        require(ownerOf(tokenId) == from, ""ERC721: transfer of token that is not own"");
        _transfer(from, to, tokenId);
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        _tokenOwners[tokenId] = to;
        _ownedTokensCount[from]--;
        _ownedTokensCount[to]++;
        emit Transfer(from, to, tokenId);
    }
}","Develop an NFT contract that allows the creation and minting of unique digital assets. The contract should support a role-based access control system and allow certain authorized users to mint new NFTs. Include a way to safely mint new NFTs, increment the token ID counter, and provide the new token ID to the caller. Additionally, consider implementing basic ERC-721 functionality, like token names and descriptions."
contract_49.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20 {
    // Mapping to keep track of each holder's balance
    mapping (address => uint256) private _balances;

    // Mapping to keep track of allocated spending limit from one account to another
    mapping (address => mapping (address => uint256)) private _allowances;

    // The total supply of the token
    uint256 private _totalSupply;

    // Name, symbol and decimals of the token
    string private _name;
    string private _symbol;
    uint8 private _decimals = 18;

    constructor (string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory){
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);
        return true;
    }

    function mint(address account, uint256 amount) public {
        _mint(account, amount);
    }

    function burn(address account, uint256 amount) public {
        _burn(account, amount);
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal {
        require(account != address(0), ""ERC20: mint to the zero address"");
        
        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) internal {
        require(account != address(0), ""ERC20: burn from the zero address"");

        _balances[account] -= amount;
        _totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    // Events to make transactions observable
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

}","Create a basic ERC20 token contract that allows users to mint, burn, and transfer tokens. Implement the necessary functions, including totalSupply, balanceOf, transfer, approve, and transferFrom. Also, consider adding other relevant functions such as increaseAllowance, decreaseAllowance, _transfer, and any other necessary methods"
contract_174.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(_owner == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

interface IOracle {
    function consult(address token, uint amountIn) external view returns (uint amountOut);
}

interface IMasonry {
    function distributeSeigniorage(uint256 amount) external;
    function delegateBonds(address to, uint256 amount) external;
}

contract Treasury is Ownable {

    IMasonry public masonry;
    IOracle public oracle;
    address public piggyAddress;
    uint256 public lastestPrice;

    constructor(address masonryAddress, address oracleAddress, address piggy) {
        masonry = IMasonry(masonryAddress);
        oracle = IOracle(oracleAddress);
        piggyAddress = piggy;
    }

    function setMasonry(address masonryAddress) public onlyOwner {
        masonry = IMasonry(masonryAddress);
    }

    function setOperator(address oracleAddress) public onlyOwner {
        oracle = IOracle(oracleAddress);;
    }
  
    function updatePiggyAddress(address piggy) public onlyOwner {
        piggyAddress = piggy;
    }

    function distributeSeigniorage(uint256 amount) public onlyOwner {
        masonry.distributeSeigniorage(amount);
    }

    function delegateBonds(address to, uint256 amount) public onlyOwner {
        masonry.delegateBonds(to, amount);
    }

    function getPiggyPrice() public returns (uint256) {
        lastestPrice = oracle.consult(piggyAddress, 1e18);
        return lastestPrice;
    }
}","Create a Solidity smart contract that manages the Treasury's PIGGY token supply, delegation of bonds, and seigniorage distribution. Implement functions for initializing the contract, setting operator roles, and interacting with Oracle and Masonry interfaces for PIGGY prices and supply management. Remember to handle edge cases and implement logical error checking for contract reliability."
contract_112.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

abstract contract IERC20 {
    function totalSupply() public virtual view returns (uint256);
    function balanceOf(address account) public virtual view returns (uint256);
    function transfer(address recipient, uint256 amount) public virtual returns (bool);
    function allowance(address owner, address spender) public virtual view returns (uint256);
    function approve(address spender, uint256 amount) public virtual returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract Token is IERC20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    address public owner;
    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;
    mapping (address => bool) private _isExcludedFromFee;
    
    uint256 private _totalSupply;
    uint256 public feePercent;
    
    modifier onlyOwner() {
        require(owner == msg.sender, ""You are not the owner"");
        _;
    }
    
    constructor (string memory name_, string memory symbol_, uint8 decimals_, uint256 totalSupply_) {
        _name = name_;
        _symbol = symbol_;
        _decimals = decimals_;
        _totalSupply = totalSupply_;
        _balances[msg.sender] = _totalSupply;
        
        owner = msg.sender;
        feePercent = 3;
    }
    
    function name() public view virtual returns (string memory) {
        return _name;
    }
    
    function symbol() public view virtual returns (string memory) {
        return _symbol;
    }
    
    function decimals() public view virtual returns (uint8) {
        return _decimals;
    }
    
    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }
    
    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }
    
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }
    
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }
    
    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }
    
    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        uint256 currentAllowance = _allowances[sender][msg.sender];
        require(currentAllowance >= amount, ""Transfer amount exceeds allowance"");
        _transfer(sender, recipient, amount);
        
        _approve(sender, msg.sender, currentAllowance - amount);
        return true;
    }
    
    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""Transfer from the zero address is not allowed"");
        require(recipient != address(0), ""Transfer to the zero address is not allowed"");
        require(_balances[sender] >= amount, ""Transfer amount exceeds balance"");
        
        uint256 fee = 0;
        if(_isExcludedFromFee[sender] == false) {
            fee = amount * feePercent / 100;
            _balances[owner] += fee;
        }
        
        _balances[sender] -= amount;
        _balances[recipient] += amount - fee;
        
        emit Transfer(sender, recipient, amount - fee);
    }
    
    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""Approve from the zero address"");
        require(spender != address(0), ""Approve to the zero address"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
    
    function setFeePercent(uint256 feePercent_) public onlyOwner returns (bool) {
        feePercent = feePercent_;
        return true;
    }
    
    function excludeFromFee(address account, bool excluded) public onlyOwner returns (bool) {
        _isExcludedFromFee[account] = excluded;
        return true;
    }
}","Create a token contract that builds upon the ERC20 standard and integrates with the IDEXRouter. The token should have a name, symbol, and decimal places. Implement functions to transfer tokens, set allowances, and get token balances. The contract should also have an owner and a modifier to restrict certain functions. Include a fee structure and a way to exclude certain addresses from fees."
contract_152.sol,"pragma solidity ^0.8.0;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

abstract contract ERC20Basic is Context {
    function totalSupply() public view virtual returns (uint256);
    function balanceOf(address who) public view virtual returns (uint256);
    function transfer(address to, uint256 value) public virtual returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
}

abstract contract ERC20 is ERC20Basic {
    function allowance(address owner, address spender) public view virtual returns (uint256);
    function transferFrom(address from, address to, uint256 value) public virtual returns (bool);
    function approve(address spender, uint256 value) public virtual returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface TokenRecipient { 
    function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external; 
}

contract UpgradableToken is Context, ERC20 {
    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowed;
    uint256 private _totalSupply;
    
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    address public newContractAddress;

    event Deprecate(address newAddress);

    constructor(string memory tokenName, string memory tokenSymbol){
        name = tokenName;
        symbol = tokenSymbol;
        _totalSupply = 1000000000 * 10 ** uint256(decimals);
        _balances[_msgSender()] = _totalSupply;
    }
    
    function deprecate(address _newContractAddress) public {
        newContractAddress = _newContractAddress;
        emit Deprecate(_newContractAddress);
    }
    
    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _balances[_msgSender()] -= amount;
        _balances[recipient] += amount;
        emit Transfer(_msgSender(), recipient, amount);

        return true;
    }
    
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        _allowed[sender][_msgSender()] -= amount;

        _balances[sender] -= amount;
        _balances[recipient] += amount;

        emit Transfer(sender, recipient, amount);

        return true;
    }

    function approve(address spender, uint256 value) public virtual override returns (bool) {
        _allowed[_msgSender()][spender] = value;
        emit Approval(_msgSender(), spender, value);
        return true;
    }

    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowed[owner][spender];
    }
    
    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {
        TokenRecipient spender = TokenRecipient(_spender);
        approve(_spender, _value);
        spender.receiveApproval(_msgSender(), _value, address(this), _extraData);
        return true;
    }
}","Create a smart contract for a token that can be upgraded to a newer version. The contract should be able to transition to a new address and continue functioning. Implement functions for standard ERC20 operations, such as transferring tokens and checking balances. Include a mechanism for handling deprecation and redirection to the newer contract. Focus on ensuring the contract's continuity and compatibility with the upgraded version."
contract_48.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// IERC20 is a contract interface for ERC20 standard
interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

// Rewards contract
contract StakingRewards {

    // Token details
    struct Token {
        IERC20 token;
        uint256 rewardRate;
        uint256 lastUpdateTime;
        uint256 rewardPerTokenStored;
    }

    // Reward Details
    struct Reward {
        uint256 userRewardPerTokenPaid;
        uint256 rewards;
    }

    // Staked tokens by users
    mapping (address => mapping (IERC20 => uint256)) public userStakes;

    // Rewards by tokens and users
    mapping (IERC20 => mapping (address => Reward)) public userRewards;

    // Mapping of token addresses to their details
    mapping(IERC20 => Token) public tokens;

    //Reward tokens
    IERC20 rewardToken;

    // Total stakes of a token
    mapping(IERC20 => uint256) public totalStakes;

    constructor(IERC20 _rewardToken) {
        rewardToken = _rewardToken;
    }

    // Add a new token to track
    function addToken(IERC20 _token, uint256 _rewardRate) public {
        require(address(_token) != address(0), ""zero address"");
        Token storage token = tokens[_token];
        require(address(token.token) == address(0), ""token already added"");

        tokens[_token] = Token({
            token: _token,
            rewardRate: _rewardRate,
            lastUpdateTime: block.timestamp,
            rewardPerTokenStored: 0
        });
    }

    // Return earned rewards of a user for a specific token
    function earned(IERC20 _token, address _account) public view returns (uint256) {
        Token storage token = tokens[_token];
        uint256 rewardPerToken = rewardPerToken(_token);
        uint256 stake = userStakes[_account][_token];
        Reward storage reward = userRewards[_token][_account];
        return (stake * (rewardPerToken-reward.userRewardPerTokenPaid)/1e18) + reward.rewards;
    }

    // Return reward per token for a specific token
    function rewardPerToken(IERC20 _token) public view returns (uint256) {
        Token storage token = tokens[_token];
        if (totalStakes[_token] == 0) {
            return token.rewardPerTokenStored;
        }
        return token.rewardPerTokenStored + ((block.timestamp - token.lastUpdateTime) * token.rewardRate * 1e18 / totalStakes[_token]);
    }

    // Stake a certain ""_amount"" of a specific ""_token""
    function stake(IERC20 _token, uint256 _amount) public {
        updateReward(_token, msg.sender);  // Update user reward
        totalStakes[_token] += _amount;
        userStakes[msg.sender][_token] += _amount;
        require(_token.transferFrom(msg.sender, address(this), _amount), ""transfer failed"");  // Transfer tokens to this contract
    }

    // Withdraw a certain ""_amount"" of a specific ""_token""
    function withdraw(IERC20 _token, uint256 _amount) public {
        updateReward(_token, msg.sender);  // Update user reward
        totalStakes[_token] -= _amount;
        userStakes[msg.sender][_token] -= _amount;
        require(_token.transfer(msg.sender, _amount), ""transfer failed"");  // Transfer tokens back to user
    }

    // Claim rewards of a specific token
    function getReward(IERC20 _token) public {
        updateReward(_token, msg.sender); // Update user reward
        uint256 reward = userRewards[_token][msg.sender].rewards;
        if (reward > 0) {
            userRewards[_token][msg.sender].rewards = 0;
            require(rewardToken.transfer(msg.sender, reward), ""transfer failed"");  // Transfer reward tokens to user
        }
    }

    // Update reward for a specific token and user
    function updateReward(IERC20 _token, address _account) internal {
        Token storage token = tokens[_token];
        token.rewardPerTokenStored = rewardPerToken(_token);
        token.lastUpdateTime = block.timestamp;
        if (_account != address(0)) {
            userRewards[_token][_account].rewards = earned(_token, _account);
            userRewards[_token][_account].userRewardPerTokenPaid = token.rewardPerTokenStored;
        }
    }
}","Create a smart contract that allows users to stake tokens and earn rewards. The contract should have the ability to mint new tokens, track user balances, and distribute rewards. The contract should also be able to handle multiple external tokens and store and track user rewards for each token. The contract should also have functions to get the last time rewards were distributed, get the reward rate, and get the reward for a specific duration."
contract_25.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.2;

contract StandardToken {
    mapping (address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowed;
    uint256 public totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < uint256(-1)) {
            allowed[_from][msg.sender] -= _value;
        }
        emit Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}

contract BurnableUpgradeableToken is StandardToken {
    event Burn(address indexed burner, uint256 value);
    event Upgrade(address indexed to, uint256 value);

    address public upgradeTarget;
    mapping(address => bool) public upgraded;

    function burn(uint256 _value) public {
        require(_value <= balances[msg.sender]);
        balances[msg.sender] -= _value;
        totalSupply -= _value;
        emit Burn(msg.sender, _value);
    }

    function setUpgradeTarget(address _target) public {
        upgradeTarget = _target;
    }

    function upgrade(uint256 _value) public {
        require(upgradeTarget != address(0));
        require(!upgraded[msg.sender]);
        require(_value <= balances[msg.sender]);
        
        balances[msg.sender] -= _value;
        totalSupply -= _value;

        upgraded[msg.sender] = true;
        balances[upgradeTarget] += _value;
        totalSupply += _value;
        
        emit Upgrade(upgradeTarget, _value);
    }
}",Create a smart contract that allows for token burning and upgrading. The contract should inherit from the StandardToken contract and include functions to modify the total supply and balance of addresses. It should also include functions to approve and add allowance for specific spenders. The contract should emit events to track these actions. Focus on implementing the necessary logic for token burning and upgrading without overcomplicating the contract with unnecessary features.
contract_239.sol,"pragma solidity ^0.8.0;

contract NounsDAO {
    struct Proposal {
        address proposer;
        string description;
        uint256 amount;
        bool executed;
    }

    uint256 public proposalCount;
    mapping(uint256 => Proposal) public proposals;
    mapping(address => uint256) public balances;
    mapping(uint256 => mapping(address => bool)) public votes;
    mapping(uint256 => uint256) public totalVotes;

    function propose(string memory description, uint256 amount) public {
        Proposal memory newProposal = Proposal({
            proposer: msg.sender,
            description: description,
            amount: amount,
            executed: false
        });

        proposals[proposalCount] = newProposal;
        proposalCount += 1;
    }

    function vote(uint256 proposalId) public {
        require(proposalId < proposalCount, ""Invalid proposalId"");
        Proposal storage proposal = proposals[proposalId];
        require(proposal.executed == false, ""Proposal already executed"");

        require(!votes[proposalId][msg.sender], ""You already voted for this proposal"");
        votes[proposalId][msg.sender] = true;
        totalVotes[proposalId] += balances[msg.sender];
    }

    function execute(uint256 proposalId) public {
        require(proposalId < proposalCount, ""Invalid proposalId"");
        Proposal storage proposal = proposals[proposalId];
        require(proposal.executed == false, ""Proposal already executed"");

        proposal.executed = true;

        payable(proposal.proposer).transfer(proposal.amount);
    }

    function depositEther() public payable {
        require(msg.value > 0, ""Please send some ether"");
        balances[msg.sender] += msg.value;
    }

    function randomNumberGenerator() public view returns (uint256) {
        return uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty)));
    }
}","Create a Solidity smart contract that allows for governance and treasury management in the Nouns DAO, including logic for proposing, voting, and executing proposals, as well as managing the treasury and random number generation."
contract_151.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface ERC20Interface {
    function transferFrom(address src, address dst, uint amount) external returns (bool);
    function approve(address dst, uint amount) external returns (bool);
}

interface RegistryInterface {
    function wallets(address) external view returns (address);
    function isOwner(address, address) external view returns (bool);
}

interface CTokenInterface {
    function mint(uint mintAmount) external returns (uint);
    function redeem(uint redeemTokens) external returns (uint);
    function borrow(uint borrowAmount) external returns (uint);
    function repayBorrow(uint repayAmount) external returns (uint);
}

contract DAILoan {
    address public admin;
    RegistryInterface public registry;
    CTokenInterface public cToken;
    ERC20Interface public daiToken;
    
    modifier onlyAdmin {
        require(msg.sender == admin, ""Caller is not the admin"");
        _;
    }

    modifier onlyOwner(address wallet) {
        require(registry.isOwner(msg.sender, wallet), ""Caller is not the wallet owner"");
        _;
    }
    
    constructor(address _registry, address _cToken, address _daiToken) {
        admin = msg.sender;
        registry = RegistryInterface(_registry);
        cToken = CTokenInterface(_cToken);
        daiToken = ERC20Interface(_daiToken);
    }
    
    function deposit(address wallet, uint amount) external onlyOwner(wallet) {
        require(daiToken.transferFrom(msg.sender, address(this), amount), ""Transfer failed"");
        daiToken.approve(address(cToken), amount);
        require(cToken.mint(amount) == 0, ""Deposit failed"");
    }

    function withdraw(address wallet, uint amount) external onlyOwner(wallet) {
        require(cToken.redeem(amount) == 0, ""Withdraw failed"");
        require(daiToken.transfer(wallet, amount), ""Transfer failed"");
    }
    
    function borrow(address wallet, uint amount) external onlyOwner(wallet) {
        require(cToken.borrow(amount) == 0, ""Borrow failed"");
        require(daiToken.transfer(wallet, amount), ""Transfer failed"");
    }
    
    function repay(address wallet, uint amount) external onlyOwner(wallet) {
        require(daiToken.transferFrom(msg.sender, address(this), amount), ""Transfer failed"");
        daiToken.approve(address(cToken), amount);
        require(cToken.repayBorrow(amount) == 0, ""Repayment failed"");
    }

    function transferOwnership(address newAdmin) external onlyAdmin {
        admin = newAdmin;
    }
}","Create a smart contract that enables users to deposit, withdraw, and borrow DAI. The contract should interact with the RegistryInterface to get user wallets and check if the user is the owner of the wallet. Implement functions to mint, repay, and redeem DAI using the CTokenInterface. Include functions for ERC20 transfers and approvals. Structure the contract to include modifiers for user authentication and administration."
contract_40.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    uint256 public totalSupply = 10000 * (10 ** 18);
    string public name = ""SimpleToken"";
    string public symbol = ""SIM"";
    uint8 public decimals = 18;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address _to, uint256 _value) external returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) external returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {
        require(_value <= balanceOf[_from], ""Insufficient balance"");
        require(_value <= allowance[_from][msg.sender], ""Insufficient allowance"");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }
}","Create a smart contract that outlines a token transfer process, allowing users to approve and withdraw tokens. The contract should include functions for checking token balances, approving transfers, and transferring tokens. Incorporate event emitting for transactions. Implement a basic security measure to prevent unauthorized transactions."
contract_243.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract IBEP20Token {
    string public constant name = ""IBEP20 Token"";
    string public constant symbol = ""IB20"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply = 1000000000000000000000000000000; // 100 trillion tokens

    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;

    constructor() {
        balances[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);
    event Transfer(address indexed from, address indexed to, uint256 tokens);

    function transferOwnership(address newOwner) public onlyOwner {
        owner = newOwner;
    }

    function balanceOf(address tokenOwner) public view returns (uint256 balance) {
        return balances[tokenOwner];
    }

    function transfer(address to, uint256 tokens) public returns (bool success) {
        require(balances[msg.sender] >= tokens, ""Not enough tokens"");
        balances[msg.sender] -= tokens;
        balances[to] += tokens;
        emit Transfer(msg.sender, to, tokens);
        return true;
    }

    function approve(address spender, uint256 tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    function allowance(address tokenOwner, address spender) public view returns (uint256 remaining) {
        return allowed[tokenOwner][spender];
    }

    function transferFrom(address from, address to, uint256 tokens) public returns (bool success) {
        require(tokens <= balances[from], ""Not enough tokens"");
        require(tokens <= allowed[from][msg.sender], ""Not enough allowance"");

        balances[from] -= tokens;
        allowed[from][msg.sender] -= tokens;
        balances[to] += tokens;
        emit Transfer(from, to, tokens);
        return true;
    }

    address public owner = msg.sender;
    modifier onlyOwner() {
        require(msg.sender == owner, ""You are not the owner"");
        _;
    }
}","Write a smart contract that adheres to the IBEP20 standard. The contract should have a total supply of 100 trillion and the owner being the address that deploys the contract. Include functions to get the owner, decimals, symbol, and name of the token. Implement functionality for users to transfer tokens and approve or transfer tokens on behalf of others. Make sure to emit events when necessary."
contract_79.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;
    uint256 private _totalSupply;
    string private _name;
    string private _symbol;

    constructor (string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public virtual returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }
    
    function allowance(address owner, address spender) public view virtual returns (uint256) {
        return _allowances[owner][spender];
    }
    
    function approve(address spender, uint256 amount) public virtual returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }
    
    function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool) {
        _transfer(sender, recipient, amount);
        uint256 currentAllowance = _allowances[sender][msg.sender];
        require(currentAllowance >= amount, ""ERC20: transfer amount exceeds allowance"");
        _approve(sender, msg.sender, currentAllowance - amount);
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        uint256 senderBalance = _balances[sender];
        require(senderBalance >= amount, ""ERC20: transfer amount exceeds balance"");
        _balances[sender] = senderBalance - amount;
        _balances[recipient] += amount;

        emit Transfer(sender, recipient, amount);
    }
  
    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}","Create a smart contract that manages a digital currency, allowing users to transfer funds and approve addresses to spend tokens. The contract should keep track of token balances and support operations such as transferring funds, approving other addresses, and retrieving the remaining allowance."
contract_18.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract RoleBasedAccessControl is AccessControl {

    bytes32 public constant USER_ROLE = keccak256(""USER_ROLE"");
    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");

    event RoleChanged(address indexed user, bytes32 indexed role, string action);

    constructor() {
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function grantRole(bytes32 role, address account) public {
        require(hasRole(ADMIN_ROLE, msg.sender), ""Caller is not an administrator"");
        _grantRole(role, account);
        emit RoleChanged(account, role, ""granted"");
    }

    function revokeRole(bytes32 role, address account) public {
        require(hasRole(ADMIN_ROLE, msg.sender), ""Caller is not an administrator"");
        _revokeRole(role, account);
        emit RoleChanged(account, role, ""revoked"");
    }

    function checkUserRole(address account) public view returns (bool) {
        return hasRole(USER_ROLE, account);
    }

    function checkAdminRole(address account) public view returns (bool) {
        return hasRole(ADMIN_ROLE, account);
    }

    function setupAdminRole(address account) public {
        require(hasRole(ADMIN_ROLE, msg.sender), ""Caller is not an administrator"");
        _setupRole(ADMIN_ROLE, account);
    }
}","Create a smart contract that integrates a role-based access control system for a decentralized application. The contract should include functions for verifying user memberships, granting and revoking permissions, and getting the administration role. Ensure the contract emits events for role changes and implements a mechanism for setting admin roles. Focus on the high-level structure and functionality of the contract."
contract_178.sol,"pragma solidity ^0.8.0;

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""Addition overflow"");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
      require(b <= a, ""Subtraction underflow"");
      uint256 c = a - b;

      return c;
    }
}

library Address {
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}

contract BasicMath {
    using SafeMath for uint256;

    function addNumber(uint256 a, uint256 b) public pure returns (uint256) {
        return a.add(b);
    }

    function subNumber(uint256 a, uint256 b) public pure returns (uint256) {
        return a.sub(b);
    }
}

contract TimeBoundToken {
    using SafeMath for uint256;
    using Address for address;

    mapping(address => uint256) balances;
    mapping(address => mapping (address => uint256)) _allowances;
  
    event Transfer(address indexed sender, address indexed recipient, uint256 amount);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");
        require(balances[sender] >= amount, ""ERC20: transfer amount exceeds balance"");

        balances[sender] = balances[sender].sub(amount);
        balances[recipient] = balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
}",Create a smart contract that performs basic arithmetic operations and token transfers. The contract should include libraries for safe arithmetic operations and address handling. Ensure that the contract handles overflow and underflow conditions. Implement the contract using Solidity and include descriptions of the functions and variables used.
contract_76.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;
    
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}


contract AssetValuation is Ownable {
    struct Asset {
        uint256 unitPrice;
        uint256 quantity;
    }

    mapping (address => Asset) private assets;

    function setAsset(address assetAddress, uint256 unitPrice, uint256 quantity) public onlyOwner {
        assets[assetAddress] = Asset(unitPrice, quantity);
    }

    function viewAsset(address assetAddress) public view returns (uint256 unitPrice, uint256 quantity) {
        return (assets[assetAddress].unitPrice, assets[assetAddress].quantity);
    }

    function calculateAssetValue(address assetAddress) public view returns (uint256) {
        Asset memory asset = assets[assetAddress];
        return asset.unitPrice * asset.quantity;
    }
}",Create a smart contract that builds upon OpenZeppelin's Ownable contract and adds a function to calculate the total value of a given asset. Use the provided formula to ensure accurate calculations. The contract should only allow the owner to transfer ownership and access specific functions. Implement smart contract best practices and include relevant error handling and debugging mechanisms.
contract_126.sol,"pragma solidity ^0.8.0;

contract WorldID {

    struct User {
        string worldID;
        string uniqueID;
    }

    mapping(string => string) internal proofs;
    mapping(string => User) internal users;

    // Emitted when a user is registered
    event UserRegistered(string worldID, string uniqueID);
    // Emitted when a proof is validated
    event ProofValidated(string worldID, string uniqueID, string hash);

    function registerUser(string memory worldID, string memory uniqueID) public {
        require(bytes(users[worldID].worldID).length == 0, ""World ID is already in use"");
        require(bytes(users[uniqueID].uniqueID).length == 0, ""Unique ID is already in use"");

        users[worldID] = User(worldID, uniqueID);

        emit UserRegistered(worldID, uniqueID);
    }

    function storeHash(string memory worldID, string memory hash) public {
        require(bytes(users[worldID].worldID).length != 0, ""User is not registered"");

        proofs[worldID] = hash;
    }

    function verifyProof(string memory worldID, string memory hash) public {
        require(bytes(users[worldID].worldID).length != 0, ""User is not registered"");
        require(keccak256(abi.encodePacked(proofs[worldID])) == keccak256(abi.encodePacked(hash)), ""Hash doesn't match"");

        // Implement specific logic here when a proof is verified

        emit ProofValidated(worldID, users[worldID].uniqueID, hash);
    }

}","Create a smart contract that verifies identities using World ID and provides a unique identifier for each user. The contract should include functions for verifying proofs, storing hashes, and executing specific logic when a proof is verified. Implement the contract with clear documentation of variables, functions, and logic."
contract_135.sol,"pragma solidity ^0.8.0;

contract Set {
    struct set {
        mapping(bytes32 => uint) index;
        bytes32[] values;
    }
    
    set private mySet;
    
    function insert(bytes32 value) public returns (bool success) {
        if (isInSet(value)) {
            return false;
        } else {
            mySet.values.push(value);
            mySet.index[value] = mySet.values.length;
            return true;
        }
    }
    
    function remove(bytes32 value) public returns (bool success) {
        if (isInSet(value)) {
            mySet.values[mySet.index[value]-1] = mySet.values[mySet.values.length-1];
            mySet.values.pop();
            delete mySet.index[value];
            return true;
        } else {
            return false;
        }
    }
    
    function isInSet(bytes32 value) public view returns (bool success) {
        if (mySet.index[value] > 0) {
            return true;
        } else {
            return false;
        }
    }
    
    function length() public view returns (uint setLength) {
        return mySet.values.length;
    }
    
    function getValueAt(uint index) public view returns (bytes32 value) {
        return mySet.values[index];
    }
    
    function sort() public {
        uint length = mySet.values.length;
        for(uint i = 0; i < length; i++) {
            for(uint j = 0; j < length-i-1; j++) {
                if(uint(mySet.values[j]) > uint(mySet.values[j+1])) {
                    bytes32 temp = mySet.values[j];
                    mySet.values[j] = mySet.values[j+1];
                    mySet.values[j+1] = temp;
                }
            }
        }
    }
}","Design a Solidity smart contract that enables the creation and management of sets. The contract should include functions for adding, removing, and checking membership. Include a function to retrieve the length of the set. Modify the contract to work with bytes32 values. Consider adding additional functionality, such as inserting and sorting the set, while maintaining the original order."
contract_131.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this;
        return msg.data;
    }
}

interface ITRC20 {
    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function transfer(address recipient, uint256 amount) external returns (bool);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract TRC20Token is Context, ITRC20 {
    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;
    string private _name;
    string private _symbol;

    constructor (string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function name() public view virtual returns (string memory) {
        return _name;
    }

    function symbol() public view virtual returns (string memory) {
        return _symbol;
    }

    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""TRC20Token: transfer from the zero address"");
        require(recipient != address(0), ""TRC20Token: transfer to the zero address"");

        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    function mint(address account, uint256 amount) public virtual {
        require(account != address(0), ""TRC20Token: mint to the zero address"");

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function burn(address account, uint256 amount) public virtual {
        require(account != address(0), ""TRC20Token: burn from the zero address"");

        _balances[account] -= amount;
        _totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""TRC20Token: approve from the zero address"");
        require(spender != address(0), ""TRC20Token: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}","Create a TRC20 token smart contract that supports token transfer, approval, and allowance management. The contract should include methods for token minting and burning. Consider implementing address validation to prevent unauthorized transactions. Ensure that the contract complies with the ITRC20 standard and follows best practices for coding and security."
