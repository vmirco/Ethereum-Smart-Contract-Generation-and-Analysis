prompt_deepseek,deepseek_contract,file_name_deepseek
"Create a smart contract that builds upon the WETHOmnibridgeRouter contract by adding features for account registration, token wrapping, and relay. The contract should integrate with the Omnibridge and WETH contracts. Include methods for registering and wrapping tokens, as well as functionality for relaying tokens to specific recipients. The contract should emit events upon successful token wrapping and relaying. Consider implementing  error handling and validation checks for user input.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IWETH {
    function deposit() external payable;
    function withdraw(uint wad) external;
    function transfer(address to, uint value) external returns (bool);
    function balanceOf(address account) external view returns (uint);
}

interface IOmnibridge {
    function relayTokens(address token, address _receiver, uint256 _value) external;
}

contract WETHOmnibridgeRouter {
    IWETH public immutable weth;
    IOmnibridge public immutable omnibridge;

    mapping(address => bool) public registeredAccounts;

    event AccountRegistered(address indexed account);
    event TokensWrapped(address indexed account, uint256 amount);
    event TokensRelayed(address indexed sender, address indexed receiver, uint256 amount);

    constructor(address _weth, address _omnibridge) {
        weth = IWETH(_weth);
        omnibridge = IOmnibridge(_omnibridge);
    }

    modifier onlyRegistered() {
        require(registeredAccounts[msg.sender], ""Account not registered"");
        _;
    }

    function registerAccount() external {
        require(!registeredAccounts[msg.sender], ""Account already registered"");
        registeredAccounts[msg.sender] = true;
        emit AccountRegistered(msg.sender);
    }

    receive() external payable {
        wrapTokens();
    }

    function wrapTokens() public payable onlyRegistered {
        require(msg.value > 0, ""No ETH sent"");
        weth.deposit{value: msg.value}();
        emit TokensWrapped(msg.sender, msg.value);
    }

    function relayTokens(address _receiver, uint256 _amount) external onlyRegistered {
        require(_amount > 0, ""Amount must be greater than zero"");
        require(weth.balanceOf(address(this)) >= _amount, ""Insufficient WETH balance"");

        weth.transfer(_receiver, _amount);
        omnibridge.relayTokens(address(weth), _receiver, _amount);
        emit TokensRelayed(msg.sender, _receiver, _amount);
    }
}",contract_1.sol
"Create a smart contract for a BlindAuctionMarketplace that allows users to create auctions with various settings. Include features for users to make offers, fill orders, and withdraw funds. Provide functions for setting auction minimum price limits, required termination periods, and maximum price percentages. The contract should have specific events for auction settlement, withdrawal, and failed transfers. Allow contract owners to update settings and control the salvorSigner and pause state.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract BlindAuctionMarketplace {
    address public owner;
    bool public paused;
    address public salvorSigner;

    struct Auction {
        address seller;
        uint256 minPrice;
        uint256 maxPrice;
        uint256 terminationPeriod;
        uint256 startTime;
        uint256 endTime;
        bool settled;
    }

    struct Offer {
        address bidder;
        uint256 amount;
        bool filled;
    }

    Auction[] public auctions;
    mapping(uint256 => Offer[]) public auctionOffers;
    mapping(address => uint256) public balances;

    event AuctionCreated(uint256 indexed auctionId, address indexed seller);
    event OfferMade(uint256 indexed auctionId, address indexed bidder, uint256 amount);
    event AuctionFilled(uint256 indexed auctionId, address indexed bidder, uint256 amount);
    event Withdrawal(address indexed user, uint256 amount);
    event TransferFailed(address indexed from, address indexed to, uint256 amount);
    event SettingsUpdated(address indexed owner);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    constructor() {
        owner = msg.sender;
        paused = false;
        salvorSigner = msg.sender;
    }

    function createAuction(uint256 _minPrice, uint256 _maxPrice, uint256 _terminationPeriod) external whenNotPaused {
        require(_minPrice > 0, ""Min price must be greater than 0"");
        require(_maxPrice > _minPrice, ""Max price must be greater than min price"");
        require(_terminationPeriod > 0, ""Termination period must be greater than 0"");

        Auction memory newAuction = Auction({
            seller: msg.sender,
            minPrice: _minPrice,
            maxPrice: _maxPrice,
            terminationPeriod: _terminationPeriod,
            startTime: block.timestamp,
            endTime: block.timestamp + _terminationPeriod,
            settled: false
        });

        auctions.push(newAuction);
        emit AuctionCreated(auctions.length - 1, msg.sender);
    }

    function makeOffer(uint256 _auctionId, uint256 _amount) external payable whenNotPaused {
        require(_auctionId < auctions.length, ""Invalid auction ID"");
        Auction storage auction = auctions[_auctionId];
        require(!auction.settled, ""Auction already settled"");
        require(block.timestamp < auction.endTime, ""Auction has ended"");
        require(_amount >= auction.minPrice && _amount <= auction.maxPrice, ""Offer out of price range"");

        Offer memory newOffer = Offer({
            bidder: msg.sender,
            amount: _amount,
            filled: false
        });

        auctionOffers[_auctionId].push(newOffer);
        emit OfferMade(_auctionId, msg.sender, _amount);
    }

    function fillAuction(uint256 _auctionId, uint256 _offerIndex) external whenNotPaused {
        require(_auctionId < auctions.length, ""Invalid auction ID"");
        Auction storage auction = auctions[_auctionId];
        require(!auction.settled, ""Auction already settled"");
        require(block.timestamp >= auction.endTime, ""Auction has not ended"");
        require(_offerIndex < auctionOffers[_auctionId].length, ""Invalid offer index"");

        Offer storage offer = auctionOffers[_auctionId][_offerIndex];
        require(!offer.filled, ""Offer already filled"");

        offer.filled = true;
        auction.settled = true;
        balances[auction.seller] += offer.amount;

        emit AuctionFilled(_auctionId, offer.bidder, offer.amount);
    }

    function withdraw(uint256 _amount) external {
        require(balances[msg.sender] >= _amount, ""Insufficient balance"");

        balances[msg.sender] -= _amount;
        (bool success, ) = msg.sender.call{value: _amount}("""");
        if (!success) {
            balances[msg.sender] += _amount;
            emit TransferFailed(address(this), msg.sender, _amount);
        } else {
            emit Withdrawal(msg.sender, _amount);
        }
    }

    function updateSettings(address _newSalvorSigner, bool _newPausedState) external onlyOwner {
        salvorSigner = _newSalvorSigner;
        paused = _newPausedState;
        emit SettingsUpdated(msg.sender);
    }

    receive() external payable {}
}",contract_2.sol
"Create a smart contract that allows for basic withdraw and deposit functionality, token transfer/approval, and proportional distribution when new underlying tokens are minted to vault. The contract should include functions that perform the following: set approvers for specific tokens, initialize Lever, set JoeRouter, Aave, and Aave V3 addresses, and have test functions for vanilla Joe swap fork, vanilla JLP in fork, and vanilla JLP in out fork.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract Vault {
    address public owner;
    IERC20 public token;
    address public joeRouter;
    address public aave;
    address public aaveV3;
    mapping(address => bool) public approvers;
    mapping(address => uint256) public balances;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the owner"");
        _;
    }

    modifier onlyApprover() {
        require(approvers[msg.sender], ""Not an approver"");
        _;
    }

    constructor(address _token) {
        owner = msg.sender;
        token = IERC20(_token);
    }

    function setApprover(address _approver, bool _status) external onlyOwner {
        approvers[_approver] = _status;
    }

    function initializeLever() external onlyOwner {
        // Initialize Leverage logic here
    }

    function setJoeRouter(address _joeRouter) external onlyOwner {
        joeRouter = _joeRouter;
    }

    function setAave(address _aave) external onlyOwner {
        aave = _aave;
    }

    function setAaveV3(address _aaveV3) external onlyOwner {
        aaveV3 = _aaveV3;
    }

    function deposit(uint256 _amount) external {
        require(token.transferFrom(msg.sender, address(this), _amount), ""Transfer failed"");
        balances[msg.sender] += _amount;
    }

    function withdraw(uint256 _amount) external {
        require(balances[msg.sender] >= _amount, ""Insufficient balance"");
        balances[msg.sender] -= _amount;
        require(token.transfer(msg.sender, _amount), ""Transfer failed"");
    }

    function transfer(address _to, uint256 _amount) external {
        require(balances[msg.sender] >= _amount, ""Insufficient balance"");
        balances[msg.sender] -= _amount;
        balances[_to] += _amount;
    }

    function approve(address _spender, uint256 _amount) external {
        token.approve(_spender, _amount);
    }

    function distribute(uint256 _totalAmount) external onlyApprover {
        uint256 totalBalance = token.balanceOf(address(this));
        for (uint256 i = 0; i < addresses.length; i++) {
            address user = addresses[i];
            uint256 userShare = (balances[user] * _totalAmount) / totalBalance;
            balances[user] += userShare;
        }
    }

    function testVanillaJoeSwapFork() external onlyOwner {
        // Test logic for vanilla Joe swap fork
    }

    function testVanillaJLPInFork() external onlyOwner {
        // Test logic for vanilla JLP in fork
    }

    function testVanillaJLPInOutFork() external onlyOwner {
        // Test logic for vanilla JLP in out fork
    }
}",contract_3.sol
"Create a smart contract for managing decentralized autonomous organizations (DAOs) and embedded registries of EVM scripts. The contract should enable the deployment and management of DAOs, as well as the registration and management of EVM script registries. Include event emitters for tracking deployments and implement permission and access control mechanisms for DAOs and registries.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DAO {
    struct DAOInfo {
        address owner;
        string name;
        bool active;
    }

    struct EVMScriptRegistry {
        address owner;
        string description;
        bytes script;
    }

    mapping(address => DAOInfo) public daos;
    mapping(address => EVMScriptRegistry) public evmScriptRegistries;
    mapping(address => mapping(address => bool)) public daoPermissions;
    mapping(address => mapping(address => bool)) public registryPermissions;

    event DAOCreated(address indexed daoAddress, string name);
    event DAOActivated(address indexed daoAddress);
    event DAODeactivated(address indexed daoAddress);
    event EVMScriptRegistered(address indexed registryAddress, string description);
    event PermissionGranted(address indexed grantor, address indexed grantee, bool isDAO);
    event PermissionRevoked(address indexed revoker, address indexed revokee, bool isDAO);

    modifier onlyDAOOwner(address daoAddress) {
        require(daos[daoAddress].owner == msg.sender, ""Not the DAO owner"");
        _;
    }

    modifier onlyRegistryOwner(address registryAddress) {
        require(evmScriptRegistries[registryAddress].owner == msg.sender, ""Not the registry owner"");
        _;
    }

    function createDAO(string memory name) public {
        address daoAddress = address(new DAOInstance(name));
        daos[daoAddress] = DAOInfo({owner: msg.sender, name: name, active: true});
        emit DAOCreated(daoAddress, name);
    }

    function activateDAO(address daoAddress) public onlyDAOOwner(daoAddress) {
        daos[daoAddress].active = true;
        emit DAOActivated(daoAddress);
    }

    function deactivateDAO(address daoAddress) public onlyDAOOwner(daoAddress) {
        daos[daoAddress].active = false;
        emit DAODeactivated(daoAddress);
    }

    function registerEVMScript(string memory description, bytes memory script) public {
        address registryAddress = address(new EVMScriptRegistryInstance(description, script));
        evmScriptRegistries[registryAddress] = EVMScriptRegistry({owner: msg.sender, description: description, script: script});
        emit EVMScriptRegistered(registryAddress, description);
    }

    function grantPermission(address grantee, bool isDAO) public {
        if (isDAO) {
            daoPermissions[msg.sender][grantee] = true;
        } else {
            registryPermissions[msg.sender][grantee] = true;
        }
        emit PermissionGranted(msg.sender, grantee, isDAO);
    }

    function revokePermission(address revokee, bool isDAO) public {
        if (isDAO) {
            daoPermissions[msg.sender][revokee] = false;
        } else {
            registryPermissions[msg.sender][revokee] = false;
        }
        emit PermissionRevoked(msg.sender, revokee, isDAO);
    }
}

contract DAOInstance {
    string public name;

    constructor(string memory _name) {
        name = _name;
    }
}

contract EVMScriptRegistryInstance {
    string public description;
    bytes public script;

    constructor(string memory _description, bytes memory _script) {
        description = _description;
        script = _script;
    }
}",contract_4.sol
"Create a smart contract that allows for a cryptocurrency crowdsale, mimicking the ARMOR token. This contract should have a constructor that sets the total token supply, allocating 90% for public sale and 10% for the owner. Implement a function to accept Ether, approve token ownership, and transfer tokens. Include decimal precision for the token. Lastly, add features for withdrawing funds and killing the contract.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ARMORCrowdsale {
    string public name = ""ARMOR Token"";
    string public symbol = ""ARMOR"";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    address public owner;
    uint256 public publicSalePercentage = 90;
    uint256 public ownerPercentage = 10;
    uint256 public publicSaleTokens;
    uint256 public ownerTokens;
    uint256 public tokensSold;
    uint256 public rate; // tokens per ether

    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowed;

    event Transfer(address indexed from, address indexed to, uint256 tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);
    event Buy(address indexed buyer, uint256 tokens);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor(uint256 _totalSupply, uint256 _rate) {
        totalSupply = _totalSupply * 10 ** uint256(decimals);
        publicSaleTokens = (totalSupply * publicSalePercentage) / 100;
        ownerTokens = (totalSupply * ownerPercentage) / 100;
        rate = _rate;
        owner = msg.sender;
        balances[owner] = ownerTokens;
        emit Transfer(address(0), owner, ownerTokens);
    }

    function buyTokens() public payable {
        require(msg.value > 0, ""Ether sent must be greater than 0"");
        uint256 tokens = msg.value * rate;
        require(tokensSold + tokens <= publicSaleTokens, ""Not enough tokens left for sale"");

        balances[msg.sender] += tokens;
        tokensSold += tokens;
        emit Transfer(address(0), msg.sender, tokens);
        emit Buy(msg.sender, tokens);
    }

    function approve(address delegate, uint256 numTokens) public returns (bool) {
        allowed[msg.sender][delegate] = numTokens;
        emit Approval(msg.sender, delegate, numTokens);
        return true;
    }

    function transfer(address receiver, uint256 numTokens) public returns (bool) {
        require(numTokens <= balances[msg.sender], ""Not enough tokens"");
        balances[msg.sender] -= numTokens;
        balances[receiver] += numTokens;
        emit Transfer(msg.sender, receiver, numTokens);
        return true;
    }

    function transferFrom(address owner, address buyer, uint256 numTokens) public returns (bool) {
        require(numTokens <= balances[owner], ""Not enough tokens"");
        require(numTokens <= allowed[owner][msg.sender], ""Allowance too low"");

        balances[owner] -= numTokens;
        allowed[owner][msg.sender] -= numTokens;
        balances[buyer] += numTokens;
        emit Transfer(owner, buyer, numTokens);
        return true;
    }

    function withdrawFunds() public onlyOwner {
        payable(owner).transfer(address(this).balance);
    }

    function kill() public onlyOwner {
        selfdestruct(payable(owner));
    }
}",contract_5.sol
"Design a smart contract that distributes tokens based on a time-vesting model with multiple claimable steps and a TGE event. The contract should allow users to claim tokens based on their proof of ownership and meet specific eligibility criteria. Incorporate a token, Merkle root, and TGE timestamp. Implement functions for checking and claiming tokens, utilizing import statements for OpenZeppelin libraries. Ensure events are triggered for claim, TGE, and step claim. The contract should have mappings for investors, categories, and claim states.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TokenVesting {
    // Token contract
    IERC20 public token;
    // Merkle root for proof of ownership
    bytes32 public merkleRoot;
    // TGE timestamp
    uint256 public tgeTimestamp;
    // Vesting steps
    uint256[] public vestingSteps;
    // Token distribution per step
    uint256[] public tokensPerStep;

    // Mapping from address to claimed status
    mapping(address => bool) public hasClaimed;
    // Mapping from address to claimed amounts per step
    mapping(address => uint256[]) public claimedAmounts;

    // Events
    event TokensClaimed(address indexed user, uint256 amount);
    event TGEOccurred(uint256 timestamp);
    event StepClaimed(address indexed user, uint256 step, uint256 amount);

    constructor(
        address _token,
        bytes32 _merkleRoot,
        uint256 _tgeTimestamp,
        uint256[] memory _vestingSteps,
        uint256[] memory _tokensPerStep
    ) {
        token = IERC20(_token);
        merkleRoot = _merkleRoot;
        tgeTimestamp = _tgeTimestamp;
        vestingSteps = _vestingSteps;
        tokensPerStep = _tokensPerStep;
    }

    function claimTokens(
        address user,
        uint256 totalAmount,
        bytes32[] calldata merkleProof
    ) external {
        require(!hasClaimed[user], ""Tokens already claimed"");
        require(verifyProof(user, totalAmount, merkleProof), ""Invalid proof"");

        hasClaimed[user] = true;
        distributeTokens(user, totalAmount);
        emit TokensClaimed(user, totalAmount);
    }

    function claimStep(
        address user,
        uint256 step,
        uint256 amount,
        bytes32[] calldata merkleProof
    ) external {
        require(step < vestingSteps.length, ""Invalid step"");
        require(block.timestamp >= vestingSteps[step], ""Step not yet available"");
        require(verifyProof(user, amount, merkleProof), ""Invalid proof"");

        claimedAmounts[user][step] += amount;
        token.transfer(user, amount);
        emit StepClaimed(user, step, amount);
    }

    function verifyProof(
        address user,
        uint256 amount,
        bytes32[] calldata merkleProof
    ) internal view returns (bool) {
        bytes32 node = keccak256(abi.encodePacked(user, amount));
        for (uint256 i = 0; i < merkleProof.length; i++) {
            node = parentHash(node, merkleProof[i]);
        }
        return node == merkleRoot;
    }

    function parentHash(bytes32 a, bytes32 b) internal pure returns (bytes32) {
        return a < b ? keccak256(abi.encodePacked(a, b)) : keccak256(abi.encodePacked(b, a));
    }

    function distributeTokens(address user, uint256 totalAmount) internal {
        for (uint256 i = 0; i < vestingSteps.length; i++) {
            claimedAmounts[user].push(0);
        }
        token.transfer(user, totalAmount);
    }
}

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}",contract_6.sol
"Create a smart contract that mirrors the behavior of the provided CAdapterTestHelper contract, focusing on simulating a Compound adapter with three adapters (cDAI, cETH, and cUSDC) and integrating with a token handler, divider, and address book. Include functions for setting contributor rewards, retrieving comp speeds, and interacting with the Compound oracle. Emphasize the importance of ensuring correct transfer of funds using SafeTransferLib. Keep an eye on backwards compatibility.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

interface ICompoundToken {
    function mint(uint256 mintAmount) external returns (uint256);
    function redeem(uint256 redeemTokens) external returns (uint256);
    function exchangeRateCurrent() external returns (uint256);
    function supplyRatePerBlock() external returns (uint256);
}

interface ICompoundOracle {
    function getUnderlyingPrice(address cToken) external view returns (uint256);
}

contract CAdapterTestHelper {
    address public tokenHandler;
    address public divider;
    address public addressBook;
    ICompoundToken public cDAI;
    ICompoundToken public cETH;
    ICompoundToken public cUSDC;
    ICompoundOracle public compoundOracle;

    constructor(
        address _tokenHandler,
        address _divider,
        address _addressBook,
        address _cDAI,
        address _cETH,
        address _cUSDC,
        address _compoundOracle
    ) {
        tokenHandler = _tokenHandler;
        divider = _divider;
        addressBook = _addressBook;
        cDAI = ICompoundToken(_cDAI);
        cETH = ICompoundToken(_cETH);
        cUSDC = ICompoundToken(_cUSDC);
        compoundOracle = ICompoundOracle(_compoundOracle);
    }

    function setContributorRewards(address contributor, uint256 amount) external {
        // Implementation for setting contributor rewards
    }

    function getCompSpeeds(address[] memory cTokens) external view returns (uint256[] memory) {
        uint256[] memory speeds = new uint256[](cTokens.length);
        for (uint256 i = 0; i < cTokens.length; i++) {
            // Fetch comp speeds from Compound
            speeds[i] = 0; // Placeholder for actual comp speed retrieval
        }
        return speeds;
    }

    function getUnderlyingPrice(address cToken) external view returns (uint256) {
        return compoundOracle.getUnderlyingPrice(cToken);
    }

    function safeTransfer(address token, address to, uint256 value) internal {
        IERC20(token).transfer(to, value);
    }

    function safeTransferFrom(address token, address from, address to, uint256 value) internal {
        IERC20(token).transferFrom(from, to, value);
    }
}",contract_7.sol
"Create a smart contract that manages user deposits, calculates dividends, and handles fees. The contract should include functions for depositing, withdrawing, and transferring funds. Implement a mapping to store user information. Develop an event handler for withdrawing funds. Implement a calculation function for dividend distribution and inflation handling.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DepositManager {
    struct User {
        uint256 balance;
        uint256 lastDividendPoint;
    }

    mapping(address => User) public users;
    uint256 public totalSupply;
    uint256 public dividendPerToken;
    uint256 public constant FEE_RATE = 1; // 1% fee
    uint256 public constant INFLATION_RATE = 2; // 2% inflation per period

    event Deposit(address indexed user, uint256 amount);
    event Withdraw(address indexed user, uint256 amount);
    event Transfer(address indexed from, address indexed to, uint256 amount);

    function deposit(uint256 amount) external payable {
        require(amount > 0, ""Amount must be greater than 0"");
        User storage user = users[msg.sender];
        updateDividend(user);
        user.balance += amount;
        totalSupply += amount;
        emit Deposit(msg.sender, amount);
    }

    function withdraw(uint256 amount) external {
        require(amount > 0, ""Amount must be greater than 0"");
        User storage user = users[msg.sender];
        require(user.balance >= amount, ""Insufficient balance"");
        updateDividend(user);
        user.balance -= amount;
        totalSupply -= amount;
        payable(msg.sender).transfer(amount);
        emit Withdraw(msg.sender, amount);
    }

    function transfer(address to, uint256 amount) external {
        require(amount > 0, ""Amount must be greater than 0"");
        User storage sender = users[msg.sender];
        User storage recipient = users[to];
        require(sender.balance >= amount, ""Insufficient balance"");
        updateDividend(sender);
        updateDividend(recipient);
        sender.balance -= amount;
        recipient.balance += amount;
        emit Transfer(msg.sender, to, amount);
    }

    function updateDividend(User storage user) internal {
        if (totalSupply > 0) {
            dividendPerToken += (block.timestamp - user.lastDividendPoint) * INFLATION_RATE / 100;
        }
        user.lastDividendPoint = block.timestamp;
        uint256 owed = dividendPerToken * user.balance / 1e18 - user.balance;
        user.balance += owed;
    }

    function calculateDividends() external view returns (uint256) {
        User memory user = users[msg.sender];
        uint256 currentDividendPerToken = dividendPerToken + (block.timestamp - user.lastDividendPoint) * INFLATION_RATE / 100;
        return (currentDividendPerToken * user.balance / 1e18) - user.balance;
    }
}",contract_8.sol
"Create a Solidity smart contract that manages the unwrapping of GM tokens. The contract should allow users to unwrap GM tokens after a specified interval. Include functions for unwrapping, setting/unsetting a flag for unlocking/unlocking GM token unwrapping, changing the GM token address, managing the user's unwrap timestamp, and calculating the maximum unwrapped amount. Consider implementing reentrancy protection and utilizing OpenZeppelin libraries. The contract should include mapping data structures and interfaces for addressing and uint256 calculations.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

contract GMTokenUnwrapper {
    IERC20 public gmToken;
    bool public unwrapEnabled;
    uint256 public unwrapInterval;

    mapping(address => uint256) public lastUnwrapTime;

    event Unwrap(address indexed user, uint256 amount);
    event UnwrapEnabled(bool enabled);
    event GMTokenAddressChanged(address newAddress);

    modifier onlyWhenUnwrapEnabled() {
        require(unwrapEnabled, ""Unwrapping is not enabled"");
        _;
    }

    modifier nonReentrant() {
        require(!_locked, ""Reentrant call"");
        _locked = true;
        _;
        _locked = false;
    }

    bool private _locked;

    constructor(address _gmTokenAddress, uint256 _unwrapInterval) {
        gmToken = IERC20(_gmTokenAddress);
        unwrapInterval = _unwrapInterval;
        unwrapEnabled = true;
    }

    function setUnwrapEnabled(bool _enabled) external {
        unwrapEnabled = _enabled;
        emit UnwrapEnabled(_enabled);
    }

    function changeGMTokenAddress(address _newAddress) external {
        gmToken = IERC20(_newAddress);
        emit GMTokenAddressChanged(_newAddress);
    }

    function unwrap(uint256 amount) external onlyWhenUnwrapEnabled nonReentrant {
        require(block.timestamp >= lastUnwrapTime[msg.sender] + unwrapInterval, ""Unwrap interval not passed"");
        require(gmToken.balanceOf(msg.sender) >= amount, ""Insufficient GM tokens"");

        lastUnwrapTime[msg.sender] = block.timestamp;
        gmToken.transfer(msg.sender, amount);

        emit Unwrap(msg.sender, amount);
    }

    function calculateMaxUnwrapAmount(address user) public view returns (uint256) {
        if (block.timestamp < lastUnwrapTime[user] + unwrapInterval) {
            return 0;
        }
        return gmToken.balanceOf(user);
    }
}",contract_9.sol
"Create a smart contract that safely manages token balances and transfer, implementing ReentrancyGuard and Ownable contracts from OpenZeppelin. Include deposit, withdraw, and balance functions, considering timestamp-based unlocking. Make sure the contract is compatible with Solidity 0.8.0.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ReentrancyGuard {
    bool private _reentrancyGuard;

    modifier nonReentrant() {
        require(!_reentrancyGuard, ""ReentrancyGuard: reentrant call"");
        _reentrancyGuard = true;
        _;
        _reentrancyGuard = false;
    }
}

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    modifier onlyOwner() {
        require(isOwner(), ""Ownable: caller is not the owner"");
        _;
    }

    function owner() public view returns (address) {
        return _owner;
    }

    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract TokenManager is ReentrancyGuard, Ownable {
    mapping(address => uint256) private _balances;
    mapping(address => uint256) private _lockTimes;

    event Deposited(address indexed user, uint256 amount);
    event Withdrawn(address indexed user, uint256 amount);

    function deposit() public payable {
        _balances[msg.sender] += msg.value;
        _lockTimes[msg.sender] = block.timestamp + 3600; // Lock for 1 hour
        emit Deposited(msg.sender, msg.value);
    }

    function withdraw(uint256 amount) public nonReentrant {
        require(_balances[msg.sender] >= amount, ""Insufficient balance"");
        require(block.timestamp >= _lockTimes[msg.sender], ""Tokens are locked"");
        _balances[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);
        emit Withdrawn(msg.sender, amount);
    }

    function balanceOf(address user) public view returns (uint256) {
        return _balances[user];
    }

    function lockTimeOf(address user) public view returns (uint256) {
        return _lockTimes[user];
    }
}",contract_10.sol
"Create a smart contract that manages collateral and liquidation for options market. The contract should include functionality for sending quote and base collateral, liquidating positions, and settling options. Implement interfaces for OpenZeppelin's ERC20 and interfaces for synthetix adapter, option market, and option token. Include initialization functions for setting up the contract's variables.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface ISynthetixAdapter {
    function getPrice(address asset) external view returns (uint256);
}

interface IOptionMarket {
    function settleOption(address optionToken, uint256 optionId) external returns (uint256);
}

interface IOptionToken {
    function exercise(uint256 optionId) external;
}

contract OptionsMarketManager {
    IERC20 public baseCollateralToken;
    IERC20 public quoteCollateralToken;
    ISynthetixAdapter public synthetixAdapter;
    IOptionMarket public optionMarket;

    mapping(address => uint256) public collateralBalances;

    event CollateralDeposited(address indexed user, uint256 amount);
    event CollateralWithdrawn(address indexed user, uint256 amount);
    event PositionLiquidated(address indexed user, uint256 amount);

    constructor(
        address _baseCollateralToken,
        address _quoteCollateralToken,
        address _synthetixAdapter,
        address _optionMarket
    ) {
        baseCollateralToken = IERC20(_baseCollateralToken);
        quoteCollateralToken = IERC20(_quoteCollateralToken);
        synthetixAdapter = ISynthetixAdapter(_synthetixAdapter);
        optionMarket = IOptionMarket(_optionMarket);
    }

    function depositCollateral(address token, uint256 amount) external {
        require(token == address(baseCollateralToken) || token == address(quoteCollateralToken), ""Invalid token"");
        IERC20(token).transferFrom(msg.sender, address(this), amount);
        collateralBalances[msg.sender] += amount;
        emit CollateralDeposited(msg.sender, amount);
    }

    function withdrawCollateral(address token, uint256 amount) external {
        require(token == address(baseCollateralToken) || token == address(quoteCollateralToken), ""Invalid token"");
        require(collateralBalances[msg.sender] >= amount, ""Insufficient balance"");
        collateralBalances[msg.sender] -= amount;
        IERC20(token).transfer(msg.sender, amount);
        emit CollateralWithdrawn(msg.sender, amount);
    }

    function liquidatePosition(address user, address optionToken, uint256 optionId) external {
        uint256 collateralAmount = collateralBalances[user];
        require(collateralAmount > 0, ""No collateral to liquidate"");

        uint256 optionPrice = synthetixAdapter.getPrice(optionToken);
        require(optionPrice > collateralAmount, ""Position is not undercollateralized"");

        collateralBalances[user] = 0;
        IOptionToken(optionToken).exercise(optionId);
        emit PositionLiquidated(user, collateralAmount);
    }

    function settleOption(address optionToken, uint256 optionId) external {
        optionMarket.settleOption(optionToken, optionId);
    }
}",contract_11.sol
Develop a smart contract that verifies the existence or non-existence of a key-value pair in a Merkle tree. The contract should include functions to validate the commitment root and leaf node of the Merkle tree. Implement a way to check against a specification to ensure the internal consistency of the Merkle tree. Your solution should handle common error cases and provide clear documentation of the contract's functionality.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MerkleTreeVerifier {
    bytes32 public commitmentRoot;

    // Event to log validation results
    event ValidationResult(bool isValid);

    // Constructor to set the commitment root
    constructor(bytes32 _commitmentRoot) {
        commitmentRoot = _commitmentRoot;
    }

    // Function to verify the existence of a key-value pair in the Merkle tree
    function verifyExistence(
        bytes32[] memory proof,
        bytes32 leaf,
        uint256 index,
        bytes32 root
    ) public view returns (bool) {
        require(root == commitmentRoot, ""Provided root does not match the commitment root"");
        bytes32 computedHash = leaf;

        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];

            if (index % 2 == 0) {
                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));
            } else {
                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));
            }

            index = index / 2;
        }

        return computedHash == root;
    }

    // Function to validate the commitment root and leaf node
    function validateCommitment(
        bytes32[] memory proof,
        bytes32 leaf,
        uint256 index
    ) public {
        bool isValid = verifyExistence(proof, leaf, index, commitmentRoot);
        emit ValidationResult(isValid);
    }

    // Function to check internal consistency of the Merkle tree
    function checkConsistency(
        bytes32[] memory proof,
        bytes32 leaf,
        uint256 index,
        bytes32 root
    ) public view returns (bool) {
        return verifyExistence(proof, leaf, index, root);
    }
}",contract_12.sol
"Create a Solidity smart contract that integrates with the MasterChef and Uniswap protocols to manage rewards and LP tokens. The contract should have functions for harvesting rewards, depositing, and preview depositing. Handle address variables for the reward token, unirouter, and masterchef. Calculate LP token amounts and total assets accurately. Implement error handling as needed.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface IMasterChef {
    function deposit(uint256 _pid, uint256 _amount) external;
    function withdraw(uint256 _pid, uint256 _amount) external;
    function userInfo(uint256 _pid, address _user) external view returns (uint256 amount, uint256 rewardDebt);
    function pendingReward(uint256 _pid, address _user) external view returns (uint256);
}

interface IUniswapV2Router02 {
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);
}

contract RewardManager {
    address public rewardToken;
    address public unirouter;
    address public masterchef;
    uint256 public pid;

    constructor(address _rewardToken, address _unirouter, address _masterchef, uint256 _pid) {
        rewardToken = _rewardToken;
        unirouter = _unirouter;
        masterchef = _masterchef;
        pid = _pid;
    }

    function harvestRewards() external {
        (uint256 amount,) = IMasterChef(masterchef).userInfo(pid, address(this));
        IMasterChef(masterchef).withdraw(pid, amount);
        uint256 pending = IMasterChef(masterchef).pendingReward(pid, address(this));
        IERC20(rewardToken).transfer(msg.sender, pending);
    }

    function deposit(uint256 amount) external {
        IERC20(rewardToken).transferFrom(msg.sender, address(this), amount);
        IERC20(rewardToken).approve(masterchef, amount);
        IMasterChef(masterchef).deposit(pid, amount);
    }

    function previewDeposit(uint256 amount) external view returns (uint256) {
        (uint256 currentAmount,) = IMasterChef(masterchef).userInfo(pid, address(this));
        return currentAmount + amount;
    }

    function totalAssets() external view returns (uint256) {
        (uint256 amount,) = IMasterChef(masterchef).userInfo(pid, address(this));
        return amount;
    }
}",contract_13.sol
Develop a smart contract for Random APE NFTs that enables minting and burning of tokens. Utilize OpenZeppelin's ERC-721 and ERC-721Burnable contracts. Require the MINTER_ROLE for minting. Implement a constructor that initializes the contract and grants the DEFAULT_ADMIN_ROLE and MINTER_ROLE to the contract deployer. Include a function for minting a new token and provide a way to burn tokens. Consider implementing a base URI function to set the prefix for IPFS links. The contract should also support the EIP-165 interface.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC165 {
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

abstract contract ERC165 is IERC165 {
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}

interface IERC721 is IERC165 {
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function balanceOf(address owner) external view returns (uint256 balance);
    function ownerOf(uint256 tokenId) external view returns (address owner);
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    function transferFrom(address from, address to, uint256 tokenId) external;
    function approve(address to, uint256 tokenId) external;
    function getApproved(uint256 tokenId) external view returns (address operator);
    function setApprovalForAll(address operator, bool _approved) external;
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}

interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}

interface IERC721Metadata is IERC721 {
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function tokenURI(uint256 tokenId) external view returns (string memory);
}

library Address {
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

library Strings {
    bytes16 private constant _HEX_SYMBOLS = ""0123456789abcdef"";

    function toString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return ""0"";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }

    function toHexString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return ""0x00"";
        }
        uint256 temp = value;
        uint256 length = 0;
        while (temp != 0) {
            length++;
            temp >>= 8;
        }
        return toHexString(value, length);
    }

    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = ""0"";
        buffer[1] = ""x"";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _HEX_SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, ""Strings: hex length insufficient"");
        return string(buffer);
    }
}

abstract contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {
    using Address for address;
    using Strings for uint256;

    string private _name;
    string private _symbol;
    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return
            interfaceId == type(IERC721).interfaceId ||
            interfaceId == type(IERC721Metadata).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    function balanceOf(address owner) public view virtual override returns (uint256) {
        require(owner != address(0), ""ERC721: balance query for the zero address"");
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) public view virtual override returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), ""ERC721: owner query for nonexistent token"");
        return owner;
    }

    function name() public view virtual override returns (string memory) {
        return _name;
    }

    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        require(_exists(tokenId), ""ERC721Metadata: URI query for nonexistent token"");

        string memory baseURI = _baseURI();
        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : """";
    }

    function _baseURI() internal view virtual returns (string memory) {
        return """";
    }

    function approve(address to, uint256 tokenId) public virtual override {
        address owner = ERC721.ownerOf(tokenId);
        require(to != owner, ""ERC721: approval to current owner"");

        require(
            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
            ""ERC721: approve caller is not owner nor approved for all""
        );

        _approve(to, tokenId);
    }

    function getApproved(uint256 tokenId) public view virtual override returns (address) {
        require(_exists(tokenId), ""ERC721: approved query for nonexistent token"");

        return _tokenApprovals[tokenId];
    }

    function setApprovalForAll(address operator, bool approved) public virtual override {
        require(operator != _msgSender(), ""ERC721: approve to caller"");

        _operatorApprovals[_msgSender()][operator] = approved;
        emit ApprovalForAll(_msgSender(), operator, approved);
    }

    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        require(_isApprovedOrOwner(_msgSender(), tokenId), ""ERC721: transfer caller is not owner nor approved"");

        _transfer(from, to, tokenId);
    }

    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        safeTransferFrom(from, to, tokenId, """");
    }

    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) public virtual override {
        require(_isApprovedOrOwner(_msgSender(), tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _safeTransfer(from, to, tokenId, _data);
    }

    function _safeTransfer(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) internal virtual {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _exists(uint256 tokenId) internal view virtual returns (bool) {
        return _owners[tokenId] != address(0);
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");
        address owner = ERC721.ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    function _safeMint(address to, uint256 tokenId) internal virtual {
        _safeMint(to, tokenId, """");
    }

    function _safeMint(
        address to,
        uint256 tokenId,
        bytes memory _data
    ) internal virtual {
        _mint(to, tokenId);
        require(
            _checkOnERC721Received(address(0), to, tokenId, _data),
            ""ERC721: transfer to non ERC721Receiver implementer""
        );
    }

    function _mint(address to, uint256 tokenId) internal virtual {
        require(to != address(0), ""ERC721: mint to the zero address"");
        require(!_exists(tokenId), ""ERC721: token already minted"");

        _beforeTokenTransfer(address(0), to, tokenId);

        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(address(0), to, tokenId);
    }

    function _burn(uint256 tokenId) internal virtual {
        address owner = ERC721.ownerOf(tokenId);

        _beforeTokenTransfer(owner, address(0), tokenId);

        _approve(address(0), tokenId);

        _balances[owner] -= 1;
        delete _owners[tokenId];

        emit Transfer(owner, address(0), tokenId);
    }

    function _transfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual {
        require(ERC721.ownerOf(tokenId) == from, ""ERC721: transfer of token that is not own"");
        require(to != address(0), ""ERC721: transfer to the zero address"");

        _beforeTokenTransfer(from, to, tokenId);

        _approve(address(0), tokenId);

        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(from, to, tokenId);
    }

    function _approve(address to, uint256 tokenId) internal virtual {
        _tokenApprovals[tokenId] = to;
        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);
    }

    function _checkOnERC721Received(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) private returns (bool) {
        if (to.isContract()) {
            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
                return retval == IERC721Receiver.onERC721Received.selector;
            } catch (bytes memory reason) {
                if (reason.length == 0) {
                    revert(""ERC721: transfer to non ERC721Receiver implementer"");
                } else {
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        } else {
            return true;
        }
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual {}
}

interface IAccessControl {
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    function hasRole(bytes32 role, address account) external view returns (bool);
    function getRoleAdmin(bytes32 role) external view returns (bytes32);
    function grantRole(bytes32 role, address account) external;
    function revokeRole(bytes32 role, address account) external;
    function renounceRole(bytes32 role, address account) external;
}

abstract contract AccessControl is Context, IAccessControl, ERC165 {
    struct RoleData {
        mapping(address => bool) members;
        bytes32 adminRole;
    }

    mapping(bytes32 => RoleData) private _roles;

    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    modifier onlyRole(bytes32 role) {
        _checkRole(role, _msgSender());
        _;
    }

    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);
    }

    function hasRole(bytes32 role, address account) public view override returns (bool) {
        return _roles[role].members[account];
    }

    function _checkRole(bytes32 role, address account) internal view {
        if (!hasRole(role, account)) {
            revert(
                string(
                    abi.encodePacked(
                        ""AccessControl: account "",
                        Strings.toHexString(uint160(account), 20),
                        "" is missing role "",
                        Strings.toHexString(uint256(role), 32)
                    )
                )
            );
        }
    }

    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {
        return _roles[role].adminRole;
    }

    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {
        _grantRole(role, account);
    }

    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {
        _revokeRole(role, account);
    }

    function renounceRole(bytes32 role, address account) public virtual override {
        require(account == _msgSender(), ""AccessControl: can only renounce roles for self"");

        _revokeRole(role, account);
    }

    function _setupRole(bytes32 role, address account) internal virtual {
        _grantRole(role, account);
    }

    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);
        _roles[role].adminRole = adminRole;
    }

    function _grantRole(bytes32 role, address account) private {
        if (!hasRole(role, account)) {
            _roles[role].members[account] = true;
            emit RoleGranted(role, account, _msgSender());
        }
    }

    function _revokeRole(bytes32 role, address account) private {
        if (hasRole(role, account)) {
            _roles[role].members[account] = false;
            emit RoleRevoked(role, account, _msgSender());
        }
    }
}

contract RandomAPENFT is ERC721, AccessControl {
    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");
    string private _baseTokenURI;

    constructor(string memory name, string memory symbol, string memory baseTokenURI) ERC721(name, symbol) {
        _baseTokenURI = baseTokenURI;
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
",contract_14.sol
"Create a smart contract for a KaijuKingz NFT collection. The contract should allow for fusion of Kaijus, revealing revealed Kaijus, and changing their names and bios. Consider implementing burn mechanics for fusion and updates. Be mindful of gas efficiency and EIP-1167 compliance.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}

contract KaijuKingzNFT {
    string public name = ""KaijuKingz"";
    string public symbol = ""KK"";
    uint256 public totalSupply;
    address public owner;

    struct Kaiju {
        string name;
        string bio;
        bool revealed;
    }

    mapping(uint256 => Kaiju) public kaijus;
    mapping(uint256 => address) public tokenOwner;
    mapping(uint256 => address) public tokenApprovals;
    mapping(address => mapping(address => bool)) private operatorApprovals;

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
    event KaijuRevealed(uint256 indexed tokenId, string name, string bio);
    event KaijuFused(uint256 indexed tokenId1, uint256 indexed tokenId2, uint256 newTokenId);
    event KaijuNameChanged(uint256 indexed tokenId, string newName);
    event KaijuBioChanged(uint256 indexed tokenId, string newBio);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not owner"");
        _;
    }

    modifier onlyTokenOwner(uint256 tokenId) {
        require(msg.sender == tokenOwner[tokenId], ""Not token owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function balanceOf(address _owner) external view returns (uint256) {
        uint256 balance = 0;
        for (uint256 i = 1; i <= totalSupply; i++) {
            if (tokenOwner[i] == _owner) {
                balance++;
            }
        }
        return balance;
    }

    function ownerOf(uint256 tokenId) public view returns (address) {
        return tokenOwner[tokenId];
    }

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {
        transferFrom(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data), ""Transfer to non ERC721Receiver implementer"");
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) external {
        safeTransferFrom(from, to, tokenId, """");
    }

    function transferFrom(address from, address to, uint256 tokenId) public {
        require(from == tokenOwner[tokenId] || msg.sender == tokenApprovals[tokenId] || isApprovedForAll(from, msg.sender), ""Not approved"");
        _transfer(from, to, tokenId);
    }

    function approve(address to, uint256 tokenId) external {
        address owner = tokenOwner[tokenId];
        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), ""Not approved"");
        tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    function setApprovalForAll(address operator, bool approved) external {
        operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function isApprovedForAll(address owner, address operator) public view returns (bool) {
        return operatorApprovals[owner][operator];
    }

    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) internal returns (bool) {
        if (to.code.length == 0) return true;
        try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data) returns (bytes4 retval) {
            return retval == IERC721Receiver.onERC721Received.selector;
        } catch (bytes memory reason) {
            if (reason.length == 0) {
                revert(""Transfer to non ERC721Receiver implementer"");
            } else {
                assembly {
                    revert(add(32, reason), mload(reason))
                }
            }
        }
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        require(tokenOwner[tokenId] == from, ""From address is not token owner"");
        require(to != address(0), ""Transfer to the zero address"");

        tokenOwner[tokenId] = to;
        tokenApprovals[tokenId] = address(0);

        emit Transfer(from, to, tokenId);
    }

    function mint(string memory _name, string memory _bio) external onlyOwner {
        totalSupply++;
        kaijus[totalSupply] = Kaiju(_name, _bio, false);
        tokenOwner[totalSupply] = owner;
        emit Transfer(address(0), owner, totalSupply);
    }

    function revealKaiju(uint256 tokenId, string memory _name, string memory _bio) external onlyTokenOwner(tokenId) {
        kaijus[tokenId].name = _name;
        kaijus[tokenId].bio = _bio;
        kaijus[tokenId].revealed = true;
        emit KaijuRevealed(tokenId, _name, _bio);
    }

    function fuseKaijus(uint256 tokenId1, uint256 tokenId2) external onlyTokenOwner(tokenId1) onlyTokenOwner(tokenId2) {
        require(tokenId1 != tokenId2, ""Cannot fuse the same token"");
        require(kaijus[tokenId1].revealed && kaijus[tokenId2].revealed, ""Kaijus must be revealed"");

        totalSupply++;
        kaijus[totalSupply] = Kaiju(kaijus[tokenId1].name, kaijus[tokenId2].bio, true);
        tokenOwner[totalSupply] = tokenOwner[tokenId1];

        _burn(tokenId1);
        _burn(tokenId2);

        emit KaijuFused(tokenId1, tokenId2, totalSupply);
    }

    function changeKaijuName(uint256 tokenId, string memory newName) external onlyTokenOwner(tokenId) {
        kaijus[tokenId].name = newName;
        emit KaijuNameChanged(tokenId, newName);
    }

    function changeKaijuBio(uint256 tokenId, string memory newBio) external onlyTokenOwner(tokenId) {
        kaijus[tokenId].bio = newBio;
        emit KaijuBioChanged(tokenId, newBio);
    }

    function _burn(uint256 tokenId) internal {
        address owner = tokenOwner[tokenId];
        tokenOwner[tokenId] = address(0);
        tokenApprovals[tokenId] = address(0);
        emit Transfer(owner, address(0), tokenId);
    }
}",contract_15.sol
"Design a contract that allows for the pause and resumption of transfer operations. The contract should allow users to set an address as pausable, check if an address is pausable, and transfer tokens. The transfer function should fail if the transfer is paused. The contract should also include a function to get the current pause status.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract PausableToken {
    mapping(address => bool) public pausableAddresses;
    bool public paused;
    mapping(address => uint256) private balances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event PauseStatusChanged(bool newStatus);
    event AddressSetPausable(address indexed addr, bool isPausable);

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function setPausable(address addr, bool isPausable) external {
        pausableAddresses[addr] = isPausable;
        emit AddressSetPausable(addr, isPausable);
    }

    function isPausable(address addr) external view returns (bool) {
        return pausableAddresses[addr];
    }

    function setPauseStatus(bool newStatus) external {
        paused = newStatus;
        emit PauseStatusChanged(newStatus);
    }

    function getPauseStatus() external view returns (bool) {
        return paused;
    }

    function transfer(address to, uint256 amount) external whenNotPaused {
        require(!pausableAddresses[msg.sender], ""Sender address is pausable"");
        require(balances[msg.sender] >= amount, ""Not enough balance"");
        balances[msg.sender] -= amount;
        balances[to] += amount;
        emit Transfer(msg.sender, to, amount);
    }

    function balanceOf(address account) external view returns (uint256) {
        return balances[account];
    }

    function mint(address account, uint256 amount) external {
        balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }
}",contract_16.sol
"Design a smart contract to manage insurance products with a focus on security matrices, capital pools, and premium pools. The contract should include functions for setup and initialization, pausing and unpausing, and secure authorizations. Implement logic for cover purchase, cancellation, and status updates. Use best practices for code organization, naming conventions, and error handling.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract InsuranceManager {
    address public owner;
    bool public paused;
    uint256 public totalCapital;
    uint256 public totalPremiums;

    struct Policy {
        address holder;
        uint256 premium;
        uint256 coverageAmount;
        bool active;
    }

    mapping(address => Policy) public policies;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    event PolicyPurchased(address indexed holder, uint256 premium, uint256 coverageAmount);
    event PolicyCancelled(address indexed holder, uint256 refundAmount);
    event StatusUpdated(address indexed holder, bool active);

    constructor() {
        owner = msg.sender;
        paused = false;
    }

    function pause() external onlyOwner {
        paused = true;
    }

    function unpause() external onlyOwner {
        paused = false;
    }

    function purchasePolicy(uint256 _premium, uint256 _coverageAmount) external payable whenNotPaused {
        require(msg.value == _premium, ""Incorrect premium amount"");
        require(_coverageAmount > 0, ""Coverage amount must be greater than zero"");
        require(policies[msg.sender].holder == address(0), ""Policy already exists"");

        policies[msg.sender] = Policy({
            holder: msg.sender,
            premium: _premium,
            coverageAmount: _coverageAmount,
            active: true
        });

        totalPremiums += _premium;
        totalCapital += _coverageAmount;

        emit PolicyPurchased(msg.sender, _premium, _coverageAmount);
    }

    function cancelPolicy() external whenNotPaused {
        Policy storage policy = policies[msg.sender];
        require(policy.holder != address(0), ""No policy found"");
        require(policy.active, ""Policy is not active"");

        uint256 refundAmount = policy.premium;
        policy.active = false;

        totalPremiums -= policy.premium;
        totalCapital -= policy.coverageAmount;

        payable(msg.sender).transfer(refundAmount);

        emit PolicyCancelled(msg.sender, refundAmount);
    }

    function updatePolicyStatus(address _holder, bool _active) external onlyOwner {
        Policy storage policy = policies[_holder];
        require(policy.holder != address(0), ""No policy found"");

        policy.active = _active;

        emit StatusUpdated(_holder, _active);
    }
}",contract_17.sol
"Create a smart contract that integrates a role-based access control system for a decentralized application. The contract should include functions for verifying user memberships, granting and revoking permissions, and getting the administration role. Ensure the contract emits events for role changes and implements a mechanism for setting admin roles. Focus on the high-level structure and functionality of the contract.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract RoleBasedAccessControl {
    struct Role {
        mapping(address => bool) members;
        bytes32 adminRole;
    }

    mapping(bytes32 => Role) private roles;

    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    modifier onlyRole(bytes32 role) {
        require(hasRole(role, msg.sender), ""RBAC: caller does not have the role"");
        _;
    }

    function hasRole(bytes32 role, address account) public view returns (bool) {
        return roles[role].members[account];
    }

    function getAdminRole(bytes32 role) public view returns (bytes32) {
        return roles[role].adminRole;
    }

    function setAdminRole(bytes32 role, bytes32 adminRole) public onlyRole(getAdminRole(role)) {
        roles[role].adminRole = adminRole;
    }

    function grantRole(bytes32 role, address account) public onlyRole(getAdminRole(role)) {
        roles[role].members[account] = true;
        emit RoleGranted(role, account, msg.sender);
    }

    function revokeRole(bytes32 role, address account) public onlyRole(getAdminRole(role)) {
        roles[role].members[account] = false;
        emit RoleRevoked(role, account, msg.sender);
    }
}",contract_18.sol
"Create a smart contract that allows for ownership transfer, paused state management, and payment withdrawal. The contract should inherit from OpenZeppelin's contracts and provide clear documentation for its functions. The contract should allow the owner to renounce ownership, transfer ownership to another address, and change the paused state. The owner should be able to withdraw payments to a payee address, and the withdrawn value should be deducted from the balance of the contract.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of ""user permissions"".
 */
contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(isOwner(), ""Ownable: caller is not the owner"");
        _;
    }

    /**
     * @dev Returns true if the caller is the current owner.
     */
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

/**
 * @title Pausable
 * @dev Base contract which allows children to implement an emergency stop mechanism.
 */
contract Pausable is Ownable {
    event Paused(address account);
    event Unpaused(address account);

    bool private _paused;

    constructor() {
        _paused = false;
    }

    /**
     * @return true if the contract is paused, false otherwise.
     */
    function paused() public view returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
        require(!_paused, ""Pausable: paused"");
        _;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is paused.
     */
    modifier whenPaused() {
        require(_paused, ""Pausable: not paused"");
        _;
    }

    /**
     * @dev Called by the owner to pause, triggers stopped state.
     */
    function pause() public onlyOwner whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    /**
     * @dev Called by the owner to unpause, returns to normal state.
     */
    function unpause() public onlyOwner whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}

/**
 * @title PaymentWithdrawable
 * @dev Contract that allows the owner to withdraw payments to a payee address.
 */
contract PaymentWithdrawable is Ownable {
    event PaymentWithdrawn(address indexed payee, uint256 amount);

    /**
     * @dev Withdraws the contract's balance to the specified payee address.
     * @param payee The address where the funds will be sent.
     */
    function withdrawPayment(address payable payee) public onlyOwner {
        uint256 balance = address(this).balance;
        require(balance > 0, ""PaymentWithdrawable: no balance to withdraw"");
        payee.transfer(balance);
        emit PaymentWithdrawn(payee, balance);
    }
}

/**
 * @title ManagedContract
 * @dev A contract that combines Ownable, Pausable, and PaymentWithdrawable functionalities.
 */
contract ManagedContract is Pausable, PaymentWithdrawable {
    /**
     * @dev Constructor that initializes the contract with the deployer as the initial owner.
     */
    constructor() Pausable() PaymentWithdrawable() {}
}",contract_19.sol
"Create a smart contract that allows for the management of tokens, enables the addition and removal of liquidity, and manages token swapping, admin fees, and LP earnings. Focus on implementing these functions in a logical and efficient manner.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TokenSwap {
    string public name = ""TokenSwap"";
    address public admin;
    uint256 public totalLiquidity;
    uint256 public constant FEE_RATE = 30; // 0.3% fee

    struct Token {
        uint256 balance;
        uint256 decimals;
        string symbol;
    }

    mapping(address => Token) public tokens;
    mapping(address => mapping(address => uint256)) public liquidity;

    event AddLiquidity(address indexed provider, address indexed token, uint256 amount);
    event RemoveLiquidity(address indexed provider, address indexed token, uint256 amount);
    event Swap(address indexed from, address indexed to, uint256 amountIn, uint256 amountOut);

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Not admin"");
        _;
    }

    constructor() {
        admin = msg.sender;
    }

    function addToken(address _tokenAddress, uint256 _decimals, string memory _symbol) public onlyAdmin {
        tokens[_tokenAddress] = Token({balance: 0, decimals: _decimals, symbol: _symbol});
    }

    function addLiquidity(address _tokenAddress, uint256 _amount) public payable {
        require(tokens[_tokenAddress].decimals > 0, ""Token not supported"");
        if (_tokenAddress == address(0)) {
            require(msg.value == _amount, ""Incorrect ETH amount"");
            tokens[address(0)].balance += _amount;
        } else {
            require(IERC20(_tokenAddress).transferFrom(msg.sender, address(this), _amount), ""Transfer failed"");
            tokens[_tokenAddress].balance += _amount;
        }
        liquidity[msg.sender][_tokenAddress] += _amount;
        totalLiquidity += _amount;
        emit AddLiquidity(msg.sender, _tokenAddress, _amount);
    }

    function removeLiquidity(address _tokenAddress, uint256 _amount) public {
        require(liquidity[msg.sender][_tokenAddress] >= _amount, ""Insufficient liquidity"");
        if (_tokenAddress == address(0)) {
            (bool sent, ) = msg.sender.call{value: _amount}("""");
            require(sent, ""Failed to send ETH"");
            tokens[address(0)].balance -= _amount;
        } else {
            require(IERC20(_tokenAddress).transfer(msg.sender, _amount), ""Transfer failed"");
            tokens[_tokenAddress].balance -= _amount;
        }
        liquidity[msg.sender][_tokenAddress] -= _amount;
        totalLiquidity -= _amount;
        emit RemoveLiquidity(msg.sender, _tokenAddress, _amount);
    }

    function swap(address _tokenIn, address _tokenOut, uint256 _amountIn) public payable {
        require(tokens[_tokenIn].decimals > 0 && tokens[_tokenOut].decimals > 0, ""Token not supported"");
        uint256 amountInWithFee = _amountIn * (10000 - FEE_RATE) / 10000;
        uint256 amountOut = (amountInWithFee * tokens[_tokenOut].balance) / (tokens[_tokenIn].balance + _amountIn);

        if (_tokenIn == address(0)) {
            require(msg.value == _amountIn, ""Incorrect ETH amount"");
            tokens[address(0)].balance += _amountIn;
        } else {
            require(IERC20(_tokenIn).transferFrom(msg.sender, address(this), _amountIn), ""Transfer failed"");
            tokens[_tokenIn].balance += _amountIn;
        }

        if (_tokenOut == address(0)) {
            (bool sent, ) = msg.sender.call{value: amountOut}("""");
            require(sent, ""Failed to send ETH"");
            tokens[address(0)].balance -= amountOut;
        } else {
            require(IERC20(_tokenOut).transfer(msg.sender, amountOut), ""Transfer failed"");
            tokens[_tokenOut].balance -= amountOut;
        }

        emit Swap(msg.sender, _tokenOut, _amountIn, amountOut);
    }
}

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}",contract_20.sol
Create a smart contract that accurately calculates logarithmic values for specific input values. Utilize the provided table of constants and implement a function that takes an unsigned integer as input and returns the corresponding logarithmic value. Ensure that the implementation seamlessly integrates with the existing code and utilizes safe arithmetic operations. Include relevant documentation comments and provide examples of how to use the contract.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract LogarithmCalculator {
    // Constants for logarithmic calculation
    uint256 constant A = 1000000; // Adjust as needed
    uint256 constant B = 2000000; // Adjust as needed
    uint256 constant C = 3000000; // Adjust as needed

    /**
     * @dev Calculates the logarithmic value of a given unsigned integer.
     * @param input The unsigned integer for which the logarithmic value is to be calculated.
     * @return The logarithmic value of the input.
     */
    function calculateLogarithm(uint256 input) public pure returns (uint256) {
        require(input > 0, ""Input must be greater than zero"");

        // Simple logarithmic approximation using constants
        uint256 logValue = A * input / (B + input) + C;

        return logValue;
    }
}
```

This contract provides a simple approximation of a logarithmic function using constants `A`, `B`, and `C`. The `calculateLogarithm` function takes an unsigned integer as input and returns an approximated logarithmic value. The constants should be adjusted based on the specific logarithmic function you intend to approximate.",contract_21.sol
"Create a smart contract that allows for token minting and burning, with approval and allowance management. The contract should include functions for getting the token name, symbol, decimal precision, total supply, and balance. Implement a system for transferring tokens between addresses, with allowance management for approving and revoking spending limits. Ensure the contract has a clear and consistent interface for users.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    string private _name;
    string private _symbol;
    uint8 private _decimals;
    uint256 private _totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory name_, string memory symbol_, uint8 decimals_) {
        _name = name_;
        _symbol = symbol_;
        _decimals = decimals_;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);
        return true;
    }

    function mint(address account, uint256 amount) public {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function burn(uint256 amount) public {
        _burn(msg.sender, amount);
    }

    function burnFrom(address account, uint256 amount) public {
        uint256 decreasedAllowance = allowance(account, msg.sender) - amount;
        _approve(account, msg.sender, decreasedAllowance);
        _burn(account, amount);
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _burn(address account, uint256 amount) internal {
        require(account != address(0), ""ERC20: burn from the zero address"");

        _balances[account] -= amount;
        _totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }
}",contract_22.sol
Create a smart contract for managing lending and withdrawing tokens. The contract should have separate functions for depositing and withdrawing tokens. Implement a mechanism to prevent reentrancy attacks. Utilize Openzeppelin's libraries for proxy and clone contracts. Include interfaces for lending and admin facets. Ensure the contract follows best practices for coding and security.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract LendingContract {
    address public admin;
    mapping(address => uint256) public balances;
    bool internal locked;

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Not admin"");
        _;
    }

    modifier noReentrancy() {
        require(!locked, ""Reentrant call"");
        locked = true;
        _;
        locked = false;
    }

    constructor() {
        admin = msg.sender;
    }

    function deposit(uint256 amount) external noReentrancy {
        balances[msg.sender] += amount;
        // Assuming ERC20 transfer from msg.sender to this contract
        // ERC20(tokenAddress).transferFrom(msg.sender, address(this), amount);
    }

    function withdraw(uint256 amount) external noReentrancy {
        require(balances[msg.sender] >= amount, ""Insufficient balance"");
        balances[msg.sender] -= amount;
        // Assuming ERC20 transfer from this contract to msg.sender
        // ERC20(tokenAddress).transfer(msg.sender, amount);
    }

    function changeAdmin(address newAdmin) external onlyAdmin {
        admin = newAdmin;
    }
}

interface ILendingFacet {
    function deposit(uint256 amount) external;
    function withdraw(uint256 amount) external;
}

interface IAdminFacet {
    function changeAdmin(address newAdmin) external;
}",contract_23.sol
"Create a smart contract that provides functionality similar to OpenZeppelin's Pausable and Ownable contracts. The contract should include functions to Pause/Unpause the contract, TransferOwnership, and RenounceOwnership. Implement all necessary variables and modifiers. Provide a general overview of how the contract's functionality works.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract PausableOwnable {
    address private _owner;
    bool private _paused;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event Paused(address account);
    event Unpaused(address account);

    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    modifier whenNotPaused() {
        require(!_paused, ""Pausable: paused"");
        _;
    }

    modifier whenPaused() {
        require(_paused, ""Pausable: not paused"");
        _;
    }

    constructor() {
        _owner = msg.sender;
        _paused = false;
    }

    function owner() public view returns (address) {
        return _owner;
    }

    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }

    function paused() public view returns (bool) {
        return _paused;
    }

    function pause() public onlyOwner whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    function unpause() public onlyOwner whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}
```

### Overview of Contract Functionality

1. **Ownership Management:**
   - The contract starts with an owner, which is set to the deployer of the contract.
   - The `onlyOwner` modifier restricts certain functions to be called only by the owner.
   - The `renounceOwnership` function allows the current owner to relinquish control of the contract.
   - The `transferOwnership` function allows the current owner to transfer ownership to a new address.

2. **Pausable Functionality:**
   - The contract can be paused and unpaused, which affects all functions that use the `whenNotPaused` or `whenPaused` modifiers.
   - The `pause` function can be called by the owner to pause the contract, and the `unpause` function can be called by the owner to unpause it.
   - The `paused` function allows anyone to check the current pause status of the contract.

This contract combines the functionalities of ownership management and pausing mechanisms, providing a robust foundation for contracts that need these features.",contract_24.sol
Create a smart contract that allows for token burning and upgrading. The contract should inherit from the StandardToken contract and include functions to modify the total supply and balance of addresses. It should also include functions to approve and add allowance for specific spenders. The contract should emit events to track these actions. Focus on implementing the necessary logic for token burning and upgrading without overcomplicating the contract with unnecessary features.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract StandardToken {
    mapping(address => uint256) internal _balances;
    mapping(address => mapping(address => uint256)) internal _allowances;
    uint256 internal _totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    function _transfer(address from, address to, uint256 value) internal {
        require(to != address(0), ""Transfer to the zero address"");
        _balances[from] -= value;
        _balances[to] += value;
        emit Transfer(from, to, value);
    }

    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    function _approve(address owner, address spender, uint256 value) internal {
        require(spender != address(0), ""Approve to the zero address"");
        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        _transfer(from, to, value);
        _approve(from, msg.sender, _allowances[from][msg.sender] - value);
        return true;
    }
}

contract BurnableUpgradeableToken is StandardToken {
    event Burn(address indexed burner, uint256 value);
    event Upgrade(address indexed upgrader, uint256 value);

    function burn(uint256 value) public {
        _burn(msg.sender, value);
    }

    function _burn(address account, uint256 value) internal {
        require(account != address(0), ""Burn from the zero address"");
        _totalSupply -= value;
        _balances[account] -= value;
        emit Burn(account, value);
        emit Transfer(account, address(0), value);
    }

    function upgrade(uint256 value) public {
        _upgrade(msg.sender, value);
    }

    function _upgrade(address account, uint256 value) internal {
        require(account != address(0), ""Upgrade from the zero address"");
        _totalSupply += value;
        _balances[account] += value;
        emit Upgrade(account, value);
        emit Transfer(address(0), account, value);
    }
}",contract_25.sol
Create a smart contract that restricts access to certain functions based on the operator's role. The contract should have an `operator` variable and an `operator` function that returns the current operator. Implement a function to transfer the operator role to a new address and another function to check if a user is the current operator. The contract should also have events for operator changes and notifications for certain actions.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract OperatorRole {
    address public operator;

    event OperatorTransferred(address indexed previousOperator, address indexed newOperator);
    event ActionNotification(string message);

    modifier onlyOperator() {
        require(msg.sender == operator, ""Caller is not the operator"");
        _;
    }

    constructor() {
        operator = msg.sender;
        emit OperatorTransferred(address(0), operator);
    }

    function getOperator() public view returns (address) {
        return operator;
    }

    function transferOperator(address newOperator) public onlyOperator {
        require(newOperator != address(0), ""New operator is the zero address"");
        emit OperatorTransferred(operator, newOperator);
        operator = newOperator;
    }

    function isOperator(address account) public view returns (bool) {
        return account == operator;
    }

    function notifyAction(string memory message) public onlyOperator {
        emit ActionNotification(message);
    }
}",contract_26.sol
"Create a smart contract that builds upon the OpenZeppelin Context contract and integrates ERC20 token management functionality. The contract should enable token transfer, approval, and balance verification. Implement SafeMath for arithmetic operations and Address library for low-level function calls. Focus on maintainable and readable code structure.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, ""SafeMath: modulo by zero"");
        return a % b;
    }
}

library Address {
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, ""Address: insufficient balance"");
        (bool success, ) = recipient.call{ value: amount }("""");
        require(success, ""Address: unable to send value, recipient may have reverted"");
    }

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, ""Address: low-level call failed"");
    }

    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, ""Address: low-level call with value failed"");
    }

    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, ""Address: insufficient balance for call"");
        require(isContract(target), ""Address: call to non-contract"");
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            if (returndata.length > 0) {
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

contract ERC20 is Context {
    using SafeMath for uint256;
    using Address for address;

    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;

    string private _name;
    string private _symbol;
    uint8 private _decimals;
    uint256 private _totalSupply;

    constructor (string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
        _decimals = 18;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, ""ERC20: transfer amount exceeds allowance""));
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, ""ERC20: decreased allowance below zero""));
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _balances[sender] = _balances[sender].sub(amount, ""ERC20: transfer amount exceeds balance"");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) internal {
        require(account != address(0), ""ERC20: burn from the zero address"");

        _balances[account] = _balances[account].sub(amount, ""ERC20: burn amount exceeds balance"");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}",contract_27.sol
"Create a smart contract that builds upon the EtherCartel example code. The new contract should allow users to collect and sell drugs, buy drugs, and manage their kilos. The contract should also include a function to seed the market with a specified number of drugs. The contract should handle funds transferred and include logic to calculate revenue shares and referral rewards.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DrugMarket {
    struct Drug {
        uint256 price;
        uint256 quantity;
    }

    mapping(address => uint256) public balances;
    mapping(address => uint256) public kilos;
    mapping(address => uint256) public referralRewards;
    Drug public drug;
    address public owner;
    uint256 public marketDrugQuantity;

    event BoughtDrug(address indexed buyer, uint256 quantity);
    event SoldDrug(address indexed seller, uint256 quantity);
    event MarketSeeded(uint256 quantity);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the owner"");
        _;
    }

    constructor(uint256 initialPrice, uint256 initialQuantity) {
        owner = msg.sender;
        drug = Drug(initialPrice, initialQuantity);
        marketDrugQuantity = initialQuantity;
    }

    function seedMarket(uint256 quantity) external onlyOwner {
        marketDrugQuantity += quantity;
        emit MarketSeeded(quantity);
    }

    function buyDrug(uint256 quantity, address referral) external payable {
        require(quantity <= marketDrugQuantity, ""Not enough drugs in market"");
        uint256 totalCost = drug.price * quantity;
        require(msg.value >= totalCost, ""Insufficient funds"");

        balances[msg.sender] += quantity;
        marketDrugQuantity -= quantity;
        kilos[msg.sender] += quantity;

        if (referral != address(0) && referral != msg.sender) {
            uint256 referralReward = totalCost / 10; // 10% referral reward
            referralRewards[referral] += referralReward;
            balances[owner] += totalCost - referralReward;
        } else {
            balances[owner] += totalCost;
        }

        emit BoughtDrug(msg.sender, quantity);
    }

    function sellDrug(uint256 quantity) external {
        require(kilos[msg.sender] >= quantity, ""Not enough kilos"");
        uint256 totalRevenue = drug.price * quantity;

        kilos[msg.sender] -= quantity;
        marketDrugQuantity += quantity;
        balances[msg.sender] -= quantity;
        balances[msg.sender] += totalRevenue;

        emit SoldDrug(msg.sender, quantity);
    }

    function withdraw() external {
        uint256 amount = balances[msg.sender];
        require(amount > 0, ""No balance to withdraw"");
        balances[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
    }

    function withdrawReferralRewards() external {
        uint256 amount = referralRewards[msg.sender];
        require(amount > 0, ""No referral rewards to withdraw"");
        referralRewards[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
    }
}",contract_28.sol
"Create a timelock smart contract that enables scheduling of transactions at a specific delay. The contract should include features for setting an admin, pending admin, and delay. Implement methods for queuing and canceling transactions, as well as functions for administering the admin and pending admin roles. The contract should restrict access to specific functions, ensuring that only authorized users can initiate actions.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Timelock {
    uint256 public constant MINIMUM_DELAY = 1 hours;
    uint256 public constant MAXIMUM_DELAY = 30 days;
    uint256 public constant GRACE_PERIOD = 14 days;

    address public admin;
    address public pendingAdmin;
    uint256 public delay;

    mapping(bytes32 => bool) public queuedTransactions;

    event NewAdmin(address indexed newAdmin);
    event NewPendingAdmin(address indexed newPendingAdmin);
    event NewDelay(uint256 indexed newDelay);
    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);
    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);
    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Timelock: Caller is not the admin"");
        _;
    }

    constructor(uint256 _delay) {
        require(_delay >= MINIMUM_DELAY && _delay <= MAXIMUM_DELAY, ""Timelock: Invalid delay"");
        admin = msg.sender;
        delay = _delay;
    }

    function setDelay(uint256 _delay) public onlyAdmin {
        require(_delay >= MINIMUM_DELAY && _delay <= MAXIMUM_DELAY, ""Timelock: Invalid delay"");
        delay = _delay;
        emit NewDelay(_delay);
    }

    function acceptAdmin() public {
        require(msg.sender == pendingAdmin, ""Timelock: Caller is not the pending admin"");
        admin = pendingAdmin;
        pendingAdmin = address(0);
        emit NewAdmin(admin);
    }

    function setPendingAdmin(address _pendingAdmin) public onlyAdmin {
        pendingAdmin = _pendingAdmin;
        emit NewPendingAdmin(_pendingAdmin);
    }

    function queueTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 eta) public onlyAdmin returns (bytes32) {
        require(eta >= block.timestamp + delay, ""Timelock: Estimated execution block is before current block"");
        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));
        queuedTransactions[txHash] = true;
        emit QueueTransaction(txHash, target, value, signature, data, eta);
        return txHash;
    }

    function cancelTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 eta) public onlyAdmin {
        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));
        queuedTransactions[txHash] = false;
        emit CancelTransaction(txHash, target, value, signature, data, eta);
    }

    function executeTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 eta) public payable onlyAdmin returns (bytes memory) {
        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));
        require(queuedTransactions[txHash], ""Timelock: Transaction hasn't been queued"");
        require(block.timestamp >= eta, ""Timelock: Transaction hasn't surpassed time lock"");
        require(block.timestamp <= eta + GRACE_PERIOD, ""Timelock: Transaction is stale"");

        queuedTransactions[txHash] = false;

        bytes memory callData;
        if (bytes(signature).length == 0) {
            callData = data;
        } else {
            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);
        }

        (bool success, bytes memory returnData) = target.call{value: value}(callData);
        require(success, ""Timelock: Transaction execution reverted."");

        emit ExecuteTransaction(txHash, target, value, signature, data, eta);
        return returnData;
    }
}",contract_29.sol
"Develop a smart contract that implements an ERC20 token with an owner. The contract should have a name and symbol, and have the ability to transfer tokens. Include a functionality to approve and increase allowance for other accounts. Implement token transfer, approval, and disapproval logic. The contract should be inheritable from OpenZeppelin's ERC20 and Ownable contracts.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;
    uint256 private _totalSupply;
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
        _decimals = 18;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) internal {
        require(account != address(0), ""ERC20: burn from the zero address"");

        _balances[account] -= amount;
        _totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(_owner == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract MyToken is ERC20, Ownable {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {
        _mint(msg.sender, 1000000 * (10 ** uint256(decimals())));
    }

    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }

    function burn(uint256 amount) public {
        _burn(msg.sender, amount);
    }
}",contract_30.sol
"Develop a smart contract that enables the creation, transfer, and management of digital assets. The contract should implement the IERC721 interface and support functions for retrieving the balance of assets, retrieving the owner of an asset, approving and transferring assets, and retrieving the approved operator for an asset. The contract should also provide metadata about the assets, including the name, symbol, and token URI. Finally, the contract should emit events to track changes in asset ownership and approval.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC721 {
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function balanceOf(address owner) external view returns (uint256 balance);
    function ownerOf(uint256 tokenId) external view returns (address owner);
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    function transferFrom(address from, address to, uint256 tokenId) external;
    function approve(address to, uint256 tokenId) external;
    function getApproved(uint256 tokenId) external view returns (address operator);
    function setApprovalForAll(address operator, bool _approved) external;
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}

contract DigitalAsset is IERC721 {
    string private _name;
    string private _symbol;
    uint256 private _tokenIdCounter;

    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;
    mapping(uint256 => string) private _tokenURIs;

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function name() external view returns (string memory) {
        return _name;
    }

    function symbol() external view returns (string memory) {
        return _symbol;
    }

    function tokenURI(uint256 tokenId) external view returns (string memory) {
        require(_exists(tokenId), ""Token does not exist"");
        return _tokenURIs[tokenId];
    }

    function balanceOf(address owner) external view override returns (uint256) {
        require(owner != address(0), ""Owner is zero address"");
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) external view override returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), ""Token does not exist"");
        return owner;
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) external override {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""Not approved or owner"");
        _safeTransfer(from, to, tokenId, """");
    }

    function transferFrom(address from, address to, uint256 tokenId) external override {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""Not approved or owner"");
        _transfer(from, to, tokenId);
    }

    function approve(address to, uint256 tokenId) external override {
        address owner = ownerOf(tokenId);
        require(to != owner, ""Approval to current owner"");
        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), ""Not approved"");
        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    function getApproved(uint256 tokenId) external view override returns (address) {
        require(_exists(tokenId), ""Token does not exist"");
        return _tokenApprovals[tokenId];
    }

    function setApprovalForAll(address operator, bool approved) external override {
        require(operator != msg.sender, ""Approval to caller"");
        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function isApprovedForAll(address owner, address operator) public view override returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal {
        _transfer(from, to, tokenId);
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        require(ownerOf(tokenId) == from, ""Not owner"");
        require(to != address(0), ""Transfer to zero address"");
        _approve(address(0), tokenId);
        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;
        emit Transfer(from, to, tokenId);
    }

    function _approve(address to, uint256 tokenId) internal {
        _tokenApprovals[tokenId] = to;
        emit Approval(ownerOf(tokenId), to, tokenId);
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return _owners[tokenId] != address(0);
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), ""Token does not exist"");
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    function createAsset(address to, string memory uri) external {
        require(to != address(0), ""Mint to zero address"");
        uint256 tokenId = _tokenIdCounter++;
        _balances[to] += 1;
        _owners[tokenId] = to;
        _tokenURIs[tokenId] = uri;
        emit Transfer(address(0), to, tokenId);
    }
}",contract_31.sol
"Create a smart contract that allows for ownership transfer and token permissioned transfer. The contract should inherit from OpenZeppelin's owned base contract, with functions for transferring ownership and permitting token transfers. The contract should include logic for checking both ownership and permit permissions. Utilize the SafeERC20 library for ensuring safe token transfers.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }
}

library Address {
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}

library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            ""SafeERC20: approve from non-zero to non-zero allowance""
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function callOptionalReturn(IERC20 token, bytes memory data) private {
        require(address(token).isContract(), ""SafeERC20: call to non-contract"");

        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, ""SafeERC20: low-level call failed"");

        if (returndata.length > 0) {
            require(abi.decode(returndata, (bool)), ""SafeERC20: ERC20 operation did not succeed"");
        }
    }
}

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(isOwner(), ""Ownable: caller is not the owner"");
        _;
    }

    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract TokenTransfer is Ownable {
    using SafeERC20 for IERC20;

    mapping(address => bool) public permittedTokens;

    function transferOwnership(address newOwner) public override onlyOwner {
        super.transferOwnership(newOwner);
    }

    function permitToken(address token) public onlyOwner {
        permittedTokens[token] = true;
    }

    function revokeToken(address token) public onlyOwner {
        permittedTokens[token] = false;
    }

    function transferToken(IERC20 token, address to, uint256 amount) public onlyOwner {
        require(permittedTokens[address(token)], ""TokenTransfer: token not permitted"");
        token.safeTransfer(to, amount);
    }
}",contract_32.sol
"Create a smart contract that demonstrates inheritance and function visibility. The contract should have a base contract (Base) that defines private, internal, and public functions. The child contract should override internal functions and call them. Ensure that private functions are inaccessible outside the contract. The contract should also include public and internal state variables. Write test functions to demonstrate the functionality of each type of function.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Base {
    uint public publicVar;
    uint internal internalVar;

    function publicFunction() public virtual {
        internalFunction();
    }

    function internalFunction() internal virtual {
        internalVar = 10;
    }

    function privateFunction() private {
        publicVar = 20;
    }
}

contract Child is Base {
    function publicFunction() public override {
        internalFunction();
    }

    function internalFunction() internal override {
        internalVar = 30;
    }

    function testPublicFunction() public {
        publicFunction();
    }

    function testInternalFunction() public {
        internalFunction();
    }

    function testPrivateFunction() public {
        // This will cause a compilation error because privateFunction is private
        // privateFunction();
    }
}",contract_33.sol
"Create a smart contract that manages buy, sell, transfer, and game fees, with the ability to set and retrieve these fees. The contract should use a counter to track revisions and emit events when fees are updated. It should also enforce limits on total fees for buy, sell, and transfer operations.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract FeeManager {
    struct Fees {
        uint256 buyFee;
        uint256 sellFee;
        uint256 transferFee;
        uint256 gameFee;
    }

    Fees public currentFees;
    uint256 public revisionCount;

    event FeesUpdated(uint256 indexed revision, uint256 buyFee, uint256 sellFee, uint256 transferFee, uint256 gameFee);

    constructor(uint256 _buyFee, uint256 _sellFee, uint256 _transferFee, uint256 _gameFee) {
        require(_buyFee + _sellFee + _transferFee <= 10000, ""Total fees exceed limit"");
        currentFees = Fees(_buyFee, _sellFee, _transferFee, _gameFee);
        revisionCount = 1;
        emit FeesUpdated(revisionCount, _buyFee, _sellFee, _transferFee, _gameFee);
    }

    function setFees(uint256 _buyFee, uint256 _sellFee, uint256 _transferFee, uint256 _gameFee) external {
        require(_buyFee + _sellFee + _transferFee <= 10000, ""Total fees exceed limit"");
        currentFees = Fees(_buyFee, _sellFee, _transferFee, _gameFee);
        revisionCount += 1;
        emit FeesUpdated(revisionCount, _buyFee, _sellFee, _transferFee, _gameFee);
    }

    function getFees() external view returns (uint256, uint256, uint256, uint256) {
        return (currentFees.buyFee, currentFees.sellFee, currentFees.transferFee, currentFees.gameFee);
    }
}",contract_34.sol
"Create a smart contract that represents an ERC20 token. The contract should manage token balances and allow for the transfer of tokens. Users should be able to query the balance of their account and approve or disapprove specific amounts for spending. Implement event listeners for token transfers and approvals. Consider implementing features for token creation, naming, and tracking of supply.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    mapping(address => uint256) private balances;
    mapping(address => mapping(address => uint256)) private allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _initialSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _initialSupply * 10 ** uint256(_decimals);
        balances[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value, ""Insufficient balance"");
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(balances[_from] >= _value, ""Insufficient balance"");
        require(allowances[_from][msg.sender] >= _value, ""Allowance too low"");
        balances[_from] -= _value;
        balances[_to] += _value;
        allowances[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowances[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowances[_owner][_spender];
    }
}",contract_35.sol
"Develop a smart contract that mimics the behavior of the IPancakePair interface. This contract should be able to handle token minting, burning, swapping, and syncing. Ensure the contract accurately manages the token reserves and pricing information. Include basic input validation and error handling.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract PancakePair {
    address public token0;
    address public token1;

    uint112 private reserve0;           // uses single storage slot, accessible via getReserves
    uint112 private reserve1;           // uses single storage slot, accessible via getReserves
    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves

    uint public price0CumulativeLast;
    uint public price1CumulativeLast;

    event Mint(address indexed sender, uint amount0, uint amount1);
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    constructor(address _token0, address _token1) {
        token0 = _token0;
        token1 = _token1;
    }

    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {
        _reserve0 = reserve0;
        _reserve1 = reserve1;
        _blockTimestampLast = blockTimestampLast;
    }

    function _safeTransfer(address token, address to, uint value) private {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'Transfer failed');
    }

    function mint(address to) external returns (uint liquidity) {
        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
        uint balance0 = IERC20(token0).balanceOf(address(this));
        uint balance1 = IERC20(token1).balanceOf(address(this));
        uint amount0 = balance0 - _reserve0;
        uint amount1 = balance1 - _reserve1;

        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
        if (_totalSupply == 0) {
            liquidity = Math.sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY;
           _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens
        } else {
            liquidity = Math.min(amount0 * _totalSupply / _reserve0, amount1 * _totalSupply / _reserve1);
        }
        require(liquidity > 0, 'Insufficient liquidity minted');
        _mint(to, liquidity);

        _update(balance0, balance1, _reserve0, _reserve1);
        emit Mint(msg.sender, amount0, amount1);
    }

    function burn(address to) external returns (uint amount0, uint amount1) {
        uint balance0 = IERC20(token0).balanceOf(address(this));
        uint balance1 = IERC20(token1).balanceOf(address(this));
        uint liquidity = balanceOf[address(this)];

        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
        amount0 = liquidity * balance0 / _totalSupply; // using balances ensures pro-rata distribution
        amount1 = liquidity * balance1 / _totalSupply; // using balances ensures pro-rata distribution
        require(amount0 > 0 && amount1 > 0, 'Insufficient liquidity burned');
        _burn(address(this), liquidity);
        _safeTransfer(token0, to, amount0);
        _safeTransfer(token1, to, amount1);
        balance0 = IERC20(token0).balanceOf(address(this));
        balance1 = IERC20(token1).balanceOf(address(this));

        _update(balance0, balance1, reserve0, reserve1);
        emit Burn(msg.sender, amount0, amount1, to);
    }

    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external {
        require(amount0Out > 0 || amount1Out > 0, 'Insufficient output amount');
        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'Insufficient liquidity');

        uint balance0;
        uint balance1;
        { // scope for _token{0,1}, avoids stack too deep errors
        address _token0 = token0;
        address _token1 = token1;
        require(to != _token0 && to != _token1, 'Invalid to');
        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens
        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens
        if (data.length > 0) IPancakeCallee(to).pancakeCall(msg.sender, amount0Out, amount1Out, data);
        balance0 = IERC20(_token0).balanceOf(address(this));
        balance1 = IERC20(_token1).balanceOf(address(this));
        }

        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;
        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;
        require(amount0In > 0 || amount1In > 0, 'Insufficient input amount');
        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors
        uint balance0Adjusted = balance0 * 1000 - amount0In * 3;
        uint balance1Adjusted = balance1 * 1000 - amount1In * 3;
        require(balance0Adjusted * balance1Adjusted >= uint(_reserve0) * _reserve1 * 1000000, 'K');
        }

        _update(balance0, balance1, _reserve0, _reserve1);
        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
    }

    function skim(address to) external {
        address _token0 = token0; // gas savings
        address _token1 = token1; // gas savings
        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)) - reserve0);
        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)) - reserve1);
    }

    function sync() external {
        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);
    }

    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {
        require(balance0 <= type(uint112).max && balance1 <= type(uint112).max, 'Overflow');
        uint32 blockTimestamp = uint32(block.timestamp % 2**32);
        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired
        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {
            // * never overflows, and + overflow is desired
            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;
            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;
        }
        reserve0 = uint112(balance0);
        reserve1 = uint112(balance1);
        blockTimestampLast = blockTimestamp;
        emit Sync(reserve0, reserve1);
    }

    function _mint(address to, uint value) private {
        totalSupply += value;
        balanceOf[to] += value;
        emit Transfer(address(0), to, value);
    }

    function _burn(address from, uint value) private {
        balanceOf[from] -= value;
        totalSupply -= value;
        emit Transfer(from, address(0), value);
    }

    uint256 private constant MINIMUM_LIQUIDITY = 10**3;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
}",contract_36.sol
"Create a smart contract that allows users to transfer a token, check their balance, and approve token transfers. The contract should utilize the IERC20 interface and inherit from OpenZeppelin's Context contract. The implementation should include SafeMath library functions for arithmetic operations and Address library functions for sending values and making function calls. Consider potential reentrancy attacks and optimize for gas efficiency.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }
}

library Address {
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, ""Address: insufficient balance"");
        (bool success, ) = recipient.call{ value: amount }("""");
        require(success, ""Address: unable to send value, recipient may have reverted"");
    }

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, ""Address: low-level call failed"");
    }

    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, ""Address: low-level call with value failed"");
    }

    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, ""Address: insufficient balance for call"");
        require(isContract(target), ""Address: call to non-contract"");
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            if (returndata.length > 0) {
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

contract ERC20 is Context, IERC20 {
    using SafeMath for uint256;
    using Address for address;

    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    constructor (string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
        _decimals = 18;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, ""ERC20: transfer amount exceeds allowance""));
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, ""ERC20: decreased allowance below zero""));
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _beforeTokenTransfer(sender, recipient, amount);

        _balances[sender] = _balances[sender].sub(amount, ""ERC20: transfer amount exceeds balance"");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: burn from the zero address"");

        _beforeTokenTransfer(account, address(0), amount);

        _balances[account] = _balances[account].sub(amount, ""ERC20: burn amount exceeds balance"");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }
}",contract_37.sol
"Create a smart contract that follows the ERC721 standard. The contract should have functions to retrieve the balance of an owner, check if a token exists, approve an operator, and transfer a token. The contract should also have a mapping to store the owner of each token. The contract should use the SafeMath library for arithmetic operations and the AddressUtils library for address utilities. The contract should have a modifier to check if the sender is the owner of the token.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC721 {
    using SafeMath for uint256;
    using AddressUtils for address;

    mapping(uint256 => address) private _tokenOwner;
    mapping(address => uint256) private _ownedTokensCount;
    mapping(uint256 => address) private _tokenApprovals;

    modifier onlyOwnerOf(uint256 _tokenId) {
        require(ownerOf(_tokenId) == msg.sender, ""Not the owner of the token"");
        _;
    }

    function balanceOf(address _owner) public view returns (uint256) {
        require(_owner != address(0), ""Owner query for the zero address"");
        return _ownedTokensCount[_owner];
    }

    function ownerOf(uint256 _tokenId) public view returns (address) {
        address owner = _tokenOwner[_tokenId];
        require(owner != address(0), ""Owner query for nonexistent token"");
        return owner;
    }

    function exists(uint256 _tokenId) public view returns (bool) {
        return _tokenOwner[_tokenId] != address(0);
    }

    function approve(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {
        _tokenApprovals[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }

    function transferFrom(address _from, address _to, uint256 _tokenId) public {
        require(_from != address(0), ""Transfer from the zero address"");
        require(_to != address(0), ""Transfer to the zero address"");
        require(_from == msg.sender || _tokenApprovals[_tokenId] == msg.sender, ""Not approved to transfer"");
        require(ownerOf(_tokenId) == _from, ""From address is not the owner"");

        _ownedTokensCount[_from] = _ownedTokensCount[_from].sub(1);
        _ownedTokensCount[_to] = _ownedTokensCount[_to].add(1);
        _tokenOwner[_tokenId] = _to;

        emit Transfer(_from, _to, _tokenId);
    }

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }
}

library AddressUtils {
    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}",contract_38.sol
Develop a Solidity smart contract that enables a staking warm-up mechanism. The contract should include: (1) Immutable addresses for staking and SOHM; (2) A constructor to initialize these addresses; (3) A retrieve function accessible only to the staking address; (4) This function should distribute specified amounts from SOHM to authorized stakers; and (5) Emit a transfer event for the transferred amount. The contract should adhere to standard best practices and follow proper smart contract development guidelines.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract StakingWarmUp {
    address public immutable stakingAddress;
    address public immutable sOHMAddress;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor(address _stakingAddress, address _sOHMAddress) {
        require(_stakingAddress != address(0), ""Invalid staking address"");
        require(_sOHMAddress != address(0), ""Invalid sOHM address"");
        stakingAddress = _stakingAddress;
        sOHMAddress = _sOHMAddress;
    }

    modifier onlyStaking() {
        require(msg.sender == stakingAddress, ""Only staking contract can call this function"");
        _;
    }

    function retrieve(address recipient, uint256 amount) external onlyStaking {
        require(recipient != address(0), ""Invalid recipient address"");
        require(amount > 0, ""Amount must be greater than zero"");

        // Assuming sOHM is an ERC20 token
        (bool success, bytes memory data) = sOHMAddress.call(
            abi.encodeWithSignature(""transfer(address,uint256)"", recipient, amount)
        );
        require(success && (data.length == 0 || abi.decode(data, (bool))), ""Transfer failed"");

        emit Transfer(sOHMAddress, recipient, amount);
    }
}",contract_39.sol
"Create a smart contract that outlines a token transfer process, allowing users to approve and withdraw tokens. The contract should include functions for checking token balances, approving transfers, and transferring tokens. Incorporate event emitting for transactions. Implement a basic security measure to prevent unauthorized transactions.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TokenTransfer {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        _transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], ""Insufficient balance"");
        require(_value <= allowance[_from][msg.sender], ""Allowance exceeded"");
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    function _transfer(address _from, address _to, uint256 _value) internal {
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
    }
}",contract_40.sol
"Create a smart contract for managing ERC721 tokens, including minting, transferring, and burning tokens. The contract should be pauseable and log all token events. Implement logic for handling gas costs and rejecting failed transactions. Include functions for minting and burning tokens, as well as functions for transferring and withdrawing tokens. Utilize relevant inheritances and interfaces from existing ERC721 contracts, ensuring compatibility with other ERC721 token contracts. Provide a clear and organized Solidity code structure for this contract.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC721 {
    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function balanceOf(address owner) public view returns (uint256) {
        require(owner != address(0), ""ERC721: balance query for the zero address"");
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) public view returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), ""ERC721: owner query for nonexistent token"");
        return owner;
    }

    function approve(address to, uint256 tokenId) public {
        address owner = ownerOf(tokenId);
        require(to != owner, ""ERC721: approval to current owner"");
        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), ""ERC721: approve caller is not owner nor approved for all"");
        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    function getApproved(uint256 tokenId) public view returns (address) {
        require(_exists(tokenId), ""ERC721: approved query for nonexistent token"");
        return _tokenApprovals[tokenId];
    }

    function setApprovalForAll(address operator, bool approved) public {
        require(operator != msg.sender, ""ERC721: approve to caller"");
        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function isApprovedForAll(address owner, address operator) public view returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function transferFrom(address from, address to, uint256 tokenId) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _transfer(from, to, tokenId);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) public {
        safeTransferFrom(from, to, tokenId, """");
    }

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _safeTransfer(from, to, tokenId, data);
    }

    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return _owners[tokenId] != address(0);
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    function _safeMint(address to, uint256 tokenId) internal {
        _safeMint(to, tokenId, """");
    }

    function _safeMint(address to, uint256 tokenId, bytes memory data) internal {
        _mint(to, tokenId);
        require(_checkOnERC721Received(address(0), to, tokenId, data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _mint(address to, uint256 tokenId) internal {
        require(to != address(0), ""ERC721: mint to the zero address"");
        require(!_exists(tokenId), ""ERC721: token already minted"");
        _beforeTokenTransfer(address(0), to, tokenId);
        _balances[to] += 1;
        _owners[tokenId] = to;
        emit Transfer(address(0), to, tokenId);
    }

    function _burn(uint256 tokenId) internal {
        address owner = ownerOf(tokenId);
        _beforeTokenTransfer(owner, address(0), tokenId);
        _approve(address(0), tokenId);
        _balances[owner] -= 1;
        delete _owners[tokenId];
        emit Transfer(owner, address(0), tokenId);
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        require(ownerOf(tokenId) == from, ""ERC721: transfer of token that is not own"");
        require(to != address(0), ""ERC721: transfer to the zero address"");
        _beforeTokenTransfer(from, to, tokenId);
        _approve(address(0), tokenId);
        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;
        emit Transfer(from, to, tokenId);
    }

    function _approve(address to, uint256 tokenId) internal {
        _tokenApprovals[tokenId] = to;
        emit Approval(ownerOf(tokenId), to, tokenId);
    }

    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) internal returns (bool) {
        if (isContract(to)) {
            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data) returns (bytes4 retval) {
                return retval == IERC721Receiver.onERC721Received.selector;
            } catch (bytes memory reason) {
                if (reason.length == 0) {
                    revert(""ERC721: transfer to non ERC721Receiver implementer"");
                } else {
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        } else {
            return true;
        }
    }

    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal {}
}

interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}

contract Pausable {
    event Paused(address account);
    event Unpaused(address account);

    bool private _paused;

    constructor() {
        _paused = false;
    }

    function paused() public view returns (bool) {
        return _paused;
    }

    modifier whenNotPaused() {
        require(!_paused, ""Pausable: paused"");
        _;
    }

    modifier whenPaused() {
        require(_paused, ""Pausable: not paused"");
        _;
    }

    function _pause() internal whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    function _unpause() internal whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}

contract MyERC721 is ERC721, Pausable {
    string private _name;
    string private _symbol;

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function pause() public {
        _pause();
    }

    function unpause() public {
        _unpause();
    }

    function mint(address to, uint256 tokenId) public whenNotPaused {
        _safeMint(to, tokenId);
    }

    function burn(uint256 tokenId) public whenNotPaused {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""MyERC721: caller is not owner nor approved"");
        _burn(tokenId);
    }

    function transfer(address to, uint256 tokenId) public whenNotPaused {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""MyERC721: transfer caller is not owner nor approved"");
        _transfer(msg.sender, to, tokenId);
    }

    function withdrawTokens(address to, uint256 tokenId) public whenNotPaused {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""MyERC721: withdraw caller is not owner nor approved"");
        _transfer(msg.sender, to, tokenId);
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override whenNotPaused {
        super._beforeTokenTransfer(from, to, tokenId);
    }
}",contract_41.sol
"Create a Solidity smart contract for a NonStopTRX system that allows users to register, update weekly referral counts, and enter the cycle pool. The contract should have modifiers for the contract owner and owner. Define private functions for registering users, updating weekly referrals, and entering the cycle pool. Implement the logic for these functions using the provided contract code as a reference. Focus on implementing the necessary data structures and variables to store user information and track weekly referrals.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract NonStopTRX {
    address public owner;

    struct User {
        bool isRegistered;
        uint256 weeklyReferrals;
        bool inCyclePool;
    }

    mapping(address => User) private users;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier onlyRegistered() {
        require(users[msg.sender].isRegistered, ""User not registered"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function registerUser() external {
        require(!users[msg.sender].isRegistered, ""User already registered"");
        users[msg.sender] = User({
            isRegistered: true,
            weeklyReferrals: 0,
            inCyclePool: false
        });
    }

    function updateWeeklyReferrals(uint256 referrals) external onlyRegistered {
        users[msg.sender].weeklyReferrals = referrals;
    }

    function enterCyclePool() external onlyRegistered {
        require(!users[msg.sender].inCyclePool, ""User already in cycle pool"");
        users[msg.sender].inCyclePool = true;
    }

    function getUserInfo(address userAddress) external view returns (bool, uint256, bool) {
        User memory user = users[userAddress];
        return (user.isRegistered, user.weeklyReferrals, user.inCyclePool);
    }
}",contract_42.sol
"Create a smart contract that interacts with various interfaces to enable approval, allowance, and utility methods. The contract should be modular and well-documented. Focus on implementing the key functions and modules outlined in the provided code fragment.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }
}",contract_43.sol
"Develop a smart contract for a derivative investment platform that allows users to invest and withdraw funds. The contract should inherit from ERC20Extended and Ownable. Implement functions for investing, withdrawing, and updating the derivative status. Incorporate modifiers for ownership and access control. Utilize the SafeMath library for arithmetic operations.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Extended {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply;
        balanceOf[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }
}

contract Ownable {
    address public owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        owner = msg.sender;
        emit OwnershipTransferred(address(0), owner);
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""Invalid address"");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }
}

contract DerivativeInvestmentPlatform is ERC20Extended, Ownable {
    using SafeMath for uint256;

    enum DerivativeStatus { Active, Inactive }
    DerivativeStatus public status;

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalSupply)
        ERC20Extended(_name, _symbol, _decimals, _totalSupply)
    {
        status = DerivativeStatus.Active;
    }

    modifier onlyActive() {
        require(status == DerivativeStatus.Active, ""Derivative is inactive"");
        _;
    }

    function invest(uint256 amount) public onlyActive {
        require(amount > 0, ""Investment amount must be greater than zero"");
        balanceOf[msg.sender] = balanceOf[msg.sender].add(amount);
        totalSupply = totalSupply.add(amount);
        emit Transfer(address(0), msg.sender, amount);
    }

    function withdraw(uint256 amount) public onlyActive {
        require(amount > 0, ""Withdrawal amount must be greater than zero"");
        require(balanceOf[msg.sender] >= amount, ""Insufficient balance"");
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(amount);
        totalSupply = totalSupply.sub(amount);
        emit Transfer(msg.sender, address(0), amount);
    }

    function updateDerivativeStatus(DerivativeStatus newStatus) public onlyOwner {
        status = newStatus;
    }
}",contract_44.sol
"Implement a smart contract that allows for the creation and management of token markets. The contract should include features for adding, removing, and modifying tokens, as well as allowing traders to trade tokens. The contract should also include mechanisms for validating transactions and ensuring the integrity of the markets.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TokenMarket {
    struct Token {
        address tokenAddress;
        string name;
        string symbol;
        uint8 decimals;
    }

    struct Trade {
        address trader;
        address tokenAddress;
        uint256 amount;
        uint256 price;
        bool isBuy;
    }

    Token[] public tokens;
    Trade[] public trades;
    mapping(address => mapping(address => uint256)) public balances;

    event TokenAdded(address indexed tokenAddress, string name, string symbol, uint8 decimals);
    event TokenRemoved(address indexed tokenAddress);
    event TradeExecuted(address indexed trader, address indexed tokenAddress, uint256 amount, uint256 price, bool isBuy);

    modifier validToken(address _tokenAddress) {
        require(_tokenAddress != address(0), ""Invalid token address"");
        bool found = false;
        for (uint256 i = 0; i < tokens.length; i++) {
            if (tokens[i].tokenAddress == _tokenAddress) {
                found = true;
                break;
            }
        }
        require(found, ""Token not found"");
        _;
    }

    function addToken(address _tokenAddress, string memory _name, string memory _symbol, uint8 _decimals) public {
        tokens.push(Token(_tokenAddress, _name, _symbol, _decimals));
        emit TokenAdded(_tokenAddress, _name, _symbol, _decimals);
    }

    function removeToken(address _tokenAddress) public validToken(_tokenAddress) {
        for (uint256 i = 0; i < tokens.length; i++) {
            if (tokens[i].tokenAddress == _tokenAddress) {
                tokens[i] = tokens[tokens.length - 1];
                tokens.pop();
                emit TokenRemoved(_tokenAddress);
                break;
            }
        }
    }

    function executeTrade(address _tokenAddress, uint256 _amount, uint256 _price, bool _isBuy) public validToken(_tokenAddress) {
        require(_amount > 0, ""Amount must be greater than 0"");
        require(_price > 0, ""Price must be greater than 0"");

        if (_isBuy) {
            require(balances[msg.sender][address(0)] >= _amount * _price, ""Insufficient balance"");
            balances[msg.sender][address(0)] -= _amount * _price;
            balances[msg.sender][_tokenAddress] += _amount;
        } else {
            require(balances[msg.sender][_tokenAddress] >= _amount, ""Insufficient token balance"");
            balances[msg.sender][_tokenAddress] -= _amount;
            balances[msg.sender][address(0)] += _amount * _price;
        }

        trades.push(Trade(msg.sender, _tokenAddress, _amount, _price, _isBuy));
        emit TradeExecuted(msg.sender, _tokenAddress, _amount, _price, _isBuy);
    }

    function deposit() public payable {
        balances[msg.sender][address(0)] += msg.value;
    }

    function withdraw(uint256 _amount) public {
        require(balances[msg.sender][address(0)] >= _amount, ""Insufficient balance"");
        balances[msg.sender][address(0)] -= _amount;
        payable(msg.sender).transfer(_amount);
    }
}",contract_45.sol
"Create a Yearn V2 Vault smart contract that allows users to deposit and withdraw tokens, obtain the current price per share, and retrieve the underlying token address. The contract should inherit from IERC20 and conform to the OpenZeppelin ERC20 standard.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract YearnV2Vault is IERC20 {
    string public name = ""Yearn V2 Vault"";
    string public symbol = ""YV2"";
    uint8 public decimals = 18;
    uint256 private _totalSupply;
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    address public underlyingToken;
    uint256 public totalUnderlying;
    uint256 public pricePerShare;

    constructor(address _underlyingToken) {
        underlyingToken = _underlyingToken;
        pricePerShare = 1e18; // Initial price per share
    }

    function totalSupply() external view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) external view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) external override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) external view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) external override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    function deposit(uint256 amount) external {
        require(IERC20(underlyingToken).transferFrom(msg.sender, address(this), amount), ""Transfer failed"");
        uint256 shares = (amount * 1e18) / pricePerShare;
        _mint(msg.sender, shares);
        totalUnderlying += amount;
    }

    function withdraw(uint256 shares) external {
        uint256 amount = (shares * pricePerShare) / 1e18;
        require(IERC20(underlyingToken).transfer(msg.sender, amount), ""Transfer failed"");
        _burn(msg.sender, shares);
        totalUnderlying -= amount;
    }

    function getPricePerShare() external view returns (uint256) {
        return pricePerShare;
    }

    function getUnderlyingTokenAddress() external view returns (address) {
        return underlyingToken;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""Transfer from the zero address"");
        require(recipient != address(0), ""Transfer to the zero address"");

        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal {
        require(account != address(0), ""Mint to the zero address"");

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) internal {
        require(account != address(0), ""Burn from the zero address"");

        _balances[account] -= amount;
        _totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""Approve from the zero address"");
        require(spender != address(0), ""Approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}",contract_46.sol
"Create a contract that allows users to swap tokens, add/remove liquidity, and query reserves. Based on the IUniswapV2Router01 and IUniswapV2Router02 interfaces, implement the necessary functions without getting into the low-level implementation details. Provide general comments explaining the functionality.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TokenSwap {
    // Struct to hold token information
    struct Token {
        address tokenAddress;
        uint256 reserve;
    }

    // Mapping to store token pairs and their reserves
    mapping(address => mapping(address => Token)) public tokenPairs;

    // Event emitted when tokens are swapped
    event Swap(address indexed sender, uint256 amountIn, uint256 amountOut, address indexed tokenIn, address indexed tokenOut);

    // Event emitted when liquidity is added
    event AddLiquidity(address indexed provider, uint256 amountTokenA, uint256 amountTokenB, uint256 liquidity);

    // Event emitted when liquidity is removed
    event RemoveLiquidity(address indexed provider, uint256 amountTokenA, uint256 amountTokenB, uint256 liquidity);

    // Function to swap tokens
    function swapTokens(address tokenIn, address tokenOut, uint256 amountIn, uint256 amountOutMin) external {
        // Retrieve the reserves for the token pair
        Token storage tokenInReserve = tokenPairs[tokenIn][tokenOut];
        Token storage tokenOutReserve = tokenPairs[tokenOut][tokenIn];

        // Update reserves (simplified, no slippage or fee calculation)
        tokenInReserve.reserve += amountIn;
        tokenOutReserve.reserve -= amountOutMin;

        // Emit swap event
        emit Swap(msg.sender, amountIn, amountOutMin, tokenIn, tokenOut);
    }

    // Function to add liquidity
    function addLiquidity(address tokenA, address tokenB, uint256 amountA, uint256 amountB) external {
        // Retrieve the reserves for the token pair
        Token storage tokenAReserve = tokenPairs[tokenA][tokenB];
        Token storage tokenBReserve = tokenPairs[tokenB][tokenA];

        // Update reserves
        tokenAReserve.reserve += amountA;
        tokenBReserve.reserve += amountB;

        // Emit add liquidity event
        emit AddLiquidity(msg.sender, amountA, amountB, amountA + amountB);
    }

    // Function to remove liquidity
    function removeLiquidity(address tokenA, address tokenB, uint256 liquidity) external {
        // Retrieve the reserves for the token pair
        Token storage tokenAReserve = tokenPairs[tokenA][tokenB];
        Token storage tokenBReserve = tokenPairs[tokenB][tokenA];

        // Calculate amounts to remove based on liquidity (simplified)
        uint256 amountA = liquidity / 2;
        uint256 amountB = liquidity / 2;

        // Update reserves
        tokenAReserve.reserve -= amountA;
        tokenBReserve.reserve -= amountB;

        // Emit remove liquidity event
        emit RemoveLiquidity(msg.sender, amountA, amountB, liquidity);
    }

    // Function to query reserves
    function getReserves(address tokenA, address tokenB) external view returns (uint256 reserveA, uint256 reserveB) {
        reserveA = tokenPairs[tokenA][tokenB].reserve;
        reserveB = tokenPairs[tokenB][tokenA].reserve;
    }
}",contract_47.sol
"Create a smart contract that allows users to stake tokens and earn rewards. The contract should have the ability to mint new tokens, track user balances, and distribute rewards. The contract should also be able to handle multiple external tokens and store and track user rewards for each token. The contract should also have functions to get the last time rewards were distributed, get the reward rate, and get the reward for a specific duration.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract StakingRewards {
    IERC20 public rewardToken;
    mapping(address => mapping(address => uint256)) public stakedBalances;
    mapping(address => mapping(address => uint256)) public rewards;
    mapping(address => uint256) public lastRewardUpdate;
    uint256 public rewardRate;
    uint256 public constant REWARD_INTERVAL = 1 days;

    constructor(address _rewardToken, uint256 _rewardRate) {
        rewardToken = IERC20(_rewardToken);
        rewardRate = _rewardRate;
    }

    function stake(address token, uint256 amount) external {
        require(amount > 0, ""Amount must be greater than 0"");
        IERC20(token).transferFrom(msg.sender, address(this), amount);
        stakedBalances[msg.sender][token] += amount;
        updateReward(msg.sender, token);
    }

    function withdraw(address token, uint256 amount) external {
        require(amount > 0, ""Amount must be greater than 0"");
        require(stakedBalances[msg.sender][token] >= amount, ""Insufficient staked balance"");
        stakedBalances[msg.sender][token] -= amount;
        IERC20(token).transfer(msg.sender, amount);
        updateReward(msg.sender, token);
    }

    function claimReward(address token) external {
        updateReward(msg.sender, token);
        uint256 reward = rewards[msg.sender][token];
        if (reward > 0) {
            rewards[msg.sender][token] = 0;
            rewardToken.transfer(msg.sender, reward);
        }
    }

    function updateReward(address user, address token) internal {
        if (lastRewardUpdate[token] == 0) {
            lastRewardUpdate[token] = block.timestamp;
        }
        if (stakedBalances[user][token] > 0) {
            uint256 timeSinceLastUpdate = block.timestamp - lastRewardUpdate[token];
            uint256 reward = (stakedBalances[user][token] * rewardRate * timeSinceLastUpdate) / REWARD_INTERVAL;
            rewards[user][token] += reward;
        }
        lastRewardUpdate[token] = block.timestamp;
    }

    function getLastRewardUpdate(address token) external view returns (uint256) {
        return lastRewardUpdate[token];
    }

    function getRewardRate() external view returns (uint256) {
        return rewardRate;
    }

    function getRewardForDuration(address token, uint256 duration) external view returns (uint256) {
        return (stakedBalances[msg.sender][token] * rewardRate * duration) / REWARD_INTERVAL;
    }

    function mintRewardTokens(uint256 amount) external {
        require(amount > 0, ""Amount must be greater than 0"");
        rewardToken.transfer(address(this), amount);
    }
}",contract_48.sol
"Create a basic ERC20 token contract that allows users to mint, burn, and transfer tokens. Implement the necessary functions, including totalSupply, balanceOf, transfer, approve, and transferFrom. Also, consider adding other relevant functions such as increaseAllowance, decreaseAllowance, _transfer, and any other necessary methods","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function _transfer(address _from, address _to, uint256 _value) internal {
        require(_to != address(0), ""Invalid recipient"");
        require(balanceOf[_from] >= _value, ""Insufficient balance"");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(allowance[_from][msg.sender] >= _value, ""Allowance exceeded"");
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    function increaseAllowance(address _spender, uint256 _addedValue) public returns (bool success) {
        allowance[msg.sender][_spender] += _addedValue;
        emit Approval(msg.sender, _spender, allowance[msg.sender][_spender]);
        return true;
    }

    function decreaseAllowance(address _spender, uint256 _subtractedValue) public returns (bool success) {
        require(allowance[msg.sender][_spender] >= _subtractedValue, ""Allowance below zero"");
        allowance[msg.sender][_spender] -= _subtractedValue;
        emit Approval(msg.sender, _spender, allowance[msg.sender][_spender]);
        return true;
    }

    function mint(address _to, uint256 _value) public {
        totalSupply += _value;
        balanceOf[_to] += _value;
        emit Transfer(address(0), _to, _value);
    }

    function burn(uint256 _value) public {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        totalSupply -= _value;
        balanceOf[msg.sender] -= _value;
        emit Transfer(msg.sender, address(0), _value);
    }
}",contract_49.sol
"Create a smart contract that allows for token transfers and includes basic functionality, utilizing the IERC20 interface and SafeMath library. Implement a balance retrieval function and include event triggers for transfer and approval operations.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }

    function getBalance(address account) public view returns (uint256) {
        return balanceOf[account];
    }
}",contract_50.sol
"Create a smart contract that allows single ownership and transferable management. The contract should have a specific default owner and implement a function to obtain the current owner. Further, it should provide the capability to transfer ownership to a new address, pushing ownership to a new address, and pulling ownership to the new address from the owner. Finally, ensure that only the current owner can execute certain actions.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;
    address private _pendingOwner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    modifier onlyOwner() {
        require(msg.sender == _owner, ""Ownable: caller is not the owner"");
        _;
    }

    function owner() public view returns (address) {
        return _owner;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _pendingOwner = newOwner;
    }

    function acceptOwnership() public {
        require(msg.sender == _pendingOwner, ""Ownable: caller is not the pending owner"");
        emit OwnershipTransferred(_owner, _pendingOwner);
        _owner = _pendingOwner;
        _pendingOwner = address(0);
    }

    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }
}",contract_51.sol
"Create a smart contract that allows for staging and committing delayed protocol parameters, leveraging the Aave LendingPool. Implement functions for delaying parameter updates and commit logic, ensuring timestamp validation and access control. Consider integrating the contract with external systems and incorporate best practices for smart contract development.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface ILendingPool {
    function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;
    function withdraw(address asset, uint256 amount, address to) external returns (uint256);
    function getReserveData(address asset) external view returns (ReserveData memory);
    struct ReserveData {
        uint256 configuration;
        uint128 liquidityIndex;
        uint128 variableBorrowIndex;
        uint128 currentLiquidityRate;
        uint128 currentVariableBorrowRate;
        uint128 currentStableBorrowRate;
        uint40 lastUpdateTimestamp;
        address aTokenAddress;
        address stableDebtTokenAddress;
        address variableDebtTokenAddress;
        uint8 id;
    }
}

contract DelayedProtocolParameters {
    address public admin;
    ILendingPool public lendingPool;
    uint256 public constant DELAY_PERIOD = 86400; // 24 hours
    uint256 public lastUpdateTimestamp;
    uint256 public proposedParameter;
    uint256 public committedParameter;

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can call this function"");
        _;
    }

    constructor(address _lendingPoolAddress) {
        admin = msg.sender;
        lendingPool = ILendingPool(_lendingPoolAddress);
    }

    function proposeParameter(uint256 newParameter) external onlyAdmin {
        proposedParameter = newParameter;
        lastUpdateTimestamp = block.timestamp;
    }

    function commitParameter() external onlyAdmin {
        require(block.timestamp >= lastUpdateTimestamp + DELAY_PERIOD, ""Delay period not yet passed"");
        committedParameter = proposedParameter;
        proposedParameter = 0;
    }

    function getCurrentParameter() external view returns (uint256) {
        return committedParameter;
    }

    function getProposedParameter() external view returns (uint256) {
        return proposedParameter;
    }

    function getRemainingDelayTime() external view returns (uint256) {
        if (block.timestamp >= lastUpdateTimestamp + DELAY_PERIOD) {
            return 0;
        }
        return (lastUpdateTimestamp + DELAY_PERIOD) - block.timestamp;
    }
}",contract_52.sol
"Create a smart contract that interacts with the provided ERC20 token. The contract should allow token transfers and update the allowance for the token owner. Implement a system for adding and removing modules, and enable static calls. Include functions for calculating the total supply of the token and querying the balance of a specific token owner. Focus on functionality and ease of use, ensuring that the contract can handle a large number of token owners. Do not worry about optimization for scalability.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract ERC20TokenInteraction {
    IERC20 public token;

    struct Module {
        bool isActive;
        address moduleAddress;
    }

    Module[] public modules;

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function addModule(address _moduleAddress) external {
        modules.push(Module({
            isActive: true,
            moduleAddress: _moduleAddress
        }));
    }

    function removeModule(uint256 _index) external {
        require(_index < modules.length, ""Module index out of range"");
        modules[_index].isActive = false;
    }

    function transferTokens(address _recipient, uint256 _amount) external {
        require(token.transfer(_recipient, _amount), ""Token transfer failed"");
    }

    function approveTokens(address _spender, uint256 _amount) external {
        require(token.approve(_spender, _amount), ""Token approval failed"");
    }

    function transferFromTokens(address _sender, address _recipient, uint256 _amount) external {
        require(token.transferFrom(_sender, _recipient, _amount), ""Token transferFrom failed"");
    }

    function getTotalSupply() external view returns (uint256) {
        return token.totalSupply();
    }

    function getBalanceOf(address _account) external view returns (uint256) {
        return token.balanceOf(_account);
    }

    function staticCall(address _target, bytes memory _data) external view returns (bytes memory) {
        (bool success, bytes memory result) = _target.staticcall(_data);
        require(success, ""Static call failed"");
        return result;
    }
}",contract_53.sol
"Create a smart contract that allows for minting, transferring, and burning tokens. The contract should have a way to query the total supply, get the owner, and set a new owner. It should also allow for token allowance and approval. Implement a mapping for tracking token balances and include functions for getting the balance of an address and transferring tokens between accounts.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    address public owner;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Burn(address indexed from, uint256 value);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        owner = msg.sender;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""New owner is the zero address"");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }

    function mint(address to, uint256 value) public onlyOwner {
        totalSupply += value;
        balanceOf[to] += value;
        emit Transfer(address(0), to, value);
    }

    function burn(uint256 value) public {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        totalSupply -= value;
        balanceOf[msg.sender] -= value;
        emit Burn(msg.sender, value);
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }
}",contract_54.sol
"Create a smart contract that manages access control for a system. The contract should allow for the modification of public access and call permissions, including support for batch updates. Implement functions for checking access and permission status, and consider incorporating events for notification purposes.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract AccessControl {
    struct Permission {
        bool canCall;
        bool isPublic;
    }

    mapping(address => Permission) private permissions;
    address private owner;

    event PermissionUpdated(address indexed user, bool canCall, bool isPublic);
    event AccessChecked(address indexed user, bool canCall, bool isPublic);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function updatePermission(address user, bool canCall, bool isPublic) public onlyOwner {
        permissions[user] = Permission(canCall, isPublic);
        emit PermissionUpdated(user, canCall, isPublic);
    }

    function batchUpdatePermissions(address[] memory users, bool[] memory canCall, bool[] memory isPublic) public onlyOwner {
        require(users.length == canCall.length && users.length == isPublic.length, ""Input arrays must be of equal length"");
        for (uint256 i = 0; i < users.length; i++) {
            permissions[users[i]] = Permission(canCall[i], isPublic[i]);
            emit PermissionUpdated(users[i], canCall[i], isPublic[i]);
        }
    }

    function checkAccess(address user) public view returns (bool, bool) {
        Permission memory perm = permissions[user];
        return (perm.canCall, perm.isPublic);
    }

    function logAccessCheck(address user) public {
        (bool canCall, bool isPublic) = checkAccess(user);
        emit AccessChecked(user, canCall, isPublic);
    }
}",contract_55.sol
"Design a smart contract to handle the creation and transfer of a Basic Attention Token (BAT). The contract should include functions for creating, transferring, and approving tokens, as well as allowing users to retrieve their token balance. Ensure the contract has logic to prevent token supply from exceeding a set cap. Include modifiers to control the token distribution and refund any remaining funds. The contract should utilize the Solidity programming language and be compatible with the Ethereum blockchain.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract BasicAttentionToken {
    string public name = ""Basic Attention Token"";
    string public symbol = ""BAT"";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    uint256 public cap = 1000000000 * 10 ** uint256(decimals); // 1 billion tokens

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    address public owner;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function createTokens(uint256 amount) public onlyOwner {
        require(totalSupply + amount <= cap, ""Exceeds token cap"");
        balanceOf[msg.sender] += amount;
        totalSupply += amount;
        emit Transfer(address(0), msg.sender, amount);
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }

    function getBalance(address account) public view returns (uint256) {
        return balanceOf[account];
    }
}",contract_56.sol
"Create a smart contract that facilitates creating, managing, and withdrawing redirection fees for collections. The contract should allow for setting repositories, routers, and budget managers, as well as chain names, collection creation, and omnichain message receiving. Incorporate ownership management and control for only-owner actions. Define necessary functions and variables within the Solidity contract. Consider compatibility with a blockchain ecosystem.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract FeeManager {
    address public owner;
    mapping(address => bool) public repositoryManagers;
    mapping(address => bool) public routerManagers;
    mapping(address => bool) public budgetManagers;
    string[] public chainNames;
    mapping(uint256 => Collection) public collections;
    uint256 public collectionCount;

    struct Collection {
        string name;
        address creator;
        uint256 balance;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier onlyRepositoryManager() {
        require(repositoryManagers[msg.sender], ""Not a repository manager"");
        _;
    }

    modifier onlyRouterManager() {
        require(routerManagers[msg.sender], ""Not a router manager"");
        _;
    }

    modifier onlyBudgetManager() {
        require(budgetManagers[msg.sender], ""Not a budget manager"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setRepositoryManager(address manager, bool status) external onlyOwner {
        repositoryManagers[manager] = status;
    }

    function setRouterManager(address manager, bool status) external onlyOwner {
        routerManagers[manager] = status;
    }

    function setBudgetManager(address manager, bool status) external onlyOwner {
        budgetManagers[manager] = status;
    }

    function addChainName(string memory chainName) external onlyOwner {
        chainNames.push(chainName);
    }

    function createCollection(string memory name) external onlyRepositoryManager {
        collections[collectionCount] = Collection(name, msg.sender, 0);
        collectionCount++;
    }

    function depositToCollection(uint256 collectionId) external payable onlyRouterManager {
        require(collectionId < collectionCount, ""Invalid collection ID"");
        collections[collectionId].balance += msg.value;
    }

    function withdrawFromCollection(uint256 collectionId, uint256 amount) external onlyBudgetManager {
        require(collectionId < collectionCount, ""Invalid collection ID"");
        Collection storage collection = collections[collectionId];
        require(collection.balance >= amount, ""Insufficient balance"");
        collection.balance -= amount;
        payable(msg.sender).transfer(amount);
    }

    function transferOwnership(address newOwner) external onlyOwner {
        owner = newOwner;
    }

    receive() external payable {}
}",contract_57.sol
"Create a Solidity smart contract that enables the deployment and management of ERC721DAOToken, ERC721Timelock, and ERC721Governor contracts, allowing for easy minting, cloning, and initialization of new instances. The contract should provide a basic framework for governance and management of each instance.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}

contract ERC721DAOToken {
    string private _name;
    string private _symbol;
    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function balanceOf(address owner) public view returns (uint256) {
        require(owner != address(0), ""ERC721: balance query for the zero address"");
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) public view returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), ""ERC721: owner query for nonexistent token"");
        return owner;
    }

    function approve(address to, uint256 tokenId) public {
        address owner = ownerOf(tokenId);
        require(to != owner, ""ERC721: approval to current owner"");
        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), ""ERC721: approve caller is not owner nor approved for all"");
        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    function getApproved(uint256 tokenId) public view returns (address) {
        require(_exists(tokenId), ""ERC721: approved query for nonexistent token"");
        return _tokenApprovals[tokenId];
    }

    function setApprovalForAll(address operator, bool approved) public {
        require(operator != msg.sender, ""ERC721: approve to caller"");
        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function isApprovedForAll(address owner, address operator) public view returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function transferFrom(address from, address to, uint256 tokenId) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _transfer(from, to, tokenId);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) public {
        safeTransferFrom(from, to, tokenId, """");
    }

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _safeTransfer(from, to, tokenId, _data);
    }

    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return _owners[tokenId] != address(0);
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    function _safeMint(address to, uint256 tokenId) internal {
        _safeMint(to, tokenId, """");
    }

    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal {
        _mint(to, tokenId);
        require(_checkOnERC721Received(address(0), to, tokenId, _data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _mint(address to, uint256 tokenId) internal {
        require(to != address(0), ""ERC721: mint to the zero address"");
        require(!_exists(tokenId), ""ERC721: token already minted"");
        _beforeTokenTransfer(address(0), to, tokenId);
        _balances[to] += 1;
        _owners[tokenId] = to;
        emit Transfer(address(0), to, tokenId);
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        require(ownerOf(tokenId) == from, ""ERC721: transfer of token that is not own"");
        require(to != address(0), ""ERC721: transfer to the zero address"");
        _beforeTokenTransfer(from, to, tokenId);
        _approve(address(0), tokenId);
        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;
        emit Transfer(from, to, tokenId);
    }

    function _approve(address to, uint256 tokenId) internal {
        _tokenApprovals[tokenId] = to;
        emit Approval(ownerOf(tokenId), to, tokenId);
    }

    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) internal returns (bool) {
        if (to.code.length > 0) {
            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data) returns (bytes4 retval) {
                return retval == IERC721Receiver.onERC721Received.selector;
            } catch (bytes memory reason) {
                if (reason.length == 0) {
                    revert(""ERC721: transfer to non ERC721Receiver implementer"");
                } else {
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        } else {
            return true;
        }
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal {}
}

contract ERC721Timelock {
    address public admin;
    address public pendingAdmin;
    uint256 public delay;
    mapping(bytes32 => bool) public queuedTransactions;

    event NewAdmin(address indexed newAdmin);
    event NewPendingAdmin(address indexed newPendingAdmin);
    event NewDelay(uint256 indexed newDelay);
    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);
    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);
    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);

    constructor(uint256 delay_) {
        require(delay_ > 0, ""Timelock::constructor: Delay must be greater than 0"");
        admin = msg.sender;
        delay = delay_;
    }

    function setDelay(uint256 delay_) public {
        require(msg.sender == address(this), ""Timelock::setDelay: Call must come from Timelock."");
        require(delay_ > 0, ""Timelock::setDelay: Delay must be greater than 0"");
        delay = delay_;
        emit NewDelay(delay);
    }

    function acceptAdmin() public {
        require(msg.sender == pendingAdmin, ""Timelock::acceptAdmin: Call must come from pendingAdmin."");
        admin = msg.sender;
        pendingAdmin = address(0);
        emit NewAdmin(admin);
    }

    function setPendingAdmin(address pendingAdmin_) public {
        require(msg.sender == address(this), ""Timelock::setPendingAdmin: Call must come from Timelock."");
        pendingAdmin = pendingAdmin_;
        emit NewPendingAdmin(pendingAdmin);
    }

    function queueTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 eta) public returns (bytes32) {
        require(msg.sender == admin, ""Timelock::queueTransaction: Call must come from admin."");
        require(eta >= getBlockTimestamp() + delay, ""Timelock::queueTransaction: Estimated execution block must satisfy delay."");
        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));
        queuedTransactions[txHash] = true;
        emit QueueTransaction(txHash, target, value, signature, data, eta);
        return txHash;
    }

    function cancelTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 eta) public {
        require(msg.sender == admin, ""Timelock::cancelTransaction: Call must come from admin."");
        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));
        queuedTransactions[txHash] = false;
        emit CancelTransaction(txHash, target, value, signature, data, eta);
    }

    function executeTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 eta) public payable returns (bytes memory) {
        require(msg.sender == admin, ""Timelock::executeTransaction: Call must come from admin."");
        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));
        require(queuedTransactions[txHash], ""Timelock::executeTransaction: Transaction hasn't been queued."");
        require(getBlockTimestamp() >= eta, ""Timelock::executeTransaction: Transaction hasn't surpassed time lock."");
        require(getBlockTimestamp() <= eta + 14 days, ""Timelock::executeTransaction: Transaction is stale."");
        queuedTransactions[txHash] = false;
        bytes memory callData;
        if (bytes(signature).length == 0) {
            callData = data;
        } else {
            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);
        }
        (bool success, bytes memory returnData) = target.call{value: value}(callData);
        require(success, ""Timelock::executeTransaction: Transaction execution reverted."");
        emit ExecuteTransaction(txHash, target, value, signature, data, eta);
        return returnData;
    }

    function getBlockTimestamp() internal view returns (uint256) {
        return block.timestamp;
    }
}

contract ERC721Governor {
    ERC721DAOToken public token;
    ERC721Timelock public timelock;
    address public guardian;

    struct Proposal {
        uint256 id;
        address proposer;
        uint256 eta;
        address[] targets;
        uint256[] values;
        string[] signatures;
        bytes[] calldatas;
        uint256 startBlock;
        uint256 endBlock;
        uint256 forVotes;
        uint256 againstVotes;
        bool canceled;
        bool executed;
    }

    mapping(uint256 => Proposal) public proposals;
    uint256 public proposalCount;

    event ProposalCreated(uint256 id, address proposer, address[] targets, uint256[] values, string[] signatures, bytes[] calldatas, uint256 startBlock, uint256 endBlock, string description);
    event VoteCast(address voter, uint256 proposalId, bool support, uint256 votes);
    event ProposalCanceled(uint256 id);
    event ProposalExecuted(uint256 id);

    constructor(ERC721DAOToken token_, ERC721Timelock timelock_, address guardian_) {
        token = token_;
        timelock = timelock_;
        guardian = guardian_;
    }

    function propose(address[] memory targets, uint256[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint256) {
        require(token.balanceOf(msg.sender) > 0, ""Governor::propose: proposer votes below proposal threshold"");
        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, ""Governor::propose: proposal function information arity mismatch"");
        require(targets.length > 0, ""Governor::propose: must provide actions"");
        uint256 startBlock = block.number + 1;
        uint256 endBlock = startBlock + 17280;
        proposalCount++;
        Proposal storage p = proposals[proposalCount];
        p.id = proposalCount;
        p.proposer = msg.sender;
        p.targets = targets;
        p.values = values;
        p.signatures = signatures;
        p.calldatas = calldatas;
        p.startBlock = startBlock;
        p.endBlock = endBlock;
        emit ProposalCreated(p.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);
        return p.id;
    }

    function castVote(uint256 proposalId, bool support) public {
        require(proposals[proposalId].id != 0, ""Governor::castVote: unknown proposal id"");
        require(block.number > proposals[proposalId].startBlock, ""Governor::castVote: voting not yet started"");
        require(block.number < proposals[proposalId].endBlock, ""Governor::castVote: voting already ended"");
        require(!proposals[proposalId].canceled, ""Governor::castVote: proposal canceled"");
        uint256 votes = token.balanceOf(msg.sender);
        require(votes > 0, ""Governor::castVote: voter has no votes"");
        if (support) {
            proposals[proposalId].forVotes += votes;
        } else {
            proposals[proposalId].againstVotes += votes;
        }
        emit VoteCast(msg.sender, proposalId, support, votes);
    }

    function queue(uint256 proposalId) public {
        require(proposals[proposalId].id != 0, ""Governor::queue: unknown proposal id"");
        require(block.number > proposals[proposalId].endBlock, ""Governor::queue: proposal voting is still active"");
        require(!proposals[proposalId].canceled, ""Governor::queue: proposal canceled"");
        require(!proposals[proposalId].executed, ""Governor::queue: proposal already executed"");
        require(proposals[proposalId].forVotes > proposals[proposalId].againstVotes, ""Governor::queue: proposal needs more for votes"");
        uint256 eta = block.timestamp + timelock.delay();
        for (uint256 i = 0; i < proposals[proposalId].targets.length; i++) {
            bytes32 txHash = keccak256(abi.encode(proposals[proposalId].targets[i], proposals[proposalId].values[i], proposals[proposalId].signatures[i], proposals[proposalId].calldatas[i], eta));
            timelock.queueTransaction(proposals[proposalId].targets[i], proposals[proposalId].values[i], proposals[proposalId].signatures[i], proposals[proposalId].calldatas[i], eta);
        }
        proposals[proposalId].eta = eta;
    }

    function execute(uint256 proposalId) public payable {
        require(proposals[proposalId].id != 0, ""Governor::execute: unknown proposal id"");
        require(!proposals[proposalId].canceled, ""Governor::execute:",contract_58.sol
Create a Solidity smart contract that adapts fees and reserves. The contract should inherit from the FeesAndReservesAdaptor class and override the `feesAndReserves` function to return a FeesAndReserves object. The FeesAndReservesAdaptor class will be imported from the specified location. The contract should be implemented using Solidity version 0.8.16 and include necessary license information.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract FeesAndReservesAdaptor {
    function feesAndReserves() virtual external view returns (uint, uint) {
        return (0, 0);
    }
}

contract MyFeesAndReservesAdaptor is FeesAndReservesAdaptor {
    struct FeesAndReserves {
        uint fees;
        uint reserves;
    }

    FeesAndReserves private _feesAndReserves;

    constructor(uint fees, uint reserves) {
        _feesAndReserves = FeesAndReserves({
            fees: fees,
            reserves: reserves
        });
    }

    function feesAndReserves() override external view returns (uint, uint) {
        return (_feesAndReserves.fees, _feesAndReserves.reserves);
    }
}",contract_59.sol
"Create a smart contract that enables a betting system for users to participate in. The contract should have functions for depositing funds, placing bets, and withdrawing winnings. Include a system for tracking user balances and betting history. Implement event tracking for deposits, bets, and withdrawals. Make sure to enforce withdrawal and betting limits. Don't forget to provide a clear description of the smart contract's functionality and structure.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract BettingSystem {
    struct User {
        uint256 balance;
        uint256[] betIds;
    }

    struct Bet {
        address user;
        uint256 amount;
        bool won;
    }

    mapping(address => User) public users;
    Bet[] public bets;
    uint256 public totalBets;
    uint256 public constant MAX_BET_AMOUNT = 100 ether;
    uint256 public constant MAX_WITHDRAWAL_AMOUNT = 500 ether;

    event Deposit(address indexed user, uint256 amount);
    event BetPlaced(address indexed user, uint256 betId, uint256 amount);
    event Withdrawal(address indexed user, uint256 amount);

    function deposit() external payable {
        require(msg.value > 0, ""Deposit amount must be greater than 0"");
        users[msg.sender].balance += msg.value;
        emit Deposit(msg.sender, msg.value);
    }

    function placeBet(uint256 amount) external {
        require(amount > 0 && amount <= MAX_BET_AMOUNT, ""Invalid bet amount"");
        require(users[msg.sender].balance >= amount, ""Insufficient balance"");

        users[msg.sender].balance -= amount;
        uint256 betId = bets.length;
        bets.push(Bet({user: msg.sender, amount: amount, won: false}));
        users[msg.sender].betIds.push(betId);
        totalBets++;

        emit BetPlaced(msg.sender, betId, amount);
    }

    function withdraw(uint256 amount) external {
        require(amount > 0 && amount <= MAX_WITHDRAWAL_AMOUNT, ""Invalid withdrawal amount"");
        require(users[msg.sender].balance >= amount, ""Insufficient balance"");

        users[msg.sender].balance -= amount;
        payable(msg.sender).transfer(amount);

        emit Withdrawal(msg.sender, amount);
    }

    function getUserBets(address user) external view returns (uint256[] memory) {
        return users[user].betIds;
    }

    function getBetDetails(uint256 betId) external view returns (address, uint256, bool) {
        Bet storage bet = bets[betId];
        return (bet.user, bet.amount, bet.won);
    }
}",contract_60.sol
"Develop a smart contract for the Dai Backstop Syndicate, incorporating functionality for depositing Dai, entering auctions, finalizing auctions, and halting new deposits and auctions. The contract should utilize Solidity's standard libraries and best practices for code organization and readability. Ensure proper event emission and handling for all contract interactions.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

contract DaiBackstopSyndicate {
    IERC20 public dai;
    address public owner;
    bool public halted;

    struct Auction {
        uint256 amount;
        address bidder;
        bool finalized;
    }

    Auction[] public auctions;
    mapping(address => uint256) public deposits;

    event Deposited(address indexed user, uint256 amount);
    event AuctionEntered(uint256 indexed auctionId, address indexed bidder, uint256 amount);
    event AuctionFinalized(uint256 indexed auctionId, address indexed bidder, uint256 amount);
    event Halted(bool status);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the owner"");
        _;
    }

    modifier notHalted() {
        require(!halted, ""Contract is halted"");
        _;
    }

    constructor(address _dai) {
        dai = IERC20(_dai);
        owner = msg.sender;
    }

    function deposit(uint256 amount) external notHalted {
        require(dai.transferFrom(msg.sender, address(this), amount), ""Transfer failed"");
        deposits[msg.sender] += amount;
        emit Deposited(msg.sender, amount);
    }

    function enterAuction(uint256 amount) external notHalted {
        require(deposits[msg.sender] >= amount, ""Insufficient deposit"");
        deposits[msg.sender] -= amount;
        auctions.push(Auction({amount: amount, bidder: msg.sender, finalized: false}));
        emit AuctionEntered(auctions.length - 1, msg.sender, amount);
    }

    function finalizeAuction(uint256 auctionId) external onlyOwner {
        Auction storage auction = auctions[auctionId];
        require(!auction.finalized, ""Auction already finalized"");
        auction.finalized = true;
        require(dai.transfer(auction.bidder, auction.amount), ""Transfer failed"");
        emit AuctionFinalized(auctionId, auction.bidder, auction.amount);
    }

    function halt(bool status) external onlyOwner {
        halted = status;
        emit Halted(status);
    }
}",contract_61.sol
"Create a smart contract that uses the OpenZeppelin libraries to manage arithmetic operations and a counter variable. The contract should have functions to increment, decrement, and reset the counter. It should also include a mapping to store and retrieve values from an enumerable set. The contract should be structured in a way that is easy to understand and maintain.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Counter {
    using SafeMath for uint256;
    using EnumerableSet for EnumerableSet.UintSet;

    uint256 private _counter;
    mapping(uint256 => uint256) private _values;
    EnumerableSet.UintSet private _keys;

    function increment() public {
        _counter = _counter.add(1);
    }

    function decrement() public {
        _counter = _counter.sub(1);
    }

    function reset() public {
        _counter = 0;
    }

    function setValue(uint256 key, uint256 value) public {
        _values[key] = value;
        _keys.add(key);
    }

    function getValue(uint256 key) public view returns (uint256) {
        require(_keys.contains(key), ""Key not found"");
        return _values[key];
    }

    function getCounter() public view returns (uint256) {
        return _counter;
    }

    function getKeys() public view returns (uint256[] memory) {
        return _keys.values();
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }
}

library EnumerableSet {
    struct UintSet {
        uint256[] _values;
        mapping(uint256 => uint256) _indexes;
    }

    function add(UintSet storage set, uint256 value) internal returns (bool) {
        if (!contains(set, value)) {
            set._values.push(value);
            set._indexes[value] = set._values.length;
            return true;
        } else {
            return false;
        }
    }

    function remove(UintSet storage set, uint256 value) internal returns (bool) {
        uint256 valueIndex = set._indexes[value];
        if (valueIndex != 0) {
            uint256 toDeleteIndex = valueIndex - 1;
            uint256 lastIndex = set._values.length - 1;
            uint256 lastValue = set._values[lastIndex];
            set._values[toDeleteIndex] = lastValue;
            set._indexes[lastValue] = toDeleteIndex + 1;
            set._values.pop();
            delete set._indexes[value];
            return true;
        } else {
            return false;
        }
    }

    function contains(UintSet storage set, uint256 value) internal view returns (bool) {
        return set._indexes[value] != 0;
    }

    function values(UintSet storage set) internal view returns (uint256[] memory) {
        return set._values;
    }
}",contract_62.sol
"Create a Solidity smart contract called 'Gamble' that enables users to make predictions on the outcome of a random event. The contract should have variables to store the maximum bet amount, percentage fee, and bank roll. Write functions to update settings, initialize the bank roll, and place bets. Design a system to determine the winner of a bet and award the winnings.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Gamble {
    address public owner;
    uint256 public maxBetAmount;
    uint256 public percentageFee;
    uint256 public bankRoll;

    struct Bet {
        address better;
        uint256 amount;
        uint256 prediction;
        bool resolved;
    }

    Bet[] public bets;
    uint256 public nextBetId;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor(uint256 _maxBetAmount, uint256 _percentageFee) {
        owner = msg.sender;
        maxBetAmount = _maxBetAmount;
        percentageFee = _percentageFee;
        bankRoll = 0;
        nextBetId = 0;
    }

    function updateSettings(uint256 _maxBetAmount, uint256 _percentageFee) public onlyOwner {
        maxBetAmount = _maxBetAmount;
        percentageFee = _percentageFee;
    }

    function initializeBankRoll(uint256 amount) public onlyOwner {
        require(amount > 0, ""Amount must be greater than 0"");
        bankRoll += amount;
    }

    function placeBet(uint256 prediction) public payable {
        require(msg.value <= maxBetAmount, ""Bet exceeds max bet amount"");
        require(msg.value > 0, ""Bet amount must be greater than 0"");
        uint256 fee = (msg.value * percentageFee) / 100;
        uint256 netAmount = msg.value - fee;
        bankRoll += netAmount;
        bets.push(Bet({
            better: msg.sender,
            amount: msg.value,
            prediction: prediction,
            resolved: false
        }));
        nextBetId++;
    }

    function resolveBet(uint256 betId, uint256 outcome) public onlyOwner {
        require(betId < nextBetId, ""Invalid bet ID"");
        Bet storage bet = bets[betId];
        require(!bet.resolved, ""Bet already resolved"");
        if (bet.prediction == outcome) {
            uint256 winnings = bet.amount * 2;
            require(bankRoll >= winnings, ""Insufficient bank roll to pay winnings"");
            payable(bet.better).transfer(winnings);
            bankRoll -= winnings;
        }
        bet.resolved = true;
    }

    function withdrawFunds(uint256 amount) public onlyOwner {
        require(amount <= bankRoll, ""Insufficient funds in bank roll"");
        payable(owner).transfer(amount);
        bankRoll -= amount;
    }
}",contract_63.sol
"Create a smart contract that interacts with IPriceProvidersAggregator, IPriceProvider, and IAddressProvider. The contract should have methods to retrieve the current price of a token in USD, quote token pairs, and update the address of the IAddressProvider. The implementation should be structured with clear functions and logic, and use modifiers to restrict access to critical functions. Focus on implementing the required functionality without focusing too much on performance or security.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IPriceProvidersAggregator {
    function getPriceProvider(address token) external view returns (IPriceProvider);
}

interface IPriceProvider {
    function getPrice(address token) external view returns (uint256);
    function getPriceInUSD(address token) external view returns (uint256);
}

interface IAddressProvider {
    function getPriceProvidersAggregator() external view returns (IPriceProvidersAggregator);
}

contract PriceQuoter {
    IAddressProvider public addressProvider;
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the owner"");
        _;
    }

    constructor(address _addressProvider) {
        addressProvider = IAddressProvider(_addressProvider);
        owner = msg.sender;
    }

    function updateAddressProvider(address _newAddressProvider) external onlyOwner {
        addressProvider = IAddressProvider(_newAddressProvider);
    }

    function getPriceInUSD(address token) public view returns (uint256) {
        IPriceProvidersAggregator aggregator = addressProvider.getPriceProvidersAggregator();
        IPriceProvider provider = aggregator.getPriceProvider(token);
        return provider.getPriceInUSD(token);
    }

    function quoteTokenPair(address tokenA, address tokenB) public view returns (uint256 priceAInUSD, uint256 priceBInUSD) {
        priceAInUSD = getPriceInUSD(tokenA);
        priceBInUSD = getPriceInUSD(tokenB);
    }
}",contract_64.sol
"Create a smart contract that represents a token with the following properties: a limited supply of tokens, the ability to transfer tokens between addresses, and support for approving and allowing of token spend. Implement functions to manage token balances, allow and disallow token transfer, and record transactions. Use Solidity and the SafeMath library to ensure accurate and secure arithmetic operations.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MyToken {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool success) {
        allowance[msg.sender][spender] += addedValue;
        emit Approval(msg.sender, spender, allowance[msg.sender][spender]);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool success) {
        require(allowance[msg.sender][spender] >= subtractedValue, ""Allowance below zero"");
        allowance[msg.sender][spender] -= subtractedValue;
        emit Approval(msg.sender, spender, allowance[msg.sender][spender]);
        return true;
    }
}",contract_65.sol
"Create a smart contract for the PIVOTCHAIN token that allows users to buy and sell tokens, with a fixed total supply, and a specified buy price. Implement functions for users to contribute ether to receive tokens, while keeping track of the creator's balance. Include event logs for transfers and contributions. Make sure to include error checking to prevent token overflows and ensure a fair transfer.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract PIVOTCHAIN {
    string public name = ""PIVOTCHAIN"";
    string public symbol = ""PVT"";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    uint256 public buyPrice;
    address public owner;

    mapping(address => uint256) public balanceOf;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Contribution(address indexed contributor, uint256 value, uint256 tokens);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor(uint256 initialSupply, uint256 _buyPrice) {
        owner = msg.sender;
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[owner] = totalSupply;
        buyPrice = _buyPrice;
        emit Transfer(address(0), owner, totalSupply);
    }

    function buyTokens() public payable {
        require(msg.value > 0, ""Insufficient ether sent"");
        uint256 tokensToBuy = msg.value * buyPrice;
        require(tokensToBuy <= balanceOf[owner], ""Not enough tokens available for sale"");
        balanceOf[owner] -= tokensToBuy;
        balanceOf[msg.sender] += tokensToBuy;
        emit Transfer(owner, msg.sender, tokensToBuy);
        emit Contribution(msg.sender, msg.value, tokensToBuy);
    }

    function sellTokens(uint256 tokenAmount) public {
        require(tokenAmount > 0, ""Insufficient tokens to sell"");
        require(balanceOf[msg.sender] >= tokenAmount, ""Insufficient balance"");
        uint256 etherToSend = tokenAmount / buyPrice;
        require(address(this).balance >= etherToSend, ""Insufficient contract balance"");
        balanceOf[msg.sender] -= tokenAmount;
        balanceOf[owner] += tokenAmount;
        payable(msg.sender).transfer(etherToSend);
        emit Transfer(msg.sender, owner, tokenAmount);
    }

    function withdrawEther() public onlyOwner {
        payable(owner).transfer(address(this).balance);
    }

    receive() external payable {
        buyTokens();
    }
}",contract_66.sol
"Create a smart contract that builds upon the provided Ownable contract and adds features to manage whitelisted addresses, funding managers/operators, and funds unlocker managers/operators. The contract should include functions to add/remove addresses, check role membership, and allow the owner to transfer ownership. Focus on implementing the logic and functions defined in the provided code fragment.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract AdvancedContract is Ownable {
    mapping(address => bool) private _whitelisted;
    mapping(address => bool) private _fundingManagers;
    mapping(address => bool) private _fundsUnlockers;

    event WhitelistedAdded(address indexed account);
    event WhitelistedRemoved(address indexed account);
    event FundingManagerAdded(address indexed account);
    event FundingManagerRemoved(address indexed account);
    event FundsUnlockerAdded(address indexed account);
    event FundsUnlockerRemoved(address indexed account);

    modifier onlyWhitelisted() {
        require(_whitelisted[msg.sender], ""Not whitelisted"");
        _;
    }

    modifier onlyFundingManager() {
        require(_fundingManagers[msg.sender], ""Not a funding manager"");
        _;
    }

    modifier onlyFundsUnlocker() {
        require(_fundsUnlockers[msg.sender], ""Not a funds unlocker"");
        _;
    }

    function addWhitelisted(address account) public onlyOwner {
        _whitelisted[account] = true;
        emit WhitelistedAdded(account);
    }

    function removeWhitelisted(address account) public onlyOwner {
        _whitelisted[account] = false;
        emit WhitelistedRemoved(account);
    }

    function isWhitelisted(address account) public view returns (bool) {
        return _whitelisted[account];
    }

    function addFundingManager(address account) public onlyOwner {
        _fundingManagers[account] = true;
        emit FundingManagerAdded(account);
    }

    function removeFundingManager(address account) public onlyOwner {
        _fundingManagers[account] = false;
        emit FundingManagerRemoved(account);
    }

    function isFundingManager(address account) public view returns (bool) {
        return _fundingManagers[account];
    }

    function addFundsUnlocker(address account) public onlyOwner {
        _fundsUnlockers[account] = true;
        emit FundsUnlockerAdded(account);
    }

    function removeFundsUnlocker(address account) public onlyOwner {
        _fundsUnlockers[account] = false;
        emit FundsUnlockerRemoved(account);
    }

    function isFundsUnlocker(address account) public view returns (bool) {
        return _fundsUnlockers[account];
    }
}",contract_67.sol
"Create a smart contract that allows users to stake LP tokens in a vault and earn AORI tokens. The contract should retrieve real-time prices from Chainlink. Implement functions for depositing, withdrawing, and claiming AORI tokens. Include a mechanism for whitelisting vaults and oracles. Adhere to the OpenZeppelin ERC20 and ERC4626 standards.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface AggregatorV3Interface {
    function latestRoundData() external view returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    );
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _transferOwnership(_msgSender());
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(owner() == _msgSender(), ""Ownable: caller is not the owner"");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract ERC20 {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    uint256 private _totalSupply;
    string private _name;
    string private _symbol;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function name() public view virtual returns (string memory) {
        return _name;
    }

    function symbol() public view virtual returns (string memory) {
        return _symbol;
    }

    function decimals() public view virtual returns (uint8) {
        return 18;
    }

    function totalSupply() public view virtual returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view virtual returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) public virtual returns (bool) {
        address owner = _msgSender();
        _transfer(owner, to, amount);
        return true;
    }

    function allowance(address owner, address spender) public view virtual returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public virtual returns (bool) {
        address owner = _msgSender();
        _approve(owner, spender, amount);
        return true;
    }

    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public virtual returns (bool) {
        address spender = _msgSender();
        _spendAllowance(from, spender, amount);
        _transfer(from, to, amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        address owner = _msgSender();
        _approve(owner, spender, allowance(owner, spender) + addedValue);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        address owner = _msgSender();
        uint256 currentAllowance = allowance(owner, spender);
        require(currentAllowance >= subtractedValue, ""ERC20: decreased allowance below zero"");
        unchecked {
            _approve(owner, spender, currentAllowance - subtractedValue);
        }

        return true;
    }

    function _transfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {
        require(from != address(0), ""ERC20: transfer from the zero address"");
        require(to != address(0), ""ERC20: transfer to the zero address"");

        _beforeTokenTransfer(from, to, amount);

        uint256 fromBalance = _balances[from];
        require(fromBalance >= amount, ""ERC20: transfer amount exceeds balance"");
        unchecked {
            _balances[from] = fromBalance - amount;
        }
        _balances[to] += amount;

        emit Transfer(from, to, amount);

        _afterTokenTransfer(from, to, amount);
    }

    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);

        _afterTokenTransfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: burn from the zero address"");

        _beforeTokenTransfer(account, address(0), amount);

        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, ""ERC20: burn amount exceeds balance"");
        unchecked {
            _balances[account] = accountBalance - amount;
        }
        _totalSupply -= amount;

        emit Transfer(account, address(0), amount);

        _afterTokenTransfer(account, address(0), amount);
    }

    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _spendAllowance(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        uint256 currentAllowance = allowance(owner, spender);
        if (currentAllowance != type(uint256).max) {
            require(currentAllowance >= amount, ""ERC20: insufficient allowance"");
            unchecked {
                _approve(owner, spender, currentAllowance - amount);
            }
        }
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}
}

contract AORIStaking is Ownable, ERC20 {
    AggregatorV3Interface public priceFeed;
    mapping(address => bool) public whitelistedVaults;
    mapping(address => bool) public whitelistedOracles;
    mapping(address => uint256) public stakedBalances;
    mapping(address => uint256) public lastClaimTimes;
    uint256 public rewardRate;

    constructor(address _priceFeed, uint256 _rewardRate) ERC20(""AORI"", ""AORI"") {
        priceFeed = AggregatorV3Interface(_priceFeed);
        rewardRate = _rewardRate;
    }

    function whitelistVault(address vault) external onlyOwner {
        whitelistedVaults[vault] = true;
    }

    function blacklistVault(address vault) external onlyOwner {
        whitelistedVaults[vault] = false;
    }

    function whitelistOracle(address oracle) external onlyOwner {
        whitelistedOracles[oracle] = true;
    }

    function blacklistOracle(address oracle) external onlyOwner {
        whitelistedOracles[oracle] = false;
    }

    function deposit(uint256 amount) external {
        require(whitelistedVaults[_msgSender()], ""Vault not whitelisted"");
        _transfer(_msgSender(), address(this), amount);
        stakedBalances[_msgSender()] += amount;
        if (lastClaimTimes[_msgSender()] == 0) {
            lastClaimTimes[_msgSender()] = block.timestamp;
        }
    }

    function withdraw(uint256 amount) external {
        require(stakedBalances[_msgSender()] >= amount, ""Insufficient staked balance"");
        _transfer(address(this), _msgSender(), amount);
        stakedBalances[_msgSender()] -= amount;
    }

    function claimRewards() external {
        uint256 rewards = calculateRewards(_msgSender());
        if (rewards > 0) {
            _mint(_msgSender(), rewards);
            lastClaimTimes[_msgSender()] = block.timestamp;
        }
    }

    function calculateRewards(address user) public view returns (uint256) {
        if (lastClaimTimes[user] == 0) return 0;
        uint256 timeSinceLastClaim = block.timestamp - lastClaimTimes[user];
        return (stakedBalances[user] * rewardRate * timeSinceLastClaim) / 365 days;
    }

    function getLatestPrice() public view returns (int256) {
        (, int256 price, , , ) = priceFeed.latestRoundData();
        return price;
    }
}",contract_68.sol
"Develop a Solidity smart contract that provides a diamond cut facet. The contract should enable users to add, replace, or remove functions from facets and execute functions with delegatecall. Consider the technical aspects of implementing this functionality, such as function selectors and facet addresses.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DiamondCutFacet {
    struct FacetCut {
        address facetAddress;
        FacetCutAction action;
        bytes4[] functionSelectors;
    }

    enum FacetCutAction { Add, Replace, Remove }

    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);

    // Internal function to add, replace, or remove function selectors
    function _diamondCut(
        FacetCut[] memory _diamondCut,
        address _init,
        bytes memory _calldata
    ) internal {
        for (uint256 i = 0; i < _diamondCut.length; i++) {
            FacetCut memory cut = _diamondCut[i];
            for (uint256 j = 0; j < cut.functionSelectors.length; j++) {
                bytes4 selector = cut.functionSelectors[j];
                if (cut.action == FacetCutAction.Add) {
                    // Add function
                    assembly {
                        sstore(selector, cut.facetAddress)
                    }
                } else if (cut.action == FacetCutAction.Replace) {
                    // Replace function
                    assembly {
                        sstore(selector, cut.facetAddress)
                    }
                } else if (cut.action == FacetCutAction.Remove) {
                    // Remove function
                    assembly {
                        sstore(selector, 0)
                    }
                }
            }
        }
        emit DiamondCut(_diamondCut, _init, _calldata);
        _initializeDiamondCut(_init, _calldata);
    }

    // Internal function to execute initialization function using delegatecall
    function _initializeDiamondCut(address _init, bytes memory _calldata) internal {
        if (_init == address(0)) {
            require(_calldata.length == 0, ""DiamondCutFacet: _init is address(0) but_calldata is not empty"");
        } else {
            require(_calldata.length != 0, ""DiamondCutFacet: _calldata is empty but _init is not address(0)"");
            (bool success, bytes memory error) = _init.delegatecall(_calldata);
            require(success, string(error));
        }
    }

    // Fallback function to delegate calls to facets
    fallback() external payable {
        address facet = sload(msg.sig);
        require(facet != address(0), ""DiamondCutFacet: Function does not exist"");
        assembly {
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())
            switch result
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
        }
    }

    receive() external payable {}
}",contract_69.sol
"Write a Solidity smart contract that allows for token transfers between users, implements approval and allowance functions for spending tokens, and includes emission of events for successful transfers and approvals. The contract should be an extension of the StandardToken contract and have variables for the total supply, balance, and approved addresses. Token transfers and approvals should be implemented.","pragma solidity ^0.8.0;

contract StandardToken {
    mapping(address => uint256) internal balances;
    mapping(address => mapping(address => uint256)) internal allowed;
    uint256 internal totalSupply_;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0), ""Invalid address"");
        require(_value <= balances[msg.sender], ""Insufficient balance"");

        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0), ""Invalid address"");
        require(_value <= balances[_from], ""Insufficient balance"");
        require(_value <= allowed[_from][msg.sender], ""Insufficient allowance"");

        balances[_from] -= _value;
        balances[_to] += _value;
        allowed[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }
}

contract MyToken is StandardToken {
    string public name;
    string public symbol;
    uint8 public decimals;

    constructor(
        string memory _name,
        string memory _symbol,
        uint8 _decimals,
        uint256 _initialSupply
    ) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply_ = _initialSupply * 10**uint256(_decimals);
        balances[msg.sender] = totalSupply_;
        emit Transfer(address(0), msg.sender, totalSupply_);
    }
}",contract_70.sol
"Create a smart contract that manages token allocation and distribution. The contract should enable users to mint and burn tokens, as well as claim rewards from the community fund and dev fund. The contract should also have a vesting period for token distribution and a reward rate calculation. The contract should include a function for setting the treasury fund and dev fund, as well as a function to distribute farming incentives. Ensure that the contract includes the necessary logic for token distribution and implementation of the OpenZeppelin contracts.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TokenManagement {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    address public owner;
    address public treasuryFund;
    address public devFund;
    uint256 public vestingPeriod;
    uint256 public rewardRate;
    uint256 public communityFund;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Mint(address indexed to, uint256 value);
    event Burn(address indexed from, uint256 value);
    event ClaimReward(address indexed user, uint256 value);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor(uint256 initialSupply, uint256 _vestingPeriod, uint256 _rewardRate) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        owner = msg.sender;
        vestingPeriod = _vestingPeriod;
        rewardRate = _rewardRate;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }

    function mint(address to, uint256 value) public onlyOwner returns (bool success) {
        totalSupply += value;
        balanceOf[to] += value;
        emit Mint(to, value);
        emit Transfer(address(0), to, value);
        return true;
    }

    function burn(uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        totalSupply -= value;
        balanceOf[msg.sender] -= value;
        emit Burn(msg.sender, value);
        emit Transfer(msg.sender, address(0), value);
        return true;
    }

    function setTreasuryFund(address _treasuryFund) public onlyOwner {
        treasuryFund = _treasuryFund;
    }

    function setDevFund(address _devFund) public onlyOwner {
        devFund = _devFund;
    }

    function claimReward(address user, uint256 value) public returns (bool success) {
        require(balanceOf[treasuryFund] >= value, ""Insufficient funds in treasury"");
        balanceOf[treasuryFund] -= value;
        balanceOf[user] += value;
        emit ClaimReward(user, value);
        emit Transfer(treasuryFund, user, value);
        return true;
    }

    function distributeFarmingIncentives(address to, uint256 value) public onlyOwner returns (bool success) {
        require(balanceOf[devFund] >= value, ""Insufficient funds in dev fund"");
        balanceOf[devFund] -= value;
        balanceOf[to] += value;
        emit Transfer(devFund, to, value);
        return true;
    }
}",contract_71.sol
Create a smart contract that enables the control and management of ownership. The contract should allow for the transfer of ownership to a new address and renounce ownership. It should also set the initial owner. Use the provided code fragment as a reference and implement the necessary functions and logic for ownership management.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    modifier onlyOwner() {
        require(msg.sender == _owner, ""Ownable: caller is not the owner"");
        _;
    }

    function owner() public view returns (address) {
        return _owner;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }

    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }
}",contract_72.sol
"Create a smart contract that follows the IERC20 token standard. It should include functions for total supply, balance checking, sending tokens, approving transfers, and handling transfer requests. Utilize the SafeMath and Address libraries to ensure accurate calculations and efficient interaction. Focus on a clean and readable code structure.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20 {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply;
        balanceOf[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        _transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], ""Insufficient balance"");
        require(_value <= allowance[_from][msg.sender], ""Allowance exceeded"");
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    function _transfer(address _from, address _to, uint256 _value) internal {
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
    }
}",contract_73.sol
"Create a smart contract that represents a standard token with custom details. The contract should include functions for transferring tokens, approving token spending, and checking balances. It should also handle token approvals and have a total supply of tokens. Make sure to include event triggers for token transfer and approval events.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract StandardToken {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }
}",contract_74.sol
"Create a Solidity smart contract that allows users to manage factories and instances. The contract should provide functions for registering new factories and instances, retrieving factory and instance information, and retrieving paginated lists of factories and instances. The contract should also handle factory and instance retirement. Note: You can refer to the provided iRegistry interface for guidance on the required functions and their functionality.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Registry {
    struct Factory {
        uint256 id;
        string name;
        bool isActive;
    }

    struct Instance {
        uint256 id;
        uint256 factoryId;
        string name;
        bool isActive;
    }

    Factory[] public factories;
    Instance[] public instances;
    mapping(uint256 => uint256[]) public factoryInstances;

    event FactoryRegistered(uint256 indexed id, string name);
    event InstanceRegistered(uint256 indexed id, uint256 factoryId, string name);
    event FactoryRetired(uint256 indexed id);
    event InstanceRetired(uint256 indexed id);

    function registerFactory(string memory _name) public {
        uint256 id = factories.length;
        factories.push(Factory(id, _name, true));
        emit FactoryRegistered(id, _name);
    }

    function registerInstance(uint256 _factoryId, string memory _name) public {
        require(_factoryId < factories.length, ""Invalid factory ID"");
        require(factories[_factoryId].isActive, ""Factory is retired"");
        uint256 id = instances.length;
        instances.push(Instance(id, _factoryId, _name, true));
        factoryInstances[_factoryId].push(id);
        emit InstanceRegistered(id, _factoryId, _name);
    }

    function retireFactory(uint256 _id) public {
        require(_id < factories.length, ""Invalid factory ID"");
        factories[_id].isActive = false;
        emit FactoryRetired(_id);
    }

    function retireInstance(uint256 _id) public {
        require(_id < instances.length, ""Invalid instance ID"");
        instances[_id].isActive = false;
        emit InstanceRetired(_id);
    }

    function getFactory(uint256 _id) public view returns (uint256, string memory, bool) {
        require(_id < factories.length, ""Invalid factory ID"");
        Factory memory factory = factories[_id];
        return (factory.id, factory.name, factory.isActive);
    }

    function getInstance(uint256 _id) public view returns (uint256, uint256, string memory, bool) {
        require(_id < instances.length, ""Invalid instance ID"");
        Instance memory instance = instances[_id];
        return (instance.id, instance.factoryId, instance.name, instance.isActive);
    }

    function getFactories(uint256 _start, uint256 _count) public view returns (Factory[] memory) {
        uint256 end = _start + _count;
        if (end > factories.length) {
            end = factories.length;
        }
        Factory[] memory result = new Factory[](end - _start);
        for (uint256 i = _start; i < end; i++) {
            result[i - _start] = factories[i];
        }
        return result;
    }

    function getInstances(uint256 _start, uint256 _count) public view returns (Instance[] memory) {
        uint256 end = _start + _count;
        if (end > instances.length) {
            end = instances.length;
        }
        Instance[] memory result = new Instance[](end - _start);
        for (uint256 i = _start; i < end; i++) {
            result[i - _start] = instances[i];
        }
        return result;
    }
}",contract_75.sol
Create a smart contract that builds upon OpenZeppelin's Ownable contract and adds a function to calculate the total value of a given asset. Use the provided formula to ensure accurate calculations. The contract should only allow the owner to transfer ownership and access specific functions. Implement smart contract best practices and include relevant error handling and debugging mechanisms.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(isOwner(), ""Ownable: caller is not the owner"");
        _;
    }

    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract AssetValueCalculator is Ownable {
    struct Asset {
        uint256 quantity;
        uint256 price;
    }

    mapping(address => Asset) public assets;

    function setAsset(address assetAddress, uint256 quantity, uint256 price) public onlyOwner {
        assets[assetAddress] = Asset(quantity, price);
    }

    function calculateTotalValue(address assetAddress) public view onlyOwner returns (uint256) {
        Asset memory asset = assets[assetAddress];
        require(asset.quantity > 0 && asset.price > 0, ""Asset not found or invalid data"");
        return asset.quantity * asset.price;
    }
}",contract_76.sol
"Create a smart contract that builds upon the provided Solidity code fragment. Incorporate the necessary functions and interfaces (IBEP20, IDEXFactory) to manage BEP20 tokens and create trading pairs with IDEX. Implement authorization mechanisms to restrict specific functionality to authorized addresses. Focus on developing a robust and secure smart contract that meets the requirements of the provided code fragment.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IBEP20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface IDEXFactory {
    function createPair(address tokenA, address tokenB) external returns (address pair);
}

contract Token is IBEP20 {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public override totalSupply;

    mapping(address => uint256) public override balanceOf;
    mapping(address => mapping(address => uint256)) public override allowance;

    address public owner;
    address public factory;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the owner"");
        _;
    }

    constructor(uint256 initialSupply, address _factory) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        owner = msg.sender;
        factory = _factory;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, allowance[sender][msg.sender] - amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, allowance[msg.sender][spender] + addedValue);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, allowance[msg.sender][spender] - subtractedValue);
        return true;
    }

    function createPairWithIDEX(address tokenB) public onlyOwner returns (address pair) {
        IDEXFactory factoryContract = IDEXFactory(factory);
        pair = factoryContract.createPair(address(this), tokenB);
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""Transfer from the zero address"");
        require(recipient != address(0), ""Transfer to the zero address"");

        balanceOf[sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""Approve from the zero address"");
        require(spender != address(0), ""Approve to the zero address"");

        allowance[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}",contract_77.sol
"Develop a smart contract that allows for wallet address balance increases, utilizes a specific function to perform the transfer, and includes error handling for insufficient balance and invalid target addresses. The contract should be structured to utilize OpenZeppelin's Initializable contract and AddressUpgradeable library. Implement a user-friendly interface for sending the specified amount to the target address.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Initializable {
    bool inited = false;

    modifier initializer() {
        require(!inited, ""already inited"");
        _;
        inited = true;
    }
}

library AddressUpgradeable {
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }
}

contract Wallet is Initializable {
    mapping(address => uint256) private balances;

    function initialize() public initializer {
        // Initialization code, if any
    }

    function increaseBalance(address wallet, uint256 amount) external {
        require(wallet != address(0), ""Invalid wallet address"");
        balances[wallet] += amount;
    }

    function transfer(address to, uint256 amount) external {
        require(to != address(0), ""Invalid target address"");
        require(balances[msg.sender] >= amount, ""Insufficient balance"");
        balances[msg.sender] -= amount;
        balances[to] += amount;
    }

    function getBalance(address wallet) external view returns (uint256) {
        return balances[wallet];
    }
}",contract_78.sol
"Create a smart contract that manages a digital currency, allowing users to transfer funds and approve addresses to spend tokens. The contract should keep track of token balances and support operations such as transferring funds, approving other addresses, and retrieving the remaining allowance.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DigitalCurrency {
    string public name = ""MyDigitalCurrency"";
    string public symbol = ""MDC"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }
}",contract_79.sol
"Create a smart contract that allows users to stake, update, and claim rewards for a specific token. The contract should enable users to create pools with varying allocation points and manage staking and unstaking of tokens. Implement functions for creating, updating, and maintaining pools, as well as handling staking, unstaking, emergency unstaking, claiming, and tier obtaining. Utilize the OpenZeppelin library for Ownable and Pausable features. Ensure that the contract tracks the total allocation points and service balance. Include event logs for each action.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract StakingRewards is Ownable, Pausable {
    using SafeMath for uint256;

    struct Pool {
        uint256 allocationPoints;
        uint256 lastRewardBlock;
        uint256 accRewardPerShare;
    }

    struct UserInfo {
        uint256 amount;
        uint256 rewardDebt;
    }

    IERC20 public rewardToken;
    uint256 public rewardPerBlock;
    uint256 public totalAllocationPoints;
    uint256 public startBlock;

    Pool[] public pools;
    mapping(uint256 => mapping(address => UserInfo)) public userInfo;

    event PoolCreated(uint256 indexed pid, uint256 allocationPoints);
    event PoolUpdated(uint256 indexed pid, uint256 allocationPoints);
    event Staked(address indexed user, uint256 indexed pid, uint256 amount);
    event Unstaked(address indexed user, uint256 indexed pid, uint256 amount);
    event EmergencyUnstake(address indexed user, uint256 indexed pid, uint256 amount);
    event Claimed(address indexed user, uint256 indexed pid, uint256 amount);

    constructor(
        IERC20 _rewardToken,
        uint256 _rewardPerBlock,
        uint256 _startBlock
    ) {
        rewardToken = _rewardToken;
        rewardPerBlock = _rewardPerBlock;
        startBlock = _startBlock;
        totalAllocationPoints = 0;
    }

    function createPool(uint256 _allocationPoints) public onlyOwner {
        require(_allocationPoints > 0, ""Invalid allocation points"");
        pools.push(Pool({
            allocationPoints: _allocationPoints,
            lastRewardBlock: block.number > startBlock ? block.number : startBlock,
            accRewardPerShare: 0
        }));
        totalAllocationPoints = totalAllocationPoints.add(_allocationPoints);
        emit PoolCreated(pools.length.sub(1), _allocationPoints);
    }

    function updatePool(uint256 _pid, uint256 _allocationPoints) public onlyOwner {
        Pool storage pool = pools[_pid];
        if (block.number > pool.lastRewardBlock) {
            uint256 lpSupply = pool.accRewardPerShare;
            if (lpSupply > 0) {
                uint256 blocks = block.number.sub(pool.lastRewardBlock);
                uint256 reward = blocks.mul(rewardPerBlock).mul(pool.allocationPoints).div(totalAllocationPoints);
                pool.accRewardPerShare = pool.accRewardPerShare.add(reward.mul(1e12).div(lpSupply));
            }
            pool.lastRewardBlock = block.number;
        }
        totalAllocationPoints = totalAllocationPoints.sub(pool.allocationPoints).add(_allocationPoints);
        pool.allocationPoints = _allocationPoints;
        emit PoolUpdated(_pid, _allocationPoints);
    }

    function stake(uint256 _pid, uint256 _amount) public whenNotPaused {
        Pool storage pool = pools[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        updatePool(_pid, pool.allocationPoints);
        if (user.amount > 0) {
            uint256 pending = user.amount.mul(pool.accRewardPerShare).div(1e12).sub(user.rewardDebt);
            if (pending > 0) {
                safeRewardTransfer(msg.sender, pending);
            }
        }
        if (_amount > 0) {
            rewardToken.transferFrom(msg.sender, address(this), _amount);
            user.amount = user.amount.add(_amount);
        }
        user.rewardDebt = user.amount.mul(pool.accRewardPerShare).div(1e12);
        emit Staked(msg.sender, _pid, _amount);
    }

    function unstake(uint256 _pid, uint256 _amount) public {
        Pool storage pool = pools[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        require(user.amount >= _amount, ""Insufficient balance"");
        updatePool(_pid, pool.allocationPoints);
        uint256 pending = user.amount.mul(pool.accRewardPerShare).div(1e12).sub(user.rewardDebt);
        if (pending > 0) {
            safeRewardTransfer(msg.sender, pending);
        }
        if (_amount > 0) {
            user.amount = user.amount.sub(_amount);
            rewardToken.transfer(msg.sender, _amount);
        }
        user.rewardDebt = user.amount.mul(pool.accRewardPerShare).div(1e12);
        emit Unstaked(msg.sender, _pid, _amount);
    }

    function emergencyUnstake(uint256 _pid, uint256 _amount) public {
        UserInfo storage user = userInfo[_pid][msg.sender];
        require(user.amount >= _amount, ""Insufficient balance"");
        user.amount = user.amount.sub(_amount);
        rewardToken.transfer(msg.sender, _amount);
        emit EmergencyUnstake(msg.sender, _pid, _amount);
    }

    function claim(uint256 _pid) public {
        Pool storage pool = pools[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        updatePool(_pid, pool.allocationPoints);
        uint256 pending = user.amount.mul(pool.accRewardPerShare).div(1e12).sub(user.rewardDebt);
        if (pending > 0) {
            safeRewardTransfer(msg.sender, pending);
        }
        user.rewardDebt = user.amount.mul(pool.accRewardPerShare).div(1e12);
        emit Claimed(msg.sender, _pid, pending);
    }

    function safeRewardTransfer(address _to, uint256 _amount) internal {
        uint256 balance = rewardToken.balanceOf(address(this));
        if (_amount > balance) {
            rewardToken.transfer(_to, balance);
        } else {
            rewardToken.transfer(_to, _amount);
        }
    }
}

abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

abstract contract Pausable is Ownable {
    bool private _paused;

    event Paused(address account);
    event Unpaused(address account);

    constructor() {
        _paused = false;
    }

    function paused() public view virtual returns (bool) {
        return _paused;
    }

    modifier whenNotPaused() {
        require(!paused(), ""Pausable: paused"");
        _;
    }

    modifier whenPaused() {
        require(paused(), ""Pausable: not paused"");
        _;
    }

    function pause() public virtual onlyOwner whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    function unpause() public virtual onlyOwner whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        return a - b;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) return 0;
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        return a / b;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: modulo by zero"");
        return a % b;
    }
}",contract_80.sol
"Create a smart contract that implements a tax office with the ability to set tax tiers and enable or disable tax exclusions for certain addresses. The contract should also store addresses for pumpkin, wftm, and uniRouter. Include a function to set tax tiers via TWAP and ensure only authorized operators can perform this action. Utilize the SafeMath library for mathematical operations.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TaxOffice {
    using SafeMath for uint256;

    address public pumpkin;
    address public wftm;
    address public uniRouter;

    struct TaxTier {
        uint256 lowerBound;
        uint256 upperBound;
        uint256 taxRate;
    }

    TaxTier[] public taxTiers;
    mapping(address => bool) public taxExclusions;
    mapping(address => bool) public authorizedOperators;

    event TaxTierSet(uint256 indexed tierIndex, uint256 lowerBound, uint256 upperBound, uint256 taxRate);
    event TaxExclusionSet(address indexed account, bool excluded);
    event OperatorSet(address indexed operator, bool authorized);

    modifier onlyOperator() {
        require(authorizedOperators[msg.sender], ""Not an authorized operator"");
        _;
    }

    constructor(address _pumpkin, address _wftm, address _uniRouter) {
        pumpkin = _pumpkin;
        wftm = _wftm;
        uniRouter = _uniRouter;
        authorizedOperators[msg.sender] = true;
    }

    function setTaxTier(uint256 _tierIndex, uint256 _lowerBound, uint256 _upperBound, uint256 _taxRate) external onlyOperator {
        require(_tierIndex < taxTiers.length, ""Invalid tier index"");
        taxTiers[_tierIndex] = TaxTier(_lowerBound, _upperBound, _taxRate);
        emit TaxTierSet(_tierIndex, _lowerBound, _upperBound, _taxRate);
    }

    function addTaxTier(uint256 _lowerBound, uint256 _upperBound, uint256 _taxRate) external onlyOperator {
        taxTiers.push(TaxTier(_lowerBound, _upperBound, _taxRate));
        emit TaxTierSet(taxTiers.length - 1, _lowerBound, _upperBound, _taxRate);
    }

    function setTaxExclusion(address _account, bool _excluded) external onlyOperator {
        taxExclusions[_account] = _excluded;
        emit TaxExclusionSet(_account, _excluded);
    }

    function setOperator(address _operator, bool _authorized) external onlyOperator {
        authorizedOperators[_operator] = _authorized;
        emit OperatorSet(_operator, _authorized);
    }

    function getTaxRate(uint256 _value) public view returns (uint256) {
        for (uint256 i = 0; i < taxTiers.length; i++) {
            if (_value >= taxTiers[i].lowerBound && _value <= taxTiers[i].upperBound) {
                return taxTiers[i].taxRate;
            }
        }
        return 0;
    }

    function isExcluded(address _account) public view returns (bool) {
        return taxExclusions[_account];
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, ""SafeMath: modulo by zero"");
        return a % b;
    }
}",contract_81.sol
"Create a smart contract that follows the ERC-20 token standard, with functions for managing token supply, balances, and transfers. The contract should include a mechanism for setting a fee recipient and distributing transfer fees. Additionally, provide functions for approving and managing token allowance for spending and transferring. Note: ensure the contract uses safe arithmetic operations and follows best practices for secure coding.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    address public feeRecipient;
    uint256 public transferFeePercentage;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event FeeRecipientSet(address indexed newFeeRecipient);
    event TransferFeePercentageSet(uint256 newTransferFeePercentage);

    constructor(
        string memory _name,
        string memory _symbol,
        uint8 _decimals,
        uint256 _initialSupply,
        address _feeRecipient,
        uint256 _transferFeePercentage
    ) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _initialSupply * 10**uint256(_decimals);
        balanceOf[msg.sender] = totalSupply;
        feeRecipient = _feeRecipient;
        transferFeePercentage = _transferFeePercentage;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(allowance[_from][msg.sender] >= _value, ""Insufficient allowance"");
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    function setFeeRecipient(address _newFeeRecipient) public {
        require(msg.sender == feeRecipient, ""Only fee recipient can set new fee recipient"");
        feeRecipient = _newFeeRecipient;
        emit FeeRecipientSet(_newFeeRecipient);
    }

    function setTransferFeePercentage(uint256 _newTransferFeePercentage) public {
        require(msg.sender == feeRecipient, ""Only fee recipient can set transfer fee percentage"");
        require(_newTransferFeePercentage <= 100, ""Fee percentage must be <= 100"");
        transferFeePercentage = _newTransferFeePercentage;
        emit TransferFeePercentageSet(_newTransferFeePercentage);
    }

    function _transfer(address _from, address _to, uint256 _value) internal {
        require(_to != address(0), ""Cannot transfer to the zero address"");
        require(balanceOf[_from] >= _value, ""Insufficient balance"");

        uint256 fee = (_value * transferFeePercentage) / 100;
        uint256 amountAfterFee = _value - fee;

        balanceOf[_from] -= _value;
        balanceOf[_to] += amountAfterFee;
        balanceOf[feeRecipient] += fee;

        emit Transfer(_from, _to, amountAfterFee);
        emit Transfer(_from, feeRecipient, fee);
    }
}",contract_82.sol
"Create a smart contract that enables the transfer of tokens, approval of allowance, and transfer of ETH. The contract should include functions for safe transfer from, safe transfer, safe approve, and safe transfer ETH. Implement basic error handling and logging. Ensure the contract's functionality is structured and readable.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TokenTransfer {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    uint256 private _totalSupply;
    string private _name;
    string private _symbol;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event TransferETH(address indexed from, address indexed to, uint256 value);

    constructor(string memory name_, string memory symbol_, uint256 totalSupply_) {
        _name = name_;
        _symbol = symbol_;
        _totalSupply = totalSupply_;
        _balances[msg.sender] = totalSupply_;
        emit Transfer(address(0), msg.sender, totalSupply_);
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) public returns (bool) {
        _safeTransfer(msg.sender, to, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _safeApprove(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) public returns (bool) {
        _safeTransferFrom(from, to, amount);
        return true;
    }

    function transferETH(address payable to, uint256 amount) public returns (bool) {
        _safeTransferETH(to, amount);
        return true;
    }

    function _safeTransfer(address from, address to, uint256 amount) internal {
        require(from != address(0), ""ERC20: transfer from the zero address"");
        require(to != address(0), ""ERC20: transfer to the zero address"");
        require(_balances[from] >= amount, ""ERC20: transfer amount exceeds balance"");

        _balances[from] -= amount;
        _balances[to] += amount;
        emit Transfer(from, to, amount);
    }

    function _safeApprove(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _safeTransferFrom(address from, address to, uint256 amount) internal {
        require(from != address(0), ""ERC20: transfer from the zero address"");
        require(to != address(0), ""ERC20: transfer to the zero address"");
        require(_balances[from] >= amount, ""ERC20: transfer amount exceeds balance"");
        require(_allowances[from][msg.sender] >= amount, ""ERC20: transfer amount exceeds allowance"");

        _balances[from] -= amount;
        _balances[to] += amount;
        _allowances[from][msg.sender] -= amount;
        emit Transfer(from, to, amount);
    }

    function _safeTransferETH(address payable to, uint256 amount) internal {
        require(to != address(0), ""ETH: transfer to the zero address"");
        require(address(this).balance >= amount, ""ETH: transfer amount exceeds balance"");

        to.transfer(amount);
        emit TransferETH(msg.sender, to, amount);
    }

    receive() external payable {
        // Allow contract to receive ETH
    }
}",contract_83.sol
"Develop a smart contract that controls access to specific roles within a decentralized application. The contract should include functionality for creating and managing roles, assigning roles to accounts, and revoking roles. It should also include a mechanism to enforce role-based access control. Provide functions for retrieving role admins and checking role membership. Implement string library functions for address and hexadecimal conversions. Focus on ensuring the contract meets the requirements outlined in the IAccessControl interface.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract AccessControl {
    bytes32 private constant DEFAULT_ADMIN_ROLE = 0x00;

    struct RoleData {
        mapping(address => bool) members;
        bytes32 adminRole;
    }

    mapping(bytes32 => RoleData) private _roles;

    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    function hasRole(bytes32 role, address account) public view returns (bool) {
        return _roles[role].members[account];
    }

    function getRoleAdmin(bytes32 role) public view returns (bytes32) {
        return _roles[role].adminRole;
    }

    function grantRole(bytes32 role, address account) public {
        require(hasRole(_roles[role].adminRole, msg.sender), ""AccessControl: sender must be an admin to grant"");
        _grantRole(role, account);
    }

    function revokeRole(bytes32 role, address account) public {
        require(hasRole(_roles[role].adminRole, msg.sender), ""AccessControl: sender must be an admin to revoke"");
        _revokeRole(role, account);
    }

    function renounceRole(bytes32 role, address account) public {
        require(account == msg.sender, ""AccessControl: can only renounce roles for self"");
        _revokeRole(role, account);
    }

    function _setupRole(bytes32 role, address account) internal {
        _grantRole(role, account);
    }

    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {
        bytes32 previousAdminRole = getRoleAdmin(role);
        _roles[role].adminRole = adminRole;
        emit RoleAdminChanged(role, previousAdminRole, adminRole);
    }

    function _grantRole(bytes32 role, address account) private {
        if (!hasRole(role, account)) {
            _roles[role].members[account] = true;
            emit RoleGranted(role, account, msg.sender);
        }
    }

    function _revokeRole(bytes32 role, address account) private {
        if (hasRole(role, account)) {
            _roles[role].members[account] = false;
            emit RoleRevoked(role, account, msg.sender);
        }
    }

    function toString(address account) public pure returns (string memory) {
        return toString(abi.encodePacked(account));
    }

    function toString(bytes memory data) public pure returns (string memory) {
        bytes memory alphabet = ""0123456789abcdef"";

        bytes memory str = new bytes(2 + data.length * 2);
        str[0] = ""0"";
        str[1] = ""x"";
        for (uint i = 0; i < data.length; i++) {
            str[2 + i * 2] = alphabet[uint(uint8(data[i] >> 4))];
            str[3 + i * 2] = alphabet[uint(uint8(data[i] & 0x0f))];
        }
        return string(str);
    }
}",contract_84.sol
"Create a Solidity contract that allows for the minting of tokens. The contract should have functions for presale and public minting, and include variables for maximum supply, public and presale prices, and allowed mint limits. The contract should also have functions for withdrawing funds and setting the merkle root. Implement a constructor that initializes the contract name and symbol.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TokenMinter {
    string public name;
    string public symbol;
    uint256 public totalSupply;
    uint256 public maxSupply;
    uint256 public publicPrice;
    uint256 public presalePrice;
    uint256 public publicMintLimit;
    uint256 public presaleMintLimit;
    bytes32 public merkleRoot;
    address public owner;

    mapping(address => uint256) public balances;
    mapping(address => uint256) public presaleMints;
    mapping(address => uint256) public publicMints;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor(
        string memory _name,
        string memory _symbol,
        uint256 _maxSupply,
        uint256 _publicPrice,
        uint256 _presalePrice,
        uint256 _publicMintLimit,
        uint256 _presaleMintLimit
    ) {
        name = _name;
        symbol = _symbol;
        maxSupply = _maxSupply;
        publicPrice = _publicPrice;
        presalePrice = _presalePrice;
        publicMintLimit = _publicMintLimit;
        presaleMintLimit = _presaleMintLimit;
        owner = msg.sender;
    }

    function setMerkleRoot(bytes32 _merkleRoot) external onlyOwner {
        merkleRoot = _merkleRoot;
    }

    function presaleMint(uint256 amount, bytes32[] calldata proof) external payable {
        require(totalSupply + amount <= maxSupply, ""Exceeds max supply"");
        require(presaleMints[msg.sender] + amount <= presaleMintLimit, ""Exceeds presale mint limit"");
        require(msg.value == presalePrice * amount, ""Incorrect ETH amount"");
        require(verify(proof, keccak256(abi.encodePacked(msg.sender))), ""Invalid proof"");

        _mint(msg.sender, amount);
        presaleMints[msg.sender] += amount;
    }

    function publicMint(uint256 amount) external payable {
        require(totalSupply + amount <= maxSupply, ""Exceeds max supply"");
        require(publicMints[msg.sender] + amount <= publicMintLimit, ""Exceeds public mint limit"");
        require(msg.value == publicPrice * amount, ""Incorrect ETH amount"");

        _mint(msg.sender, amount);
        publicMints[msg.sender] += amount;
    }

    function _mint(address to, uint256 amount) internal {
        totalSupply += amount;
        balances[to] += amount;
    }

    function withdraw() external onlyOwner {
        payable(owner).transfer(address(this).balance);
    }

    function verify(bytes32[] memory proof, bytes32 leaf) internal view returns (bool) {
        bytes32 computedHash = leaf;

        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];

            if (computedHash <= proofElement) {
                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));
            } else {
                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));
            }
        }

        return computedHash == merkleRoot;
    }
}",contract_85.sol
"Create a smart contract that allows for minting of a new token, with specific name, symbol, and decimals. The contract should also enable token transfer, allow for approval and increase/decrease approval, and implement burn functionality. Ownership is also important, ensuring that only the owner can transfer tokens.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MyToken {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    address public owner;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Burn(address indexed from, uint256 value);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _initialSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _initialSupply * 10 ** uint256(_decimals);
        balanceOf[msg.sender] = totalSupply;
        owner = msg.sender;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address _to, uint256 _value) public onlyOwner returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], ""Insufficient balance"");
        require(_value <= allowance[_from][msg.sender], ""Allowance exceeded"");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    function increaseApproval(address _spender, uint256 _addedValue) public returns (bool success) {
        allowance[msg.sender][_spender] += _addedValue;
        emit Approval(msg.sender, _spender, allowance[msg.sender][_spender]);
        return true;
    }

    function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool success) {
        uint256 oldValue = allowance[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
            allowance[msg.sender][_spender] = 0;
        } else {
            allowance[msg.sender][_spender] = oldValue - _subtractedValue;
        }
        emit Approval(msg.sender, _spender, allowance[msg.sender][_spender]);
        return true;
    }

    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        totalSupply -= _value;
        emit Burn(msg.sender, _value);
        emit Transfer(msg.sender, address(0), _value);
        return true;
    }
}",contract_86.sol
"Create a smart contract that implements a revenue sharing model for a multi-level marketing organization. The contract should allow investors to deposit funds, make investments, and withdraw funds. It should also track deposits and withdrawals, and calculate daily income and commission distributions. The contract should include variables for storing investor information and investment records, and has internal functions for processing deposits and withdrawals. Externally, allow users to deposit and withdraw funds. Include modifiers for restricting access to certain functions based on user roles.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract RevenueSharing {
    struct Investor {
        uint256 totalInvestment;
        uint256 lastWithdrawal;
        uint256 pendingIncome;
        bool isActive;
    }

    mapping(address => Investor) public investors;
    address[] public investorList;
    uint256 public totalInvestments;
    uint256 public totalWithdrawals;
    uint256 public dailyIncomeRate; // in wei per investment unit

    modifier onlyActiveInvestor() {
        require(investors[msg.sender].isActive, ""Not an active investor"");
        _;
    }

    modifier onlyNonActiveInvestor() {
        require(!investors[msg.sender].isActive, ""Already an active investor"");
        _;
    }

    constructor(uint256 _dailyIncomeRate) {
        dailyIncomeRate = _dailyIncomeRate;
    }

    function deposit() public payable onlyNonActiveInvestor {
        require(msg.value > 0, ""Deposit amount must be greater than 0"");
        if (!investors[msg.sender].isActive) {
            investors[msg.sender].isActive = true;
            investorList.push(msg.sender);
        }
        investors[msg.sender].totalInvestment += msg.value;
        totalInvestments += msg.value;
        distributeDailyIncome();
    }

    function withdraw(uint256 amount) public onlyActiveInvestor {
        require(amount > 0, ""Withdrawal amount must be greater than 0"");
        require(amount <= investors[msg.sender].pendingIncome, ""Insufficient balance"");
        investors[msg.sender].pendingIncome -= amount;
        totalWithdrawals += amount;
        payable(msg.sender).transfer(amount);
        distributeDailyIncome();
    }

    function distributeDailyIncome() internal {
        for (uint256 i = 0; i < investorList.length; i++) {
            address investorAddress = investorList[i];
            if (investors[investorAddress].isActive) {
                uint256 daysSinceLastWithdrawal = (block.timestamp - investors[investorAddress].lastWithdrawal) / 1 days;
                if (daysSinceLastWithdrawal > 0) {
                    uint256 income = daysSinceLastWithdrawal * dailyIncomeRate * investors[investorAddress].totalInvestment;
                    investors[investorAddress].pendingIncome += income;
                    investors[investorAddress].lastWithdrawal = block.timestamp;
                }
            }
        }
    }

    function getInvestorBalance(address investor) public view returns (uint256) {
        return investors[investor].pendingIncome;
    }

    function getTotalInvestments() public view returns (uint256) {
        return totalInvestments;
    }

    function getTotalWithdrawals() public view returns (uint256) {
        return totalWithdrawals;
    }
}",contract_87.sol
"Create a smart contract that supports asset transfer between addresses. The contract should allow for basic operations like withdraw, balance check, and allowance setting. Include event emitters for key actions like transfer, approve, and transferFrom. Implement necessary error handling for arithmetic operations.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract AssetTransfer {
    string public name = ""AssetTransfer"";
    string public symbol = ""AT"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }
}",contract_88.sol
"Create a smart contract that manages vaults, allowing users to deposit, borrow, and repay tokens. functions should get asset and debt information, as well as calculate equity. Implement getter functions for current asset value and equity. Utilize ReentrancyGuard, Pausable, and AccessControl for added security. Familiarize yourself with the OpenZeppelin libraries and explore their usage.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract VaultManager is ReentrancyGuard, Pausable, AccessControl {
    bytes32 public constant PAUSER_ROLE = keccak256(""PAUSER_ROLE"");
    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");

    struct Vault {
        uint256 assets;
        uint256 debt;
    }

    mapping(address => Vault) public vaults;
    IERC20 public token;

    event Deposit(address indexed user, uint256 amount);
    event Borrow(address indexed user, uint256 amount);
    event Repay(address indexed user, uint256 amount);

    constructor(address _token) {
        token = IERC20(_token);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(PAUSER_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    modifier onlyAdmin() {
        require(hasRole(ADMIN_ROLE, msg.sender), ""VaultManager: caller is not an admin"");
        _;
    }

    function pause() public onlyAdmin {
        _pause();
    }

    function unpause() public onlyAdmin {
        _unpause();
    }

    function deposit(uint256 amount) public nonReentrant whenNotPaused {
        require(token.transferFrom(msg.sender, address(this), amount), ""VaultManager: deposit transfer failed"");
        vaults[msg.sender].assets += amount;
        emit Deposit(msg.sender, amount);
    }

    function borrow(uint256 amount) public nonReentrant whenNotPaused {
        require(vaults[msg.sender].assets >= amount, ""VaultManager: insufficient assets"");
        require(token.transfer(msg.sender, amount), ""VaultManager: borrow transfer failed"");
        vaults[msg.sender].debt += amount;
        emit Borrow(msg.sender, amount);
    }

    function repay(uint256 amount) public nonReentrant whenNotPaused {
        require(token.transferFrom(msg.sender, address(this), amount), ""VaultManager: repay transfer failed"");
        vaults[msg.sender].debt -= amount;
        emit Repay(msg.sender, amount);
    }

    function getAssetValue(address user) public view returns (uint256) {
        return vaults[user].assets;
    }

    function getDebtValue(address user) public view returns (uint256) {
        return vaults[user].debt;
    }

    function calculateEquity(address user) public view returns (int256) {
        return int256(vaults[user].assets) - int256(vaults[user].debt);
    }
}

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

abstract contract ReentrancyGuard {
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    modifier nonReentrant() {
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");
        _status = _ENTERED;
        _;
        _status = _NOT_ENTERED;
    }
}

abstract contract Pausable is Context {
    event Paused(address account);
    event Unpaused(address account);

    bool private _paused;

    constructor() {
        _paused = false;
    }

    function paused() public view virtual returns (bool) {
        return _paused;
    }

    modifier whenNotPaused() {
        require(!_paused, ""Pausable: paused"");
        _;
    }

    modifier whenPaused() {
        require(_paused, ""Pausable: not paused"");
        _;
    }

    function _pause() internal virtual whenNotPaused {
        _paused = true;
        emit Paused(_msgSender());
    }

    function _unpause() internal virtual whenPaused {
        _paused = false;
        emit Unpaused(_msgSender());
    }
}

abstract contract AccessControl is Context {
    struct RoleData {
        mapping(address => bool) members;
        bytes32 adminRole;
    }

    mapping(bytes32 => RoleData) private _roles;

    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    function hasRole(bytes32 role, address account) public view returns (bool) {
        return _roles[role].members[account];
    }

    function getRoleAdmin(bytes32 role) public view returns (bytes32) {
        return _roles[role].adminRole;
    }

    function grantRole(bytes32 role, address account) public virtual {
        require(hasRole(getRoleAdmin(role), _msgSender()), ""AccessControl: sender must be an admin to grant"");
        _grantRole(role, account);
    }

    function revokeRole(bytes32 role, address account) public virtual {
        require(hasRole(getRoleAdmin(role), _msgSender()), ""AccessControl: sender must be an admin to revoke"");
        _revokeRole(role, account);
    }

    function renounceRole(bytes32 role, address account) public virtual {
        require(account == _msgSender(), ""AccessControl: can only renounce roles for self"");
        _revokeRole(role, account);
    }

    function _setupRole(bytes32 role, address account) internal virtual {
        _grantRole(role, account);
    }

    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
        _roles[role].adminRole = adminRole;
    }

    function _grantRole(bytes32 role, address account) private {
        if (!hasRole(role, account)) {
            _roles[role].members[account] = true;
            emit RoleGranted(role, account, _msgSender());
        }
    }

    function _revokeRole(bytes32 role, address account) private {
        if (hasRole(role, account)) {
            _roles[role].members[account] = false;
            emit RoleRevoked(role, account, _msgSender());
        }
    }
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}",contract_89.sol
"Create a smart contract that builds upon the SafeMath library and incorporates authorization mechanisms using the Auth contract. The contract should interact with IDEXFactory and IDEXRouter interfaces for integration with decentralized exchanges. Provide high-level descriptions for each function, focusing on the desired functionality and technical implementation.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }
}

contract Auth {
    address private _owner;

    constructor() {
        _owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == _owner, ""Auth: caller is not the owner"");
        _;
    }

    function changeOwner(address newOwner) external onlyOwner {
        _owner = newOwner;
    }
}

interface IDEXFactory {
    function createPair(address tokenA, address tokenB) external returns (address pair);
}

interface IDEXRouter {
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);

    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
}

contract DEXIntegration is SafeMath, Auth {
    IDEXFactory public factory;
    IDEXRouter public router;

    constructor(address _factory, address _router) {
        factory = IDEXFactory(_factory);
        router = IDEXRouter(_router);
    }

    function createPair(address tokenA, address tokenB) external onlyOwner returns (address pair) {
        pair = factory.createPair(tokenA, tokenB);
    }

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external onlyOwner returns (uint amountA, uint amountB, uint liquidity) {
        (amountA, amountB, liquidity) = router.addLiquidity(
            tokenA,
            tokenB,
            amountADesired,
            amountBDesired,
            amountAMin,
            amountBMin,
            to,
            deadline
        );
    }

    function swapTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external onlyOwner returns (uint[] memory amounts) {
        amounts = router.swapExactTokensForTokens(
            amountIn,
            amountOutMin,
            path,
            to,
            deadline
        );
    }
}",contract_90.sol
"Create a smart contract for the F4Kings game, inheriting from F3Devents. The contract should track game settings, admin and shareCom addresses, and game statistics. Implement events for player registration, buying/reloading, withdrawing, and affiliate payouts. Include features for air drops, round timers, and affiliate payments. Focus on readability and maintainability.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract F3Devents {
    event onPlayerRegistered(address playerAddress);
    event onPlayerBuy(address playerAddress, uint256 amount);
    event onPlayerReload(address playerAddress, uint256 amount);
    event onWithdraw(address playerAddress, uint256 amount);
    event onAffiliatePayout(address affiliateAddress, uint256 amount);
}

contract F4Kings is F3Devents {
    address public admin;
    address public shareCom;

    struct GameSettings {
        uint256 registrationFee;
        uint256 buyFee;
        uint256 reloadFee;
        uint256 withdrawFee;
        uint256 affiliatePercentage;
    }

    struct GameStatistics {
        uint256 totalPlayers;
        uint256 totalBuys;
        uint256 totalReloads;
        uint256 totalWithdrawals;
        uint256 totalAffiliatePayouts;
    }

    GameSettings public settings;
    GameStatistics public statistics;

    mapping(address => bool) public players;
    mapping(address => address) public affiliates;
    mapping(address => uint256) public balances;

    uint256 public roundStartTime;
    uint256 public roundDuration;

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can call this function"");
        _;
    }

    constructor(address _admin, address _shareCom, uint256 _roundDuration) {
        admin = _admin;
        shareCom = _shareCom;
        roundDuration = _roundDuration;
        roundStartTime = block.timestamp;
    }

    function registerPlayer(address _affiliate) public payable {
        require(msg.value == settings.registrationFee, ""Incorrect registration fee"");
        require(!players[msg.sender], ""Player already registered"");

        players[msg.sender] = true;
        affiliates[msg.sender] = _affiliate;
        statistics.totalPlayers++;

        emit onPlayerRegistered(msg.sender);
    }

    function buy(uint256 amount) public payable {
        require(msg.value == amount + settings.buyFee, ""Incorrect buy fee"");
        require(players[msg.sender], ""Player not registered"");

        balances[msg.sender] += amount;
        statistics.totalBuys += amount;

        emit onPlayerBuy(msg.sender, amount);
    }

    function reload(uint256 amount) public payable {
        require(msg.value == amount + settings.reloadFee, ""Incorrect reload fee"");
        require(players[msg.sender], ""Player not registered"");

        balances[msg.sender] += amount;
        statistics.totalReloads += amount;

        emit onPlayerReload(msg.sender, amount);
    }

    function withdraw(uint256 amount) public {
        require(balances[msg.sender] >= amount, ""Insufficient balance"");
        require(amount > settings.withdrawFee, ""Amount must be greater than withdraw fee"");

        balances[msg.sender] -= amount;
        payable(msg.sender).transfer(amount - settings.withdrawFee);
        statistics.totalWithdrawals += amount;

        emit onWithdraw(msg.sender, amount);
    }

    function affiliatePayout(address affiliate, uint256 amount) internal {
        require(amount > 0, ""Amount must be greater than zero"");

        payable(affiliate).transfer(amount);
        statistics.totalAffiliatePayouts += amount;

        emit onAffiliatePayout(affiliate, amount);
    }

    function airDrop(address[] memory recipients, uint256[] memory amounts) public onlyAdmin {
        require(recipients.length == amounts.length, ""Mismatched arrays"");

        for (uint256 i = 0; i < recipients.length; i++) {
            balances[recipients[i]] += amounts[i];
        }
    }

    function setRoundDuration(uint256 _roundDuration) public onlyAdmin {
        roundDuration = _roundDuration;
        roundStartTime = block.timestamp;
    }

    function setSettings(uint256 _registrationFee, uint256 _buyFee, uint256 _reloadFee, uint256 _withdrawFee, uint256 _affiliatePercentage) public onlyAdmin {
        settings = GameSettings({
            registrationFee: _registrationFee,
            buyFee: _buyFee,
            reloadFee: _reloadFee,
            withdrawFee: _withdrawFee,
            affiliatePercentage: _affiliatePercentage
        });
    }
}",contract_91.sol
"Create a smart contract that enables the issuance, transfer, and management of certifications. The contract should include functions for tracking the total supply of certifications, getting the balance of certifications held by an entity, transferring certifications, and approving or rejecting certification transfers. The contract should also include events for tracking certification transfers and approvals.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract CertificationManager {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event CertificationIssued(address indexed to, uint256 value);
    event CertificationTransferred(address indexed from, address indexed to, uint256 value);
    event TransferApproved(address indexed owner, address indexed spender, uint256 value);
    event TransferRejected(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _initialSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _initialSupply;
        balanceOf[msg.sender] = _initialSupply;
        emit CertificationIssued(msg.sender, _initialSupply);
    }

    function issueCertifications(address _to, uint256 _value) public {
        require(_to != address(0), ""Invalid address"");
        totalSupply += _value;
        balanceOf[_to] += _value;
        emit CertificationIssued(_to, _value);
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        emit CertificationTransferred(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        emit TransferApproved(msg.sender, _spender, _value);
        return true;
    }

    function rejectTransfer(address _spender) public returns (bool success) {
        allowance[msg.sender][_spender] = 0;
        emit TransferRejected(msg.sender, _spender, 0);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], ""Insufficient balance"");
        require(_value <= allowance[_from][msg.sender], ""Allowance exceeded"");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        emit CertificationTransferred(_from, _to, _value);
        return true;
    }
}",contract_92.sol
"Create a smart contract using Solidity that represents a Talentum token. The token should have a name, symbol, and total supply. Implement functions for transferring tokens, approving transfers, and allow-listed transfers. The contract should also include features for writers to write in the Holy Bible, readers to read the Holy Bible, and administrators to set writers and country codes. Include a donation mechanic with different price tiers based on the donate step.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TalentumToken {
    string public name = ""Talentum Token"";
    string public symbol = ""TTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    mapping(address => bool) public writers;
    mapping(address => string) public countryCodes;
    mapping(address => uint256) public donationSteps;

    address public admin;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Donation(address indexed donor, uint256 amount, uint256 step);
    event Write(address indexed writer, string text);

    constructor(uint256 _initialSupply) {
        totalSupply = _initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        admin = msg.sender;
    }

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can perform this action"");
        _;
    }

    modifier onlyWriter() {
        require(writers[msg.sender], ""Only writers can perform this action"");
        _;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], ""Insufficient balance"");
        require(_value <= allowance[_from][msg.sender], ""Allowance exceeded"");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    function setWriter(address _writer, bool _status) public onlyAdmin {
        writers[_writer] = _status;
    }

    function setCountryCode(address _user, string memory _code) public onlyAdmin {
        countryCodes[_user] = _code;
    }

    function donate(uint256 _step) public payable {
        require(_step > 0, ""Invalid donation step"");
        uint256[] memory prices = [0.1 ether, 0.5 ether, 1 ether];
        require(msg.value == prices[_step - 1], ""Incorrect donation amount"");
        donationSteps[msg.sender] = _step;
        emit Donation(msg.sender, msg.value, _step);
    }

    function write(string memory _text) public onlyWriter {
        emit Write(msg.sender, _text);
    }
}",contract_93.sol
"Create a smart contract that allows for locking and unlocking of gold, with a cache contract to manage the locked gold and a separate contract for managing the gold, implementing basic token-like functionality with supply, balance, and allowance tracking.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GoldToken {
    string public name = ""GoldToken"";
    string public symbol = ""GLD"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }
}

contract GoldLock {
    GoldToken public goldToken;
    mapping(address => uint256) public lockedGold;

    event GoldLocked(address indexed user, uint256 amount);
    event GoldUnlocked(address indexed user, uint256 amount);

    constructor(address _goldToken) {
        goldToken = GoldToken(_goldToken);
    }

    function lockGold(uint256 amount) public {
        require(goldToken.transferFrom(msg.sender, address(this), amount), ""Transfer failed"");
        lockedGold[msg.sender] += amount;
        emit GoldLocked(msg.sender, amount);
    }

    function unlockGold(uint256 amount) public {
        require(lockedGold[msg.sender] >= amount, ""Insufficient locked gold"");
        require(goldToken.transfer(msg.sender, amount), ""Transfer failed"");
        lockedGold[msg.sender] -= amount;
        emit GoldUnlocked(msg.sender, amount);
    }
}",contract_94.sol
"Create a smart contract that enables the delegation of function calls to another contract. The contract should have the ability to set various variables, including uint256 values and addresses, using a delegatecall mechanism. Implement functions for setting the num and value variables, and utilize encoding and encoding signatures to ensure proper delegation and validation.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DelegateCallProxy {
    address public implementation;
    uint256 public num;
    uint256 public value;

    constructor(address _implementation) {
        implementation = _implementation;
    }

    function setNum(uint256 _num) public {
        (bool success, ) = implementation.delegatecall(
            abi.encodeWithSignature(""setNum(uint256)"", _num)
        );
        require(success, ""Delegate call failed"");
    }

    function setValue(uint256 _value) public {
        (bool success, ) = implementation.delegatecall(
            abi.encodeWithSignature(""setValue(uint256)"", _value)
        );
        require(success, ""Delegate call failed"");
    }
}

contract Implementation {
    uint256 public num;
    uint256 public value;

    function setNum(uint256 _num) public {
        num = _num;
    }

    function setValue(uint256 _value) public {
        value = _value;
    }
}",contract_95.sol
"Create a smart contract that enables users to deposit and withdraw funds, with specific minimums and return rates. Design a system for deposit returns and product purchases. Implement functions for user registration, deposit, investment, and withdrawal. Incorporate modifiers for authorized access and log events for auditing purposes.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract InvestmentPlatform {
    struct User {
        uint balance;
        bool isRegistered;
    }

    mapping(address => User) public users;
    address public owner;
    uint public constant MIN_DEPOSIT = 1 ether;
    uint public constant RETURN_RATE = 5; // 5% return rate

    event UserRegistered(address indexed user);
    event DepositMade(address indexed user, uint amount);
    event InvestmentMade(address indexed user, uint amount);
    event WithdrawalMade(address indexed user, uint amount);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier onlyRegistered() {
        require(users[msg.sender].isRegistered, ""User not registered"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function register() external {
        require(!users[msg.sender].isRegistered, ""Already registered"");
        users[msg.sender] = User({balance: 0, isRegistered: true});
        emit UserRegistered(msg.sender);
    }

    function deposit() external payable onlyRegistered {
        require(msg.value >= MIN_DEPOSIT, ""Deposit amount too low"");
        users[msg.sender].balance += msg.value;
        emit DepositMade(msg.sender, msg.value);
    }

    function invest(uint amount) external onlyRegistered {
        require(amount <= users[msg.sender].balance, ""Insufficient balance"");
        uint returnAmount = (amount * RETURN_RATE) / 100;
        users[msg.sender].balance += returnAmount;
        emit InvestmentMade(msg.sender, amount);
    }

    function withdraw(uint amount) external onlyRegistered {
        require(amount <= users[msg.sender].balance, ""Insufficient balance"");
        users[msg.sender].balance -= amount;
        payable(msg.sender).transfer(amount);
        emit WithdrawalMade(msg.sender, amount);
    }

    function getBalance() external view returns (uint) {
        return users[msg.sender].balance;
    }
}",contract_96.sol
"Create a smart contract that handles rewards distribution for suppliers, borrowers, and transactors. The contract should have variables indicating whether it's a rewards distributor and a flywheel. Implement functions for pre-supplier, pre-borrower, and pre-transfer actions to accrue rewards. Add a function to retrieve accrued rewards and another to add new markets for rewards accrual. The contract should allow for reading the current state of markets. Provide a clear and understandable implementation.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract RewardsDistribution {
    bool public isRewardsDistributor;
    bool public isFlywheel;

    struct Market {
        bool isActive;
        uint256 rewardsRate;
    }

    mapping(address => uint256) public accruedRewards;
    mapping(address => Market) public markets;

    event RewardsAccrued(address indexed account, uint256 amount);
    event MarketAdded(address indexed market, uint256 rewardsRate);

    constructor(bool _isRewardsDistributor, bool _isFlywheel) {
        isRewardsDistributor = _isRewardsDistributor;
        isFlywheel = _isFlywheel;
    }

    function preSupplierAction(address supplier, uint256 amount) external {
        require(markets[msg.sender].isActive, ""Market not active"");
        accrueRewards(supplier, amount);
    }

    function preBorrowerAction(address borrower, uint256 amount) external {
        require(markets[msg.sender].isActive, ""Market not active"");
        accrueRewards(borrower, amount);
    }

    function preTransferAction(address from, address to, uint256 amount) external {
        require(markets[msg.sender].isActive, ""Market not active"");
        accrueRewards(from, amount);
        accrueRewards(to, amount);
    }

    function accrueRewards(address account, uint256 amount) internal {
        uint256 rewards = (amount * markets[msg.sender].rewardsRate) / 1e18;
        accruedRewards[account] += rewards;
        emit RewardsAccrued(account, rewards);
    }

    function getAccruedRewards(address account) external view returns (uint256) {
        return accruedRewards[account];
    }

    function addMarket(address market, uint256 rewardsRate) external {
        markets[market] = Market({
            isActive: true,
            rewardsRate: rewardsRate
        });
        emit MarketAdded(market, rewardsRate);
    }

    function getMarketState(address market) external view returns (bool, uint256) {
        Market memory marketInfo = markets[market];
        return (marketInfo.isActive, marketInfo.rewardsRate);
    }
}",contract_97.sol
Create a smart contract to manage the Declaration of Decentralization (DoD). The contract should store the DoD text and allow signing by designated parties. Implement validation logic to ensure only authorized parties can modify the contract state. Incorporate a constructor to initialize the debot's address and the DoD text.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DeclarationOfDecentralization {
    string public declarationText;
    address public debotAddress;
    mapping(address => bool) public signers;
    address[] public signatures;

    modifier onlyDebot() {
        require(msg.sender == debotAddress, ""Only the debot can call this function"");
        _;
    }

    modifier onlySigner() {
        require(signers[msg.sender], ""Only authorized signers can call this function"");
        _;
    }

    constructor(address _debotAddress, string memory _declarationText) {
        debotAddress = _debotAddress;
        declarationText = _declarationText;
    }

    function updateDeclaration(string memory newDeclarationText) public onlyDebot {
        declarationText = newDeclarationText;
    }

    function addSigner(address newSigner) public onlyDebot {
        signers[newSigner] = true;
    }

    function removeSigner(address signer) public onlyDebot {
        signers[signer] = false;
    }

    function signDeclaration() public onlySigner {
        signatures.push(msg.sender);
    }

    function getSignatures() public view returns (address[] memory) {
        return signatures;
    }
}",contract_98.sol
"Create a smart contract that allows for basic ownership management. The contract should have a way to initialize the owner and register feature functions, as well as a function to transfer ownership and a function to migrate the contract. Make sure to include error handling in case of unexpected inputs. The contract should also include a way to retrieve the current owner.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract OwnershipManager {
    address public owner;
    bool public initialized;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the owner"");
        _;
    }

    modifier isInitialized() {
        require(initialized, ""Contract not initialized"");
        _;
    }

    function initialize(address _owner) public {
        require(!initialized, ""Already initialized"");
        require(_owner != address(0), ""Invalid owner address"");
        owner = _owner;
        initialized = true;
    }

    function transferOwnership(address newOwner) public onlyOwner isInitialized {
        require(newOwner != address(0), ""Invalid new owner address"");
        owner = newOwner;
    }

    function migrateContract(address newContract) public onlyOwner isInitialized {
        require(newContract != address(0), ""Invalid new contract address"");
        (bool success, ) = newContract.call("""");
        require(success, ""Migration failed"");
    }

    function getOwner() public view returns (address) {
        return owner;
    }
}",contract_99.sol
"Develop a Solidity smart contract that replicates the functionality of the Electrocoin token. This contract should include key functions like `distr`, `transfer`, and `approve`, while adhering to the ERC20 standard. The contract should also incorporate necessary modifiers and events. Pay attention to the logical flow and technical aspects, ensuring that the contract is structured correctly and follows best practices in Smart Contract development.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Electrocoin {
    string public name = ""Electrocoin"";
    string public symbol = ""ELC"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function _transfer(address _from, address _to, uint256 _value) internal {
        require(_to != address(0), ""Invalid recipient"");
        require(balanceOf[_from] >= _value, ""Insufficient balance"");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(allowance[_from][msg.sender] >= _value, ""Allowance exceeded"");
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    function distr(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }
}",contract_100.sol
"Create a smart contract that manages a fungible token. Implement the following functionality: allow users to transfer tokens, set token allowances, and burn tokens. Include functionality for the owner to mint new tokens. Provide a high-level overview of how the contract should be structured and involve the reader in the development process.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract FungibleToken {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    address public owner;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Burn(address indexed from, uint256 value);
    event Mint(address indexed to, uint256 value);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor(uint256 initialSupply) {
        owner = msg.sender;
        mint(owner, initialSupply);
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance too low"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }

    function burn(uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        totalSupply -= value;
        emit Burn(msg.sender, value);
        return true;
    }

    function mint(address to, uint256 value) public onlyOwner returns (bool success) {
        balanceOf[to] += value;
        totalSupply += value;
        emit Mint(to, value);
        return true;
    }
}",contract_101.sol
Design a smart contract for managing ownership of a target. The contract should inherit from a parent contract (PRBProxyPlugin) and implement a specific interface (TargetChangeOwner). The contract should provide two functions: one to change the owner of the target and another to retrieve the current owner. The implementation should be suitable for a real-world use case and include necessary functions and variables.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface TargetChangeOwner {
    function changeOwner(address newOwner) external;
    function getOwner() external view returns (address);
}

contract PRBProxyPlugin {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the owner"");
        _;
    }
}

contract TargetOwnerManager is PRBProxyPlugin, TargetChangeOwner {
    address private targetOwner;

    constructor(address initialOwner) {
        targetOwner = initialOwner;
    }

    function changeOwner(address newOwner) external override onlyOwner {
        require(newOwner != address(0), ""Invalid address"");
        targetOwner = newOwner;
    }

    function getOwner() external view override returns (address) {
        return targetOwner;
    }
}",contract_102.sol
"Create a smart contract for the Median protocol that supports various cryptocurrency exchange rates. The contract should be structured to manage multiple currency pairs (e.g. ETH/USD, BAT/USD, etc.) with a single function for recovering the signer's address from a signed message. Focus on implementing the necessary functions and variables to achieve this functionality.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MedianProtocol {
    struct CurrencyPair {
        uint256 rate;
        uint256 lastUpdate;
    }

    mapping(bytes32 => CurrencyPair) public currencyPairs;
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function updateRate(bytes32 _currencyPair, uint256 _rate) external onlyOwner {
        currencyPairs[_currencyPair].rate = _rate;
        currencyPairs[_currencyPair].lastUpdate = block.timestamp;
    }

    function getRate(bytes32 _currencyPair) external view returns (uint256) {
        return currencyPairs[_currencyPair].rate;
    }

    function getLastUpdate(bytes32 _currencyPair) external view returns (uint256) {
        return currencyPairs[_currencyPair].lastUpdate;
    }

    function recoverSigner(bytes32 message, bytes memory signature) public pure returns (address) {
        bytes32 r;
        bytes32 s;
        uint8 v;

        // Check the signature length
        if (signature.length != 65) {
            return address(0);
        }

        // Divide the signature in r, s and v variables
        assembly {
            r := mload(add(signature, 32))
            s := mload(add(signature, 64))
            v := byte(0, mload(add(signature, 96)))
        }

        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions
        if (v < 27) {
            v += 27;
        }

        // If the version is correct return the signer address
        if (v != 27 && v != 28) {
            return address(0);
        } else {
            return ecrecover(keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", message)), v, r, s);
        }
    }
}",contract_103.sol
"Create a smart contract for an ERC20 token with the following requirements: manage token balances, approve transfers, and burn tokens. The contract should include functions for token transfer, approval, and transfer from. Additionally, consider implementing private modifier onlySuper and public view functions for token total supply, unLock time, and burn amount.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    uint256 public unLockTime;
    uint256 public burnAmount;
    address private superAdmin;

    mapping(address => uint256) private balances;
    mapping(address => mapping(address => uint256)) private allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Burn(address indexed burner, uint256 value);

    modifier onlySuper() {
        require(msg.sender == superAdmin, ""Not super admin"");
        _;
    }

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balances[msg.sender] = totalSupply;
        superAdmin = msg.sender;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        require(balances[msg.sender] >= amount, ""Insufficient balance"");
        balances[msg.sender] -= amount;
        balances[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        require(balances[sender] >= amount, ""Insufficient balance"");
        require(allowances[sender][msg.sender] >= amount, ""Allowance too low"");
        balances[sender] -= amount;
        balances[recipient] += amount;
        allowances[sender][msg.sender] -= amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }

    function burn(uint256 amount) public onlySuper returns (bool) {
        require(balances[msg.sender] >= amount, ""Insufficient balance"");
        balances[msg.sender] -= amount;
        totalSupply -= amount;
        burnAmount += amount;
        emit Burn(msg.sender, amount);
        return true;
    }

    function setUnLockTime(uint256 newUnLockTime) public onlySuper {
        unLockTime = newUnLockTime;
    }
}",contract_104.sol
"Create a smart contract that restricts access to certain functions based on specific roles. The contract should have four roles: DAO_ADMIN, OPERATOR, CALLER, and CALLEE. Each role should have specific privileges, such as DAO_ADMIN being able to set up initial administrators. The contract should include modifier functions for each role to control access to specific functions. Use Solidity 0.8.10 and include necessary import statements.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract RoleBasedAccessControl {
    // Role definitions
    bytes32 public constant DAO_ADMIN = keccak256(""DAO_ADMIN"");
    bytes32 public constant OPERATOR = keccak256(""OPERATOR"");
    bytes32 public constant CALLER = keccak256(""CALLER"");
    bytes32 public constant CALLEE = keccak256(""CALLEE"");

    // Mapping from role to account to boolean (true if account has role)
    mapping(bytes32 => mapping(address => bool)) private _roles;

    // Events
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    // Modifiers
    modifier onlyRole(bytes32 role) {
        require(_roles[role][msg.sender], ""AccessControl: account does not have role"");
        _;
    }

    // Constructor
    constructor() {
        _grantRole(DAO_ADMIN, msg.sender);
    }

    // Role management functions
    function grantRole(bytes32 role, address account) external onlyRole(DAO_ADMIN) {
        _grantRole(role, account);
    }

    function revokeRole(bytes32 role, address account) external onlyRole(DAO_ADMIN) {
        _revokeRole(role, account);
    }

    function hasRole(bytes32 role, address account) public view returns (bool) {
        return _roles[role][account];
    }

    // Internal functions for role management
    function _grantRole(bytes32 role, address account) internal {
        if (!hasRole(role, account)) {
            _roles[role][account] = true;
            emit RoleGranted(role, account, msg.sender);
        }
    }

    function _revokeRole(bytes32 role, address account) internal {
        if (hasRole(role, account)) {
            _roles[role][account] = false;
            emit RoleRevoked(role, account, msg.sender);
        }
    }

    // Example functions with role-based access control
    function adminFunction() external onlyRole(DAO_ADMIN) {
        // Functionality for DAO_ADMIN
    }

    function operatorFunction() external onlyRole(OPERATOR) {
        // Functionality for OPERATOR
    }

    function callerFunction() external onlyRole(CALLER) {
        // Functionality for CALLER
    }

    function calleeFunction() external onlyRole(CALLEE) {
        // Functionality for CALLEE
    }
}",contract_105.sol
"Create a smart contract that allows users to stake and unstake tokens. The contract should keep track of total staked amounts and provide functions for staking, unstaking, and retrieving the total staked amount. Implement arithmetic operations securely using the SafeMath library. Consider the event-driven nature of the provided code snippets, such as the transfer events from IERC20. Ensure the contract is scalable and maintainable.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}

contract StakingContract {
    IERC20 public token;
    uint256 public totalStaked;
    mapping(address => uint256) public stakedBalances;

    event Staked(address indexed user, uint256 amount);
    event Unstaked(address indexed user, uint256 amount);

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function stake(uint256 amount) external {
        require(amount > 0, ""Amount must be greater than 0"");
        require(token.transferFrom(msg.sender, address(this), amount), ""Transfer failed"");

        stakedBalances[msg.sender] += amount;
        totalStaked += amount;

        emit Staked(msg.sender, amount);
    }

    function unstake(uint256 amount) external {
        require(amount > 0, ""Amount must be greater than 0"");
        require(stakedBalances[msg.sender] >= amount, ""Insufficient staked balance"");

        stakedBalances[msg.sender] -= amount;
        totalStaked -= amount;

        require(token.transfer(msg.sender, amount), ""Transfer failed"");

        emit Unstaked(msg.sender, amount);
    }

    function getTotalStaked() external view returns (uint256) {
        return totalStaked;
    }
}",contract_106.sol
"Develop a smart contract that follows the IERC721 standard for managing unique digital assets. The contract should include functions for transferring ownership, approving operators, and querying token balances. Implement methods for setting and retrieving token metadata, such as token names and symbols. Include support for ERC721Receiver events and consider adding features for token burning, conversion, or renaming. Structure the contract with clear and readable code, and include basic documentation for the contract's variables, functions, and events.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}

contract ERC721 {
    string private _name;
    string private _symbol;
    uint256 private _tokenIdCounter;

    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function balanceOf(address owner) public view returns (uint256) {
        require(owner != address(0), ""ERC721: balance query for the zero address"");
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) public view returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), ""ERC721: owner query for nonexistent token"");
        return owner;
    }

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _safeTransfer(from, to, tokenId, data);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) public {
        safeTransferFrom(from, to, tokenId, """");
    }

    function transferFrom(address from, address to, uint256 tokenId) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _transfer(from, to, tokenId);
    }

    function approve(address to, uint256 tokenId) public {
        address owner = ERC721.ownerOf(tokenId);
        require(to != owner, ""ERC721: approval to current owner"");
        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), ""ERC721: approve caller is not owner nor approved for all"");

        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    function getApproved(uint256 tokenId) public view returns (address) {
        require(_exists(tokenId), ""ERC721: approved query for nonexistent token"");
        return _tokenApprovals[tokenId];
    }

    function setApprovalForAll(address operator, bool approved) public {
        require(operator != msg.sender, ""ERC721: approve to caller"");
        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function isApprovedForAll(address owner, address operator) public view returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return _owners[tokenId] != address(0);
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");
        address owner = ERC721.ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    function _safeMint(address to, uint256 tokenId) internal {
        _safeMint(to, tokenId, """");
    }

    function _safeMint(address to, uint256 tokenId, bytes memory data) internal {
        _mint(to, tokenId);
        require(_checkOnERC721Received(address(0), to, tokenId, data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _mint(address to, uint256 tokenId) internal {
        require(to != address(0), ""ERC721: mint to the zero address"");
        require(!_exists(tokenId), ""ERC721: token already minted"");

        _beforeTokenTransfer(address(0), to, tokenId);

        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(address(0), to, tokenId);
    }

    function _burn(uint256 tokenId) internal {
        address owner = ERC721.ownerOf(tokenId);

        _beforeTokenTransfer(owner, address(0), tokenId);

        _approve(address(0), tokenId);

        _balances[owner] -= 1;
        delete _owners[tokenId];

        emit Transfer(owner, address(0), tokenId);
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        require(ERC721.ownerOf(tokenId) == from, ""ERC721: transfer of token that is not own"");
        require(to != address(0), ""ERC721: transfer to the zero address"");

        _beforeTokenTransfer(from, to, tokenId);

        _approve(address(0), tokenId);

        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(from, to, tokenId);
    }

    function _approve(address to, uint256 tokenId) internal {
        _tokenApprovals[tokenId] = to;
        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);
    }

    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private returns (bool) {
        if (to.code.length > 0) {
            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data) returns (bytes4 retval) {
                return retval == IERC721Receiver.onERC721Received.selector;
            } catch (bytes memory reason) {
                if (reason.length == 0) {
                    revert(""ERC721: transfer to non ERC721Receiver implementer"");
                } else {
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        } else {
            return true;
        }
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal {
        // Optional hook for token transfer logic
    }
}",contract_107.sol
"Create a smart contract for the RED token, implementing the ERC20 standard. The contract should include functions for managing the token supply, balance, and transfer. Initialize the token supply in the constructor. Implement a function for transferring tokens from one address to another. Include a function for approving a spender. Handle events for token transfer and approval. Focus on implementing the core functionality of the contract, using built-in Solidity features and libraries where possible.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract REDToken {
    string public name = ""RED Token"";
    string public symbol = ""RED"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }
}",contract_108.sol
"Create a Solidity smart contract that manages a cover pool, allowing users to provide, withdraw, claim, and withdraw epoch tokens. The contract should include logic for setting the epoch changing price and starting new epochs. Implement functions for adding and withdrawing tokens, claiming unclaimed profit, and withdrawing from epochs. Include variables to track cumulative profit, total share, and unwithdrawn cover tokens.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract CoverPool {
    address public owner;
    uint256 public totalShares;
    uint256 public cumulativeProfit;
    uint256 public totalUnwithdrawnCoverTokens;
    uint256 public currentEpoch;
    uint256 public epochPrice;

    struct Epoch {
        uint256 startBlock;
        uint256 endBlock;
        uint256 totalTokens;
        uint256 totalShares;
        uint256 price;
        bool isActive;
    }

    mapping(uint256 => Epoch) public epochs;
    mapping(address => uint256) public userShares;
    mapping(address => uint256) public userUnclaimedProfit;
    mapping(address => uint256) public userUnwithdrawnCoverTokens;

    event EpochStarted(uint256 epoch, uint256 startBlock, uint256 endBlock, uint256 price);
    event TokensAdded(address indexed user, uint256 amount);
    event TokensWithdrawn(address indexed user, uint256 amount);
    event ProfitClaimed(address indexed user, uint256 amount);
    event EpochTokensWithdrawn(address indexed user, uint256 epoch, uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
        currentEpoch = 1;
    }

    function startNewEpoch(uint256 _endBlock, uint256 _price) external onlyOwner {
        require(_endBlock > block.number, ""End block must be in the future"");
        epochs[currentEpoch] = Epoch({
            startBlock: block.number,
            endBlock: _endBlock,
            totalTokens: 0,
            totalShares: 0,
            price: _price,
            isActive: true
        });
        epochPrice = _price;
        emit EpochStarted(currentEpoch, block.number, _endBlock, _price);
        currentEpoch++;
    }

    function addTokens(uint256 _amount) external {
        require(epochs[currentEpoch - 1].isActive, ""Current epoch is not active"");
        userShares[msg.sender] += _amount;
        totalShares += _amount;
        epochs[currentEpoch - 1].totalTokens += _amount;
        epochs[currentEpoch - 1].totalShares += _amount;
        emit TokensAdded(msg.sender, _amount);
    }

    function withdrawTokens(uint256 _amount) external {
        require(userShares[msg.sender] >= _amount, ""Insufficient shares"");
        userShares[msg.sender] -= _amount;
        totalShares -= _amount;
        userUnwithdrawnCoverTokens[msg.sender] += _amount;
        totalUnwithdrawnCoverTokens += _amount;
        emit TokensWithdrawn(msg.sender, _amount);
    }

    function claimProfit() external {
        uint256 profit = userUnclaimedProfit[msg.sender];
        require(profit > 0, ""No profit to claim"");
        userUnclaimedProfit[msg.sender] = 0;
        cumulativeProfit -= profit;
        payable(msg.sender).transfer(profit);
        emit ProfitClaimed(msg.sender, profit);
    }

    function withdrawEpochTokens(uint256 _epoch) external {
        require(_epoch < currentEpoch, ""Epoch not yet ended"");
        uint256 tokens = userUnwithdrawnCoverTokens[msg.sender];
        require(tokens > 0, ""No tokens to withdraw"");
        userUnwithdrawnCoverTokens[msg.sender] = 0;
        totalUnwithdrawnCoverTokens -= tokens;
        payable(msg.sender).transfer(tokens);
        emit EpochTokensWithdrawn(msg.sender, _epoch, tokens);
    }

    receive() external payable {
        cumulativeProfit += msg.value;
        distributeProfit();
    }

    function distributeProfit() internal {
        uint256 profitPerShare = cumulativeProfit / totalShares;
        for (uint256 i = 0; i < currentEpoch; i++) {
            if (epochs[i].isActive) {
                for (uint256 j = 0; j < epochs[i].totalShares; j++) {
                    address user = address(j);
                    userUnclaimedProfit[user] += profitPerShare * userShares[user];
                }
            }
        }
    }
}",contract_109.sol
"Create a smart contract that allows for the transfer of tokens, checking of balances, and management of allowances. The contract should include functions for minting and burning tokens, as well as event emissions for transparency. Use the SafeMath library for reliable calculations. The contract should also include correct handling and validation of edge cases.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    using SafeMath for uint256;

    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Mint(address indexed to, uint256 value);
    event Burn(address indexed from, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(value);
        balanceOf[to] = balanceOf[to].add(value);
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] = balanceOf[from].sub(value);
        balanceOf[to] = balanceOf[to].add(value);
        allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);
        emit Transfer(from, to, value);
        return true;
    }

    function mint(address to, uint256 value) public returns (bool success) {
        totalSupply = totalSupply.add(value);
        balanceOf[to] = balanceOf[to].add(value);
        emit Mint(to, value);
        emit Transfer(address(0), to, value);
        return true;
    }

    function burn(uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        totalSupply = totalSupply.sub(value);
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(value);
        emit Burn(msg.sender, value);
        emit Transfer(msg.sender, address(0), value);
        return true;
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }
}",contract_110.sol
"Create a Solidity smart contract that inherits from CrossChainEnabled and uses the LibArbitrumL1 library to manage cross-chain interactions. The contract should store an immutable bridge address, implement methods for determining cross-chain status and retrieving the cross-chain sender's address, and integrate with the provided library for smooth interactions.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

abstract contract CrossChainEnabled {
    function isCrossChain() public view virtual returns (bool);
    function crossChainSender() public view virtual returns (address);
}

library LibArbitrumL1 {
    function getBridge(address _bridge) internal pure returns (address) {
        return _bridge;
    }
}

contract CrossChainContract is CrossChainEnabled {
    address immutable public bridgeAddress;

    constructor(address _bridgeAddress) {
        bridgeAddress = _bridgeAddress;
    }

    function isCrossChain() public view override returns (bool) {
        // Placeholder implementation
        return true;
    }

    function crossChainSender() public view override returns (address) {
        // Placeholder implementation
        return LibArbitrumL1.getBridge(bridgeAddress);
    }
}",contract_111.sol
"Create a token contract that builds upon the ERC20 standard and integrates with the IDEXRouter. The token should have a name, symbol, and decimal places. Implement functions to transfer tokens, set allowances, and get token balances. The contract should also have an owner and a modifier to restrict certain functions. Include a fee structure and a way to exclude certain addresses from fees.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface IDEXRouter {
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
}

contract MyToken is IERC20 {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 private _totalSupply;
    address public owner;
    address public routerAddress;
    IDEXRouter public router;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    mapping(address => bool) private _isExcludedFromFee;

    uint256 public transferFee = 5; // 5% fee

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the owner"");
        _;
    }

    constructor(uint256 initialSupply, address _routerAddress) {
        _totalSupply = initialSupply * 10 ** uint256(decimals);
        _balances[msg.sender] = _totalSupply;
        owner = msg.sender;
        routerAddress = _routerAddress;
        router = IDEXRouter(routerAddress);
        _isExcludedFromFee[msg.sender] = true;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function totalSupply() external view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address _owner, address spender) external view override returns (uint256) {
        return _allowances[_owner][spender];
    }

    function approve(address spender, uint256 amount) external override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""Transfer from the zero address"");
        require(recipient != address(0), ""Transfer to the zero address"");

        uint256 fee = _isExcludedFromFee[sender] || _isExcludedFromFee[recipient] ? 0 : (amount * transferFee) / 100;
        uint256 amountAfterFee = amount - fee;

        _balances[sender] -= amount;
        _balances[recipient] += amountAfterFee;
        _balances[address(this)] += fee;

        emit Transfer(sender, recipient, amountAfterFee);
        emit Transfer(sender, address(this), fee);
    }

    function _approve(address _owner, address spender, uint256 amount) internal {
        require(_owner != address(0), ""Approve from the zero address"");
        require(spender != address(0), ""Approve to the zero address"");

        _allowances[_owner][spender] = amount;
        emit Approval(_owner, spender, amount);
    }

    function excludeFromFee(address account) external onlyOwner {
        _isExcludedFromFee[account] = true;
    }

    function includeInFee(address account) external onlyOwner {
        _isExcludedFromFee[account] = false;
    }

    function setTransferFeePercent(uint256 fee) external onlyOwner {
        transferFee = fee;
    }
}",contract_112.sol
"Develop a smart contract that manages a digital asset with features such as token transfer, minting, and burning. Ensure the contract has a total supply tracker and allows the owner to manage the minting and burning of tokens. Make sure the contract includes a minting function that checks the total supply before minting new tokens. Provide a high-level overview of the contract structure and functionality.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DigitalAsset {
    string public name = ""MyDigitalAsset"";
    string public symbol = ""MDA"";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    address public owner;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Mint(address indexed to, uint256 value);
    event Burn(address indexed from, uint256 value);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor(uint256 initialSupply) {
        owner = msg.sender;
        mint(owner, initialSupply);
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }

    function mint(address to, uint256 value) public onlyOwner returns (bool success) {
        require(totalSupply + value >= totalSupply, ""Overflow"");
        totalSupply += value;
        balanceOf[to] += value;
        emit Mint(to, value);
        emit Transfer(address(0), to, value);
        return true;
    }

    function burn(uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        totalSupply -= value;
        balanceOf[msg.sender] -= value;
        emit Burn(msg.sender, value);
        emit Transfer(msg.sender, address(0), value);
        return true;
    }
}",contract_113.sol
"Create a smart contract that allows users to mint, transfer, and burn NFTs. Implement a token cap and royalty mechanism. The contract should be pausable and have a base URI for token metadata. Organize your code following best practices and use OpenZeppelin's pre-written contracts for compatibility and security.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC165 {
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

interface IERC721 is IERC165 {
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function balanceOf(address owner) external view returns (uint256 balance);
    function ownerOf(uint256 tokenId) external view returns (address owner);
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    function transferFrom(address from, address to, uint256 tokenId) external;
    function approve(address to, uint256 tokenId) external;
    function getApproved(uint256 tokenId) external view returns (address operator);
    function setApprovalForAll(address operator, bool _approved) external;
    function isApprovedForAll(address owner, address operator) external view returns (bool);
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
}

interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}

interface IERC721Metadata is IERC721 {
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function tokenURI(uint256 tokenId) external view returns (string memory);
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

contract ERC165 is IERC165 {
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}

library Strings {
    bytes16 private constant _HEX_SYMBOLS = ""0123456789abcdef"";

    function toString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return ""0"";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }

    function toHexString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return ""0x00"";
        }
        uint256 temp = value;
        uint256 length = 0;
        while (temp != 0) {
            length++;
            temp >>= 8;
        }
        return toHexString(value, length);
    }

    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = ""0"";
        buffer[1] = ""x"";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _HEX_SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, ""Strings: hex length insufficient"");
        return string(buffer);
    }
}

contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {
    using Address for address;
    using Strings for uint256;

    string private _name;
    string private _symbol;
    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return
            interfaceId == type(IERC721).interfaceId ||
            interfaceId == type(IERC721Metadata).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    function balanceOf(address owner) public view virtual override returns (uint256) {
        require(owner != address(0), ""ERC721: balance query for the zero address"");
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) public view virtual override returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), ""ERC721: owner query for nonexistent token"");
        return owner;
    }

    function name() public view virtual override returns (string memory) {
        return _name;
    }

    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        require(_exists(tokenId), ""ERC721Metadata: URI query for nonexistent token"");

        string memory baseURI = _baseURI();
        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : """";
    }

    function _baseURI() internal view virtual returns (string memory) {
        return """";
    }

    function approve(address to, uint256 tokenId) public virtual override {
        address owner = ERC721.ownerOf(tokenId);
        require(to != owner, ""ERC721: approval to current owner"");

        require(
            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
            ""ERC721: approve caller is not owner nor approved for all""
        );

        _approve(to, tokenId);
    }

    function getApproved(uint256 tokenId) public view virtual override returns (address) {
        require(_exists(tokenId), ""ERC721: approved query for nonexistent token"");

        return _tokenApprovals[tokenId];
    }

    function setApprovalForAll(address operator, bool approved) public virtual override {
        require(operator != _msgSender(), ""ERC721: approve to caller"");

        _operatorApprovals[_msgSender()][operator] = approved;
        emit ApprovalForAll(_msgSender(), operator, approved);
    }

    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        require(_isApprovedOrOwner(_msgSender(), tokenId), ""ERC721: transfer caller is not owner nor approved"");

        _transfer(from, to, tokenId);
    }

    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        safeTransferFrom(from, to, tokenId, """");
    }

    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) public virtual override {
        require(_isApprovedOrOwner(_msgSender(), tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _safeTransfer(from, to, tokenId, _data);
    }

    function _safeTransfer(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) internal virtual {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _exists(uint256 tokenId) internal view virtual returns (bool) {
        return _owners[tokenId] != address(0);
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");
        address owner = ERC721.ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    function _safeMint(address to, uint256 tokenId) internal virtual {
        _safeMint(to, tokenId, """");
    }

    function _safeMint(
        address to,
        uint256 tokenId,
        bytes memory _data
    ) internal virtual {
        _mint(to, tokenId);
        require(
            _checkOnERC721Received(address(0), to, tokenId, _data),
            ""ERC721: transfer to non ERC721Receiver implementer""
        );
    }

    function _mint(address to, uint256 tokenId) internal virtual {
        require(to != address(0), ""ERC721: mint to the zero address"");
        require(!_exists(tokenId), ""ERC721: token already minted"");

        _beforeTokenTransfer(address(0), to, tokenId);

        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(address(0), to, tokenId);
    }

    function _burn(uint256 tokenId) internal virtual {
        address owner = ERC721.ownerOf(tokenId);

        _beforeTokenTransfer(owner, address(0), tokenId);

        _approve(address(0), tokenId);

        _balances[owner] -= 1;
        delete _owners[tokenId];

        emit Transfer(owner, address(0), tokenId);
    }

    function _transfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual {
        require(ERC721.ownerOf(tokenId) == from, ""ERC721: transfer of token that is not own"");
        require(to != address(0), ""ERC721: transfer to the zero address"");

        _beforeTokenTransfer(from, to, tokenId);

        _approve(address(0), tokenId);

        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(from, to, tokenId);
    }

    function _approve(address to, uint256 tokenId) internal virtual {
        _tokenApprovals[tokenId] = to;
        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);
    }

    function _checkOnERC721Received(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) private returns (bool) {
        if (to.isContract()) {
            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
                return retval == IERC721Receiver.onERC721Received.selector;
            } catch (bytes memory reason) {
                if (reason.length == 0) {
                    revert(""ERC721: transfer to non ERC721Receiver implementer"");
                } else {
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        } else {
            return true;
        }
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual {}
}

library Address {
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }

    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, ""Address: insufficient balance"");

        (bool success, ) = recipient.call{value: amount}("""");
        require(success, ""Address: unable to send value, recipient may have reverted"");
    }

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, ""Address: low-level call failed"");
    }

    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, ""Address: low-level call with value failed"");
    }

    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, ""Address: insufficient balance for call"");
        require(isContract(target), ""Address: call to non-contract"");

        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, ""Address: low-level static call failed"");
    }

    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        require(isContract(target), ""Address: static call to non-contract"");

        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, ""Address: low-level delegate call failed"");
    }

    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(isContract(target), ""Address: delegate call to non-contract"");

        (bool success, bytes memory returndata) = target.delegatecall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function _verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) private pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            if (returndata.length > 0) {
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _setOwner(_msgSender());
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(owner() == _msgSender(), ""Ownable: caller is not the owner"");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(",contract_114.sol
"Develop a smart contract that follows the ERC20 token standard. The contract should manage token balances and allowance values for each address. Implement transfer, approve, and transferFrom functions. Ensure minting and burning tokens are supported. Include a constructor for initializing the token's name, symbol, and decimals.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;
    uint256 private _totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory name_, string memory symbol_, uint8 decimals_) {
        _name = name_;
        _symbol = symbol_;
        _decimals = decimals_;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);
        return true;
    }

    function mint(address account, uint256 amount) public {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function burn(address account, uint256 amount) public {
        require(account != address(0), ""ERC20: burn from the zero address"");

        _balances[account] -= amount;
        _totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}",contract_115.sol
"Create a smart contract for the Olympus ERC20 token, implementing minting, burning, and total supply functionality. Integrate the OlympusAuthority contract and ensure token security measures are in place. Test the contract for reliability, including edge cases such as unauthorized minting and burn excess.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract OlympusAuthority {
    address public governor;
    address public guardian;
    address public policy;

    constructor(address _governor, address _guardian, address _policy) {
        governor = _governor;
        guardian = _guardian;
        policy = _policy;
    }

    modifier onlyGovernor() {
        require(msg.sender == governor, ""Only Governor"");
        _;
    }

    modifier onlyGuardian() {
        require(msg.sender == guardian, ""Only Guardian"");
        _;
    }

    modifier onlyPolicy() {
        require(msg.sender == policy, ""Only Policy"");
        _;
    }

    function setGovernor(address _governor) public onlyGovernor {
        governor = _governor;
    }

    function setGuardian(address _guardian) public onlyGovernor {
        guardian = _guardian;
    }

    function setPolicy(address _policy) public onlyGovernor {
        policy = _policy;
    }
}

contract OlympusERC20Token {
    string public name = ""Olympus"";
    string public symbol = ""OLY"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    OlympusAuthority public authority;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Mint(address indexed to, uint256 value);
    event Burn(address indexed from, uint256 value);

    constructor(address _governor, address _guardian, address _policy) {
        authority = new OlympusAuthority(_governor, _guardian, _policy);
    }

    modifier onlyGovernor() {
        require(msg.sender == authority.governor(), ""Only Governor"");
        _;
    }

    modifier onlyGuardian() {
        require(msg.sender == authority.guardian(), ""Only Guardian"");
        _;
    }

    modifier onlyPolicy() {
        require(msg.sender == authority.policy(), ""Only Policy"");
        _;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value, ""Insufficient balance"");
        require(allowance[_from][msg.sender] >= _value, ""Allowance exceeded"");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    function mint(address _to, uint256 _value) public onlyPolicy returns (bool success) {
        totalSupply += _value;
        balanceOf[_to] += _value;
        emit Mint(_to, _value);
        emit Transfer(address(0), _to, _value);
        return true;
    }

    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        totalSupply -= _value;
        balanceOf[msg.sender] -= _value;
        emit Burn(msg.sender, _value);
        emit Transfer(msg.sender, address(0), _value);
        return true;
    }
}",contract_116.sol
"Develop an NFT contract that allows the creation and minting of unique digital assets. The contract should support a role-based access control system and allow certain authorized users to mint new NFTs. Include a way to safely mint new NFTs, increment the token ID counter, and provide the new token ID to the caller. Additionally, consider implementing basic ERC-721 functionality, like token names and descriptions.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}

contract ERC721 {
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    string private _name;
    string private _symbol;
    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function balanceOf(address owner) public view returns (uint256) {
        require(owner != address(0), ""ERC721: balance query for the zero address"");
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) public view returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), ""ERC721: owner query for nonexistent token"");
        return owner;
    }

    function approve(address to, uint256 tokenId) public {
        address owner = ownerOf(tokenId);
        require(to != owner, ""ERC721: approval to current owner"");
        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), ""ERC721: approve caller is not owner nor approved for all"");
        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    function getApproved(uint256 tokenId) public view returns (address) {
        require(_exists(tokenId), ""ERC721: approved query for nonexistent token"");
        return _tokenApprovals[tokenId];
    }

    function setApprovalForAll(address operator, bool approved) public {
        require(operator != msg.sender, ""ERC721: approve to caller"");
        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function isApprovedForAll(address owner, address operator) public view returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function transferFrom(address from, address to, uint256 tokenId) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _transfer(from, to, tokenId);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) public {
        safeTransferFrom(from, to, tokenId, """");
    }

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _safeTransfer(from, to, tokenId, _data);
    }

    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return _owners[tokenId] != address(0);
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    function _safeMint(address to, uint256 tokenId) internal {
        _safeMint(to, tokenId, """");
    }

    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal {
        _mint(to, tokenId);
        require(_checkOnERC721Received(address(0), to, tokenId, _data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _mint(address to, uint256 tokenId) internal {
        require(to != address(0), ""ERC721: mint to the zero address"");
        require(!_exists(tokenId), ""ERC721: token already minted"");
        _beforeTokenTransfer(address(0), to, tokenId);
        _balances[to] += 1;
        _owners[tokenId] = to;
        emit Transfer(address(0), to, tokenId);
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        require(ownerOf(tokenId) == from, ""ERC721: transfer of token that is not own"");
        require(to != address(0), ""ERC721: transfer to the zero address"");
        _beforeTokenTransfer(from, to, tokenId);
        _approve(address(0), tokenId);
        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;
        emit Transfer(from, to, tokenId);
    }

    function _approve(address to, uint256 tokenId) internal {
        _tokenApprovals[tokenId] = to;
        emit Approval(ownerOf(tokenId), to, tokenId);
    }

    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) internal returns (bool) {
        if (isContract(to)) {
            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data) returns (bytes4 retval) {
                return retval == IERC721Receiver.onERC721Received.selector;
            } catch (bytes memory reason) {
                if (reason.length == 0) {
                    revert(""ERC721: transfer to non ERC721Receiver implementer"");
                } else {
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        } else {
            return true;
        }
    }

    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal {}
}

contract NFT is ERC721 {
    using SafeMath for uint256;

    mapping(address => bool) public minters;
    uint256 public tokenCounter;

    constructor(string memory name, string memory symbol) ERC721(name, symbol) {
        minters[msg.sender] = true;
    }

    modifier onlyMinter() {
        require(minters[msg.sender], ""Caller is not a minter"");
        _;
    }

    function addMinter(address account) public onlyMinter {
        minters[account] = true;
    }

    function removeMinter(address account) public onlyMinter {
        minters[account] = false;
    }

    function mintNFT(address to, string memory tokenURI) public onlyMinter returns (uint256) {
        uint256 newTokenId = tokenCounter.add(1);
        _safeMint(to, newTokenId);
        tokenCounter = newTokenId;
        return newTokenId;
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, ""SafeMath: modulo by zero"");
        return a % b;
    }
}",contract_117.sol
"Create a smart contract that implements a subscription-based membership system for an NFT collection. The contract should allow users to subscribe to different plans, which specify the subscription duration and price. Develop functions to manage subscription plans, mint tokens, and track user subscriptions. Include checks for valid inputs and handle exceptions for invalid requests. Prioritize maintainability and scalability for future updates.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SubscriptionNFT {
    struct Plan {
        uint256 duration; // in seconds
        uint256 price; // in wei
    }

    struct Subscription {
        uint256 planId;
        uint256 startTimestamp;
    }

    address public owner;
    uint256 public nextPlanId;
    uint256 public nextTokenId;
    mapping(uint256 => Plan) public plans;
    mapping(address => Subscription) public subscriptions;
    mapping(uint256 => address) public tokenOwners;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier validPlan(uint256 _planId) {
        require(_planId < nextPlanId, ""Invalid plan ID"");
        _;
    }

    modifier validAddress(address _addr) {
        require(_addr != address(0), ""Invalid address"");
        _;
    }

    constructor() {
        owner = msg.sender;
        nextPlanId = 0;
        nextTokenId = 0;
    }

    function addPlan(uint256 _duration, uint256 _price) external onlyOwner {
        plans[nextPlanId] = Plan(_duration, _price);
        nextPlanId++;
    }

    function updatePlan(uint256 _planId, uint256 _duration, uint256 _price) external onlyOwner validPlan(_planId) {
        plans[_planId] = Plan(_duration, _price);
    }

    function subscribe(uint256 _planId) external payable validPlan(_planId) {
        Plan memory plan = plans[_planId];
        require(msg.value == plan.price, ""Incorrect subscription fee"");
        require(subscriptions[msg.sender].planId == 0, ""Already subscribed"");

        subscriptions[msg.sender] = Subscription(_planId, block.timestamp);
        _mintToken(msg.sender);
    }

    function renewSubscription() external payable {
        Subscription storage sub = subscriptions[msg.sender];
        require(sub.planId != 0, ""Not subscribed"");

        Plan memory plan = plans[sub.planId];
        require(msg.value == plan.price, ""Incorrect subscription fee"");
        require(block.timestamp >= sub.startTimestamp + plan.duration, ""Subscription still active"");

        sub.startTimestamp = block.timestamp;
    }

    function isSubscriptionActive(address _user) public view returns (bool) {
        Subscription memory sub = subscriptions[_user];
        if (sub.planId == 0) return false;

        Plan memory plan = plans[sub.planId];
        return block.timestamp < sub.startTimestamp + plan.duration;
    }

    function _mintToken(address _to) internal validAddress(_to) {
        tokenOwners[nextTokenId] = _to;
        nextTokenId++;
    }

    function withdraw() external onlyOwner {
        payable(owner).transfer(address(this).balance);
    }
}",contract_118.sol
"Create a smart contract that enables liquidity pool management, including deposit and withdrawal functionality, and administrator control. The contract should use mappings to track pool balances and total supply, and include functions for depositing and withdrawing tokens, setting administrators, and emitting events.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract LiquidityPool {
    mapping(address => uint256) public balances;
    uint256 public totalSupply;
    address public owner;
    mapping(address => bool) public administrators;

    event Deposit(address indexed user, uint256 amount);
    event Withdrawal(address indexed user, uint256 amount);
    event AdministratorSet(address indexed admin, bool isSet);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the owner"");
        _;
    }

    modifier onlyAdmin() {
        require(administrators[msg.sender], ""Not an administrator"");
        _;
    }

    constructor() {
        owner = msg.sender;
        administrators[msg.sender] = true;
    }

    function setAdministrator(address admin, bool isSet) external onlyOwner {
        administrators[admin] = isSet;
        emit AdministratorSet(admin, isSet);
    }

    function deposit(uint256 amount) external onlyAdmin {
        balances[msg.sender] += amount;
        totalSupply += amount;
        emit Deposit(msg.sender, amount);
    }

    function withdraw(uint256 amount) external onlyAdmin {
        require(balances[msg.sender] >= amount, ""Insufficient balance"");
        balances[msg.sender] -= amount;
        totalSupply -= amount;
        emit Withdrawal(msg.sender, amount);
    }
}",contract_119.sol
"Implement a smart contract for a token that is compatible with the IERC20 interface. The contract should include functions for transferring tokens, approving transfers, and emitting events for transaction records. It should also include variables for keeping track of token balances and allowances. The SafeMath library should be used for arithmetic operations.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        _transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        allowance[from][msg.sender] -= value;
        _transfer(from, to, value);
        return true;
    }

    function _transfer(address from, address to, uint256 value) internal {
        balanceOf[from] -= value;
        balanceOf[to] += value;
        emit Transfer(from, to, value);
    }
}",contract_120.sol
"Create a smart contract that builds upon the OraclizeI contract by introducing a mechanism to manage data sources. Develop functions to set and retrieve data sources, and include a mapping to track gas prices. Utilize the Buffer and CBOR libraries in your implementation. Ensure the contract is well-structured and correctly implemented.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract OraclizeI {
    function query(uint _timestamp, string memory _datasource, string memory _arg) public payable returns (bytes32 _id);
}

library Buffer {
    struct buffer {
        bytes buf;
        uint capacity;
    }

    function init(buffer memory buf, uint capacity) internal pure returns (buffer memory) {
        bytes memory newBuf = new bytes(capacity);
        return buffer({buf: newBuf, capacity: capacity});
    }

    function append(buffer memory buf, bytes memory data) internal pure {
        uint length = data.length;
        require(buf.capacity >= buf.buf.length + length, ""Buffer overflow"");
        uint destPtr;
        assembly {
            destPtr := add(add(buf.buf, 32), mload(buf.buf))
        }
        memcpy(destPtr, data, length);
        assembly {
            mstore(buf.buf, add(mload(buf.buf), length))
        }
    }

    function memcpy(uint dest, uint src, uint len) private pure {
        for (; len >= 32; len -= 32) {
            assembly {
                mstore(dest, mload(src))
            }
            dest += 32;
            src += 32;
        }
        uint mask = 256 ** (32 - len) - 1;
        assembly {
            let srcpart := and(mload(src), not(mask))
            let destpart := and(mload(dest), mask)
            mstore(dest, or(srcpart, destpart))
        }
    }
}

library CBOR {
    using Buffer for Buffer.buffer;

    function encodeType(Buffer.buffer memory buf, uint8 major, uint value) private pure {
        if(value <= 23) {
            buf.append(abi.encodePacked(uint8((major << 5) | value)));
        } else if(value <= 0xFF) {
            buf.append(abi.encodePacked(uint8((major << 5) | 24), uint8(value)));
        } else if(value <= 0xFFFF) {
            buf.append(abi.encodePacked(uint8((major << 5) | 25), uint16(value)));
        } else if(value <= 0xFFFFFFFF) {
            buf.append(abi.encodePacked(uint8((major << 5) | 26), uint32(value)));
        } else {
            buf.append(abi.encodePacked(uint8((major << 5) | 27), uint64(value)));
        }
    }

    function encodeBytes(Buffer.buffer memory buf, bytes memory value) internal pure {
        encodeType(buf, 2, value.length);
        buf.append(value);
    }
}

contract DataSourceManager is OraclizeI {
    using CBOR for Buffer.buffer;

    struct DataSource {
        string name;
        uint gasPrice;
    }

    mapping(bytes32 => DataSource) public dataSources;
    mapping(bytes32 => uint) public gasPrices;

    function setDataSource(string memory _name, uint _gasPrice) public returns (bytes32) {
        bytes32 id = keccak256(abi.encodePacked(_name, block.timestamp));
        dataSources[id] = DataSource(_name, _gasPrice);
        gasPrices[id] = _gasPrice;
        return id;
    }

    function getDataSource(bytes32 _id) public view returns (string memory, uint) {
        DataSource memory ds = dataSources[_id];
        return (ds.name, ds.gasPrice);
    }

    function query(uint _timestamp, string memory _datasource, string memory _arg) public payable override returns (bytes32 _id) {
        _id = super.query(_timestamp, _datasource, _arg);
        gasPrices[_id] = msg.value;
    }
}",contract_121.sol
"Create a Solidity smart contract that allows token minting and tracks token count. The contract should inherit from ERC721 and include a function for minting new tokens. The function should take owner's address, token amount, and delegate's address as parameters and emit an event for tracking minting activity. Focus on implementing the necessary functions and views for token URI generation.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}

contract ERC721 {
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    function balanceOf(address owner) public view returns (uint256) {
        require(owner != address(0), ""ERC721: balance query for the zero address"");
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) public view returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), ""ERC721: owner query for nonexistent token"");
        return owner;
    }

    function approve(address to, uint256 tokenId) public {
        address owner = ownerOf(tokenId);
        require(to != owner, ""ERC721: approval to current owner"");
        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), ""ERC721: approve caller is not owner nor approved for all"");
        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    function getApproved(uint256 tokenId) public view returns (address) {
        require(_exists(tokenId), ""ERC721: approved query for nonexistent token"");
        return _tokenApprovals[tokenId];
    }

    function setApprovalForAll(address operator, bool approved) public {
        require(operator != msg.sender, ""ERC721: approve to caller"");
        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function isApprovedForAll(address owner, address operator) public view returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function transferFrom(address from, address to, uint256 tokenId) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _transfer(from, to, tokenId);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) public {
        safeTransferFrom(from, to, tokenId, """");
    }

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _safeTransfer(from, to, tokenId, _data);
    }

    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return _owners[tokenId] != address(0);
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    function _safeMint(address to, uint256 tokenId) internal {
        _safeMint(to, tokenId, """");
    }

    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal {
        _mint(to, tokenId);
        require(_checkOnERC721Received(address(0), to, tokenId, _data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _mint(address to, uint256 tokenId) internal {
        require(to != address(0), ""ERC721: mint to the zero address"");
        require(!_exists(tokenId), ""ERC721: token already minted"");
        _beforeTokenTransfer(address(0), to, tokenId);
        _balances[to] += 1;
        _owners[tokenId] = to;
        emit Transfer(address(0), to, tokenId);
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        require(ownerOf(tokenId) == from, ""ERC721: transfer of token that is not own"");
        require(to != address(0), ""ERC721: transfer to the zero address"");
        _beforeTokenTransfer(from, to, tokenId);
        _approve(address(0), tokenId);
        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;
        emit Transfer(from, to, tokenId);
    }

    function _approve(address to, uint256 tokenId) internal {
        _tokenApprovals[tokenId] = to;
        emit Approval(ownerOf(tokenId), to, tokenId);
    }

    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) internal returns (bool) {
        if (to.code.length > 0) {
            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data) returns (bytes4 retval) {
                return retval == IERC721Receiver.onERC721Received.selector;
            } catch (bytes memory reason) {
                if (reason.length == 0) {
                    revert(""ERC721: transfer to non ERC721Receiver implementer"");
                } else {
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        } else {
            return true;
        }
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal {}
}

contract MyToken is ERC721 {
    uint256 private _tokenIdCounter;
    string private _baseTokenURI;

    event TokenMinted(address indexed owner, uint256 indexed tokenId, address indexed delegate);

    constructor(string memory baseURI) {
        _baseTokenURI = baseURI;
    }

    function mintToken(address owner, uint256 amount, address delegate) public {
        for (uint256 i = 0; i < amount; i++) {
            uint256 newTokenId = _tokenIdCounter;
            _safeMint(owner, newTokenId);
            emit TokenMinted(owner, newTokenId, delegate);
            _tokenIdCounter++;
        }
    }

    function tokenURI(uint256 tokenId) public view returns (string memory) {
        require(_exists(tokenId), ""ERC721Metadata: URI query for nonexistent token"");
        return string(abi.encodePacked(_baseTokenURI, uint2str(tokenId)));
    }

    function uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {
        if (_i == 0) {
            return ""0"";
        }
        uint256 j = _i;
        uint256 len;
        while (j != 0) {
            len++;
            j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint256 k = len;
        while (_i != 0) {
            k = k - 1;
            uint8 temp = (48 + uint8(_i - _i / 10 * 10));
            bytes1 b1 = bytes1(temp);
            bstr[k] = b1;
            _i /= 10;
        }
        return string(bstr);
    }
}",contract_122.sol
Create a smart contract that builds upon the provided Contract and Ownable contract. The contract should allow users to create and manage assets. Include a constructor that takes a unique identifier and a name. Add functions for creating and transferring assets. Ensure the owner has control over creating and managing assets. Utilize the IBEP20 interface for interacting with assets. Keep the contract easy to understand and maintainable.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IBEP20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(msg.sender == _owner, ""Ownable: caller is not the owner"");
        _;
    }

    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract AssetManager is Ownable {
    struct Asset {
        uint256 id;
        string name;
        address owner;
    }

    uint256 private _assetCount;
    mapping(uint256 => Asset) private _assets;
    mapping(address => uint256[]) private _userAssets;

    event AssetCreated(uint256 indexed id, string name, address owner);
    event AssetTransferred(uint256 indexed id, address from, address to);

    constructor(string memory uniqueIdentifier, string memory name) {
        createAsset(uniqueIdentifier, name);
    }

    function createAsset(string memory uniqueIdentifier, string memory name) public onlyOwner returns (uint256) {
        _assetCount++;
        Asset memory newAsset = Asset(_assetCount, name, msg.sender);
        _assets[_assetCount] = newAsset;
        _userAssets[msg.sender].push(_assetCount);
        emit AssetCreated(_assetCount, name, msg.sender);
        return _assetCount;
    }

    function transferAsset(uint256 assetId, address to) public {
        require(_assets[assetId].owner == msg.sender, ""AssetManager: caller is not the owner of the asset"");
        require(to != address(0), ""AssetManager: transfer to the zero address"");

        _assets[assetId].owner = to;
        _userAssets[to].push(assetId);
        removeAssetFromUser(msg.sender, assetId);

        emit AssetTransferred(assetId, msg.sender, to);
    }

    function getAsset(uint256 assetId) public view returns (uint256, string memory, address) {
        Asset memory asset = _assets[assetId];
        return (asset.id, asset.name, asset.owner);
    }

    function getUserAssets(address user) public view returns (uint256[] memory) {
        return _userAssets[user];
    }

    function removeAssetFromUser(address user, uint256 assetId) internal {
        uint256[] storage userAssetList = _userAssets[user];
        for (uint256 i = 0; i < userAssetList.length; i++) {
            if (userAssetList[i] == assetId) {
                userAssetList[i] = userAssetList[userAssetList.length - 1];
                userAssetList.pop();
                break;
            }
        }
    }
}",contract_123.sol
"Create a token contract that enables token transfer between addresses, approves external transactions, and tracks token balances. The contract should provide functions for allowing and withdrawing token approvals. Implement arithmetic operations using the SafeMath library to ensure security. Include a constructor to set the initial token supply and owner.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    address public owner;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        owner = msg.sender;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool success) {
        allowance[msg.sender][spender] += addedValue;
        emit Approval(msg.sender, spender, allowance[msg.sender][spender]);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool success) {
        require(allowance[msg.sender][spender] >= subtractedValue, ""Allowance below zero"");
        allowance[msg.sender][spender] -= subtractedValue;
        emit Approval(msg.sender, spender, allowance[msg.sender][spender]);
        return true;
    }
}",contract_124.sol
"Create a token contract called 'PucieToken' that provides basic token functionality and advanced features. The contract should allow users to transfer tokens, approve transfers, and retrieve token balances. It should also include taxation on transfers, fee exemption, and integration with a swapper interface. The taxation mechanism should deduct fees from the transfer amount and allocate them to a designated recipient. Fee exemption should enable specific addresses to be exempt from paying fees. The swapper interface should enable token transfer between PucieToken and other tokens. Implement the contract with thorough testing and good documentation.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface ISwapper {
    function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns (uint256 amountOut);
}

contract PucieToken {
    string public name = ""PucieToken"";
    string public symbol = ""PUC"";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    address public taxRecipient;
    uint256 public taxRate; // in basis points (10000 = 100%)

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    mapping(address => bool) public feeExempt;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event TaxRateUpdated(uint256 newRate);
    event TaxRecipientUpdated(address newRecipient);
    event FeeExemptionSet(address indexed account, bool exempt);

    constructor(uint256 initialSupply, address _taxRecipient, uint256 _taxRate) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        taxRecipient = _taxRecipient;
        taxRate = _taxRate;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address to, uint256 value) external returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) external returns (bool) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) external returns (bool) {
        require(allowance[from][msg.sender] >= value, ""Insufficient allowance"");
        allowance[from][msg.sender] -= value;
        _transfer(from, to, value);
        return true;
    }

    function setTaxRate(uint256 newRate) external {
        require(msg.sender == taxRecipient, ""Only tax recipient can update tax rate"");
        taxRate = newRate;
        emit TaxRateUpdated(newRate);
    }

    function setTaxRecipient(address newRecipient) external {
        require(msg.sender == taxRecipient, ""Only tax recipient can update tax recipient"");
        taxRecipient = newRecipient;
        emit TaxRecipientUpdated(newRecipient);
    }

    function setFeeExemption(address account, bool exempt) external {
        require(msg.sender == taxRecipient, ""Only tax recipient can set fee exemption"");
        feeExempt[account] = exempt;
        emit FeeExemptionSet(account, exempt);
    }

    function _transfer(address from, address to, uint256 value) internal {
        require(balanceOf[from] >= value, ""Insufficient balance"");
        uint256 taxAmount = feeExempt[from] ? 0 : (value * taxRate) / 10000;
        uint256 transferAmount = value - taxAmount;

        balanceOf[from] -= value;
        balanceOf[to] += transferAmount;
        balanceOf[taxRecipient] += taxAmount;

        emit Transfer(from, to, transferAmount);
        emit Transfer(from, taxRecipient, taxAmount);
    }

    function swapTokens(address tokenIn, address tokenOut, uint256 amountIn, ISwapper swapper) external returns (uint256 amountOut) {
        require(allowance[msg.sender][address(this)] >= amountIn, ""Insufficient allowance"");
        allowance[msg.sender][address(this)] -= amountIn;
        _transfer(msg.sender, address(this), amountIn);
        amountOut = swapper.swap(tokenIn, tokenOut, amountIn);
        _transfer(address(this), msg.sender, amountOut);
    }
}",contract_125.sol
"Create a smart contract that verifies identities using World ID and provides a unique identifier for each user. The contract should include functions for verifying proofs, storing hashes, and executing specific logic when a proof is verified. Implement the contract with clear documentation of variables, functions, and logic.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract IdentityVerifier {
    // World ID verification status
    enum VerificationStatus { Unverified, Verified }

    // Struct to store user details
    struct User {
        bytes32 hash; // Hash of the user's identity
        VerificationStatus status; // Verification status
    }

    // Mapping from user's unique identifier to User struct
    mapping(uint256 => User) public users;

    // Event emitted when a user is verified
    event UserVerified(uint256 indexed userId, bytes32 hash);

    // Function to verify a proof and store the hash
    function verifyProof(uint256 userId, bytes32 hash, bytes memory proof) public {
        // Placeholder for actual World ID verification logic
        // This should be replaced with actual verification code from World ID
        bool isValid = _verifyWorldIDProof(proof);

        require(isValid, ""Proof verification failed"");

        // Store the hash and mark the user as verified
        users[userId] = User({
            hash: hash,
            status: VerificationStatus.Verified
        });

        emit UserVerified(userId, hash);
    }

    // Function to check if a user is verified
    function isVerified(uint256 userId) public view returns (bool) {
        return users[userId].status == VerificationStatus.Verified;
    }

    // Placeholder function for World ID proof verification
    function _verifyWorldIDProof(bytes memory proof) internal pure returns (bool) {
        // Replace this with actual World ID verification logic
        // This is a placeholder and should be implemented according to World ID's specifications
        return true;
    }
}
```

This contract provides a basic framework for verifying identities using World ID and storing a unique identifier for each user. The `verifyProof` function is intended to verify a proof provided by World ID and store the hash of the user's identity. The `isVerified` function checks if a user is verified. The `_verifyWorldIDProof` function is a placeholder for the actual World ID verification logic, which should be implemented according to World ID's specifications.",contract_126.sol
Create a smart contract that uses the OpenZeppelin's AccessControl contract and implements a simple role-based access control system. The contract should allow users to grant and revoke roles for addresses and check if a specific role is held by an address. Provide a detailed description of the required functionality and include specific Solidity functions and variables as necessary. The contract should adhere to the IAccessControl interface and emit relevant events.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract AccessControl {
    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    struct RoleData {
        mapping(address => bool) members;
        bytes32 adminRole;
    }

    mapping(bytes32 => RoleData) private _roles;

    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    function hasRole(bytes32 role, address account) public view returns (bool) {
        return _roles[role].members[account];
    }

    function getRoleAdmin(bytes32 role) public view returns (bytes32) {
        return _roles[role].adminRole;
    }

    function grantRole(bytes32 role, address account) public {
        require(hasRole(_roles[role].adminRole, msg.sender), ""AccessControl: sender must be an admin to grant"");
        _grantRole(role, account);
    }

    function revokeRole(bytes32 role, address account) public {
        require(hasRole(_roles[role].adminRole, msg.sender), ""AccessControl: sender must be an admin to revoke"");
        _revokeRole(role, account);
    }

    function renounceRole(bytes32 role, address account) public {
        require(account == msg.sender, ""AccessControl: can only renounce roles for self"");
        _revokeRole(role, account);
    }

    function _setupRole(bytes32 role, address account) internal {
        _grantRole(role, account);
    }

    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {
        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);
        _roles[role].adminRole = adminRole;
    }

    function _grantRole(bytes32 role, address account) private {
        if (!hasRole(role, account)) {
            _roles[role].members[account] = true;
            emit RoleGranted(role, account, msg.sender);
        }
    }

    function _revokeRole(bytes32 role, address account) private {
        if (hasRole(role, account)) {
            _roles[role].members[account] = false;
            emit RoleRevoked(role, account, msg.sender);
        }
    }
}",contract_127.sol
"Create a smart contract that implements the Anyswap USDC v5 ERC20 standard. The contract should allow for token transfers, approve and call other contracts, and permit-based approvals. Include a function for token approval and another for token transfer. Utilize the SafeERC20 library for secure and efficient token handling. Implement necessary logic for managing token balances and allowances. Focus on ensuring the contract adheres to common ERC20 and EIP-677 standards.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface IERC20Permit {
    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
}

library SafeERC20 {
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            ""SafeERC20: approve from non-zero to non-zero allowance""
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, ""SafeERC20: low-level call failed"");

        if (returndata.length > 0) {
            require(abi.decode(returndata, (bool)), ""SafeERC20: ERC20 operation did not succeed"");
        }
    }
}

library Address {
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, ""Address: insufficient balance"");

        (bool success, ) = recipient.call{value: amount}("""");
        require(success, ""Address: unable to send value, recipient may have reverted"");
    }

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, ""Address: low-level call failed"");
    }

    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, ""Address: low-level call with value failed"");
    }

    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, ""Address: insufficient balance for call"");
        require(isContract(target), ""Address: call to non-contract"");

        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            if (returndata.length > 0) {
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

contract AnyswapUSDC is IERC20, IERC20Permit {
    using SafeERC20 for IERC20;
    string public constant name = ""Anyswap USDC"";
    string public constant symbol = ""aUSDC"";
    uint8 public constant decimals = 6;
    uint256 private _totalSupply;
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    bytes32 public DOMAIN_SEPARATOR;
    mapping(address => uint256) public nonces;

    constructor() {
        uint256 chainId;
        assembly {
            chainId := chainid()
        }
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                keccak256(""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""),
                keccak256(bytes(name)),
                keccak256(bytes(""1"")),
                chainId,
                address(this)
            )
        );
    }

    function totalSupply() external view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) external view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) external override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) external view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) external override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external override {
        require(deadline >= block.timestamp, ""AnyswapUSDC: EXPIRED"");
        bytes32 digest = keccak256(
            abi.encodePacked(
                ""\x19\x01"",
                DOMAIN_SEPARATOR,
                keccak256(abi.encode(keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)""), owner, spender, value, nonces[owner]++, deadline))
            )
        );
        address recoveredAddress = ecrecover(digest, v, r, s);
        require(recoveredAddress != address(0) && recoveredAddress == owner, ""AnyswapUSDC: INVALID_SIGNATURE"");
        _approve(owner, spender, value);
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""AnyswapUSDC: transfer from the zero address"");
        require(recipient != address(0), ""AnyswapUSDC: transfer to the zero address"");

        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""AnyswapUSDC: approve from the zero address"");
        require(spender != address(0), ""AnyswapUSDC: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _mint(address account, uint256 amount) internal {
        require(account != address(0), ""AnyswapUSDC: mint to the zero address"");

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) internal {
        require(account != address(0), ""AnyswapUSDC: burn from the zero address"");

        _balances[account] -= amount;
        _totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }
}",contract_128.sol
"Create a smart contract that is similar to an existing one, but with some modifications. The contract should be based on the provided code and should implement a new token with its own symbol, name, and contract owner. The contract should allow for token transfers and approvals, and should emit events when such actions occur. Include a constructor to initialize the contract's main variables.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MyToken {
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    uint256 public totalSupply;
    address public owner;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply, string memory tokenName, string memory tokenSymbol) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        name = tokenName;
        symbol = tokenSymbol;
        owner = msg.sender;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], ""Insufficient balance"");
        require(_value <= allowance[_from][msg.sender], ""Allowance exceeded"");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }
}",contract_129.sol
Create a smart contract that allows for initialization and reinitialization to a specific version. Use modifiers to control the initialization process. Implement functions to manage initialization and reinitialization. Incorporate a library that enables contract interaction and value sending. Make sure the contract complies with the MIT license. Keep in mind the need for flexibility in initializable contracts.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Initializable {
    uint256 private _version;
    bool private _initialized;
    bool private _initializing;

    modifier initializer() {
        require(_initializing || !_initialized, ""Contract instance has already been initialized"");
        bool isTopLevelCall = !_initializing;
        if (isTopLevelCall) {
            _initializing = true;
            _initialized = true;
        }
        _;
        if (isTopLevelCall) {
            _initializing = false;
        }
    }

    modifier reinitializer(uint256 version) {
        require(!_initializing && _initialized && version == _version + 1, ""Invalid version for reinitialization"");
        _initializing = true;
        _version = version;
        _;
        _initialized = true;
        _initializing = false;
    }

    function getVersion() public view returns (uint256) {
        return _version;
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }
}

contract MyContract is Initializable {
    using SafeMath for uint256;

    uint256 public value;

    function initialize(uint256 initialValue) public initializer {
        value = initialValue;
    }

    function reinitialize(uint256 newVersion, uint256 newValue) public reinitializer(newVersion) {
        value = newValue;
    }

    function sendValue(address payable recipient, uint256 amount) public {
        require(address(this).balance >= amount, ""Insufficient balance"");
        recipient.transfer(amount);
    }
}",contract_130.sol
"Create a TRC20 token smart contract that supports token transfer, approval, and allowance management. The contract should include methods for token minting and burning. Consider implementing address validation to prevent unauthorized transactions. Ensure that the contract complies with the ITRC20 standard and follows best practices for coding and security.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface ITRC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract TRC20Token is ITRC20 {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 private _totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor(uint256 initialSupply) {
        owner = msg.sender;
        _mint(msg.sender, initialSupply);
    }

    function totalSupply() external view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) external view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) external override returns (bool) {
        require(recipient != address(0), ""Transfer to the zero address"");
        require(_balances[msg.sender] >= amount, ""Insufficient balance"");

        _balances[msg.sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address _owner, address spender) external view override returns (uint256) {
        return _allowances[_owner][spender];
    }

    function approve(address spender, uint256 amount) external override returns (bool) {
        _allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {
        require(recipient != address(0), ""Transfer to the zero address"");
        require(_balances[sender] >= amount, ""Insufficient balance"");
        require(_allowances[sender][msg.sender] >= amount, ""Allowance exceeded"");

        _balances[sender] -= amount;
        _balances[recipient] += amount;
        _allowances[sender][msg.sender] -= amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }

    function mint(address account, uint256 amount) external onlyOwner {
        _mint(account, amount);
    }

    function burn(uint256 amount) external {
        _burn(msg.sender, amount);
    }

    function _mint(address account, uint256 amount) internal {
        require(account != address(0), ""Mint to the zero address"");

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) internal {
        require(account != address(0), ""Burn from the zero address"");
        require(_balances[account] >= amount, ""Insufficient balance"");

        _balances[account] -= amount;
        _totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }
}",contract_131.sol
"Develop a smart contract that implements a token with a maximum supply of 600 Billion tokens. The token should have a pre-minted balance of 600 Billion tokens. The contract should allow for token transfers between accounts, approve spending of tokens, and enable or disable transfer of frozen accounts. Include a function to burn tokens. Implement safe math operations and ensure proper permissions checks.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    address public owner;
    bool public transfersEnabled;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    mapping(address => bool) public frozenAccount;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Burn(address indexed from, uint256 value);
    event FrozenAccount(address indexed target, bool frozen);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier canTransfer() {
        require(transfersEnabled || msg.sender == owner, ""Transfers are disabled"");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply = 600 * 10**9 * 10**uint256(decimals); // 600 Billion tokens
        balanceOf[owner] = totalSupply;
        transfersEnabled = true;
        emit Transfer(address(0), owner, totalSupply);
    }

    function transfer(address _to, uint256 _value) public canTransfer returns (bool success) {
        require(_to != address(0), ""Invalid address"");
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        require(!frozenAccount[msg.sender], ""Sender account is frozen"");
        require(!frozenAccount[_to], ""Receiver account is frozen"");

        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public canTransfer returns (bool success) {
        require(_to != address(0), ""Invalid address"");
        require(balanceOf[_from] >= _value, ""Insufficient balance"");
        require(allowance[_from][msg.sender] >= _value, ""Allowance exceeded"");
        require(!frozenAccount[_from], ""Sender account is frozen"");
        require(!frozenAccount[_to], ""Receiver account is frozen"");

        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");

        balanceOf[msg.sender] -= _value;
        totalSupply -= _value;
        emit Burn(msg.sender, _value);
        emit Transfer(msg.sender, address(0), _value);
        return true;
    }

    function freezeAccount(address target, bool freeze) public onlyOwner {
        frozenAccount[target] = freeze;
        emit FrozenAccount(target, freeze);
    }

    function enableTransfers(bool _enabled) public onlyOwner {
        transfersEnabled = _enabled;
    }
}",contract_132.sol
Develop a smart contract that splits payments to multiple recipients based on their shares. The contract should have a constructor that initializes the payees and their shares. Implement functions to release payments to payees and track the total amount released. The contract should also release ERC20 tokens to payees. Include descriptive comments to explain the logic and error handling mechanisms.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

contract PaymentSplitter {
    address[] private payees;
    uint256[] private shares;
    uint256 private totalShares;
    uint256 private totalReleased;
    mapping(address => uint256) private released;
    mapping(address => uint256) private tokenReleased;
    IERC20 private erc20Token;

    event PayeeAdded(address account, uint256 shares);
    event PaymentReleased(address to, uint256 amount);
    event ERC20PaymentReleased(address token, address to, uint256 amount);
    event PaymentReceived(address from, uint256 amount);

    constructor(address[] memory _payees, uint256[] memory _shares, address _erc20Token) {
        require(_payees.length == _shares.length, ""PaymentSplitter: payees and shares length mismatch"");
        require(_payees.length > 0, ""PaymentSplitter: no payees"");

        for (uint256 i = 0; i < _payees.length; i++) {
            addPayee(_payees[i], _shares[i]);
        }

        erc20Token = IERC20(_erc20Token);
    }

    receive() external payable {
        emit PaymentReceived(msg.sender, msg.value);
    }

    function totalShares() public view returns (uint256) {
        return totalShares;
    }

    function totalReleased() public view returns (uint256) {
        return totalReleased;
    }

    function shares(address account) public view returns (uint256) {
        return shares[indexOf(account)];
    }

    function released(address account) public view returns (uint256) {
        return released[account];
    }

    function tokenReleased(address account) public view returns (uint256) {
        return tokenReleased[account];
    }

    function payee(uint256 index) public view returns (address) {
        return payees[index];
    }

    function release(address account) public {
        uint256 totalReceived = address(this).balance + totalReleased;
        uint256 payment = pendingPayment(account, totalReceived, released[account]);

        require(payment != 0, ""PaymentSplitter: account is not due payment"");

        released[account] += payment;
        totalReleased += payment;

        payable(account).transfer(payment);
        emit PaymentReleased(account, payment);
    }

    function releaseERC20(address account) public {
        uint256 totalReceived = erc20Token.balanceOf(address(this)) + tokenReleased[account];
        uint256 payment = pendingPayment(account, totalReceived, tokenReleased[account]);

        require(payment != 0, ""PaymentSplitter: account is not due ERC20 payment"");

        tokenReleased[account] += payment;

        require(erc20Token.transfer(account, payment), ""PaymentSplitter: ERC20 transfer failed"");
        emit ERC20PaymentReleased(address(erc20Token), account, payment);
    }

    function pendingPayment(address account, uint256 totalReceived, uint256 alreadyReleased) private view returns (uint256) {
        uint256 share = shares[indexOf(account)];
        return (totalReceived * share) / totalShares - alreadyReleased;
    }

    function addPayee(address account, uint256 _shares) private {
        require(account != address(0), ""PaymentSplitter: account is the zero address"");
        require(_shares > 0, ""PaymentSplitter: shares are 0"");
        require(shares[indexOf(account)] == 0, ""PaymentSplitter: account already has shares"");

        payees.push(account);
        shares.push(_shares);
        totalShares += _shares;

        emit PayeeAdded(account, _shares);
    }

    function indexOf(address account) private view returns (uint256) {
        for (uint256 i = 0; i < payees.length; i++) {
            if (payees[i] == account) {
                return i;
            }
        }
        revert(""PaymentSplitter: account not found"");
    }
}",contract_133.sol
"Write a Solidity contract that includes assertion functions for boolean conditions. The contract should have three test cases: one for a successful assertion, one for a failed assertion, and one that handles errors. Use a specific function to emit logs and handle errors accordingly. Implement unit tests for these assertions, considering error handling and logging.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract AssertionContract {
    event AssertionResult(bool success, string message);

    function assertSuccess() public {
        bool condition = true;
        assert(condition);
        emit AssertionResult(true, ""Assertion passed successfully."");
    }

    function assertFailure() public {
        bool condition = false;
        try this.customAssert(condition) {
            emit AssertionResult(true, ""Unexpected success in assertFailure."");
        } catch Error(string memory reason) {
            emit AssertionResult(false, reason);
        } catch {
            emit AssertionResult(false, ""An unknown error occurred."");
        }
    }

    function assertErrorHandling() public {
        bool condition = false;
        try this.customAssert(condition) {
            emit AssertionResult(true, ""Unexpected success in assertErrorHandling."");
        } catch Error(string memory reason) {
            emit AssertionResult(false, reason);
        } catch {
            emit AssertionResult(false, ""An unknown error occurred."");
        }
    }

    function customAssert(bool condition) public pure {
        if (!condition) {
            revert(""Assertion failed."");
        }
    }
}",contract_134.sol
"Design a Solidity smart contract that enables the creation and management of sets. The contract should include functions for adding, removing, and checking membership. Include a function to retrieve the length of the set. Modify the contract to work with bytes32 values. Consider adding additional functionality, such as inserting and sorting the set, while maintaining the original order.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Bytes32Set {
    bytes32[] private items;

    function add(bytes32 item) public {
        if (!exists(item)) {
            items.push(item);
        }
    }

    function remove(bytes32 item) public {
        for (uint i = 0; i < items.length; i++) {
            if (items[i] == item) {
                items[i] = items[items.length - 1];
                items.pop();
                break;
            }
        }
    }

    function exists(bytes32 item) public view returns (bool) {
        for (uint i = 0; i < items.length; i++) {
            if (items[i] == item) {
                return true;
            }
        }
        return false;
    }

    function length() public view returns (uint) {
        return items.length;
    }

    function insert(uint index, bytes32 item) public {
        require(index <= items.length, ""Index out of bounds"");
        items.push(item);
        for (uint i = items.length - 1; i > index; i--) {
            items[i] = items[i - 1];
        }
        items[index] = item;
    }

    function sort() public {
        quickSort(items, int(0), int(items.length - 1));
    }

    function quickSort(bytes32[] memory arr, int left, int right) internal pure {
        int i = left;
        int j = right;
        if (i == j) return;
        bytes32 pivot = arr[uint(left + (right - left) / 2)];
        while (i <= j) {
            while (arr[uint(i)] < pivot) i++;
            while (pivot < arr[uint(j)]) j--;
            if (i <= j) {
                (arr[uint(i)], arr[uint(j)]) = (arr[uint(j)], arr[uint(i)]);
                i++;
                j--;
            }
        }
        if (left < j)
            quickSort(arr, left, j);
        if (i < right)
            quickSort(arr, i, right);
    }
}",contract_135.sol
"Create a new token contract based on the OpenZeppelin ERC-20 implementation, specifying the token's name, symbol, and total supply. Implement increase and decrease allowance functionality, transfer capabilities, and event triggers for token transfers. Utilize OpenZeppelin's Context and IERC20 contracts as a foundation for the new token. Use mapping variables to track token balances, allowance, and global token supply, and incorporate robust exception handling to ensure secure and reliable token operations.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string private _name;
    string private _symbol;
    uint256 private _totalSupply;
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory name_, string memory symbol_, uint256 totalSupply_) {
        _name = name_;
        _symbol = symbol_;
        _totalSupply = totalSupply_;
        _balances[msg.sender] = totalSupply_;
        emit Transfer(address(0), msg.sender, totalSupply_);
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) public returns (bool) {
        _transfer(msg.sender, to, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) public returns (bool) {
        _spendAllowance(from, msg.sender, amount);
        _transfer(from, to, amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        uint256 currentAllowance = _allowances[msg.sender][spender];
        require(currentAllowance >= subtractedValue, ""ERC20: decreased allowance below zero"");
        _approve(msg.sender, spender, currentAllowance - subtractedValue);
        return true;
    }

    function _transfer(address from, address to, uint256 amount) internal {
        require(from != address(0), ""ERC20: transfer from the zero address"");
        require(to != address(0), ""ERC20: transfer to the zero address"");

        uint256 fromBalance = _balances[from];
        require(fromBalance >= amount, ""ERC20: transfer amount exceeds balance"");
        _balances[from] = fromBalance - amount;
        _balances[to] += amount;

        emit Transfer(from, to, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _spendAllowance(address owner, address spender, uint256 amount) internal {
        uint256 currentAllowance = _allowances[owner][spender];
        if (currentAllowance != type(uint256).max) {
            require(currentAllowance >= amount, ""ERC20: insufficient allowance"");
            _approve(owner, spender, currentAllowance - amount);
        }
    }
}",contract_136.sol
"Create a smart contract that allows users to deposit and withdraw ERC721 tokens. The contract should support single and batch transactions. The deposit function should handle single and batch deposits, while the withdraw and withdrawBatch functions should handle single and batch withdrawals. The contract should also have role-based access control and emit events for withdrawn batches.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC721 {
    function transferFrom(address from, address to, uint256 tokenId) external;
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    function ownerOf(uint256 tokenId) external view returns (address);
}

contract ERC721DepositWithdraw {
    address public owner;
    mapping(address => bool) public admins;
    mapping(address => mapping(uint256 => bool)) public depositedTokens;

    event TokenDeposited(address indexed user, uint256 tokenId);
    event TokenWithdrawn(address indexed user, uint256 tokenId);
    event BatchWithdrawn(address indexed user, uint256[] tokenIds);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the owner"");
        _;
    }

    modifier onlyAdmin() {
        require(admins[msg.sender] || msg.sender == owner, ""Not an admin"");
        _;
    }

    constructor() {
        owner = msg.sender;
        admins[msg.sender] = true;
    }

    function addAdmin(address admin) external onlyOwner {
        admins[admin] = true;
    }

    function removeAdmin(address admin) external onlyOwner {
        admins[admin] = false;
    }

    function deposit(uint256 tokenId) external {
        IERC721 tokenContract = IERC721(msg.sender);
        require(tokenContract.ownerOf(tokenId) == msg.sender, ""Not the owner of the token"");
        tokenContract.transferFrom(msg.sender, address(this), tokenId);
        depositedTokens[msg.sender][tokenId] = true;
        emit TokenDeposited(msg.sender, tokenId);
    }

    function depositBatch(uint256[] calldata tokenIds) external {
        IERC721 tokenContract = IERC721(msg.sender);
        for (uint256 i = 0; i < tokenIds.length; i++) {
            uint256 tokenId = tokenIds[i];
            require(tokenContract.ownerOf(tokenId) == msg.sender, ""Not the owner of the token"");
            tokenContract.transferFrom(msg.sender, address(this), tokenId);
            depositedTokens[msg.sender][tokenId] = true;
            emit TokenDeposited(msg.sender, tokenId);
        }
    }

    function withdraw(uint256 tokenId) external {
        require(depositedTokens[msg.sender][tokenId], ""Token not deposited or not owned by sender"");
        IERC721 tokenContract = IERC721(msg.sender);
        tokenContract.safeTransferFrom(address(this), msg.sender, tokenId);
        depositedTokens[msg.sender][tokenId] = false;
        emit TokenWithdrawn(msg.sender, tokenId);
    }

    function withdrawBatch(uint256[] calldata tokenIds) external {
        IERC721 tokenContract = IERC721(msg.sender);
        for (uint256 i = 0; i < tokenIds.length; i++) {
            uint256 tokenId = tokenIds[i];
            require(depositedTokens[msg.sender][tokenId], ""Token not deposited or not owned by sender"");
            tokenContract.safeTransferFrom(address(this), msg.sender, tokenId);
            depositedTokens[msg.sender][tokenId] = false;
        }
        emit BatchWithdrawn(msg.sender, tokenIds);
    }
}",contract_137.sol
"Create a smart contract in Solidity that implements an ERC-20 token, taking into account the following requirements: the token shall have a name and symbol; it shall have a total supply; it shall have a balance for each account; it shall have functionality for transferring tokens between accounts; it shall have functionality for allowing one account to spend tokens on behalf of another account; the contract shall emit events for these actions. Focus on the overall structure and relationships between functions.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint256 _initialSupply) {
        name = _name;
        symbol = _symbol;
        totalSupply = _initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], ""Insufficient balance"");
        require(_value <= allowance[_from][msg.sender], ""Allowance exceeded"");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }
}",contract_138.sol
"Create a smart contract that manages a permission list for disputable items. The contract should allow users to submit, clear, or challenge items, as well as resolve disputes. Consider implementing lists for item submission and clearing requests, as well as a system to manage dispute resolution. Ensure that the contract has the ability to flag items as blacklisted or whitelisted, depending on the 'blacklist' variable. Include functions for submitting, clearing, and challenging items, as well as resolving disputes.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DisputableItems {
    struct Item {
        address submitter;
        bool isBlacklisted;
        bool isWhitelisted;
        bool isChallenged;
        uint256 challengeTimestamp;
    }

    mapping(uint256 => Item) public items;
    uint256 public itemCount;
    uint256 public challengePeriod = 3 days;

    event ItemSubmitted(uint256 indexed itemId, address indexed submitter);
    event ItemCleared(uint256 indexed itemId);
    event ItemChallenged(uint256 indexed itemId, address indexed challenger);
    event DisputeResolved(uint256 indexed itemId, bool isBlacklisted);

    function submitItem() external returns (uint256) {
        uint256 itemId = itemCount++;
        items[itemId] = Item({
            submitter: msg.sender,
            isBlacklisted: false,
            isWhitelisted: false,
            isChallenged: false,
            challengeTimestamp: 0
        });
        emit ItemSubmitted(itemId, msg.sender);
        return itemId;
    }

    function clearItem(uint256 itemId) external {
        require(items[itemId].submitter == msg.sender, ""Not the submitter"");
        items[itemId].isWhitelisted = true;
        emit ItemCleared(itemId);
    }

    function challengeItem(uint256 itemId) external {
        require(!items[itemId].isChallenged, ""Item already challenged"");
        items[itemId].isChallenged = true;
        items[itemId].challengeTimestamp = block.timestamp;
        emit ItemChallenged(itemId, msg.sender);
    }

    function resolveDispute(uint256 itemId, bool blacklist) external {
        require(items[itemId].isChallenged, ""Item not challenged"");
        require(block.timestamp >= items[itemId].challengeTimestamp + challengePeriod, ""Challenge period not over"");
        items[itemId].isChallenged = false;
        items[itemId].isBlacklisted = blacklist;
        items[itemId].isWhitelisted = !blacklist;
        emit DisputeResolved(itemId, blacklist);
    }
}",contract_139.sol
"Create a smart contract that serves as a service administration system, providing service and finance management. The contract should include admin-only functions and modifiers. Develop a library for safe arithmetic operations and interfaces for IBitGuildToken and IAgonFight. Design a contract that manages agon fights, including functions for creating, canceling, challenging, and resolving fights. Set max agon count and agon fight contract address during deployment.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }
}

interface IBitGuildToken {
    function transfer(address to, uint256 value) external returns (bool);
    function balanceOf(address who) external view returns (uint256);
}

interface IAgonFight {
    function createFight(uint256 fightId, address challenger) external;
    function cancelFight(uint256 fightId) external;
    function challengeFight(uint256 fightId, address challenger) external;
    function resolveFight(uint256 fightId, address winner) external;
}

contract ServiceAdministration {
    using SafeMath for uint256;

    address public admin;
    uint256 public maxAgonCount;
    address public agonFightContractAddress;

    struct Fight {
        uint256 fightId;
        address challenger;
        bool isActive;
    }

    Fight[] public fights;
    mapping(uint256 => address) public fightOwner;

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can call this function"");
        _;
    }

    constructor(uint256 _maxAgonCount, address _agonFightContractAddress) {
        admin = msg.sender;
        maxAgonCount = _maxAgonCount;
        agonFightContractAddress = _agonFightContractAddress;
    }

    function setMaxAgonCount(uint256 _maxAgonCount) external onlyAdmin {
        maxAgonCount = _maxAgonCount;
    }

    function setAgonFightContractAddress(address _agonFightContractAddress) external onlyAdmin {
        agonFightContractAddress = _agonFightContractAddress;
    }

    function createFight(uint256 fightId) external {
        require(fights.length < maxAgonCount, ""Max agon count reached"");
        fights.push(Fight({fightId: fightId, challenger: msg.sender, isActive: true}));
        fightOwner[fightId] = msg.sender;
        IAgonFight(agonFightContractAddress).createFight(fightId, msg.sender);
    }

    function cancelFight(uint256 fightId) external {
        require(fightOwner[fightId] == msg.sender, ""Only fight owner can cancel"");
        IAgonFight(agonFightContractAddress).cancelFight(fightId);
        for (uint256 i = 0; i < fights.length; i++) {
            if (fights[i].fightId == fightId) {
                fights[i].isActive = false;
                break;
            }
        }
    }

    function challengeFight(uint256 fightId) external {
        require(fightOwner[fightId] != msg.sender, ""Cannot challenge own fight"");
        IAgonFight(agonFightContractAddress).challengeFight(fightId, msg.sender);
    }

    function resolveFight(uint256 fightId, address winner) external onlyAdmin {
        IAgonFight(agonFightContractAddress).resolveFight(fightId, winner);
        for (uint256 i = 0; i < fights.length; i++) {
            if (fights[i].fightId == fightId) {
                fights[i].isActive = false;
                break;
            }
        }
    }
}",contract_140.sol
"Create a Solidity smart contract that allows for airdrops of items. The contract should include functions for minting new items, retrieving the items held by an owner, and retrieving the URI of an item. Implement the ERC721Enumerable and Ownable contracts from OpenZeppelin to enable access controls and enumeration of items. Include functions for setting the cost of new item minting, maximum mint amount, not revealed URI, and base URI. Add event logs for the mint function and reveal function.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC721 {
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    function balanceOf(address owner) public view returns (uint256) {
        require(owner != address(0), ""ERC721: balance query for the zero address"");
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) public view returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), ""ERC721: owner query for nonexistent token"");
        return owner;
    }

    function approve(address to, uint256 tokenId) public {
        address owner = ownerOf(tokenId);
        require(to != owner, ""ERC721: approval to current owner"");
        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), ""ERC721: approve caller is not owner nor approved for all"");
        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    function getApproved(uint256 tokenId) public view returns (address) {
        require(_exists(tokenId), ""ERC721: approved query for nonexistent token"");
        return _tokenApprovals[tokenId];
    }

    function setApprovalForAll(address operator, bool approved) public {
        require(operator != msg.sender, ""ERC721: approve to caller"");
        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function isApprovedForAll(address owner, address operator) public view returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function transferFrom(address from, address to, uint256 tokenId) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _transfer(from, to, tokenId);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) public {
        safeTransferFrom(from, to, tokenId, """");
    }

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _safeTransfer(from, to, tokenId, _data);
    }

    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return _owners[tokenId] != address(0);
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    function _safeMint(address to, uint256 tokenId) internal {
        _safeMint(to, tokenId, """");
    }

    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal {
        _mint(to, tokenId);
        require(_checkOnERC721Received(address(0), to, tokenId, _data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _mint(address to, uint256 tokenId) internal {
        require(to != address(0), ""ERC721: mint to the zero address"");
        require(!_exists(tokenId), ""ERC721: token already minted"");
        _beforeTokenTransfer(address(0), to, tokenId);
        _balances[to] += 1;
        _owners[tokenId] = to;
        emit Transfer(address(0), to, tokenId);
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        require(ownerOf(tokenId) == from, ""ERC721: transfer of token that is not own"");
        require(to != address(0), ""ERC721: transfer to the zero address"");
        _beforeTokenTransfer(from, to, tokenId);
        _approve(address(0), tokenId);
        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;
        emit Transfer(from, to, tokenId);
    }

    function _approve(address to, uint256 tokenId) internal {
        _tokenApprovals[tokenId] = to;
        emit Approval(ownerOf(tokenId), to, tokenId);
    }

    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) internal returns (bool) {
        if (to.code.length > 0) {
            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data) returns (bytes4 retval) {
                return retval == IERC721Receiver.onERC721Received.selector;
            } catch (bytes memory reason) {
                if (reason.length == 0) {
                    revert(""ERC721: transfer to non ERC721Receiver implementer"");
                } else {
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        } else {
            return true;
        }
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal {}
}

interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}

contract ERC721Enumerable is ERC721 {
    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;
    mapping(uint256 => uint256) private _ownedTokensIndex;
    uint256[] private _allTokens;
    mapping(uint256 => uint256) private _allTokensIndex;

    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {
        require(index < balanceOf(owner), ""ERC721Enumerable: owner index out of bounds"");
        return _ownedTokens[owner][index];
    }

    function totalSupply() public view returns (uint256) {
        return _allTokens.length;
    }

    function tokenByIndex(uint256 index) public view returns (uint256) {
        require(index < totalSupply(), ""ERC721Enumerable: global index out of bounds"");
        return _allTokens[index];
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override {
        super._beforeTokenTransfer(from, to, tokenId);
        if (from == address(0)) {
            _addTokenToAllTokensEnumeration(tokenId);
        } else if (from != to) {
            _removeTokenFromOwnerEnumeration(from, tokenId);
        }
        if (to == address(0)) {
            _removeTokenFromAllTokensEnumeration(tokenId);
        } else if (to != from) {
            _addTokenToOwnerEnumeration(to, tokenId);
        }
    }

    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {
        uint256 length = balanceOf(to);
        _ownedTokens[to][length] = tokenId;
        _ownedTokensIndex[tokenId] = length;
    }

    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {
        _allTokensIndex[tokenId] = _allTokens.length;
        _allTokens.push(tokenId);
    }

    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {
        uint256 lastTokenIndex = balanceOf(from) - 1;
        uint256 tokenIndex = _ownedTokensIndex[tokenId];
        if (tokenIndex != lastTokenIndex) {
            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];
            _ownedTokens[from][tokenIndex] = lastTokenId;
            _ownedTokensIndex[lastTokenId] = tokenIndex;
        }
        delete _ownedTokensIndex[tokenId];
        delete _ownedTokens[from][lastTokenIndex];
    }

    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {
        uint256 lastTokenIndex = _allTokens.length - 1;
        uint256 tokenIndex = _allTokensIndex[tokenId];
        uint256 lastTokenId = _allTokens[lastTokenIndex];
        _allTokens[tokenIndex] = lastTokenId;
        _allTokensIndex[lastTokenId] = tokenIndex;
        delete _allTokensIndex[tokenId];
        _allTokens.pop();
    }
}

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract AirdropContract is ERC721Enumerable, Ownable {
    string private _baseURI;
    string private _notRevealedURI;
    uint256 private _cost;
    uint256 private _maxMintAmount;
    bool private _revealed;

    event Minted(address indexed to, uint256 indexed tokenId);
    event Revealed();

    constructor(string memory baseURI, string memory notRevealedURI, uint256 cost, uint256 maxMintAmount) {
        _baseURI = baseURI;
        _notRevealedURI = notRevealedURI;
        _cost = cost;
        _maxMintAmount = maxMintAmount;
        _revealed = false;
    }

    function mint(address to, uint256 tokenId) public payable {
        require(msg.value >= _cost, ""Not enough ether sent"");
        require(tokenId < _maxMintAmount, ""Max mint amount exceeded"");
        _safeMint(to, tokenId);
        emit Minted(to, tokenId);
    }

    function reveal() public onlyOwner {
        _revealed = true;
        emit Revealed();
    }

    function setCost(uint256 cost) public onlyOwner {
        _cost = cost;
    }

    function setMaxMintAmount(uint256 maxMintAmount) public onlyOwner {
        _maxMintAmount = maxMintAmount;
    }

    function setNotRevealedURI(string memory notRevealedURI) public onlyOwner {
        _notRevealedURI = notRevealedURI;
    }

    function setBaseURI(string memory baseURI) public onlyOwner {
        _baseURI = baseURI;
    }

    function tokenURI(uint256 tokenId) public view returns (string memory) {
        require(_exists(tokenId), ""ERC721Metadata: URI query for nonexistent token"");
        if (_revealed) {
            return string(abi.encodePacked(_baseURI, toString(tokenId)));
        } else {
            return _notRevealedURI;
        }
    }

    function toString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return ""0"";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }
}",contract_141.sol
"Develop a smart contract that provides a data structure for storing and managing a set of values. This set should allow for efficient addition, removal, and membership checking. Implement the necessary logic for maintaining the set's storage and indexing. Include functions for setting and getting the set's length and individual values. Ensure the contract is well-structured and follows best practices in Solidity syntax and organization.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract EfficientSet {
    struct Set {
        uint[] values;
        mapping(uint => uint) valueToIndex;
        uint size;
    }

    Set private set;

    function add(uint value) public {
        require(!contains(value), ""Value already exists in the set."");
        set.values.push(value);
        set.valueToIndex[value] = set.values.length - 1;
        set.size++;
    }

    function remove(uint value) public {
        require(contains(value), ""Value does not exist in the set."");
        uint index = set.valueToIndex[value];
        uint lastValue = set.values[set.values.length - 1];
        set.values[index] = lastValue;
        set.valueToIndex[lastValue] = index;
        set.values.pop();
        delete set.valueToIndex[value];
        set.size--;
    }

    function contains(uint value) public view returns (bool) {
        return set.valueToIndex[value] != 0 || value == set.values[0];
    }

    function length() public view returns (uint) {
        return set.size;
    }

    function getValue(uint index) public view returns (uint) {
        require(index < set.values.length, ""Index out of bounds."");
        return set.values[index];
    }
}",contract_142.sol
"Create an ERC721 token contract that allows for the minting, transfer, approval, and ownership of tokens. The contract should include functions for querying the total supply of tokens, the balance of tokens for each owner, and the ownership of each token. The transfer function should enable the transfer of tokens between owners, the approve function should enable approval of a third party to manage tokens on behalf of the owner, and the takeOwnership function should enable the owner of a token to transfer ownership of the token to another address.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC721 {
    string private _name;
    string private _symbol;
    uint256 private _totalSupply;
    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address owner) public view returns (uint256) {
        require(owner != address(0), ""ERC721: balance query for the zero address"");
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) public view returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), ""ERC721: owner query for nonexistent token"");
        return owner;
    }

    function approve(address to, uint256 tokenId) public {
        address owner = ownerOf(tokenId);
        require(to != owner, ""ERC721: approval to current owner"");
        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), ""ERC721: approve caller is not owner nor approved for all"");
        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    function getApproved(uint256 tokenId) public view returns (address) {
        require(_exists(tokenId), ""ERC721: approved query for nonexistent token"");
        return _tokenApprovals[tokenId];
    }

    function setApprovalForAll(address operator, bool approved) public {
        require(operator != msg.sender, ""ERC721: approve to caller"");
        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function isApprovedForAll(address owner, address operator) public view returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function transferFrom(address from, address to, uint256 tokenId) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _transfer(from, to, tokenId);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) public {
        safeTransferFrom(from, to, tokenId, """");
    }

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _safeTransfer(from, to, tokenId, _data);
    }

    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return _owners[tokenId] != address(0);
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    function _safeMint(address to, uint256 tokenId) internal {
        _safeMint(to, tokenId, """");
    }

    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal {
        _mint(to, tokenId);
        require(_checkOnERC721Received(address(0), to, tokenId, _data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _mint(address to, uint256 tokenId) internal {
        require(to != address(0), ""ERC721: mint to the zero address"");
        require(!_exists(tokenId), ""ERC721: token already minted"");
        _beforeTokenTransfer(address(0), to, tokenId);
        _balances[to] += 1;
        _owners[tokenId] = to;
        _totalSupply += 1;
        emit Transfer(address(0), to, tokenId);
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        require(ownerOf(tokenId) == from, ""ERC721: transfer of token that is not own"");
        require(to != address(0), ""ERC721: transfer to the zero address"");
        _beforeTokenTransfer(from, to, tokenId);
        _approve(address(0), tokenId);
        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;
        emit Transfer(from, to, tokenId);
    }

    function _approve(address to, uint256 tokenId) internal {
        _tokenApprovals[tokenId] = to;
        emit Approval(ownerOf(tokenId), to, tokenId);
    }

    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) internal returns (bool) {
        if (isContract(to)) {
            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data) returns (bytes4 retval) {
                return retval == IERC721Receiver.onERC721Received.selector;
            } catch (bytes memory reason) {
                if (reason.length == 0) {
                    revert(""ERC721: transfer to non ERC721Receiver implementer"");
                } else {
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        } else {
            return true;
        }
    }

    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal {}
}

interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}",contract_143.sol
"Create a smart contract that extends the InterestRateModel contract. The contract should have a function that calculates the interest rate for borrowing based on the amount of cash, borrows, and reserves. The rate calculation should be influenced by the amount of borrows. The function should return a success flag and the calculated rate. A separate function should be added to verify if the contract is an InterestRateModel.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract InterestRateModel {
    function isInterestRateModel() external pure returns (bool) {
        return true;
    }
}

contract CustomInterestRateModel is InterestRateModel {
    function calculateInterestRate(uint256 cash, uint256 borrows, uint256 reserves) external view returns (bool, uint256) {
        if (cash == 0 || borrows == 0) {
            return (false, 0);
        }

        uint256 utilizationRate = (borrows * 1e18) / (cash + borrows - reserves);
        uint256 baseRate = 2 * 1e16; // 2% base rate
        uint256 multiplier = 4 * 1e16; // 4% multiplier

        uint256 rate = baseRate + (multiplier * utilizationRate) / 1e18;

        return (true, rate);
    }

    function isInterestRateModel() external pure override returns (bool) {
        return true;
    }
}",contract_144.sol
"Create a smart contract that simulates a sports AMM, allowing users to place bets on sports games. The contract should support bet creation, bet settlement, and payment processing. Implement logic for calculating odds and handling multiple collateral tokens. Integrate with interfaces like IERC20Upgradeable and IStakingThales.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20Upgradeable {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

interface IStakingThales {
    function stake(uint256 amount) external;
    function unstake(uint256 amount) external;
}

contract SportsAMM {
    struct Bet {
        uint256 id;
        address creator;
        address collateralToken;
        uint256 amount;
        uint256 odds;
        bool settled;
        bool outcome;
    }

    Bet[] public bets;
    mapping(uint256 => address) public betToCreator;
    mapping(address => uint256[]) public creatorToBets;
    mapping(address => uint256) public userBalances;

    IERC20Upgradeable public collateralToken;
    IStakingThales public stakingContract;

    event BetCreated(uint256 betId, address creator, address collateralToken, uint256 amount, uint256 odds);
    event BetSettled(uint256 betId, bool outcome);

    constructor(address _collateralToken, address _stakingContract) {
        collateralToken = IERC20Upgradeable(_collateralToken);
        stakingContract = IStakingThales(_stakingContract);
    }

    function createBet(address _collateralToken, uint256 _amount, uint256 _odds) external {
        require(_amount > 0, ""Amount must be greater than 0"");
        require(_odds > 0, ""Odds must be greater than 0"");

        IERC20Upgradeable(_collateralToken).transferFrom(msg.sender, address(this), _amount);

        Bet memory newBet = Bet({
            id: bets.length,
            creator: msg.sender,
            collateralToken: _collateralToken,
            amount: _amount,
            odds: _odds,
            settled: false,
            outcome: false
        });

        bets.push(newBet);
        betToCreator[newBet.id] = msg.sender;
        creatorToBets[msg.sender].push(newBet.id);

        emit BetCreated(newBet.id, msg.sender, _collateralToken, _amount, _odds);
    }

    function settleBet(uint256 _betId, bool _outcome) external {
        Bet storage bet = bets[_betId];
        require(!bet.settled, ""Bet already settled"");

        bet.settled = true;
        bet.outcome = _outcome;

        if (_outcome) {
            uint256 winnings = bet.amount * bet.odds;
            IERC20Upgradeable(bet.collateralToken).transfer(bet.creator, winnings);
        } else {
            IERC20Upgradeable(bet.collateralToken).transfer(address(this), bet.amount);
        }

        emit BetSettled(_betId, _outcome);
    }

    function withdraw(address _token, uint256 _amount) external {
        require(userBalances[msg.sender] >= _amount, ""Insufficient balance"");
        userBalances[msg.sender] -= _amount;
        IERC20Upgradeable(_token).transfer(msg.sender, _amount);
    }

    function stake(uint256 _amount) external {
        collateralToken.transferFrom(msg.sender, address(this), _amount);
        stakingContract.stake(_amount);
    }

    function unstake(uint256 _amount) external {
        stakingContract.unstake(_amount);
        collateralToken.transfer(msg.sender, _amount);
    }
}",contract_145.sol
"Create a Smart Contract that implements NFKeyStaking functionality, including a constructor to set the NFKey address. The contract should have an admin feature with a mapping to store admin addresses, add, and remove admin capabilities. Define a staker struct with properties for token ID, token index, rewards earned, and rewards released. Implement functions for staking, unstaking, and updating treasure reward times. Include getter functions for staked tokens, rewards count, and treasure unlock times. Make sure the contract includes logging for emissions, chest tiers, and token IDs.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC721 {
    function transferFrom(address from, address to, uint256 tokenId) external;
    function ownerOf(uint256 tokenId) external view returns (address);
}

contract NFKeyStaking {
    struct Staker {
        uint256 tokenId;
        uint256 tokenIndex;
        uint256 rewardsEarned;
        uint256 rewardsReleased;
    }

    IERC721 public nfKey;
    address public admin;
    mapping(address => bool) public admins;
    mapping(address => Staker[]) public stakers;
    mapping(uint256 => uint256) public tokenIndexToStaker;
    uint256 public totalStaked;
    uint256 public rewardPerToken;
    uint256 public lastUpdateTime;
    uint256 public rewardRate;

    event Staked(address indexed user, uint256 tokenId);
    event Unstaked(address indexed user, uint256 tokenId);
    event RewardsPaid(address indexed user, uint256 reward);
    event AdminAdded(address indexed admin);
    event AdminRemoved(address indexed admin);

    modifier onlyAdmin() {
        require(admins[msg.sender], ""Not an admin"");
        _;
    }

    constructor(address _nfKey) {
        nfKey = IERC721(_nfKey);
        admin = msg.sender;
        admins[msg.sender] = true;
    }

    function addAdmin(address _admin) external onlyAdmin {
        admins[_admin] = true;
        emit AdminAdded(_admin);
    }

    function removeAdmin(address _admin) external onlyAdmin {
        admins[_admin] = false;
        emit AdminRemoved(_admin);
    }

    function stake(uint256 tokenId) external {
        require(nfKey.ownerOf(tokenId) == msg.sender, ""Not the owner"");
        nfKey.transferFrom(msg.sender, address(this), tokenId);
        Staker memory newStaker = Staker({
            tokenId: tokenId,
            tokenIndex: stakers[msg.sender].length,
            rewardsEarned: 0,
            rewardsReleased: 0
        });
        stakers[msg.sender].push(newStaker);
        tokenIndexToStaker[tokenId] = stakers[msg.sender].length - 1;
        totalStaked++;
        emit Staked(msg.sender, tokenId);
    }

    function unstake(uint256 tokenId) external {
        uint256 index = tokenIndexToStaker[tokenId];
        require(stakers[msg.sender][index].tokenId == tokenId, ""Token not staked by user"");
        Staker storage staker = stakers[msg.sender][index];
        staker.rewardsEarned = earned(msg.sender);
        staker.rewardsReleased += staker.rewardsEarned;
        nfKey.transferFrom(address(this), msg.sender, tokenId);
        _removeStaker(msg.sender, index);
        totalStaked--;
        emit Unstaked(msg.sender, tokenId);
        emit RewardsPaid(msg.sender, staker.rewardsEarned);
    }

    function earned(address account) public view returns (uint256) {
        uint256 earnedRewards = 0;
        for (uint256 i = 0; i < stakers[account].length; i++) {
            Staker storage staker = stakers[account][i];
            earnedRewards += (block.timestamp - staker.rewardsReleased) * rewardRate;
        }
        return earnedRewards;
    }

    function updateRewardRate(uint256 newRate) external onlyAdmin {
        rewardRate = newRate;
    }

    function getStakedTokens(address account) external view returns (uint256[] memory) {
        uint256[] memory tokens = new uint256[](stakers[account].length);
        for (uint256 i = 0; i < stakers[account].length; i++) {
            tokens[i] = stakers[account][i].tokenId;
        }
        return tokens;
    }

    function getRewardsCount(address account) external view returns (uint256) {
        return earned(account);
    }

    function getTreasureUnlockTimes(address account) external view returns (uint256[] memory) {
        uint256[] memory unlockTimes = new uint256[](stakers[account].length);
        for (uint256 i = 0; i < stakers[account].length; i++) {
            unlockTimes[i] = stakers[account][i].rewardsReleased;
        }
        return unlockTimes;
    }

    function _removeStaker(address account, uint256 index) internal {
        stakers[account][index] = stakers[account][stakers[account].length - 1];
        stakers[account].pop();
    }
}",contract_146.sol
"Develop a Solidity smart contract that tests the receipt of ERC721 tokens. The contract should include a function to mint and transfer a mock ERC721 token, and another function to test token reception with varying amounts.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MockERC721 {
    string public name = ""MockERC721"";
    string public symbol = ""MOCK"";
    uint256 private _tokenIdCounter;
    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function balanceOf(address owner) public view returns (uint256) {
        require(owner != address(0), ""ERC721: balance query for the zero address"");
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) public view returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), ""ERC721: owner query for nonexistent token"");
        return owner;
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _safeTransfer(from, to, tokenId, """");
    }

    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal {
        _transfer(from, to, tokenId);
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return _owners[tokenId] != address(0);
    }

    function getApproved(uint256 tokenId) public view returns (address) {
        require(_exists(tokenId), ""ERC721: approved query for nonexistent token"");
        return _tokenApprovals[tokenId];
    }

    function isApprovedForAll(address owner, address operator) public view returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        require(ownerOf(tokenId) == from, ""ERC721: transfer of token that is not own"");
        require(to != address(0), ""ERC721: transfer to the zero address"");

        _approve(address(0), tokenId);

        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(from, to, tokenId);
    }

    function _approve(address to, uint256 tokenId) internal {
        _tokenApprovals[tokenId] = to;
        emit Approval(ownerOf(tokenId), to, tokenId);
    }

    function mint(address to) public {
        uint256 tokenId = _tokenIdCounter++;
        _mint(to, tokenId);
    }

    function _mint(address to, uint256 tokenId) internal {
        require(to != address(0), ""ERC721: mint to the zero address"");
        require(!_exists(tokenId), ""ERC721: token already minted"");

        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(address(0), to, tokenId);
    }
}

contract ERC721ReceiverTest {
    MockERC721 public mockERC721;

    constructor(address mockERC721Address) {
        mockERC721 = MockERC721(mockERC721Address);
    }

    function onERC721Received(address, address, uint256, bytes memory) public pure returns (bytes4) {
        return this.onERC721Received.selector;
    }

    function testTokenReception(uint256 amount) public {
        for (uint256 i = 0; i < amount; i++) {
            mockERC721.mint(address(this));
        }
    }
}",contract_147.sol
"Create a Smart Contract that implements the IERC20 standard, allowing users to transfer tokens and manage their balances. The contract should have a function to calculate the total supply of tokens, and update the total supply. Include an event for token transfers and a function to approve and transfer tokens. The contract should be compatible with the IERC20 standard and follow best practices for smart contract development.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20 {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    mapping(address => uint256) private balances;
    mapping(address => mapping(address => uint256)) private allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _initialSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _initialSupply * 10 ** uint256(_decimals);
        balances[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        require(balances[msg.sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        balances[msg.sender] -= amount;
        balances[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        require(balances[sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        require(allowances[sender][msg.sender] >= amount, ""ERC20: transfer amount exceeds allowance"");
        balances[sender] -= amount;
        balances[recipient] += amount;
        allowances[sender][msg.sender] -= amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return allowances[owner][spender];
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        allowances[msg.sender][spender] += addedValue;
        emit Approval(msg.sender, spender, allowances[msg.sender][spender]);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        require(allowances[msg.sender][spender] >= subtractedValue, ""ERC20: decreased allowance below zero"");
        allowances[msg.sender][spender] -= subtractedValue;
        emit Approval(msg.sender, spender, allowances[msg.sender][spender]);
        return true;
    }
}",contract_148.sol
"Create a smart contract that manages a collection of NFTs. The contract should enable users to mint NFTs, re-roll NFTs, and deposit tokens. Implement functionality for checking the accessibility of tokens within a specific time limit.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
}

contract NFTCollection {
    struct NFT {
        uint256 id;
        uint256 timestamp;
        address owner;
    }

    NFT[] public nfts;
    mapping(uint256 => bool) public nftExists;
    mapping(address => uint256[]) public userNFTs;
    uint256 public nftCounter;
    IERC20 public token;
    uint256 public timeLimit;

    event NFTMinted(uint256 indexed id, address indexed owner);
    event NFTRerolled(uint256 indexed id);
    event TokensDeposited(address indexed user, uint256 amount);

    constructor(address _tokenAddress, uint256 _timeLimit) {
        token = IERC20(_tokenAddress);
        timeLimit = _timeLimit;
    }

    function mintNFT() external {
        nfts.push(NFT({
            id: nftCounter,
            timestamp: block.timestamp,
            owner: msg.sender
        }));
        userNFTs[msg.sender].push(nftCounter);
        nftExists[nftCounter] = true;
        emit NFTMinted(nftCounter, msg.sender);
        nftCounter++;
    }

    function rerollNFT(uint256 _id) external {
        require(nftExists[_id], ""NFT does not exist"");
        require(nfts[_id].owner == msg.sender, ""Not the owner"");
        nfts[_id].timestamp = block.timestamp;
        emit NFTRerolled(_id);
    }

    function depositTokens(uint256 _amount) external {
        require(token.transferFrom(msg.sender, address(this), _amount), ""Transfer failed"");
        emit TokensDeposited(msg.sender, _amount);
    }

    function isTokenAccessible(uint256 _id) public view returns (bool) {
        require(nftExists[_id], ""NFT does not exist"");
        return (block.timestamp - nfts[_id].timestamp) <= timeLimit;
    }
}",contract_149.sol
"Develop a smart contract that can upgrade and change the admin address, implementing the TransparentUpgradeableProxy contract. Ensure the contract includes functions for the admin and implementation slots, utilizing the _admin and _implementation functions. Integrate a mechanism for handling errors and provide informative error messages.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TransparentUpgradeableProxy {
    address private _admin;
    address private _implementation;

    event Upgraded(address indexed implementation);
    event AdminChanged(address previousAdmin, address newAdmin);

    constructor(address _logic, address admin_, bytes memory _data) payable {
        _setAdmin(admin_);
        _setImplementation(_logic);
        if (_data.length > 0) {
            (bool success, ) = _logic.delegatecall(_data);
            require(success, ""Proxy: data execution failed"");
        }
    }

    modifier onlyAdmin() {
        require(msg.sender == _admin, ""Proxy: caller is not the admin"");
        _;
    }

    function upgradeTo(address newImplementation) external onlyAdmin {
        _setImplementation(newImplementation);
        emit Upgraded(newImplementation);
    }

    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable onlyAdmin {
        _setImplementation(newImplementation);
        emit Upgraded(newImplementation);
        (bool success, ) = newImplementation.delegatecall(data);
        require(success, ""Proxy: data execution failed"");
    }

    function changeAdmin(address newAdmin) external onlyAdmin {
        emit AdminChanged(_admin, newAdmin);
        _setAdmin(newAdmin);
    }

    function getAdmin() external view returns (address) {
        return _admin;
    }

    function getImplementation() external view returns (address) {
        return _implementation;
    }

    function _setAdmin(address newAdmin) private {
        require(newAdmin != address(0), ""Proxy: new admin is the zero address"");
        _admin = newAdmin;
    }

    function _setImplementation(address newImplementation) private {
        require(newImplementation != address(0), ""Proxy: new implementation is the zero address"");
        _implementation = newImplementation;
    }

    fallback() external payable {
        _fallback();
    }

    receive() external payable {
        _fallback();
    }

    function _fallback() private {
        _delegate(_implementation);
    }

    function _delegate(address implementation) private {
        assembly {
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())
            switch result
            case 0 { revert(0, returndatasize()) }
            default { return(0, returndatasize()) }
        }
    }
}",contract_150.sol
"Create a smart contract that enables users to deposit, withdraw, and borrow DAI. The contract should interact with the RegistryInterface to get user wallets and check if the user is the owner of the wallet. Implement functions to mint, repay, and redeem DAI using the CTokenInterface. Include functions for ERC20 transfers and approvals. Structure the contract to include modifiers for user authentication and administration.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface RegistryInterface {
    function isOwnerOf(address user, address wallet) external view returns (bool);
}

interface CTokenInterface {
    function mint(uint mintAmount) external returns (uint);
    function redeem(uint redeemTokens) external returns (uint);
    function repayBorrow(uint repayAmount) external returns (uint);
}

contract DAIContract {
    IERC20 public dai;
    RegistryInterface public registry;
    CTokenInterface public cDai;
    address public admin;

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can call this function"");
        _;
    }

    modifier onlyOwner(address wallet) {
        require(registry.isOwnerOf(msg.sender, wallet), ""Not the owner of the wallet"");
        _;
    }

    constructor(address _dai, address _registry, address _cDai) {
        dai = IERC20(_dai);
        registry = RegistryInterface(_registry);
        cDai = CTokenInterface(_cDai);
        admin = msg.sender;
    }

    function deposit(uint256 amount) external {
        require(dai.transferFrom(msg.sender, address(this), amount), ""Transfer failed"");
        require(cDai.mint(amount) == 0, ""Mint failed"");
    }

    function withdraw(uint256 amount) external {
        require(cDai.redeem(amount) == 0, ""Redeem failed"");
        require(dai.transfer(msg.sender, amount), ""Transfer failed"");
    }

    function borrow(uint256 amount) external onlyOwner(msg.sender) {
        require(dai.transfer(msg.sender, amount), ""Transfer failed"");
    }

    function repayBorrow(uint256 amount) external {
        require(dai.transferFrom(msg.sender, address(this), amount), ""Transfer failed"");
        require(cDai.repayBorrow(amount) == 0, ""Repay failed"");
    }

    function approveDAI(address spender, uint256 amount) external onlyAdmin {
        require(dai.approve(spender, amount), ""Approval failed"");
    }

    function transferDAI(address recipient, uint256 amount) external onlyAdmin {
        require(dai.transfer(recipient, amount), ""Transfer failed"");
    }
}",contract_151.sol
"Create a smart contract for a token that can be upgraded to a newer version. The contract should be able to transition to a new address and continue functioning. Implement functions for standard ERC20 operations, such as transferring tokens and checking balances. Include a mechanism for handling deprecation and redirection to the newer contract. Focus on ensuring the contract's continuity and compatibility with the upgraded version.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract UpgradableToken is IERC20 {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    address public admin;
    address public newContractAddress;
    bool public deprecated;

    mapping(address => uint256) private balances;
    mapping(address => mapping(address => uint256)) private allowances;

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can call this function"");
        _;
    }

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _initialSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _initialSupply;
        balances[msg.sender] = _initialSupply;
        admin = msg.sender;
        emit Transfer(address(0), msg.sender, _initialSupply);
    }

    function balanceOf(address account) public view override returns (uint256) {
        if (deprecated && newContractAddress != address(0)) {
            return IERC20(newContractAddress).balanceOf(account);
        }
        return balances[account];
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        if (deprecated && newContractAddress != address(0)) {
            return IERC20(newContractAddress).transfer(recipient, amount);
        }
        require(balances[msg.sender] >= amount, ""Insufficient balance"");
        balances[msg.sender] -= amount;
        balances[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view override returns (uint256) {
        if (deprecated && newContractAddress != address(0)) {
            return IERC20(newContractAddress).allowance(owner, spender);
        }
        return allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        if (deprecated && newContractAddress != address(0)) {
            return IERC20(newContractAddress).approve(spender, amount);
        }
        allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        if (deprecated && newContractAddress != address(0)) {
            return IERC20(newContractAddress).transferFrom(sender, recipient, amount);
        }
        require(allowances[sender][msg.sender] >= amount, ""Allowance too low"");
        require(balances[sender] >= amount, ""Insufficient balance"");
        allowances[sender][msg.sender] -= amount;
        balances[sender] -= amount;
        balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }

    function deprecate(address _newContractAddress) public onlyAdmin {
        deprecated = true;
        newContractAddress = _newContractAddress;
    }

    function undeprecate() public onlyAdmin {
        deprecated = false;
        newContractAddress = address(0);
    }
}",contract_152.sol
Design a Solidity smart contract that represents a token with a limited supply. The contract should enable users to transfer tokens to each other and allow for token burning and increased allowance. The contract should have a maximum supply of 50 million tokens and use the OpenZeppelin ERC20 contract as a base. The contract's behavior should closely resemble the provided code fragment.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MyToken is ERC20 {
    uint256 public constant MAX_SUPPLY = 50000000 * 10**18;

    constructor() ERC20(""MyToken"", ""MTK"") {
        _mint(msg.sender, MAX_SUPPLY);
    }

    function burn(uint256 amount) public {
        _burn(msg.sender, amount);
    }

    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(msg.sender, spender, allowance(msg.sender, spender) + addedValue);
        return true;
    }
}

abstract contract ERC20 {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    uint256 private _totalSupply;
    string private _name;
    string private _symbol;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function name() public view virtual returns (string memory) {
        return _name;
    }

    function symbol() public view virtual returns (string memory) {
        return _symbol;
    }

    function decimals() public view virtual returns (uint8) {
        return 18;
    }

    function totalSupply() public view virtual returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view virtual returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) public virtual returns (bool) {
        address owner = msg.sender;
        _transfer(owner, to, amount);
        return true;
    }

    function allowance(address owner, address spender) public view virtual returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public virtual returns (bool) {
        address owner = msg.sender;
        _approve(owner, spender, amount);
        return true;
    }

    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public virtual returns (bool) {
        address spender = msg.sender;
        _spendAllowance(from, spender, amount);
        _transfer(from, to, amount);
        return true;
    }

    function _transfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {
        require(from != address(0), ""ERC20: transfer from the zero address"");
        require(to != address(0), ""ERC20: transfer to the zero address"");

        uint256 fromBalance = _balances[from];
        require(fromBalance >= amount, ""ERC20: transfer amount exceeds balance"");
        unchecked {
            _balances[from] = fromBalance - amount;
        }
        _balances[to] += amount;

        emit Transfer(from, to, amount);
    }

    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: burn from the zero address"");

        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, ""ERC20: burn amount exceeds balance"");
        unchecked {
            _balances[account] = accountBalance - amount;
        }
        _totalSupply -= amount;

        emit Transfer(account, address(0), amount);
    }

    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _spendAllowance(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        uint256 currentAllowance = allowance(owner, spender);
        if (currentAllowance != type(uint256).max) {
            require(currentAllowance >= amount, ""ERC20: insufficient allowance"");
            unchecked {
                _approve(owner, spender, currentAllowance - amount);
            }
        }
    }
}",contract_153.sol
"Create a smart contract that extends the ERC20 standard, with a focus on managing node rewards and liquidity. The contract should have functions for initializing the contract state variables, tracking blacklisted addresses, and updating the UniswapV2 router and swap tokens amount. Implement the required interfaces and libraries. Ensure the contract has modular design and follows best practices for smart contract development.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface IUniswapV2Router02 {
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
}

contract NodeRewardToken is IERC20 {
    string public name = ""NodeRewardToken"";
    string public symbol = ""NRT"";
    uint8 public decimals = 18;
    uint256 private _totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    mapping(address => bool) public blacklisted;

    address public owner;
    address public uniswapV2Router;
    uint256 public swapTokensAmount;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor(uint256 initialSupply, address _uniswapV2Router, uint256 _swapTokensAmount) {
        _totalSupply = initialSupply * 10 ** uint256(decimals);
        _balances[msg.sender] = _totalSupply;
        owner = msg.sender;
        uniswapV2Router = _uniswapV2Router;
        swapTokensAmount = _swapTokensAmount;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function totalSupply() external view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) external view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) external override returns (bool) {
        require(!blacklisted[msg.sender], ""Sender is blacklisted"");
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address _owner, address spender) external view override returns (uint256) {
        return _allowances[_owner][spender];
    }

    function approve(address spender, uint256 amount) external override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {
        require(!blacklisted[sender], ""Sender is blacklisted"");
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);
        return true;
    }

    function blacklistAddress(address account, bool value) external onlyOwner {
        blacklisted[account] = value;
    }

    function updateUniswapV2Router(address newAddress) external onlyOwner {
        uniswapV2Router = newAddress;
    }

    function updateSwapTokensAmount(uint256 newAmount) external onlyOwner {
        swapTokensAmount = newAmount;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""Transfer from the zero address"");
        require(recipient != address(0), ""Transfer to the zero address"");
        require(_balances[sender] >= amount, ""Transfer amount exceeds balance"");

        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    function _approve(address _owner, address spender, uint256 amount) internal {
        require(_owner != address(0), ""Approve from the zero address"");
        require(spender != address(0), ""Approve to the zero address"");

        _allowances[_owner][spender] = amount;
        emit Approval(_owner, spender, amount);
    }
}",contract_154.sol
"Create a smart contract that implements role-based access control using the provided AccessControl contract as a reference. The contract should allow administrators to create, manage, and assign roles. Include functions for role creation, revocation, and assignment. The contract should support role-based access control, ensuring that only authorized users can perform specific actions. Ensure that the contract emits events for role administration and role changes.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract AccessControl {
    mapping(bytes32 => mapping(address => bool)) private _roles;
    mapping(bytes32 => bytes32) private _roleAdmins;

    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    function hasRole(bytes32 role, address account) public view returns (bool) {
        return _roles[role][account];
    }

    function getRoleAdmin(bytes32 role) public view returns (bytes32) {
        return _roleAdmins[role];
    }

    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {
        bytes32 previousAdminRole = getRoleAdmin(role);
        _roleAdmins[role] = adminRole;
        emit RoleAdminChanged(role, previousAdminRole, adminRole);
    }

    function grantRole(bytes32 role, address account) public {
        require(hasRole(getRoleAdmin(role), msg.sender), ""AccessControl: sender must be an admin to grant"");
        _grantRole(role, account);
    }

    function revokeRole(bytes32 role, address account) public {
        require(hasRole(getRoleAdmin(role), msg.sender), ""AccessControl: sender must be an admin to revoke"");
        _revokeRole(role, account);
    }

    function renounceRole(bytes32 role, address account) public {
        require(account == msg.sender, ""AccessControl: can only renounce roles for self"");
        _revokeRole(role, account);
    }

    function _grantRole(bytes32 role, address account) internal {
        if (!hasRole(role, account)) {
            _roles[role][account] = true;
            emit RoleGranted(role, account, msg.sender);
        }
    }

    function _revokeRole(bytes32 role, address account) internal {
        if (hasRole(role, account)) {
            _roles[role][account] = false;
            emit RoleRevoked(role, account, msg.sender);
        }
    }
}

contract RoleBasedAccessControl is AccessControl {
    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    bytes32 public constant MANAGER_ROLE = keccak256(""MANAGER_ROLE"");

    constructor() {
        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);
        _setRoleAdmin(MANAGER_ROLE, ADMIN_ROLE);
        _grantRole(ADMIN_ROLE, msg.sender);
    }

    function createRole(bytes32 role, bytes32 adminRole) public {
        require(hasRole(ADMIN_ROLE, msg.sender), ""RoleBasedAccessControl: must have admin role to create role"");
        _setRoleAdmin(role, adminRole);
    }

    function assignRole(bytes32 role, address account) public {
        require(hasRole(getRoleAdmin(role), msg.sender), ""RoleBasedAccessControl: must have role admin to assign role"");
        _grantRole(role, account);
    }

    function revokeRole(bytes32 role, address account) public {
        require(hasRole(getRoleAdmin(role), msg.sender), ""RoleBasedAccessControl: must have role admin to revoke role"");
        _revokeRole(role, account);
    }
}",contract_155.sol
"Design a smart contract to manage scheduled operations, allowing authorized proposers to submit tasks, tracked by unique identifiers. Implement delay periods, block and execute operations based on timestamp checks.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ScheduledOperations {
    struct Task {
        uint256 id;
        uint256 delay;
        uint256 timestamp;
        bool executed;
    }

    mapping(uint256 => Task) public tasks;
    mapping(address => bool) public proposers;
    uint256 public taskCount;

    modifier onlyProposer() {
        require(proposers[msg.sender], ""Not a proposer"");
        _;
    }

    modifier taskExists(uint256 _id) {
        require(tasks[_id].id != 0, ""Task does not exist"");
        _;
    }

    constructor(address[] memory _proposers) {
        for (uint256 i = 0; i < _proposers.length; i++) {
            proposers[_proposers[i]] = true;
        }
    }

    function submitTask(uint256 _delay) public onlyProposer returns (uint256) {
        taskCount++;
        tasks[taskCount] = Task({
            id: taskCount,
            delay: _delay,
            timestamp: block.timestamp,
            executed: false
        });
        return taskCount;
    }

    function executeTask(uint256 _id) public taskExists(_id) {
        Task storage task = tasks[_id];
        require(!task.executed, ""Task already executed"");
        require(block.timestamp >= task.timestamp + task.delay, ""Task not ready"");
        task.executed = true;
        // Perform task execution logic here
    }

    function getTask(uint256 _id) public view returns (uint256, uint256, uint256, bool) {
        Task storage task = tasks[_id];
        return (task.id, task.delay, task.timestamp, task.executed);
    }
}",contract_156.sol
"Develop a smart contract that mimics the PancakeSwap router, allowing users to add and remove liquidity. The contract should include a constructor that sets the factory and WETH addresses. The addLiquidity function should calculate the amount of tokens to add, and the removeLiquidity function should calculate the amount of liquidity to remove. Include the necessary logic for ownership transfer and locking/unlocking. Use the provided code as a reference for the Ownable and Context contract structures.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(_owner == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

contract PancakeSwapRouter is Ownable, Context {
    address public factory;
    address public WETH;

    modifier ensure(uint deadline) {
        require(deadline >= block.timestamp, 'PancakeSwapRouter: EXPIRED');
        _;
    }

    constructor(address _factory, address _WETH) {
        factory = _factory;
        WETH = _WETH;
    }

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {
        // Calculate the amounts to add
        // This is a simplified version and should be replaced with actual logic
        amountA = amountADesired;
        amountB = amountBDesired;
        liquidity = 1000; // Placeholder value

        // Transfer tokens to this contract
        // This is a simplified version and should be replaced with actual logic
        // IERC20(tokenA).transferFrom(msg.sender, address(this), amountA);
        // IERC20(tokenB).transferFrom(msg.sender, address(this), amountB);

        // Add liquidity to the pool
        // This is a simplified version and should be replaced with actual logic
        // IPancakeFactory(factory).addLiquidity(tokenA, tokenB, amountA, amountB, to);
    }

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) public ensure(deadline) returns (uint amountA, uint amountB) {
        // Calculate the amounts to remove
        // This is a simplified version and should be replaced with actual logic
        amountA = 500; // Placeholder value
        amountB = 500; // Placeholder value

        // Remove liquidity from the pool
        // This is a simplified version and should be replaced with actual logic
        // IPancakeFactory(factory).removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to);
    }
}",contract_157.sol
"Design a smart contract for an Original Token Vault that manages token deposits and withdrawals. Incorporate security measures like ReentrancyGuard, Pauser, VolumeControl, and DelayedTransfer. The contract should have functions for depositing and withdrawing tokens, utilizing IERC20 and IWETH interfaces. Implement a constructor for initializing sigsVerifier. Ensure that the contract handles token safety and functionality for deposit and withdrawal events. Focus on the overall structure and functionality of the contract.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
    function approve(address spender, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
    function balanceOf(address who) external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface IWETH {
    function deposit() external payable;
    function transfer(address to, uint256 value) external returns (bool);
    function withdraw(uint256) external;
}

contract ReentrancyGuard {
    bool private _notEntered;

    constructor() {
        _notEntered = true;
    }

    modifier nonReentrant() {
        require(_notEntered, ""ReentrancyGuard: reentrant call"");
        _notEntered = false;
        _;
        _notEntered = true;
    }
}

contract Pauser {
    bool private _paused;

    constructor() {
        _paused = false;
    }

    modifier whenNotPaused() {
        require(!_paused, ""Pauser: paused"");
        _;
    }

    function pause() external {
        _paused = true;
    }

    function unpause() external {
        _paused = false;
    }
}

contract VolumeControl {
    uint256 private _dailyLimit;
    uint256 private _usedToday;
    uint256 private _dayStart;

    constructor(uint256 dailyLimit) {
        _dailyLimit = dailyLimit;
        _usedToday = 0;
        _dayStart = block.timestamp;
    }

    modifier withinLimit(uint256 amount) {
        if (block.timestamp > _dayStart + 1 days) {
            _usedToday = 0;
            _dayStart = block.timestamp;
        }
        require(_usedToday + amount <= _dailyLimit, ""VolumeControl: exceeds daily limit"");
        _;
    }

    function updateDailyLimit(uint256 newLimit) external {
        _dailyLimit = newLimit;
    }
}

contract DelayedTransfer {
    struct TransferRequest {
        address recipient;
        uint256 amount;
        uint256 unlockTime;
    }

    TransferRequest[] private _requests;

    function requestTransfer(address recipient, uint256 amount, uint256 delay) external {
        _requests.push(TransferRequest({
            recipient: recipient,
            amount: amount,
            unlockTime: block.timestamp + delay
        }));
    }

    function executeTransfer(uint256 requestIndex) external {
        TransferRequest storage request = _requests[requestIndex];
        require(block.timestamp >= request.unlockTime, ""DelayedTransfer: transfer is delayed"");
        // Perform the transfer
        // This is a placeholder for the actual transfer logic
    }
}

contract OriginalTokenVault is ReentrancyGuard, Pauser, VolumeControl, DelayedTransfer {
    address public sigsVerifier;
    IERC20 public token;
    IWETH public weth;

    event Deposit(address indexed user, uint256 amount);
    event Withdrawal(address indexed user, uint256 amount);

    constructor(address _sigsVerifier, address _token, address _weth, uint256 dailyLimit) VolumeControl(dailyLimit) {
        sigsVerifier = _sigsVerifier;
        token = IERC20(_token);
        weth = IWETH(_weth);
    }

    function deposit(uint256 amount) external whenNotPaused nonReentrant withinLimit(amount) {
        require(token.transferFrom(msg.sender, address(this), amount), ""Deposit failed"");
        emit Deposit(msg.sender, amount);
    }

    function withdraw(uint256 amount) external whenNotPaused nonReentrant {
        require(token.balanceOf(address(this)) >= amount, ""Insufficient balance"");
        require(token.transfer(msg.sender, amount), ""Withdrawal failed"");
        emit Withdrawal(msg.sender, amount);
    }

    function depositETH() external payable whenNotPaused nonReentrant withinLimit(msg.value) {
        weth.deposit{value: msg.value}();
        emit Deposit(msg.sender, msg.value);
    }

    function withdrawETH(uint256 amount) external whenNotPaused nonReentrant {
        weth.withdraw(amount);
        (bool success, ) = msg.sender.call{value: amount}("""");
        require(success, ""ETH transfer failed"");
        emit Withdrawal(msg.sender, amount);
    }
}",contract_158.sol
"Create a smart contract that allows for role-based access control. The contract should be based on OpenZeppelin's AccessControl contract and include functions for managing roles, such as granting, revoking, and renouncing roles. The contract should also track role changes and notify relevant parties. The implementation should be efficient, secure, and follow industry best practices.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract RoleBasedAccessControl {
    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    struct RoleData {
        mapping(address => bool) members;
        bytes32 adminRole;
    }

    mapping(bytes32 => RoleData) private _roles;

    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    function hasRole(bytes32 role, address account) public view returns (bool) {
        return _roles[role].members[account];
    }

    function getRoleAdmin(bytes32 role) public view returns (bytes32) {
        return _roles[role].adminRole;
    }

    function grantRole(bytes32 role, address account) public {
        require(hasRole(_roles[role].adminRole, msg.sender), ""AccessControl: sender must be an admin to grant"");
        _grantRole(role, account);
    }

    function revokeRole(bytes32 role, address account) public {
        require(hasRole(_roles[role].adminRole, msg.sender), ""AccessControl: sender must be an admin to revoke"");
        _revokeRole(role, account);
    }

    function renounceRole(bytes32 role, address account) public {
        require(account == msg.sender, ""AccessControl: can only renounce roles for self"");
        _revokeRole(role, account);
    }

    function _setupRole(bytes32 role, address account) internal {
        _grantRole(role, account);
    }

    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {
        bytes32 previousAdminRole = _roles[role].adminRole;
        _roles[role].adminRole = adminRole;
        emit RoleAdminChanged(role, previousAdminRole, adminRole);
    }

    function _grantRole(bytes32 role, address account) private {
        if (!hasRole(role, account)) {
            _roles[role].members[account] = true;
            emit RoleGranted(role, account, msg.sender);
        }
    }

    function _revokeRole(bytes32 role, address account) private {
        if (hasRole(role, account)) {
            _roles[role].members[account] = false;
            emit RoleRevoked(role, account, msg.sender);
        }
    }
}",contract_159.sol
"Create a smart contract that allows users to mint and manage tokens. The contract should support token metadata and allow for token approvals. Implement functions for minting tokens, updating metadata, and managing approvals. Ensure that the contract includes logging for token events.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    mapping(uint256 => string) public tokenMetadata;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event MetadataUpdate(uint256 indexed tokenId, string metadata);

    constructor(string memory _name, string memory _symbol, uint8 _decimals) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
    }

    function mint(address to, uint256 value) public {
        require(to != address(0), ""Invalid address"");
        totalSupply += value;
        balanceOf[to] += value;
        emit Transfer(address(0), to, value);
    }

    function transfer(address to, uint256 value) public returns (bool) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        require(balanceOf[from] >= value, ""Insufficient balance"");
        require(allowance[from][msg.sender] >= value, ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }

    function updateMetadata(uint256 tokenId, string memory metadata) public {
        tokenMetadata[tokenId] = metadata;
        emit MetadataUpdate(tokenId, metadata);
    }
}",contract_160.sol
Develop a smart contract called SevenToken that enables users to deposit and withdraw Ether. The contract should keep track of user balances and allow for withdrawals. Include a feature for getting the balance of a specific address and the total balance of the owner. Implement logging for withdrawals and ensure gas fees are correctly handled. Consider potential attacks and include measures to prevent them.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SevenToken {
    mapping(address => uint256) private balances;
    address public owner;

    event Deposit(address indexed user, uint256 amount);
    event Withdrawal(address indexed user, uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function deposit() public payable {
        require(msg.value > 0, ""Deposit amount must be greater than 0"");
        balances[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }

    function withdraw(uint256 amount) public {
        require(balances[msg.sender] >= amount, ""Insufficient balance"");
        balances[msg.sender] -= amount;
        (bool success, ) = msg.sender.call{value: amount}("""");
        require(success, ""Transfer failed"");
        emit Withdrawal(msg.sender, amount);
    }

    function getBalance(address user) public view returns (uint256) {
        return balances[user];
    }

    function getTotalBalance() public view onlyOwner returns (uint256) {
        return address(this).balance;
    }

    receive() external payable {
        deposit();
    }

    fallback() external payable {
        deposit();
    }
}",contract_161.sol
Create a smart contract that allows the minting of NFTs based on digital signatures. The contract should have a function to verify the signature and process the mint request. It should also store the requesting address and the signature provided. The contract should allow for the minting of multiple tokens and keep track of the minted tokens. The contract should also allow for the verification and processing of the mint request in a single transaction.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract NFTMinter {
    struct MintRequest {
        address requester;
        bytes signature;
    }

    mapping(uint256 => MintRequest) public mintRequests;
    mapping(address => uint256[]) public mintedTokens;
    uint256 public tokenCounter;

    function verifySignature(bytes32 messageHash, bytes memory signature, address signer) internal pure returns (bool) {
        bytes32 ethSignedMessageHash = keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", messageHash));
        return recoverSigner(ethSignedMessageHash, signature) == signer;
    }

    function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature) internal pure returns (address) {
        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);
        return ecrecover(_ethSignedMessageHash, v, r, s);
    }

    function splitSignature(bytes memory sig) internal pure returns (bytes32 r, bytes32 s, uint8 v) {
        require(sig.length == 65, ""invalid signature length"");
        assembly {
            r := mload(add(sig, 32))
            s := mload(add(sig, 64))
            v := byte(0, mload(add(sig, 96)))
        }
    }

    function mintNFT(bytes memory signature, bytes32 messageHash) public {
        require(verifySignature(messageHash, signature, msg.sender), ""Signature verification failed"");

        uint256 tokenId = tokenCounter++;
        mintRequests[tokenId] = MintRequest({
            requester: msg.sender,
            signature: signature
        });
        mintedTokens[msg.sender].push(tokenId);
    }

    function getMintedTokens(address owner) public view returns (uint256[] memory) {
        return mintedTokens[owner];
    }
}",contract_162.sol
"Develop a smart contract that manages access control for a system with different roles and administrators. The contract should allow administrators to grant and revoke roles, and include a way to query the membership of a role. Implement a new role with moderately restrictive permissions. Provide a clear and concise description of the contract's functionality and structure.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract AccessControl {
    struct Role {
        mapping(address => bool) members;
        bytes32 roleName;
    }

    mapping(bytes32 => Role) private roles;
    bytes32[] private roleList;
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier onlyRoleMember(bytes32 _role) {
        require(roles[_role].members[msg.sender], ""Not a member of the role"");
        _;
    }

    constructor() {
        owner = msg.sender;
        _createRole(""ADMIN"");
        _grantRole(""ADMIN"", msg.sender);
    }

    function _createRole(bytes32 _roleName) internal {
        require(roles[_roleName].roleName == bytes32(0), ""Role already exists"");
        roles[_roleName].roleName = _roleName;
        roleList.push(_roleName);
    }

    function createRole(bytes32 _roleName) external onlyOwner {
        _createRole(_roleName);
    }

    function grantRole(bytes32 _role, address _account) external onlyRoleMember(""ADMIN"") {
        _grantRole(_role, _account);
    }

    function _grantRole(bytes32 _role, address _account) internal {
        require(roles[_role].roleName != bytes32(0), ""Role does not exist"");
        roles[_role].members[_account] = true;
    }

    function revokeRole(bytes32 _role, address _account) external onlyRoleMember(""ADMIN"") {
        require(roles[_role].roleName != bytes32(0), ""Role does not exist"");
        roles[_role].members[_account] = false;
    }

    function isMemberOfRole(bytes32 _role, address _account) public view returns (bool) {
        return roles[_role].members[_account];
    }

    function getRoleList() external view returns (bytes32[] memory) {
        return roleList;
    }
}",contract_163.sol
Design a smart contract that allows users to invest and earn interest on their deposits. The contract should have a system in place to regulate daily investments and have a referral system for earning more interest. The contract should also have a mechanism to pay out dividends to investors. Provide a general outline of the contract's structure and key functions.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract InvestmentPlatform {
    struct Investor {
        uint256 deposit;
        uint256 lastDepositTime;
        uint256 totalEarned;
        address referrer;
    }

    mapping(address => Investor) public investors;
    address[] public investorList;
    uint256 public totalInvested;
    uint256 public constant INTEREST_RATE = 5; // 5% annual interest rate
    uint256 public constant REFERRAL_BONUS = 2; // 2% referral bonus
    uint256 public constant MAX_DAILY_INVESTMENT = 1000 ether;
    uint256 public constant DIVIDEND_RATE = 10; // 10% of total invested

    event Deposit(address indexed investor, uint256 amount);
    event Withdraw(address indexed investor, uint256 amount);
    event ReferralEarned(address indexed referrer, address indexed investor, uint256 amount);
    event DividendPaid(address indexed investor, uint256 amount);

    function deposit(address referrer) public payable {
        require(msg.value > 0, ""Deposit amount must be greater than 0"");
        require(msg.value <= MAX_DAILY_INVESTMENT, ""Exceeds daily investment limit"");

        Investor storage investor = investors[msg.sender];
        if (investor.lastDepositTime == 0) {
            investorList.push(msg.sender);
        } else {
            require(block.timestamp > investor.lastDepositTime + 1 days, ""Can only deposit once per day"");
        }

        investor.deposit += msg.value;
        investor.lastDepositTime = block.timestamp;
        totalInvested += msg.value;

        if (referrer != address(0) && referrer != msg.sender) {
            investors[referrer].totalEarned += (msg.value * REFERRAL_BONUS) / 100;
            emit ReferralEarned(referrer, msg.sender, (msg.value * REFERRAL_BONUS) / 100);
        }

        emit Deposit(msg.sender, msg.value);
    }

    function calculateInterest(address investorAddress) public view returns (uint256) {
        Investor storage investor = investors[investorAddress];
        uint256 timeElapsed = block.timestamp - investor.lastDepositTime;
        uint256 interest = (investor.deposit * INTEREST_RATE * timeElapsed) / (365 days * 100);
        return interest;
    }

    function withdraw() public {
        Investor storage investor = investors[msg.sender];
        uint256 interest = calculateInterest(msg.sender);
        uint256 totalAmount = investor.deposit + interest;

        require(totalAmount > 0, ""No funds to withdraw"");

        investor.deposit = 0;
        investor.totalEarned += interest;
        payable(msg.sender).transfer(totalAmount);

        emit Withdraw(msg.sender, totalAmount);
    }

    function payDividends() public {
        uint256 totalDividends = (totalInvested * DIVIDEND_RATE) / 100;
        require(totalDividends > 0, ""No dividends to pay"");

        for (uint256 i = 0; i < investorList.length; i++) {
            address investorAddress = investorList[i];
            Investor storage investor = investors[investorAddress];
            uint256 dividend = (investor.deposit * totalDividends) / totalInvested;
            investor.totalEarned += dividend;
            payable(investorAddress).transfer(dividend);
            emit DividendPaid(investorAddress, dividend);
        }
    }
}",contract_164.sol
"Create a smart contract that builds upon the IncrementalMerkleTree library by introducing a constructor that initializes the tree's structure with customizable parameters and a reusable function for inserting new leaves, focusing on facilitating the management of large datasets within the Ethereum network.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract IncrementalMerkleTree {
    struct Tree {
        uint256 depth;
        uint256[] layers;
        uint256 zeroValue;
    }

    Tree public tree;

    constructor(uint256 _depth, uint256 _zeroValue) {
        tree.depth = _depth;
        tree.zeroValue = _zeroValue;
        tree.layers = new uint256[](1 << _depth);
        for (uint256 i = 0; i < tree.layers.length; i++) {
            tree.layers[i] = _zeroValue;
        }
    }

    function insertLeaf(uint256 _leaf) public {
        require(tree.layers.length > 0, ""Tree not initialized"");
        require(tree.layers[0] == tree.zeroValue, ""Tree is full"");

        uint256 index = 0;
        for (uint256 i = 0; i < tree.depth; i++) {
            if (index * 2 + 1 < tree.layers.length && tree.layers[index * 2 + 1] == tree.zeroValue) {
                tree.layers[index * 2 + 1] = _leaf;
                index = index * 2 + 1;
            } else {
                tree.layers[index * 2 + 2] = _leaf;
                index = index * 2 + 2;
            }
        }
    }
}",contract_165.sol
"Create a Solidity smart contract that deploys a money market with various facets, including functions for lending, borrowing, and liquidation. The contract should utilize a library to deploy the money market diamond and retrieve facet addresses. Implement functions to serialize and write JSON data for the money market and facet addresses. Design the contract to provide flexibility in managing the money market and its facets.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MoneyMarket {
    struct Facet {
        address facetAddress;
        bytes4[] functionSelectors;
    }

    Facet[] public facets;
    mapping(address => bool) public lenders;
    mapping(address => bool) public borrowers;
    mapping(address => uint256) public balances;
    mapping(address => uint256) public debts;
    uint256 public totalLent;
    uint256 public totalBorrowed;

    event Lend(address indexed lender, uint256 amount);
    event Borrow(address indexed borrower, uint256 amount);
    event Liquidate(address indexed borrower, uint256 amount);

    function addFacet(address _facetAddress, bytes4[] memory _functionSelectors) external {
        facets.push(Facet(_facetAddress, _functionSelectors));
    }

    function getFacetAddresses() external view returns (address[] memory) {
        address[] memory facetAddresses = new address[](facets.length);
        for (uint256 i = 0; i < facets.length; i++) {
            facetAddresses[i] = facets[i].facetAddress;
        }
        return facetAddresses;
    }

    function lend(uint256 amount) external {
        require(amount > 0, ""Amount must be greater than zero"");
        balances[msg.sender] += amount;
        totalLent += amount;
        lenders[msg.sender] = true;
        emit Lend(msg.sender, amount);
    }

    function borrow(uint256 amount) external {
        require(amount > 0, ""Amount must be greater than zero"");
        require(totalLent >= totalBorrowed + amount, ""Not enough liquidity"");
        debts[msg.sender] += amount;
        totalBorrowed += amount;
        borrowers[msg.sender] = true;
        emit Borrow(msg.sender, amount);
    }

    function liquidate(address borrower, uint256 amount) external {
        require(amount > 0, ""Amount must be greater than zero"");
        require(debts[borrower] >= amount, ""Insufficient debt"");
        debts[borrower] -= amount;
        totalBorrowed -= amount;
        emit Liquidate(borrower, amount);
    }

    function serializeFacetAddresses() external view returns (string memory) {
        address[] memory addresses = getFacetAddresses();
        string memory json = ""["";
        for (uint256 i = 0; i < addresses.length; i++) {
            json = string(abi.encodePacked(json, ""\"""", toHexString(addresses[i]), ""\""""));
            if (i < addresses.length - 1) {
                json = string(abi.encodePacked(json, "",""));
            }
        }
        json = string(abi.encodePacked(json, ""]""));
        return json;
    }

    function toHexString(address addr) internal pure returns (string memory) {
        bytes32 value = bytes32(uint256(uint160(addr)));
        bytes memory alphabet = ""0123456789abcdef"";
        bytes memory str = new bytes(42);
        str[0] = '0';
        str[1] = 'x';
        for (uint256 i = 0; i < 20; i++) {
            str[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];
            str[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];
        }
        return string(str);
    }
}",contract_166.sol
"Design a smart contract that conforms to the ERC20 token standard, enabling token transfers, setting Allowance levels, and emitting events for transfers and approvals. Ensure the contract includes variables for storing token balances and allowance amounts, as well as event emissions for transfer and approval operations.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply;
        balanceOf[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], ""Insufficient balance"");
        require(_value <= allowance[_from][msg.sender], ""Allowance exceeded"");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }
}",contract_167.sol
"Create a smart contract that allows users to invest in a smart contract-based investment portfolio. The contract should enable users to deposit and withdraw funds, calculate investment returns based on block time, and allow for secure withdrawal of earnings. Focus on implementing the logic and structure for this functionality, without delving into low-level details.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract InvestmentPortfolio {
    address public owner;
    uint256 public totalInvestment;
    uint256 public startTime;
    uint256 public constant INTEREST_RATE_PER_BLOCK = 1e14; // 0.0001% per block

    mapping(address => uint256) public investments;
    mapping(address => uint256) public lastUpdateBlock;
    mapping(address => uint256) public accumulatedRewards;

    event Deposit(address indexed investor, uint256 amount);
    event Withdraw(address indexed investor, uint256 amount);
    event EarningsWithdrawn(address indexed investor, uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
        startTime = block.number;
    }

    function deposit() external payable {
        require(msg.value > 0, ""Deposit amount must be greater than 0"");
        if (investments[msg.sender] == 0) {
            lastUpdateBlock[msg.sender] = block.number;
        }
        updateRewards(msg.sender);
        investments[msg.sender] += msg.value;
        totalInvestment += msg.value;
        emit Deposit(msg.sender, msg.value);
    }

    function withdraw(uint256 amount) external {
        require(amount > 0, ""Withdrawal amount must be greater than 0"");
        require(investments[msg.sender] >= amount, ""Insufficient balance"");
        updateRewards(msg.sender);
        investments[msg.sender] -= amount;
        totalInvestment -= amount;
        payable(msg.sender).transfer(amount);
        emit Withdraw(msg.sender, amount);
    }

    function withdrawEarnings() external {
        updateRewards(msg.sender);
        uint256 earnings = accumulatedRewards[msg.sender];
        require(earnings > 0, ""No earnings to withdraw"");
        accumulatedRewards[msg.sender] = 0;
        payable(msg.sender).transfer(earnings);
        emit EarningsWithdrawn(msg.sender, earnings);
    }

    function updateRewards(address investor) internal {
        if (investments[investor] > 0) {
            uint256 blocksSinceLastUpdate = block.number - lastUpdateBlock[investor];
            uint256 newRewards = (investments[investor] * INTEREST_RATE_PER_BLOCK * blocksSinceLastUpdate) / 1e18;
            accumulatedRewards[investor] += newRewards;
        }
        lastUpdateBlock[investor] = block.number;
    }

    function getInvestorInfo(address investor) external view returns (uint256 investment, uint256 rewards) {
        return (investments[investor], accumulatedRewards[investor]);
    }
}",contract_168.sol
"Create a Smart Contract that allows users to deposit funds and track their profits. Implement functions to add F1 and network deposits, retrieve deposited amounts, and display overall deposited amounts. Include modifiers to restrict access to certain functions based on user roles. Ensure accurate decimal calculations using the SafeMath library. Focus on simplicity and modularity in the contract structure.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract FundTracker {
    using SafeMath for uint256;

    address public owner;
    mapping(address => uint256) public deposits;
    mapping(address => uint256) public profits;
    uint256 public totalDeposits;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function deposit() public payable {
        deposits[msg.sender] = deposits[msg.sender].add(msg.value);
        totalDeposits = totalDeposits.add(msg.value);
    }

    function addF1Deposit(address _user, uint256 _amount) public onlyOwner {
        deposits[_user] = deposits[_user].add(_amount);
        totalDeposits = totalDeposits.add(_amount);
    }

    function addNetworkDeposit(address _user, uint256 _amount) public onlyOwner {
        deposits[_user] = deposits[_user].add(_amount);
        totalDeposits = totalDeposits.add(_amount);
    }

    function getDeposit(address _user) public view returns (uint256) {
        return deposits[_user];
    }

    function getTotalDeposits() public view returns (uint256) {
        return totalDeposits;
    }

    function updateProfit(address _user, uint256 _profit) public onlyOwner {
        profits[_user] = profits[_user].add(_profit);
    }

    function getProfit(address _user) public view returns (uint256) {
        return profits[_user];
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }
}",contract_169.sol
"Create a smart contract that allows users to register names, track player information, and incentivize affiliate referrals. Ensure the contract includes a fee structure for registering names and validation for preventing duplicates. Include a simple constructor for initializing the contract and basic controls for moderation. Utilize the provided NameFilter and SafeMath libraries for additional functionality. Focus on creating a user-friendly and scalable solution.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract PlayerRegistry {
    using SafeMath for uint256;

    struct Player {
        string name;
        address referrer;
        uint256 referralCount;
        uint256 balance;
    }

    mapping(address => Player) public players;
    mapping(string => address) public nameToAddress;
    address public owner;
    uint256 public registrationFee;

    event PlayerRegistered(address indexed player, string name, address referrer);
    event ReferralAdded(address indexed player, address indexed referrer);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor(uint256 _registrationFee) {
        owner = msg.sender;
        registrationFee = _registrationFee;
    }

    function registerName(string memory _name, address _referrer) public payable {
        require(msg.value == registrationFee, ""Incorrect registration fee"");
        require(bytes(_name).length > 0, ""Name cannot be empty"");
        require(nameToAddress[_name] == address(0), ""Name already registered"");

        _name = _filterName(_name);
        require(bytes(_name).length > 0, ""Invalid name"");

        Player storage player = players[msg.sender];
        require(bytes(player.name).length == 0, ""Player already registered"");

        player.name = _name;
        player.referrer = _referrer;
        nameToAddress[_name] = msg.sender;

        if (_referrer != address(0)) {
            Player storage referrerPlayer = players[_referrer];
            referrerPlayer.referralCount = referrerPlayer.referralCount.add(1);
            referrerPlayer.balance = referrerPlayer.balance.add(msg.value.div(10)); // 10% referral bonus
            emit ReferralAdded(msg.sender, _referrer);
        }

        emit PlayerRegistered(msg.sender, _name, _referrer);
    }

    function _filterName(string memory _name) internal pure returns (string memory) {
        bytes memory nameBytes = bytes(_name);
        bytes memory result = new bytes(nameBytes.length);
        uint256 resultLength = 0;

        for (uint256 i = 0; i < nameBytes.length; i++) {
            if (nameBytes[i] >= 0x41 && nameBytes[i] <= 0x5A) { // A-Z
                result[resultLength++] = nameBytes[i] + 0x20; // Convert to lowercase
            } else if (nameBytes[i] >= 0x61 && nameBytes[i] <= 0x7A) { // a-z
                result[resultLength++] = nameBytes[i];
            }
        }

        return string(result);
    }

    function withdraw() public onlyOwner {
        payable(owner).transfer(address(this).balance);
    }

    function setRegistrationFee(uint256 _newFee) public onlyOwner {
        registrationFee = _newFee;
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }
}",contract_170.sol
"Create a Solidity smart contract that allows for pausing and unpausing of smart contract functionality, utilizing the Pausable abstract contract. Implement interfaces for receiving IAccounting, AggregatorV3Interface, and IHedgingReactor, integrating them to facilitate delta hedging, collateralling, and withdrawals. Utilize state variables and modifiers to restrict functionality when paused or unpaused. Include functions for interacting with above interfaces and emitting events during significant transactions.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Pausable {
    bool private _paused;

    event Paused(address account);
    event Unpaused(address account);

    constructor() {
        _paused = false;
    }

    modifier whenNotPaused() {
        require(!_paused, ""Pausable: paused"");
        _;
    }

    modifier whenPaused() {
        require(_paused, ""Pausable: not paused"");
        _;
    }

    function paused() public view returns (bool) {
        return _paused;
    }

    function _pause() internal virtual whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    function _unpause() internal virtual whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}

interface IAccounting {
    function collateralize() external;
    function withdraw(uint256 amount) external;
}

interface AggregatorV3Interface {
    function latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80);
}

interface IHedgingReactor {
    function deltaHedge() external;
}

contract HedgingContract is Pausable {
    IAccounting public accounting;
    AggregatorV3Interface public priceFeed;
    IHedgingReactor public hedgingReactor;

    event Collateralized(uint256 amount);
    event Withdrawn(uint256 amount);
    event Hedged();

    constructor(address _accounting, address _priceFeed, address _hedgingReactor) {
        accounting = IAccounting(_accounting);
        priceFeed = AggregatorV3Interface(_priceFeed);
        hedgingReactor = IHedgingReactor(_hedgingReactor);
    }

    function pause() public whenNotPaused {
        _pause();
    }

    function unpause() public whenPaused {
        _unpause();
    }

    function collateralize() public whenNotPaused {
        accounting.collateralize();
        emit Collateralized(1); // Assuming collateralize function does not return amount
    }

    function withdraw(uint256 amount) public whenNotPaused {
        accounting.withdraw(amount);
        emit Withdrawn(amount);
    }

    function deltaHedge() public whenNotPaused {
        hedgingReactor.deltaHedge();
        emit Hedged();
    }

    function getLatestPrice() public view returns (int256) {
        (
            uint80 roundID, 
            int256 price, 
            uint256 startedAt, 
            uint256 timeStamp, 
            uint80 answeredInRound
        ) = priceFeed.latestRoundData();
        return price;
    }
}",contract_171.sol
Create a smart contract that utilizes the IPoseidonHasher interface to compute the poseidon hash of a given input vector. The contract should include a function to register a new poseidon hash and retrieve the poseidon hash of a given input. Take into consideration the technical requirements outlined in the provided code and ensure the contract is well-structured and maintainable.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IPoseidonHasher {
    function poseidon(uint256[] memory input) external pure returns (uint256);
}

contract PoseidonHashRegistry {
    struct HashRecord {
        uint256 hashValue;
        bool exists;
    }

    mapping(uint256 => HashRecord) public hashes;
    IPoseidonHasher public poseidonHasher;

    event HashRegistered(uint256 indexed inputHash, uint256 hashValue);

    constructor(address _poseidonHasherAddress) {
        poseidonHasher = IPoseidonHasher(_poseidonHasherAddress);
    }

    function registerHash(uint256[] memory input) public {
        uint256 inputHash = uint256(keccak256(abi.encodePacked(input)));
        require(!hashes[inputHash].exists, ""Hash already registered"");

        uint256 hashValue = poseidonHasher.poseidon(input);
        hashes[inputHash] = HashRecord(hashValue, true);

        emit HashRegistered(inputHash, hashValue);
    }

    function getHash(uint256[] memory input) public view returns (uint256) {
        uint256 inputHash = uint256(keccak256(abi.encodePacked(input)));
        require(hashes[inputHash].exists, ""Hash not found"");

        return hashes[inputHash].hashValue;
    }
}",contract_172.sol
"Create a token contract that supports both ERC20 and ERC223 standards. The contract should allow for token transfers, balance checks, and allowance management. Implement the necessary logic for token transfers, including balance checks and transfer notifications. Make use of the SafeMath library to ensure secure arithmetic operations. Include variables for the token's name, symbol, and total supply. Implement methods for getting the token name, symbol, and total supply. The contract should be compatible with both ERC20 and ERC223 standards.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20ERC223Token {
    using SafeMath for uint256;

    string private _name;
    string private _symbol;
    uint256 private _totalSupply;
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory name_, string memory symbol_, uint256 totalSupply_) {
        _name = name_;
        _symbol = symbol_;
        _totalSupply = totalSupply_;
        _balances[msg.sender] = totalSupply_;
        emit Transfer(address(0), msg.sender, totalSupply_);
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) public returns (bool) {
        _transfer(msg.sender, to, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) public returns (bool) {
        _spendAllowance(from, msg.sender, amount);
        _transfer(from, to, amount);
        return true;
    }

    function _transfer(address from, address to, uint256 amount) internal {
        require(from != address(0), ""ERC20: transfer from the zero address"");
        require(to != address(0), ""ERC20: transfer to the zero address"");

        _beforeTokenTransfer(from, to, amount);

        uint256 fromBalance = _balances[from];
        require(fromBalance >= amount, ""ERC20: transfer amount exceeds balance"");
        unchecked {
            _balances[from] = fromBalance - amount;
        }
        _balances[to] += amount;

        emit Transfer(from, to, amount);

        _afterTokenTransfer(from, to, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _spendAllowance(address owner, address spender, uint256 amount) internal {
        uint256 currentAllowance = allowance(owner, spender);
        if (currentAllowance != type(uint256).max) {
            require(currentAllowance >= amount, ""ERC20: insufficient allowance"");
            unchecked {
                _approve(owner, spender, currentAllowance - amount);
            }
        }
    }

    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}

    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, ""SafeMath: modulo by zero"");
        return a % b;
    }
}",contract_173.sol
"Create a Solidity smart contract that manages the Treasury's PIGGY token supply, delegation of bonds, and seigniorage distribution. Implement functions for initializing the contract, setting operator roles, and interacting with Oracle and Masonry interfaces for PIGGY prices and supply management. Remember to handle edge cases and implement logical error checking for contract reliability.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Treasury {
    address public operator;
    uint256 public totalPiggySupply;
    uint256 public seigniorage;
    IOracle public oracle;
    IMasonry public masonry;

    struct Bond {
        address delegate;
        uint256 amount;
    }

    mapping(address => Bond) public bonds;

    modifier onlyOperator() {
        require(msg.sender == operator, ""Not the operator"");
        _;
    }

    constructor(address _oracle, address _masonry) {
        operator = msg.sender;
        oracle = IOracle(_oracle);
        masonry = IMasonry(_masonry);
    }

    function setOperator(address _newOperator) external onlyOperator {
        operator = _newOperator;
    }

    function delegateBond(address _delegate, uint256 _amount) external {
        require(_amount > 0, ""Amount must be greater than zero"");
        bonds[msg.sender] = Bond(_delegate, _amount);
    }

    function distributeSeigniorage() external onlyOperator {
        uint256 piggyPrice = oracle.getPiggyPrice();
        require(piggyPrice > 0, ""Invalid piggy price"");

        uint256 totalSupply = masonry.totalSupply();
        seigniorage = totalSupply * piggyPrice;
        // Distribute seigniorage logic here
    }

    function mintPiggy(uint256 _amount) external onlyOperator {
        require(_amount > 0, ""Amount must be greater than zero"");
        totalPiggySupply += _amount;
        // Minting logic here
    }

    function burnPiggy(uint256 _amount) external onlyOperator {
        require(_amount > 0, ""Amount must be greater than zero"");
        require(totalPiggySupply >= _amount, ""Insufficient supply"");
        totalPiggySupply -= _amount;
        // Burning logic here
    }
}

interface IOracle {
    function getPiggyPrice() external view returns (uint256);
}

interface IMasonry {
    function totalSupply() external view returns (uint256);
}",contract_174.sol
"Create a smart contract that allows for ownership management, including the ability to initialize and transfer ownership. The contract should include functions for transferring ownership and retrieving the current owner. Use the provided code as a reference. Modify the code to fit the required functionality and include necessary variables and modifiers.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    modifier onlyOwner() {
        require(msg.sender == _owner, ""Ownable: caller is not the owner"");
        _;
    }

    function owner() public view returns (address) {
        return _owner;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}",contract_175.sol
"Create a smart contract for a mintable token that has an owner and allows for token minting and transfer. The contract should have an owner that can start and stop the minting process. The contract should also track the last time a token was moved by an address. Additionally, the owner should be able to unlock the minting process and allow tokens to be transferred.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MintableToken {
    string public name = ""MintableToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    address public owner;
    bool public mintingStopped = false;
    bool public transferAllowed = false;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    mapping(address => uint256) public lastTransferTimestamp;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event MintingStopped(address indexed owner);
    event MintingStarted(address indexed owner);
    event TransferAllowed(address indexed owner);
    event TransferDisallowed(address indexed owner);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function startMinting() external onlyOwner {
        mintingStopped = false;
        emit MintingStarted(msg.sender);
    }

    function stopMinting() external onlyOwner {
        mintingStopped = true;
        emit MintingStopped(msg.sender);
    }

    function allowTransfer() external onlyOwner {
        transferAllowed = true;
        emit TransferAllowed(msg.sender);
    }

    function disallowTransfer() external onlyOwner {
        transferAllowed = false;
        emit TransferDisallowed(msg.sender);
    }

    function mint(address to, uint256 amount) external onlyOwner {
        require(!mintingStopped, ""Minting is stopped"");
        _mint(to, amount);
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        require(transferAllowed, ""Transfer is not allowed"");
        _transfer(msg.sender, to, amount);
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        require(transferAllowed, ""Transfer is not allowed"");
        require(allowance[from][msg.sender] >= amount, ""Allowance exceeded"");
        allowance[from][msg.sender] -= amount;
        _transfer(from, to, amount);
        return true;
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function _mint(address to, uint256 amount) internal {
        totalSupply += amount;
        balanceOf[to] += amount;
        emit Transfer(address(0), to, amount);
    }

    function _transfer(address from, address to, uint256 amount) internal {
        require(balanceOf[from] >= amount, ""Insufficient balance"");
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        lastTransferTimestamp[from] = block.timestamp;
        emit Transfer(from, to, amount);
    }
}",contract_176.sol
Create a smart contract that has a owner and allows for ownership transfer. Implement a pause and unpause function to pause and resume the contract's functionality. The contract should emit events when ownership is transferred or paused/unpaused. The contract should inherit from OpenZeppelin's contracts and implement the required functions.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract Pausable is Ownable {
    bool private _paused;

    event Paused(address account);
    event Unpaused(address account);

    constructor() {
        _paused = false;
    }

    modifier whenNotPaused() {
        require(!paused(), ""Pausable: paused"");
        _;
    }

    modifier whenPaused() {
        require(paused(), ""Pausable: not paused"");
        _;
    }

    function paused() public view virtual returns (bool) {
        return _paused;
    }

    function pause() public virtual onlyOwner whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    function unpause() public virtual onlyOwner whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}

contract MyContract is Pausable {
    // Your contract logic here
}",contract_177.sol
Create a smart contract that performs basic arithmetic operations and token transfers. The contract should include libraries for safe arithmetic operations and address handling. Ensure that the contract handles overflow and underflow conditions. Implement the contract using Solidity and include descriptions of the functions and variables used.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ArithmeticOperations {
    // SafeMath library to prevent overflow and underflow
    library SafeMath {
        function add(uint256 a, uint256 b) internal pure returns (uint256) {
            uint256 c = a + b;
            require(c >= a, ""SafeMath: addition overflow"");
            return c;
        }

        function sub(uint256 a, uint256 b) internal pure returns (uint256) {
            require(b <= a, ""SafeMath: subtraction overflow"");
            uint256 c = a - b;
            return c;
        }

        function mul(uint256 a, uint256 b) internal pure returns (uint256) {
            if (a == 0) {
                return 0;
            }
            uint256 c = a * b;
            require(c / a == b, ""SafeMath: multiplication overflow"");
            return c;
        }

        function div(uint256 a, uint256 b) internal pure returns (uint256) {
            require(b > 0, ""SafeMath: division by zero"");
            uint256 c = a / b;
            return c;
        }
    }

    // Address library to handle address type
    library Address {
        function isContract(address account) internal view returns (bool) {
            uint256 size;
            assembly { size := extcodesize(account) }
            return size > 0;
        }
    }

    using SafeMath for uint256;
    using Address for address;

    // Token variables
    mapping(address => uint256) private _balances;
    uint256 private _totalSupply;

    // Events
    event Transfer(address indexed from, address indexed to, uint256 value);

    // Constructor to initialize total supply and allocate tokens to the contract creator
    constructor(uint256 initialSupply) {
        _totalSupply = initialSupply;
        _balances[msg.sender] = initialSupply;
        emit Transfer(address(0), msg.sender, initialSupply);
    }

    // Function to get the total supply of tokens
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    // Function to get the balance of a specific address
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    // Function to transfer tokens from the caller to a recipient
    function transfer(address recipient, uint256 amount) public returns (bool) {
        require(_balances[msg.sender] >= amount, ""Insufficient balance"");
        _balances[msg.sender] = _balances[msg.sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    // Function to perform addition
    function add(uint256 a, uint256 b) public pure returns (uint256) {
        return a.add(b);
    }

    // Function to perform subtraction
    function sub(uint256 a, uint256 b) public pure returns (uint256) {
        return a.sub(b);
    }

    // Function to perform multiplication
    function mul(uint256 a, uint256 b) public pure returns (uint256) {
        return a.mul(b);
    }

    // Function to perform division
    function div(uint256 a, uint256 b) public pure returns (uint256) {
        return a.div(b);
    }
}",contract_178.sol
"Create a smart contract that defines a router for equalizing liquidity. The contract should have functions for adding and removing liquidity, swapping tokens, and getting the amount of tokens out given the amount in. Implement the logic for these functions, including checks and error handling. Ensure that the contract inherits from OpenZeppelin's Pausable and Ownable contracts.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract LiquidityRouter is Pausable, Ownable {
    mapping(address => mapping(address => uint256)) public liquidityPools;
    mapping(address => uint256) public totalLiquidity;

    event LiquidityAdded(address indexed tokenA, address indexed tokenB, uint256 amountA, uint256 amountB);
    event LiquidityRemoved(address indexed tokenA, address indexed tokenB, uint256 amountA, uint256 amountB);
    event TokensSwapped(address indexed tokenIn, address indexed tokenOut, uint256 amountIn, uint256 amountOut);

    function addLiquidity(address tokenA, address tokenB, uint256 amountA, uint256 amountB) external whenNotPaused {
        require(tokenA != address(0) && tokenB != address(0), ""Invalid token address"");
        require(amountA > 0 && amountB > 0, ""Amount must be greater than zero"");

        liquidityPools[tokenA][tokenB] += amountA;
        liquidityPools[tokenB][tokenA] += amountB;
        totalLiquidity[tokenA] += amountA;
        totalLiquidity[tokenB] += amountB;

        emit LiquidityAdded(tokenA, tokenB, amountA, amountB);
    }

    function removeLiquidity(address tokenA, address tokenB, uint256 amountA, uint256 amountB) external whenNotPaused {
        require(tokenA != address(0) && tokenB != address(0), ""Invalid token address"");
        require(amountA > 0 && amountB > 0, ""Amount must be greater than zero"");
        require(liquidityPools[tokenA][tokenB] >= amountA && liquidityPools[tokenB][tokenA] >= amountB, ""Insufficient liquidity"");

        liquidityPools[tokenA][tokenB] -= amountA;
        liquidityPools[tokenB][tokenA] -= amountB;
        totalLiquidity[tokenA] -= amountA;
        totalLiquidity[tokenB] -= amountB;

        emit LiquidityRemoved(tokenA, tokenB, amountA, amountB);
    }

    function swapTokens(address tokenIn, address tokenOut, uint256 amountIn) external whenNotPaused returns (uint256 amountOut) {
        require(tokenIn != address(0) && tokenOut != address(0), ""Invalid token address"");
        require(amountIn > 0, ""Amount must be greater than zero"");
        require(liquidityPools[tokenIn][tokenOut] > 0, ""No liquidity for this pair"");

        amountOut = (amountIn * liquidityPools[tokenOut][tokenIn]) / (liquidityPools[tokenIn][tokenOut] + amountIn);
        require(amountOut > 0, ""Insufficient output amount"");

        liquidityPools[tokenIn][tokenOut] += amountIn;
        liquidityPools[tokenOut][tokenIn] -= amountOut;

        emit TokensSwapped(tokenIn, tokenOut, amountIn, amountOut);
    }

    function getAmountOut(address tokenIn, address tokenOut, uint256 amountIn) external view returns (uint256 amountOut) {
        require(tokenIn != address(0) && tokenOut != address(0), ""Invalid token address"");
        require(amountIn > 0, ""Amount must be greater than zero"");
        require(liquidityPools[tokenIn][tokenOut] > 0, ""No liquidity for this pair"");

        amountOut = (amountIn * liquidityPools[tokenOut][tokenIn]) / (liquidityPools[tokenIn][tokenOut] + amountIn);
    }

    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }
}",contract_179.sol
"Develop a smart contract that simulates the modularLong contract's structure and functionality. Incorporate event triggers for player registration, game timers, and affiliate payouts. Include functions for calculating game metrics and managing player data. Ensure the smart contract is well-organized, readable, and follows conventional coding practices.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ModularLong {
    struct Player {
        address playerAddress;
        uint256 balance;
        bool isRegistered;
    }

    struct Game {
        uint256 startTime;
        uint256 endTime;
        bool isActive;
    }

    address public owner;
    mapping(address => Player) public players;
    Game public currentGame;
    uint256 public totalPlayers;
    uint256 public totalAffiliatePayouts;

    event PlayerRegistered(address indexed player);
    event GameTimerStarted(uint256 startTime, uint256 endTime);
    event AffiliatePayout(address indexed affiliate, uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function registerPlayer() external {
        require(!players[msg.sender].isRegistered, ""Player already registered"");
        players[msg.sender] = Player({
            playerAddress: msg.sender,
            balance: 0,
            isRegistered: true
        });
        totalPlayers++;
        emit PlayerRegistered(msg.sender);
    }

    function startGameTimer(uint256 duration) external onlyOwner {
        require(!currentGame.isActive, ""Game already active"");
        currentGame = Game({
            startTime: block.timestamp,
            endTime: block.timestamp + duration,
            isActive: true
        });
        emit GameTimerStarted(currentGame.startTime, currentGame.endTime);
    }

    function calculateGameMetrics() public view returns (uint256, uint256) {
        return (totalPlayers, totalAffiliatePayouts);
    }

    function managePlayerData(address playerAddress, uint256 newBalance) external onlyOwner {
        require(players[playerAddress].isRegistered, ""Player not registered"");
        players[playerAddress].balance = newBalance;
    }

    function payoutAffiliate(address affiliate, uint256 amount) external onlyOwner {
        require(players[affiliate].isRegistered, ""Affiliate not registered"");
        players[affiliate].balance += amount;
        totalAffiliatePayouts += amount;
        emit AffiliatePayout(affiliate, amount);
    }
}",contract_180.sol
"Design a smart contract to manage a token for digital entertainment. The contract should include features for owner transfer, approval, and token transfer. Implement a system for tracking token balances and allowed transactions. Emit events for transfer and approval. Build upon a library that provides safe arithmetic operations. Keep in mind the specific functionality demonstrated in the provided code snippet.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DigitalEntertainmentToken {
    string public name = ""DigitalEntertainmentToken"";
    string public symbol = ""DET"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    address public owner;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        owner = msg.sender;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""New owner is the zero address"");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance too low"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }
}",contract_181.sol
"Create a token contract that allows users to transfer tokens, track balances, and grant approvals. The contract should include features for pausing and unpausing token transfers. Implement the total supply tracking and provide functions for users to check their balances and approve token transfers.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    bool public paused;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    address public owner;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Pause();
    event Unpause();

    modifier whenNotPaused() {
        require(!paused, ""Paused"");
        _;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not owner"");
        _;
    }

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        owner = msg.sender;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool success) {
        require(_value <= balanceOf[_from], ""Insufficient balance"");
        require(_value <= allowance[_from][msg.sender], ""Allowance exceeded"");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    function pause() public onlyOwner {
        paused = true;
        emit Pause();
    }

    function unpause() public onlyOwner {
        paused = false;
        emit Unpause();
    }
}",contract_182.sol
"Develop a smart contract that manages a token, allowing users to send and receive tokens, with the ability to freeze and unfreeze values for future release. The contract should include functions for transferring tokens, freezing, and unfreezing values, as well as variables to store the total supply, user balances, and a data structure to store frozen values and release times.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    mapping(address => FrozenBalance[]) public frozenBalances;

    struct FrozenBalance {
        uint256 amount;
        uint256 releaseTime;
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Freeze(address indexed owner, uint256 value, uint256 releaseTime);
    event Unfreeze(address indexed owner, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }

    function freeze(uint256 value, uint256 releaseTime) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        frozenBalances[msg.sender].push(FrozenBalance(value, releaseTime));
        emit Freeze(msg.sender, value, releaseTime);
        return true;
    }

    function unfreeze(uint256 index) public returns (bool success) {
        require(index < frozenBalances[msg.sender].length, ""Invalid index"");
        FrozenBalance storage frozenBalance = frozenBalances[msg.sender][index];
        require(block.timestamp >= frozenBalance.releaseTime, ""Release time not reached"");
        balanceOf[msg.sender] += frozenBalance.amount;
        frozenBalances[msg.sender][index] = frozenBalances[msg.sender][frozenBalances[msg.sender].length - 1];
        frozenBalances[msg.sender].pop();
        emit Unfreeze(msg.sender, frozenBalance.amount);
        return true;
    }
}",contract_183.sol
"Create a smart contract that enables the creation of a basic ERC20 token. The token should have a total supply of 500 million and 8 decimal places. Include functionality for transferring tokens, approving allowances, and checking remaining balances. Utilize the SafeMath library for arithmetic operations. Pay attention to event emissions and ensure that the contract is compliant with the ERC20 standard.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 8;
    uint256 public totalSupply = 500000000 * 10**uint256(decimals);

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        balanceOf[msg.sender] = totalSupply;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }
}",contract_184.sol
"Develop a smart contract that follows the IERC721Full standard, allowing for the creation, management, and transfer of unique digital assets. The contract should include functions for token minting, updating, and querying, as well as support for token metadata and enumeration. Consider gas efficiency and error handling in your implementation.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC721Full {
    string private _name;
    string private _symbol;
    uint256 private _tokenIdCounter;

    mapping(uint256 => address) private _tokenOwner;
    mapping(uint256 => string) private _tokenURIs;
    mapping(address => uint256) private _ownedTokensCount;

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event TokenURIUpdated(uint256 indexed tokenId, string uri);

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function balanceOf(address owner) public view returns (uint256) {
        require(owner != address(0), ""ERC721: balance query for the zero address"");
        return _ownedTokensCount[owner];
    }

    function ownerOf(uint256 tokenId) public view returns (address) {
        address owner = _tokenOwner[tokenId];
        require(owner != address(0), ""ERC721: owner query for nonexistent token"");
        return owner;
    }

    function tokenURI(uint256 tokenId) public view returns (string memory) {
        require(_exists(tokenId), ""ERC721Metadata: URI query for nonexistent token"");
        return _tokenURIs[tokenId];
    }

    function mint(address to, string memory uri) public returns (uint256) {
        require(to != address(0), ""ERC721: mint to the zero address"");

        _tokenIdCounter++;
        uint256 newTokenId = _tokenIdCounter;
        _mint(to, newTokenId);
        _setTokenURI(newTokenId, uri);

        return newTokenId;
    }

    function updateTokenURI(uint256 tokenId, string memory uri) public {
        require(_exists(tokenId), ""ERC721: token does not exist"");
        require(msg.sender == ownerOf(tokenId), ""ERC721: only owner can update token URI"");
        _setTokenURI(tokenId, uri);
    }

    function transferFrom(address from, address to, uint256 tokenId) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _transfer(from, to, tokenId);
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return _tokenOwner[tokenId] != address(0);
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");
        address owner = ownerOf(tokenId);
        return (spender == owner);
    }

    function _mint(address to, uint256 tokenId) internal {
        _tokenOwner[tokenId] = to;
        _ownedTokensCount[to] += 1;
        emit Transfer(address(0), to, tokenId);
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        require(ownerOf(tokenId) == from, ""ERC721: transfer of token that is not own"");
        require(to != address(0), ""ERC721: transfer to the zero address"");

        _ownedTokensCount[from] -= 1;
        _ownedTokensCount[to] += 1;
        _tokenOwner[tokenId] = to;

        emit Transfer(from, to, tokenId);
    }

    function _setTokenURI(uint256 tokenId, string memory uri) internal {
        _tokenURIs[tokenId] = uri;
        emit TokenURIUpdated(tokenId, uri);
    }
}",contract_185.sol
"Create a smart contract called 'StakingWarmup' that supports withdrawals. The contract should have two immutable addresses, 'staking' and 'sHocus'. Implement a constructor function to set these addresses. Include a function 'retrieve' that allows the 'staking' address to withdraw a specified amount to a specified staker. The function should validate that the caller is indeed the 'staking' address.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract StakingWarmup {
    address immutable public staking;
    address immutable public sHocus;

    constructor(address _staking, address _sHocus) {
        staking = _staking;
        sHocus = _sHocus;
    }

    function retrieve(address staker, uint256 amount) external {
        require(msg.sender == staking, ""Only staking contract can call this function"");
        payable(staker).transfer(amount);
    }
}",contract_186.sol
"Create a Solidity smart contract that implements the Moloch token system. The contract should include functions for submitting proposals, voting, and executing proposals. Implement mechanisms for managing member roles and delegate keys. Ensure the contract can handle multiple proposals and events for tracking proposal status. Optimize the contract for gas efficiency and follow proper coding standards.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MolochTokenSystem {
    struct Proposal {
        address proposer;
        uint256 startingPeriod;
        uint256 yesVotes;
        uint256 noVotes;
        bool processed;
        bool didPass;
    }

    struct Member {
        address delegateKey;
        uint256 shares;
        bool exists;
    }

    address public summoner;
    uint256 public proposalCount;
    uint256 public votingPeriodLength;
    uint256 public gracePeriodLength;
    uint256 public proposalDeposit;
    uint256 public processingReward;
    uint256 public periodDuration;

    mapping(uint256 => Proposal) public proposals;
    mapping(address => Member) public members;
    mapping(address => bool) public isMember;
    mapping(address => uint256) public memberIndexes;

    event SubmitProposal(uint256 proposalId, address proposer);
    event Vote(uint256 proposalId, address voter, bool approve);
    event ProcessProposal(uint256 proposalId, bool didPass);

    modifier onlyMember() {
        require(isMember[msg.sender], ""not a member"");
        _;
    }

    constructor(
        uint256 _votingPeriodLength,
        uint256 _gracePeriodLength,
        uint256 _proposalDeposit,
        uint256 _processingReward,
        uint256 _periodDuration
    ) {
        summoner = msg.sender;
        votingPeriodLength = _votingPeriodLength;
        gracePeriodLength = _gracePeriodLength;
        proposalDeposit = _proposalDeposit;
        processingReward = _processingReward;
        periodDuration = _periodDuration;

        members[summoner] = Member({
            delegateKey: summoner,
            shares: 1,
            exists: true
        });
        isMember[summoner] = true;
        memberIndexes[summoner] = 0;
    }

    function submitProposal(address proposer) external onlyMember {
        proposalCount++;
        uint256 startingPeriod = block.number / periodDuration;

        proposals[proposalCount] = Proposal({
            proposer: proposer,
            startingPeriod: startingPeriod,
            yesVotes: 0,
            noVotes: 0,
            processed: false,
            didPass: false
        });

        emit SubmitProposal(proposalCount, proposer);
    }

    function vote(uint256 proposalId, bool approve) external onlyMember {
        Proposal storage proposal = proposals[proposalId];
        require(proposal.startingPeriod > 0, ""proposal does not exist"");
        require(block.number / periodDuration < proposal.startingPeriod + votingPeriodLength, ""voting period is over"");

        Member storage member = members[msg.sender];
        require(member.delegateKey == msg.sender, ""not delegated"");

        if (approve) {
            proposal.yesVotes += member.shares;
        } else {
            proposal.noVotes += member.shares;
        }

        emit Vote(proposalId, msg.sender, approve);
    }

    function processProposal(uint256 proposalId) external {
        Proposal storage proposal = proposals[proposalId];
        require(!proposal.processed, ""proposal already processed"");
        require(block.number / periodDuration >= proposal.startingPeriod + votingPeriodLength + gracePeriodLength, ""grace period not over"");

        proposal.processed = true;
        proposal.didPass = proposal.yesVotes > proposal.noVotes;

        emit ProcessProposal(proposalId, proposal.didPass);
    }
}",contract_187.sol
"Create a smart contract that allows users to deposit funds, receive marketing and commission rates based on their investment amounts. The contract should keep track of total deposits made by users and allow users to withdraw their funds. Implement a mechanism to calculate contract balance rate, leader bonus rate, and community bonus rate. Define events for deposit creation, withdrawal, and bonus payment. Utilize a safe math library to prevent overflow and underflow issues.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract InvestmentPlatform {
    using SafeMath for uint256;

    struct User {
        uint256 deposit;
        uint256 lastDepositTime;
        uint256 marketingRate;
        uint256 commissionRate;
    }

    mapping(address => User) public users;
    uint256 public totalDeposits;
    uint256 public contractBalanceRate;
    uint256 public leaderBonusRate;
    uint256 public communityBonusRate;

    event DepositCreated(address indexed user, uint256 amount);
    event Withdrawal(address indexed user, uint256 amount);
    event BonusPaid(address indexed user, uint256 amount, string bonusType);

    function deposit() external payable {
        require(msg.value > 0, ""Deposit amount must be greater than zero"");
        User storage user = users[msg.sender];
        user.deposit = user.deposit.add(msg.value);
        user.lastDepositTime = block.timestamp;
        totalDeposits = totalDeposits.add(msg.value);
        updateRates(msg.sender);
        emit DepositCreated(msg.sender, msg.value);
    }

    function withdraw(uint256 amount) external {
        User storage user = users[msg.sender];
        require(amount > 0 && amount <= user.deposit, ""Invalid withdrawal amount"");
        user.deposit = user.deposit.sub(amount);
        totalDeposits = totalDeposits.sub(amount);
        payable(msg.sender).transfer(amount);
        emit Withdrawal(msg.sender, amount);
    }

    function updateRates(address userAddress) internal {
        User storage user = users[userAddress];
        if (user.deposit >= 100 ether) {
            user.marketingRate = 5;
            user.commissionRate = 3;
        } else if (user.deposit >= 50 ether) {
            user.marketingRate = 3;
            user.commissionRate = 2;
        } else {
            user.marketingRate = 1;
            user.commissionRate = 1;
        }
    }

    function calculateContractBalanceRate() public view returns (uint256) {
        return address(this).balance.mul(100).div(totalDeposits);
    }

    function calculateLeaderBonusRate() public view returns (uint256) {
        return calculateContractBalanceRate().mul(2);
    }

    function calculateCommunityBonusRate() public view returns (uint256) {
        return calculateContractBalanceRate().mul(1);
    }

    function payBonus(address userAddress, string memory bonusType) internal {
        User storage user = users[userAddress];
        uint256 bonusAmount;
        if (keccak256(abi.encodePacked(bonusType)) == keccak256(abi.encodePacked(""leader""))) {
            bonusAmount = user.deposit.mul(leaderBonusRate).div(100);
        } else if (keccak256(abi.encodePacked(bonusType)) == keccak256(abi.encodePacked(""community""))) {
            bonusAmount = user.deposit.mul(communityBonusRate).div(100);
        }
        payable(userAddress).transfer(bonusAmount);
        emit BonusPaid(userAddress, bonusAmount, bonusType);
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }
}",contract_188.sol
"Develop a smart contract that allows users to lend and borrow tokens. The contract should provide functionality for depositing and withdrawing tokens, as well as borrowing and repaying loans. Implement a basic interest rate system and manage borrower and lender relationships. Utilize OpenZeppelin's ERC20 and SafeMath libraries to ensure efficiency and reliability. Include simple logic for handling TryAdd, TrySub, TryMul, TryDiv, and TryMod calculations. Focus on creating a functional and secure contract, with documentation and comments to help others understand the code. Consider implementing mechanisms for borrowers to participate in lending pools and for lenders to earn interest and returns.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TokenLending {
    using SafeMath for uint256;

    struct Loan {
        uint256 amount;
        uint256 interestRate;
        uint256 dueDate;
        bool repaid;
    }

    IERC20 public token;
    mapping(address => uint256) public balances;
    mapping(address => Loan) public loans;
    uint256 public totalDeposits;
    uint256 public totalLoans;
    uint256 public constant INTEREST_RATE = 5; // 5% interest rate

    event Deposit(address indexed user, uint256 amount);
    event Withdraw(address indexed user, uint256 amount);
    event Borrow(address indexed user, uint256 amount);
    event Repay(address indexed user, uint256 amount);

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function deposit(uint256 _amount) external {
        require(token.transferFrom(msg.sender, address(this), _amount), ""Transfer failed"");
        balances[msg.sender] = balances[msg.sender].add(_amount);
        totalDeposits = totalDeposits.add(_amount);
        emit Deposit(msg.sender, _amount);
    }

    function withdraw(uint256 _amount) external {
        require(balances[msg.sender] >= _amount, ""Insufficient balance"");
        require(token.transfer(msg.sender, _amount), ""Transfer failed"");
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        totalDeposits = totalDeposits.sub(_amount);
        emit Withdraw(msg.sender, _amount);
    }

    function borrow(uint256 _amount) external {
        require(totalDeposits >= _amount, ""Not enough deposits"");
        require(loans[msg.sender].amount == 0, ""Already borrowed"");
        uint256 interest = _amount.mul(INTEREST_RATE).div(100);
        uint256 totalAmount = _amount.add(interest);
        require(token.transfer(msg.sender, _amount), ""Transfer failed"");
        loans[msg.sender] = Loan({
            amount: _amount,
            interestRate: INTEREST_RATE,
            dueDate: block.timestamp + 30 days,
            repaid: false
        });
        totalLoans = totalLoans.add(totalAmount);
        emit Borrow(msg.sender, _amount);
    }

    function repay() external {
        Loan storage loan = loans[msg.sender];
        require(loan.amount > 0, ""No loan to repay"");
        require(!loan.repaid, ""Loan already repaid"");
        uint256 totalAmount = loan.amount.add(loan.amount.mul(loan.interestRate).div(100));
        require(token.transferFrom(msg.sender, address(this), totalAmount), ""Transfer failed"");
        loan.repaid = true;
        totalLoans = totalLoans.sub(totalAmount);
        emit Repay(msg.sender, totalAmount);
    }
}

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, ""SafeMath: modulo by zero"");
        return a % b;
    }
}",contract_189.sol
"Create a smart contract for a cryptocurrency-based miner engineer game. The contract should allow players to buy and sell engineer characters, buy boosters for mining, and change virus types. The contract should have an interface for mining war games and mini-games. The contract structure should include defining structs for miner and boost data, mapping player information, and implementing functions for buying and selling engineers. Implement the contract functionality by writing Solidity code that mirrors the functionality of the provided code snippet.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MinerEngineerGame {
    struct Engineer {
        uint256 id;
        uint256 efficiency;
        uint256 price;
    }

    struct Booster {
        uint256 id;
        uint256 boostPercentage;
        uint256 price;
    }

    struct Player {
        uint256 balance;
        uint256[] ownedEngineers;
        uint256[] ownedBoosters;
    }

    uint256 public nextEngineerId;
    uint256 public nextBoosterId;
    mapping(uint256 => Engineer) public engineers;
    mapping(uint256 => Booster) public boosters;
    mapping(address => Player) public players;

    event EngineerBought(address indexed player, uint256 engineerId);
    event EngineerSold(address indexed player, uint256 engineerId);
    event BoosterBought(address indexed player, uint256 boosterId);
    event VirusTypeChanged(uint256 newVirusType);

    function buyEngineer(uint256 engineerId) external {
        require(engineers[engineerId].id != 0, ""Engineer does not exist"");
        require(players[msg.sender].balance >= engineers[engineerId].price, ""Insufficient balance"");

        players[msg.sender].balance -= engineers[engineerId].price;
        players[msg.sender].ownedEngineers.push(engineerId);
        emit EngineerBought(msg.sender, engineerId);
    }

    function sellEngineer(uint256 engineerId) external {
        require(engineers[engineerId].id != 0, ""Engineer does not exist"");
        bool isOwned = false;
        for (uint256 i = 0; i < players[msg.sender].ownedEngineers.length; i++) {
            if (players[msg.sender].ownedEngineers[i] == engineerId) {
                isOwned = true;
                delete players[msg.sender].ownedEngineers[i];
                break;
            }
        }
        require(isOwned, ""Engineer not owned by player"");

        players[msg.sender].balance += engineers[engineerId].price;
        emit EngineerSold(msg.sender, engineerId);
    }

    function buyBooster(uint256 boosterId) external {
        require(boosters[boosterId].id != 0, ""Booster does not exist"");
        require(players[msg.sender].balance >= boosters[boosterId].price, ""Insufficient balance"");

        players[msg.sender].balance -= boosters[boosterId].price;
        players[msg.sender].ownedBoosters.push(boosterId);
        emit BoosterBought(msg.sender, boosterId);
    }

    function changeVirusType(uint256 newVirusType) external {
        emit VirusTypeChanged(newVirusType);
    }

    function addEngineer(uint256 efficiency, uint256 price) external {
        engineers[nextEngineerId] = Engineer(nextEngineerId, efficiency, price);
        nextEngineerId++;
    }

    function addBooster(uint256 boostPercentage, uint256 price) external {
        boosters[nextBoosterId] = Booster(nextBoosterId, boostPercentage, price);
        nextBoosterId++;
    }

    function deposit() external payable {
        players[msg.sender].balance += msg.value;
    }
}",contract_190.sol
"Create a Solidity smart contract that extends the provided 'ERC20' contract to implement a basic token. The contract should allow for setting the token name and symbol. Implement functions for minting and burning tokens. Also, add a function to set the allowance for a spender account. Consider implementing a pending transaction signature verification mechanism. Focus on creating a functional smart contract that fulfills the provided contract's requirements.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20 {
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol) {
        name = _name;
        symbol = _symbol;
    }

    function _transfer(address _from, address _to, uint256 _value) internal {
        require(_to != address(0), ""Invalid recipient"");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
    }

    function transfer(address _to, uint256 _value) public returns (bool) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(_value <= allowance[_from][msg.sender], ""Allowance exceeded"");
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}

contract BasicToken is ERC20 {
    address public owner;

    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    function mint(address _to, uint256 _amount) public onlyOwner {
        totalSupply += _amount;
        balanceOf[_to] += _amount;
        emit Transfer(address(0), _to, _amount);
    }

    function burn(uint256 _amount) public {
        require(balanceOf[msg.sender] >= _amount, ""Insufficient balance"");
        totalSupply -= _amount;
        balanceOf[msg.sender] -= _amount;
        emit Transfer(msg.sender, address(0), _amount);
    }

    function setAllowance(address _spender, uint256 _value) public {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
    }
}",contract_191.sol
"Develop a smart contract that facilitates a malt arbitration mechanism with auction features. The contract should allow users to initiate auctions, manage commitments, and allocate arbitrage rewards. Ensure efficient gas management. Implement event emissions for key functionality.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MaltArbitration {
    struct Auction {
        uint256 id;
        uint256 startTime;
        uint256 endTime;
        uint256 commitment;
        address highestBidder;
        uint256 highestBid;
        bool ended;
    }

    Auction[] public auctions;
    mapping(uint256 => mapping(address => uint256)) public bids;
    mapping(address => uint256) public pendingReturns;
    uint256 public auctionCount;

    event AuctionCreated(uint256 auctionId, uint256 startTime, uint256 endTime, uint256 commitment);
    event BidPlaced(uint256 auctionId, address bidder, uint256 amount);
    event AuctionEnded(uint256 auctionId, address winner, uint256 amount);
    event Withdrawal(address bidder, uint256 amount);

    function createAuction(uint256 _commitment, uint256 _duration) public {
        uint256 startTime = block.timestamp;
        uint256 endTime = startTime + _duration;
        uint256 auctionId = auctionCount++;
        auctions.push(Auction({
            id: auctionId,
            startTime: startTime,
            endTime: endTime,
            commitment: _commitment,
            highestBidder: address(0),
            highestBid: 0,
            ended: false
        }));
        emit AuctionCreated(auctionId, startTime, endTime, _commitment);
    }

    function bid(uint256 _auctionId) public payable {
        Auction storage auction = auctions[_auctionId];
        require(block.timestamp >= auction.startTime && block.timestamp <= auction.endTime, ""Auction not active"");
        require(msg.value > auction.highestBid, ""Bid must be higher than current highest bid"");

        if (auction.highestBid != 0) {
            pendingReturns[auction.highestBidder] += auction.highestBid;
        }

        auction.highestBid = msg.value;
        auction.highestBidder = msg.sender;
        bids[_auctionId][msg.sender] = msg.value;
        emit BidPlaced(_auctionId, msg.sender, msg.value);
    }

    function endAuction(uint256 _auctionId) public {
        Auction storage auction = auctions[_auctionId];
        require(block.timestamp >= auction.endTime, ""Auction not yet ended"");
        require(!auction.ended, ""Auction end has already been called"");

        auction.ended = true;
        emit AuctionEnded(_auctionId, auction.highestBidder, auction.highestBid);
    }

    function withdraw() public returns (bool) {
        uint256 amount = pendingReturns[msg.sender];
        if (amount > 0) {
            pendingReturns[msg.sender] = 0;
            (bool success, ) = msg.sender.call{value: amount}("""");
            require(success, ""Transfer failed"");
            emit Withdrawal(msg.sender, amount);
        }
        return true;
    }

    receive() external payable {}
}",contract_192.sol
Create a Solidity smart contract that can be used to mint a limited number of NFTs. The contract should have a way to set the base URI and base extension. It should also allow the owner to set the cost and maximum supply of NFTs. The contract should include a minting function that checks if the total supply is below the maximum supply and if the sender has sufficient Ether to cover the cost. Implement a way to retrieve the token URI using the token ID.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract LimitedNFT {
    string private _baseURI;
    string private _baseExtension;
    uint256 private _cost;
    uint256 private _maxSupply;
    uint256 private _totalSupply;
    address private _owner;

    mapping(uint256 => string) private _tokenURIs;

    event Mint(address indexed to, uint256 tokenId);

    modifier onlyOwner() {
        require(msg.sender == _owner, ""Not the contract owner"");
        _;
    }

    constructor(string memory baseURI, string memory baseExtension, uint256 cost, uint256 maxSupply) {
        _baseURI = baseURI;
        _baseExtension = baseExtension;
        _cost = cost;
        _maxSupply = maxSupply;
        _owner = msg.sender;
    }

    function setBaseURI(string memory baseURI) public onlyOwner {
        _baseURI = baseURI;
    }

    function setBaseExtension(string memory baseExtension) public onlyOwner {
        _baseExtension = baseExtension;
    }

    function setCost(uint256 cost) public onlyOwner {
        _cost = cost;
    }

    function setMaxSupply(uint256 maxSupply) public onlyOwner {
        require(maxSupply >= _totalSupply, ""New max supply must be greater than current total supply"");
        _maxSupply = maxSupply;
    }

    function mint() public payable {
        require(_totalSupply < _maxSupply, ""Max supply reached"");
        require(msg.value >= _cost, ""Insufficient Ether sent"");

        _totalSupply++;
        uint256 tokenId = _totalSupply;
        _tokenURIs[tokenId] = string(abi.encodePacked(_baseURI, toString(tokenId), _baseExtension));

        emit Mint(msg.sender, tokenId);
    }

    function tokenURI(uint256 tokenId) public view returns (string memory) {
        require(tokenId <= _totalSupply && tokenId > 0, ""Token ID does not exist"");
        return _tokenURIs[tokenId];
    }

    function toString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return ""0"";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }
}",contract_193.sol
"Write a smart contract that allows for token swaps and liquidities. The contract should interact with the IERC20, SwapperInterface, and IUniswapV2Router01 interfaces. Make sure to include functions for swapping, adding and removing liquidity, and getting balances and token information.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface IUniswapV2Router01 {
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
}

interface SwapperInterface {
    function swap(address tokenIn, address tokenOut, uint amountIn, uint amountOutMin, address to, uint deadline) external returns (uint amountOut);
}

contract TokenSwapper is SwapperInterface {
    IUniswapV2Router01 public uniswapRouter;

    constructor(address _uniswapRouter) {
        uniswapRouter = IUniswapV2Router01(_uniswapRouter);
    }

    function swap(address tokenIn, address tokenOut, uint amountIn, uint amountOutMin, address to, uint deadline) external override returns (uint amountOut) {
        IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn);
        IERC20(tokenIn).approve(address(uniswapRouter), amountIn);

        address[] memory path = new address[](2);
        path[0] = tokenIn;
        path[1] = tokenOut;

        uint[] memory amounts = uniswapRouter.swapExactTokensForTokens(
            amountIn,
            amountOutMin,
            path,
            to,
            deadline
        );

        return amounts[1];
    }

    function addLiquidity(address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB, uint liquidity) {
        IERC20(tokenA).transferFrom(msg.sender, address(this), amountADesired);
        IERC20(tokenB).transferFrom(msg.sender, address(this), amountBDesired);

        IERC20(tokenA).approve(address(uniswapRouter), amountADesired);
        IERC20(tokenB).approve(address(uniswapRouter), amountBDesired);

        return uniswapRouter.addLiquidity(
            tokenA,
            tokenB,
            amountADesired,
            amountBDesired,
            amountAMin,
            amountBMin,
            to,
            deadline
        );
    }

    function removeLiquidity(address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB) {
        IERC20(tokenA).transferFrom(msg.sender, address(this), liquidity);
        IERC20(tokenA).approve(address(uniswapRouter), liquidity);

        return uniswapRouter.removeLiquidity(
            tokenA,
            tokenB,
            liquidity,
            amountAMin,
            amountBMin,
            to,
            deadline
        );
    }

    function getBalance(address token, address account) external view returns (uint) {
        return IERC20(token).balanceOf(account);
    }

    function getTokenInfo(address token) external view returns (uint totalSupply, uint balance) {
        totalSupply = IERC20(token).totalSupply();
        balance = IERC20(token).balanceOf(msg.sender);
    }
}",contract_194.sol
"Create a basic smart contract for managing digital assets with owner and operator approvals, implementing ERC721 and ERC721Metadata functionality, while allowing for token minting and transferring, with approval and operator approval management.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC721 {
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    function balanceOf(address owner) public view returns (uint256) {
        require(owner != address(0), ""ERC721: balance query for the zero address"");
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) public view returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), ""ERC721: owner query for nonexistent token"");
        return owner;
    }

    function approve(address to, uint256 tokenId) public {
        address owner = ownerOf(tokenId);
        require(to != owner, ""ERC721: approval to current owner"");
        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), ""ERC721: approve caller is not owner nor approved for all"");

        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    function getApproved(uint256 tokenId) public view returns (address) {
        require(_exists(tokenId), ""ERC721: approved query for nonexistent token"");
        return _tokenApprovals[tokenId];
    }

    function setApprovalForAll(address operator, bool approved) public {
        require(operator != msg.sender, ""ERC721: approve to caller"");
        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function isApprovedForAll(address owner, address operator) public view returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function transferFrom(address from, address to, uint256 tokenId) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _transfer(from, to, tokenId);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) public {
        safeTransferFrom(from, to, tokenId, """");
    }

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _safeTransfer(from, to, tokenId, _data);
    }

    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return _owners[tokenId] != address(0);
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    function _safeMint(address to, uint256 tokenId) internal {
        _safeMint(to, tokenId, """");
    }

    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal {
        _mint(to, tokenId);
        require(_checkOnERC721Received(address(0), to, tokenId, _data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _mint(address to, uint256 tokenId) internal {
        require(to != address(0), ""ERC721: mint to the zero address"");
        require(!_exists(tokenId), ""ERC721: token already minted"");

        _beforeTokenTransfer(address(0), to, tokenId);

        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(address(0), to, tokenId);
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        require(ownerOf(tokenId) == from, ""ERC721: transfer of token that is not own"");
        require(to != address(0), ""ERC721: transfer to the zero address"");

        _beforeTokenTransfer(from, to, tokenId);

        _approve(address(0), tokenId);

        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(from, to, tokenId);
    }

    function _approve(address to, uint256 tokenId) internal {
        _tokenApprovals[tokenId] = to;
        emit Approval(ownerOf(tokenId), to, tokenId);
    }

    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) internal returns (bool) {
        if (isContract(to)) {
            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data) returns (bytes4 retval) {
                return retval == IERC721Receiver.onERC721Received.selector;
            } catch (bytes memory reason) {
                if (reason.length == 0) {
                    revert(""ERC721: transfer to non ERC721Receiver implementer"");
                } else {
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        } else {
            return true;
        }
    }

    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal {}
}

interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}

contract ERC721Metadata {
    string private _name;
    string private _symbol;
    mapping(uint256 => string) private _tokenURIs;

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function name() external view returns (string memory) {
        return _name;
    }

    function symbol() external view returns (string memory) {
        return _symbol;
    }

    function tokenURI(uint256 tokenId) external view returns (string memory) {
        require(_exists(tokenId), ""ERC721Metadata: URI query for nonexistent token"");
        return _tokenURIs[tokenId];
    }

    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal {
        require(_exists(tokenId), ""ERC721Metadata: URI set of nonexistent token"");
        _tokenURIs[tokenId] = _tokenURI;
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return ERC721(address(this)).ownerOf(tokenId) != address(0);
    }
}

contract DigitalAssetManager is ERC721, ERC721Metadata {
    constructor(string memory name, string memory symbol) ERC721Metadata(name, symbol) {}

    function mint(address to, uint256 tokenId, string memory tokenURI) public {
        _safeMint(to, tokenId);
        _setTokenURI(tokenId, tokenURI);
    }
}",contract_195.sol
Design a smart contract that manages fee settings for a decentralized platform. The contract should have two main functions: one to set the fee maker's rate and another to set the fee taker's rate. The fees should be represented as uint values and be bounded by a maximum allowed rate. The contract should provide a clean and structured way to manage these settings. Provide a general overview of the contract's architecture and functionality.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract FeeManager {
    uint256 public constant MAX_FEE_RATE = 1000; // Maximum fee rate (1000 = 100%)
    uint256 public feeMakerRate;
    uint256 public feeTakerRate;
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier validFeeRate(uint256 _rate) {
        require(_rate <= MAX_FEE_RATE, ""Fee rate exceeds maximum allowed"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setFeeMakerRate(uint256 _rate) external onlyOwner validFeeRate(_rate) {
        feeMakerRate = _rate;
    }

    function setFeeTakerRate(uint256 _rate) external onlyOwner validFeeRate(_rate) {
        feeTakerRate = _rate;
    }
}",contract_196.sol
"Create a Solidity smart contract for the '10xAmin Token'. The contract should allow for token transfers, approvals, and minting capabilities. Implement the ERC223 and ERC20 standards. Define the token's name, symbol, and decimal places. Include functionality for owner-only access to certain functions and implement modifiers as necessary.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface IERC223 {
    function transfer(address to, uint256 value, bytes memory data) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value, bytes indexed data);
}

contract TenxAminToken is IERC20, IERC223 {
    string public name = ""10xAmin Token"";
    string public symbol = ""10XA"";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    address public owner;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10**uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        owner = msg.sender;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address to, uint256 value) public override returns (bool) {
        _transfer(msg.sender, to, value, """");
        return true;
    }

    function transfer(address to, uint256 value, bytes memory data) public override returns (bool) {
        _transfer(msg.sender, to, value, data);
        return true;
    }

    function _transfer(address from, address to, uint256 value, bytes memory data) internal {
        require(to != address(0), ""Invalid recipient"");
        require(balanceOf[from] >= value, ""Insufficient balance"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        emit Transfer(from, to, value, data);
        if (isContract(to)) {
            _callTokenFallback(from, to, value, data);
        }
    }

    function approve(address spender, uint256 value) public override returns (bool) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        require(allowance[sender][msg.sender] >= amount, ""Allowance too low"");
        allowance[sender][msg.sender] -= amount;
        _transfer(sender, recipient, amount, """");
        return true;
    }

    function mint(address to, uint256 amount) public onlyOwner {
        totalSupply += amount;
        balanceOf[to] += amount;
        emit Transfer(address(0), to, amount);
    }

    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    function _callTokenFallback(address from, address to, uint256 value, bytes memory data) private {
        IERC223Receiver(to).tokenFallback(from, value, data);
    }
}

interface IERC223Receiver {
    function tokenFallback(address from, uint256 value, bytes memory data) external;
}",contract_197.sol
"Create a Solidity smart contract that mimics the Uniswap V2 router functionality. The contract should allow for adding and removing liquidity, swapping tokens, and getting quotes. Implement the most important functions such as addLiquidity and removeLiquidity. Consider the router's interaction with the factory contract, managing the pairs and fee management. Focus on robustness and simplicity, making it easy to understand and maintain. Write a brief description and documentation for each function or variable, making it easy for other developers to use the contract.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

interface IUniswapV2Factory {
    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function createPair(address tokenA, address tokenB) external returns (address pair);
}

interface IUniswapV2Pair {
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function mint(address to) external returns (uint liquidity);
    function burn(address to) external returns (uint amount0, uint amount1);
}

contract UniswapV2Router {
    address public factory;
    address public WETH;

    modifier ensure(uint deadline) {
        require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');
        _;
    }

    constructor(address _factory, address _WETH) {
        factory = _factory;
        WETH = _WETH;
    }

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {
        address pair = IUniswapV2Factory(factory).getPair(tokenA, tokenB);
        if (pair == address(0)) {
            pair = IUniswapV2Factory(factory).createPair(tokenA, tokenB);
        }
        (uint reserveA, uint reserveB) = getReserves(tokenA, tokenB);
        if (reserveA == 0 && reserveB == 0) {
            (amountA, amountB) = (amountADesired, amountBDesired);
        } else {
            uint amountBOptimal = quote(amountADesired, reserveA, reserveB);
            if (amountBOptimal <= amountBDesired) {
                require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');
                (amountA, amountB) = (amountADesired, amountBOptimal);
            } else {
                uint amountAOptimal = quote(amountBDesired, reserveB, reserveA);
                assert(amountAOptimal <= amountADesired);
                require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');
                (amountA, amountB) = (amountAOptimal, amountBDesired);
            }
        }
        IERC20(tokenA).transferFrom(msg.sender, pair, amountA);
        IERC20(tokenB).transferFrom(msg.sender, pair, amountB);
        liquidity = IUniswapV2Pair(pair).mint(to);
    }

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) public ensure(deadline) returns (uint amountA, uint amountB) {
        address pair = IUniswapV2Factory(factory).getPair(tokenA, tokenB);
        IERC20(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair
        (amountA, amountB) = IUniswapV2Pair(pair).burn(to);
        require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');
        require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');
    }

    function quote(uint amountA, uint reserveA, uint reserveB) public pure returns (uint amountB) {
        require(amountA > 0, 'UniswapV2Router: INSUFFICIENT_AMOUNT');
        require(reserveA > 0 && reserveB > 0, 'UniswapV2Router: INSUFFICIENT_LIQUIDITY');
        amountB = amountA * reserveB / reserveA;
    }

    function getReserves(address tokenA, address tokenB) public view returns (uint reserveA, uint reserveB) {
        address pair = IUniswapV2Factory(factory).getPair(tokenA, tokenB);
        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pair).getReserves();
        (reserveA, reserveB) = tokenA < tokenB ? (reserve0, reserve1) : (reserve1, reserve0);
    }
}",contract_198.sol
"Create a smart contract that utilizes the AggregatorV3Interface to retrieve current prices and IERC20 interface for token management. Implement functions for permit, nonce, DOMAIN_SEPARATOR, totalSupply, balanceOf, transfer, allowance, and approve to manage token ownership and transfer. Utilize the SafeERC20 library to ensure secure token transfers. Consider implementing re-entrancy protection and handling potential errors.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface AggregatorV3Interface {
    function latestRoundData() external view returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    );
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

library SafeERC20 {
    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        require(token.transfer(to, value), ""SafeERC20: transfer failed"");
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        require(token.transferFrom(from, to, value), ""SafeERC20: transferFrom failed"");
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        require(token.approve(spender, value), ""SafeERC20: approve failed"");
    }
}

contract MyToken is IERC20 {
    using SafeERC20 for IERC20;

    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 private _totalSupply;
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    mapping(address => uint256) private _nonces;

    bytes32 public DOMAIN_SEPARATOR;
    bytes32 public constant PERMIT_TYPEHASH = keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");

    AggregatorV3Interface public priceFeed;

    constructor(address _priceFeed) {
        priceFeed = AggregatorV3Interface(_priceFeed);
        uint256 chainId;
        assembly {
            chainId := chainid()
        }
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                keccak256(""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""),
                keccak256(bytes(name)),
                keccak256(bytes(""1"")),
                chainId,
                address(this)
            )
        );
    }

    function totalSupply() external view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) external view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) external override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) external view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) external override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {
        require(deadline >= block.timestamp, ""MyToken: EXPIRED"");
        bytes32 digest = keccak256(
            abi.encodePacked(
                ""\x19\x01"",
                DOMAIN_SEPARATOR,
                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _nonces[owner]++, deadline))
            )
        );
        address recoveredAddress = ecrecover(digest, v, r, s);
        require(recoveredAddress != address(0) && recoveredAddress == owner, ""MyToken: INVALID_SIGNATURE"");
        _approve(owner, spender, value);
    }

    function nonce(address owner) external view returns (uint256) {
        return _nonces[owner];
    }

    function getLatestPrice() public view returns (int) {
        (
            uint80 roundID, 
            int price,
            uint startedAt,
            uint timeStamp,
            uint80 answeredInRound
        ) = priceFeed.latestRoundData();
        return price;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""MyToken: transfer from the zero address"");
        require(recipient != address(0), ""MyToken: transfer to the zero address"");

        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""MyToken: approve from the zero address"");
        require(spender != address(0), ""MyToken: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}",contract_199.sol
"Create a smart contract that allows for the creation of a KoalaToken. The token should be mintable with a maximum total supply of 400 million tokens. Implement a mint function that allows authorized addresses to mint new tokens to a specified recipient address. Ensure that the contract checks for invalid recipient addresses and excess token minting. For development, utilize the provided ERC20 contract as a base and build upon its functionality.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20 {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        _transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], ""Insufficient balance"");
        require(_value <= allowance[_from][msg.sender], ""Allowance exceeded"");
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    function _transfer(address _from, address _to, uint256 _value) internal {
        require(_to != address(0), ""Invalid recipient address"");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
    }
}

contract KoalaToken is ERC20 {
    address public owner;
    uint256 public constant MAX_SUPPLY = 400000000 * 10**18;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor() ERC20(""KoalaToken"", ""KOALA"", 18) {
        owner = msg.sender;
    }

    function mint(address _to, uint256 _value) public onlyOwner returns (bool success) {
        require(_to != address(0), ""Invalid recipient address"");
        require(totalSupply + _value <= MAX_SUPPLY, ""Exceeds maximum supply"");
        totalSupply += _value;
        balanceOf[_to] += _value;
        emit Transfer(address(0), _to, _value);
        return true;
    }
}",contract_200.sol
"Create a smart contract that mimics the functionality of the provided TriggerOrderManager contract. The contract should have functions for setting the router, triggering positions, canceling trigger orders, and executing trigger orders. Include events for when the router is set or trigger orders are executed. The contract should also have modifiers for restricting access to certain functions. Focus on creating a clean and readable code structure.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TriggerOrderManager {
    address public router;
    address public owner;

    enum OrderStatus { Pending, Executed, Canceled }

    struct TriggerOrder {
        uint256 id;
        address trader;
        bytes orderData;
        OrderStatus status;
    }

    TriggerOrder[] public triggerOrders;
    mapping(uint256 => bool) public orderExists;

    event RouterSet(address indexed router);
    event TriggerOrderExecuted(uint256 indexed orderId, address indexed trader);
    event TriggerOrderCanceled(uint256 indexed orderId, address indexed trader);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the owner"");
        _;
    }

    modifier onlyRouter() {
        require(msg.sender == router, ""Not the router"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setRouter(address _router) external onlyOwner {
        router = _router;
        emit RouterSet(_router);
    }

    function createTriggerOrder(bytes memory _orderData) external {
        uint256 orderId = triggerOrders.length;
        triggerOrders.push(TriggerOrder({
            id: orderId,
            trader: msg.sender,
            orderData: _orderData,
            status: OrderStatus.Pending
        }));
        orderExists[orderId] = true;
    }

    function executeTriggerOrder(uint256 _orderId) external onlyRouter {
        require(orderExists[_orderId], ""Order does not exist"");
        TriggerOrder storage order = triggerOrders[_orderId];
        require(order.status == OrderStatus.Pending, ""Order not pending"");
        order.status = OrderStatus.Executed;
        emit TriggerOrderExecuted(_orderId, order.trader);
    }

    function cancelTriggerOrder(uint256 _orderId) external {
        require(orderExists[_orderId], ""Order does not exist"");
        TriggerOrder storage order = triggerOrders[_orderId];
        require(order.trader == msg.sender, ""Not the trader"");
        require(order.status == OrderStatus.Pending, ""Order not pending"");
        order.status = OrderStatus.Canceled;
        emit TriggerOrderCanceled(_orderId, order.trader);
    }
}",contract_201.sol
"Create a token smart contract that allows the owner to transfer ownership to another address. The contract should include functions to mint and burn tokens. Ensure that the total supply of tokens does not exceed 100 million. Utilize the OpenZeppelin's SafeMath library to prevent arithmetic overflow. Define the token's total supply, balance, and allowance functions using the IERC20 interface. Implement a transfer function that logs the transfer event.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MyToken {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    address public owner;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor(uint256 initialSupply) {
        owner = msg.sender;
        _mint(msg.sender, initialSupply);
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""New owner is the zero address"");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }

    function _mint(address to, uint256 value) internal {
        require(totalSupply + value <= 100000000 * (10 ** uint256(decimals)), ""Total supply exceeds limit"");
        totalSupply += value;
        balanceOf[to] += value;
        emit Transfer(address(0), to, value);
    }

    function mint(address to, uint256 value) public onlyOwner {
        _mint(to, value);
    }

    function burn(uint256 value) public {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        totalSupply -= value;
        balanceOf[msg.sender] -= value;
        emit Transfer(msg.sender, address(0), value);
    }

    function transfer(address to, uint256 value) public returns (bool) {
        require(to != address(0), ""Transfer to the zero address"");
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        require(to != address(0), ""Transfer to the zero address"");
        require(balanceOf[from] >= value, ""Insufficient balance"");
        require(allowance[from][msg.sender] >= value, ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }
}",contract_202.sol
"Create a smart contract in Solidity that implements the ERC-20 token standard for the Voken token, utilizing the SafeMath library for basic arithmetic operations. Ensure the contract includes necessary functions for minting, transferring, and approving token transfers. Don't forget to implement necessary security measures and logging for debugging purposes.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract VokenToken {
    string public name = ""Voken"";
    string public symbol = ""VKN"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Mint(address indexed to, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }

    function mint(address to, uint256 value) public returns (bool success) {
        totalSupply += value;
        balanceOf[to] += value;
        emit Mint(to, value);
        emit Transfer(address(0), to, value);
        return true;
    }
}",contract_203.sol
"Create a token contract that follows the ERC-20 standard. The contract should allow for token transfer, approval, and allowance management. It should have a total supply limit of 1,000,000 tokens. Implement a constructor function for the contract. Include functions for increase and decrease in allowance, token transfer, approval, transfer from, and burn. Use the ERC20 interface as a reference.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply = 1000000 * 10 ** uint256(decimals);

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        balanceOf[msg.sender] = totalSupply;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool success) {
        allowance[msg.sender][spender] += addedValue;
        emit Approval(msg.sender, spender, allowance[msg.sender][spender]);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool success) {
        require(allowance[msg.sender][spender] >= subtractedValue, ""Allowance below zero"");
        allowance[msg.sender][spender] -= subtractedValue;
        emit Approval(msg.sender, spender, allowance[msg.sender][spender]);
        return true;
    }

    function burn(uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        totalSupply -= value;
        emit Transfer(msg.sender, address(0), value);
        return true;
    }
}",contract_204.sol
"Develop a smart contract that allows users to request and fulfill healing requests, implementing a pending heal system, managing token IDs, and utilizing Chainlink VRF for random number generation. Consider pausing/unpausing the contract and maintaining upgradeability. Ensure smart contract logic is reasonable and efficient.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface VRFCoordinatorV2Interface {
    function requestRandomWords(
        bytes32 keyHash,
        uint64 subId,
        uint16 minimumRequestConfirmations,
        uint32 callbackGasLimit,
        uint32 numWords
    ) external returns (uint256 requestId);
}

contract HealingRequest {
    VRFCoordinatorV2Interface immutable vrfCoordinator;
    bytes32 immutable keyHash;
    uint64 immutable subId;
    uint16 constant minimumRequestConfirmations = 3;
    uint32 constant callbackGasLimit = 100000;
    uint32 constant numWords = 1;

    enum Status { Pending, Fulfilled, Cancelled }

    struct Request {
        address requester;
        uint256 tokenId;
        Status status;
        uint256 randomResult;
    }

    Request[] public requests;
    mapping(uint256 => uint256) public requestIdToIndex;
    address public owner;
    bool public paused;

    event RequestCreated(uint256 indexed requestId, address indexed requester, uint256 tokenId);
    event RequestFulfilled(uint256 indexed requestId, uint256 randomResult);
    event RequestCancelled(uint256 indexed requestId);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    constructor(address _vrfCoordinator, bytes32 _keyHash, uint64 _subId) {
        vrfCoordinator = VRFCoordinatorV2Interface(_vrfCoordinator);
        keyHash = _keyHash;
        subId = _subId;
        owner = msg.sender;
    }

    function pause() external onlyOwner {
        paused = true;
    }

    function unpause() external onlyOwner {
        paused = false;
    }

    function createRequest(uint256 tokenId) external whenNotPaused returns (uint256) {
        uint256 requestId = requests.length;
        requests.push(Request({
            requester: msg.sender,
            tokenId: tokenId,
            status: Status.Pending,
            randomResult: 0
        }));
        requestIdToIndex[requestId] = requestId;
        emit RequestCreated(requestId, msg.sender, tokenId);
        return requestId;
    }

    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal {
        require(requestId < requests.length, ""Invalid request ID"");
        Request storage request = requests[requestId];
        require(request.status == Status.Pending, ""Request is not pending"");
        request.randomResult = randomWords[0];
        request.status = Status.Fulfilled;
        emit RequestFulfilled(requestId, randomWords[0]);
    }

    function cancelRequest(uint256 requestId) external onlyOwner {
        require(requestId < requests.length, ""Invalid request ID"");
        Request storage request = requests[requestId];
        require(request.status == Status.Pending, ""Request is not pending"");
        request.status = Status.Cancelled;
        emit RequestCancelled(requestId);
    }

    function requestRandomness() external onlyOwner returns (uint256) {
        return vrfCoordinator.requestRandomWords(
            keyHash,
            subId,
            minimumRequestConfirmations,
            callbackGasLimit,
            numWords
        );
    }
}",contract_205.sol
Create a smart contract that utilizes the SafeMath library to perform arithmetic operations with safety checks. Implement a function that checks if an address is a contract or not using the Address library. Include a function that sends Ether to a specified recipient. Ensure the contract includes error handling and documentation explaining the logic behind the contract functions.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }
}

contract Address {
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }
}

contract SafeOperations is SafeMath, Address {
    function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {
        return add(a, b);
    }

    function safeSub(uint256 a, uint256 b) public pure returns (uint256) {
        return sub(a, b);
    }

    function safeMul(uint256 a, uint256 b) public pure returns (uint256) {
        return mul(a, b);
    }

    function safeDiv(uint256 a, uint256 b) public pure returns (uint256) {
        return div(a, b);
    }

    function checkContract(address account) public view returns (bool) {
        return isContract(account);
    }

    function sendEther(address payable recipient) public payable {
        require(recipient != address(0), ""Invalid recipient address"");
        require(msg.value > 0, ""Ether amount must be greater than zero"");
        recipient.transfer(msg.value);
    }
}
```

This contract includes the SafeMath library for safe arithmetic operations and the Address library to check if an address is a contract. It provides functions for safe addition, subtraction, multiplication, and division, as well as a function to check if an address is a contract. Additionally, it includes a function to send Ether to a specified recipient with appropriate error handling.",contract_206.sol
"Create a token distribution smart contract that uses the provided SafeMath library for arithmetic operations. Include functions for token transfer, balance retrieval, allowance setting, and approval. Initialize the token supply and set the token wallet in the constructor.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TokenDistribution {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    address public owner;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        owner = msg.sender;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }
}",contract_207.sol
"Create a smart contract that can encode and decode Leb128 integers. The contract should have methods for encoding and decoding unsigned integers with Leb128. The encoding methods should take uint64 values as input and output the encoded byte arrays. The decoding methods should take encoded byte arrays as input and output the decoded uint64 values. Use the Buffer library to implement the Leb128 encoding and decoding logic, ensuring accurate results.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Leb128 {
    function encodeUnsignedLeb128(uint64 value) public pure returns (bytes memory) {
        bytes memory buffer = new bytes(10);
        uint index = 0;
        while (true) {
            uint8 byte = uint8(value & 0x7F);
            value >>= 7;
            if (value != 0) {
                buffer[index++] = bytes1(byte | 0x80);
            } else {
                buffer[index++] = bytes1(byte);
                break;
            }
        }
        bytes memory result = new bytes(index);
        for (uint i = 0; i < index; i++) {
            result[i] = buffer[i];
        }
        return result;
    }

    function decodeUnsignedLeb128(bytes memory data) public pure returns (uint64) {
        uint64 result = 0;
        uint64 shift = 0;
        for (uint i = 0; i < data.length; i++) {
            uint8 byte = uint8(data[i]);
            result |= uint64(byte & 0x7F) << shift;
            if ((byte & 0x80) == 0) {
                break;
            }
            shift += 7;
        }
        return result;
    }
}",contract_208.sol
"Develop a smart contract that enables management of item sets with varying rarity. The contract should permit registering and deregistering items, and provide functionality to retrieve item sets based on set ID, rarity, and the list of all sets. Follow the existing code structure and logic, making necessary adjustments to complete the implementation.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ItemSetManager {
    struct ItemSet {
        uint256 setId;
        string name;
        string rarity;
        bool registered;
    }

    mapping(uint256 => ItemSet) private itemSets;
    uint256 private nextSetId;

    event ItemSetRegistered(uint256 indexed setId, string name, string rarity);
    event ItemSetDeregistered(uint256 indexed setId);

    function registerItemSet(string memory name, string memory rarity) public {
        uint256 setId = nextSetId++;
        itemSets[setId] = ItemSet(setId, name, rarity, true);
        emit ItemSetRegistered(setId, name, rarity);
    }

    function deregisterItemSet(uint256 setId) public {
        require(itemSets[setId].registered, ""Item set not found"");
        itemSets[setId].registered = false;
        emit ItemSetDeregistered(setId);
    }

    function getItemSetById(uint256 setId) public view returns (ItemSet memory) {
        require(itemSets[setId].registered, ""Item set not found"");
        return itemSets[setId];
    }

    function getItemSetsByRarity(string memory rarity) public view returns (ItemSet[] memory) {
        uint256 count = 0;
        for (uint256 i = 0; i < nextSetId; i++) {
            if (itemSets[i].registered && keccak256(abi.encodePacked(itemSets[i].rarity)) == keccak256(abi.encodePacked(rarity))) {
                count++;
            }
        }

        ItemSet[] memory sets = new ItemSet[](count);
        uint256 index = 0;
        for (uint256 i = 0; i < nextSetId; i++) {
            if (itemSets[i].registered && keccak256(abi.encodePacked(itemSets[i].rarity)) == keccak256(abi.encodePacked(rarity))) {
                sets[index] = itemSets[i];
                index++;
            }
        }
        return sets;
    }

    function getAllItemSets() public view returns (ItemSet[] memory) {
        uint256 count = 0;
        for (uint256 i = 0; i < nextSetId; i++) {
            if (itemSets[i].registered) {
                count++;
            }
        }

        ItemSet[] memory sets = new ItemSet[](count);
        uint256 index = 0;
        for (uint256 i = 0; i < nextSetId; i++) {
            if (itemSets[i].registered) {
                sets[index] = itemSets[i];
                index++;
            }
        }
        return sets;
    }
}",contract_209.sol
"Create a smart contract that represents a token, enabling users to transfer tokens, freeze/unfreeze accounts, and manage token supply. The contract should include functions for calculating total supply, checking account balances, and managing allowances. Include modifiers to restrict access to certain functions, such as pausing/unpausing token transfers. Ensure the contract is secure, with error handling for invalid mathematical operations, and includes necessary events for auditing and tracking changes.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    address public owner;
    bool public paused;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    mapping(address => bool) public frozenAccounts;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Freeze(address indexed target, bool frozen);
    event Pause(bool paused);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Token transfers are paused"");
        _;
    }

    modifier whenPaused() {
        require(paused, ""Token transfers are not paused"");
        _;
    }

    constructor(uint256 initialSupply) {
        owner = msg.sender;
        mint(owner, initialSupply);
    }

    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {
        require(!frozenAccounts[msg.sender], ""Sender account is frozen"");
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {
        require(!frozenAccounts[from], ""Sender account is frozen"");
        require(balanceOf[from] >= value, ""Insufficient balance"");
        require(allowance[from][msg.sender] >= value, ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }

    function mint(address to, uint256 value) public onlyOwner returns (bool) {
        totalSupply += value;
        balanceOf[to] += value;
        emit Transfer(address(0), to, value);
        return true;
    }

    function burn(uint256 value) public returns (bool) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        totalSupply -= value;
        balanceOf[msg.sender] -= value;
        emit Transfer(msg.sender, address(0), value);
        return true;
    }

    function freezeAccount(address target, bool freeze) public onlyOwner {
        frozenAccounts[target] = freeze;
        emit Freeze(target, freeze);
    }

    function pause() public onlyOwner whenNotPaused {
        paused = true;
        emit Pause(paused);
    }

    function unpause() public onlyOwner whenPaused {
        paused = false;
        emit Pause(paused);
    }
}",contract_210.sol
"Develop a smart contract that allows users to participate in a node-staking system. The contract should manage node settings, user data, and rewards. Include functions for initializing node settings, retrieving general node data, and claiming rewards. Implement basic smart contract features such as modifiers and inheritance. Integrate the contract with external services like UniswapV2Router02.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IUniswapV2Router02 {
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
}

contract NodeStaking {
    struct Node {
        uint256 stakeAmount;
        uint256 rewardRate;
        bool isActive;
    }

    struct User {
        uint256 stakedAmount;
        uint256 lastClaimTime;
    }

    address public owner;
    Node public node;
    mapping(address => User) public users;
    IUniswapV2Router02 public uniswapRouter;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor(address _uniswapRouter) {
        owner = msg.sender;
        uniswapRouter = IUniswapV2Router02(_uniswapRouter);
    }

    function initializeNode(uint256 _stakeAmount, uint256 _rewardRate) external onlyOwner {
        node = Node({
            stakeAmount: _stakeAmount,
            rewardRate: _rewardRate,
            isActive: true
        });
    }

    function stake(uint256 amount) external {
        require(node.isActive, ""Node is not active"");
        require(amount >= node.stakeAmount, ""Insufficient stake amount"");

        User storage user = users[msg.sender];
        user.stakedAmount += amount;
        user.lastClaimTime = block.timestamp;
    }

    function claimRewards() external {
        User storage user = users[msg.sender];
        require(user.stakedAmount > 0, ""No staked amount"");

        uint256 timeSinceLastClaim = block.timestamp - user.lastClaimTime;
        uint256 rewards = (user.stakedAmount * node.rewardRate * timeSinceLastClaim) / 1 days;

        user.lastClaimTime = block.timestamp;

        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = msg.sender;

        uniswapRouter.swapExactTokensForTokens(
            rewards,
            0,
            path,
            msg.sender,
            block.timestamp + 15 minutes
        );
    }

    function getNodeData() external view returns (uint256, uint256, bool) {
        return (node.stakeAmount, node.rewardRate, node.isActive);
    }
}",contract_211.sol
"Create a Solidity smart contract that allows for the creation, transfer, and management of tokens. The contract should include functions for basic token operations such as totalSupply(), balanceOf(), transfer(), and allowance(). The contract should also include a constructor that allows for the initialization of the token's name, symbol, and decimal places. Include a method to mint new tokens and a method to burn existing tokens.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Mint(address indexed to, uint256 value);
    event Burn(address indexed from, uint256 value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _initialSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _initialSupply * 10 ** uint256(_decimals);
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value, ""Insufficient balance"");
        require(allowance[_from][msg.sender] >= _value, ""Allowance too low"");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    function mint(address _to, uint256 _value) public returns (bool success) {
        totalSupply += _value;
        balanceOf[_to] += _value;
        emit Mint(_to, _value);
        emit Transfer(address(0), _to, _value);
        return true;
    }

    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        totalSupply -= _value;
        balanceOf[msg.sender] -= _value;
        emit Burn(msg.sender, _value);
        emit Transfer(msg.sender, address(0), _value);
        return true;
    }
}",contract_212.sol
"Develop a smart contract that has two functions: 'f' and 'g'. Function 'f' should accept three parameters: a bytes array, a bytes calldata, and a uint array. It should return six values. Function 'g' should call function 'f' with predefined input. Explain the basic logic and structure of the contract without delving into minute technical details.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MyContract {
    function f(bytes memory param1, bytes calldata param2, uint[] memory param3) public pure returns (uint, uint, uint, uint, uint, uint) {
        uint sum = 0;
        for (uint i = 0; i < param3.length; i++) {
            sum += param3[i];
        }
        return (param1.length, param2.length, param3.length, sum, 0, 0);
    }

    function g() public pure returns (uint, uint, uint, uint, uint, uint) {
        bytes memory predefinedBytes = hex""00010203"";
        bytes memory predefinedBytesCalldata = hex""04050607"";
        uint[] memory predefinedUintArray = new uint[](3);
        predefinedUintArray[0] = 1;
        predefinedUintArray[1] = 2;
        predefinedUintArray[2] = 3;
        return f(predefinedBytes, predefinedBytesCalldata, predefinedUintArray);
    }
}",contract_213.sol
"Create a smart contract that allows for ownership transfer, allowing either direct transfer to a new address or pending transfer followed by a claim by the new owner. Implement inheritance from the Ownable contract, with a constructor that sets the owner to the message sender. Include a function for transferring ownership, using either direct transfer or pending transfer. Ensure that the owner function can only be called by the current owner. Include modifier onlyOwner that checks the sender for the current owner.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Ownable {
    address public owner;
    address public pendingOwner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event OwnershipTransferPending(address indexed currentOwner, address indexed pendingOwner);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Ownable: caller is not the owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
        emit OwnershipTransferred(address(0), owner);
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferPending(owner, newOwner);
        pendingOwner = newOwner;
    }

    function claimOwnership() public {
        require(msg.sender == pendingOwner, ""Ownable: caller is not the pending owner"");
        emit OwnershipTransferred(owner, pendingOwner);
        owner = pendingOwner;
        pendingOwner = address(0);
    }
}",contract_214.sol
"Create an ERC1155-compliant token standard that allows for flexible token management. The contract should enable token transfers, balance inquiries, and operator approval management. Implement the necessary functions, such as balanceOf, balanceOfBatch, setApprovalForAll, isApprovedForAll, safeTransferFrom, and safeBatchTransferFrom. Consider using mapping data structures to efficiently manage token balances and operator approvals. Write clear, concise documentation explaining the contract's functionality and technical implementation.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC1155 {
    // Mapping from account to operator approvals
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    // Mapping from account to token IDs to balances
    mapping(address => mapping(uint256 => uint256)) private _balances;

    // Event emitted when tokens are transferred
    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);

    // Event emitted when a batch of tokens are transferred
    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);

    // Event emitted when an operator is approved or disapproved
    event ApprovalForAll(address indexed account, address indexed operator, bool approved);

    /**
     * @dev Returns the balance of a specific token ID for a given account.
     * @param account The address of the account to query.
     * @param id The token ID to query.
     * @return The balance of the specified token ID for the account.
     */
    function balanceOf(address account, uint256 id) public view returns (uint256) {
        require(account != address(0), ""ERC1155: balance query for the zero address"");
        return _balances[account][id];
    }

    /**
     * @dev Returns the balances of multiple token IDs for a given account.
     * @param accounts The addresses of the accounts to query.
     * @param ids The token IDs to query.
     * @return A list of balances corresponding to the input accounts and token IDs.
     */
    function balanceOfBatch(address[] memory accounts, uint256[] memory ids) public view returns (uint256[] memory) {
        require(accounts.length == ids.length, ""ERC1155: accounts and IDs length mismatch"");

        uint256[] memory batchBalances = new uint256[](accounts.length);

        for (uint256 i = 0; i < accounts.length; ++i) {
            batchBalances[i] = balanceOf(accounts[i], ids[i]);
        }

        return batchBalances;
    }

    /**
     * @dev Approves or disapproves an operator for all tokens of a specific account.
     * @param operator The address of the operator.
     * @param approved True if the operator is approved, false to revoke approval.
     */
    function setApprovalForAll(address operator, bool approved) public {
        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    /**
     * @dev Returns whether an operator is approved for all tokens of a specific account.
     * @param account The address of the account.
     * @param operator The address of the operator.
     * @return True if the operator is approved, false otherwise.
     */
    function isApprovedForAll(address account, address operator) public view returns (bool) {
        return _operatorApprovals[account][operator];
    }

    /**
     * @dev Safely transfers tokens from one address to another.
     * @param from The address to transfer tokens from.
     * @param to The address to transfer tokens to.
     * @param id The token ID to transfer.
     * @param value The amount of tokens to transfer.
     * @param data Additional data with no specified format.
     */
    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) public {
        require(from == msg.sender || isApprovedForAll(from, msg.sender), ""ERC1155: caller is not owner nor approved"");
        require(to != address(0), ""ERC1155: transfer to the zero address"");

        _balances[from][id] -= value;
        _balances[to][id] += value;

        emit TransferSingle(msg.sender, from, to, id, value);

        _doSafeTransferAcceptanceCheck(msg.sender, from, to, id, value, data);
    }

    /**
     * @dev Safely transfers a batch of tokens from one address to another.
     * @param from The address to transfer tokens from.
     * @param to The address to transfer tokens to.
     * @param ids The token IDs to transfer.
     * @param values The amounts of tokens to transfer.
     * @param data Additional data with no specified format.
     */
    function safeBatchTransferFrom(address from, address to, uint256[] memory ids, uint256[] memory values, bytes memory data) public {
        require(from == msg.sender || isApprovedForAll(from, msg.sender), ""ERC1155: caller is not owner nor approved"");
        require(to != address(0), ""ERC1155: transfer to the zero address"");
        require(ids.length == values.length, ""ERC1155: ids and values length mismatch"");

        for (uint256 i = 0; i < ids.length; ++i) {
            uint256 id = ids[i];
            uint256 value = values[i];

            _balances[from][id] -= value;
            _balances[to][id] += value;
        }

        emit TransferBatch(msg.sender, from, to, ids, values);

        _doSafeBatchTransferAcceptanceCheck(msg.sender, from, to, ids, values, data);
    }

    /**
     * @dev Internal function to perform safe transfer acceptance check.
     * @param operator The address of the operator.
     * @param from The address to transfer tokens from.
     * @param to The address to transfer tokens to.
     * @param id The token ID to transfer.
     * @param value The amount of tokens to transfer.
     * @param data Additional data with no specified format.
     */
    function _doSafeTransferAcceptanceCheck(address operator, address from, address to, uint256 id, uint256 value, bytes memory data) private {
        if (to.code.length > 0) {
            try IERC1155Receiver(to).onERC1155Received(operator, from, id, value, data) returns (bytes4 response) {
                if (response != IERC1155Receiver.onERC1155Received.selector) {
                    revert(""ERC1155: ERC1155Receiver rejected tokens"");
                }
            } catch Error(string memory reason) {
                revert(reason);
            } catch {
                revert(""ERC1155: transfer to non ERC1155Receiver implementer"");
            }
        }
    }

    /**
     * @dev Internal function to perform safe batch transfer acceptance check.
     * @param operator The address of the operator.
     * @param from The address to transfer tokens from.
     * @param to The address to transfer tokens to.
     * @param ids The token IDs to transfer.
     * @param values The amounts of tokens to transfer.
     * @param data Additional data with no specified format.
     */
    function _doSafeBatchTransferAcceptanceCheck(address operator, address from, address to, uint256[] memory ids, uint256[] memory values, bytes memory data) private {
        if (to.code.length > 0) {
            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, values, data) returns (bytes4 response) {
                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {
                    revert(""ERC1155: ERC1155Receiver rejected tokens"");
                }
            } catch Error(string memory reason) {
                revert(reason);
            } catch {
                revert(""ERC1155: transfer to non ERC1155Receiver implementer"");
            }
        }
    }
}

interface IERC1155Receiver {
    function onERC1155Received(address operator, address from, uint256 id, uint256 value, bytes calldata data) external returns (bytes4);
    function onERC1155BatchReceived(address operator, address from, uint256[] calldata ids, uint256[] calldata values, bytes calldata data) external returns (bytes4);
}",contract_215.sol
"Design a smart contract that complies with the ERC20 standard, focusing on token transfer, approval, and ownership management. Implement a token supply of 1,000,000, with half of the initial distribution going to the owner and the remaining half to a reserve address. Use the SafeMath library for arithmetical operations. Concentrate on creating secure and well-maintained code. Note that this prompt is designed for users with some knowledge of smart contract development and programming languages like Solidity.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    address public owner;
    address public reserve;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor(address _reserve) {
        owner = msg.sender;
        reserve = _reserve;
        totalSupply = 1000000 * (10 ** uint256(decimals));
        balanceOf[owner] = totalSupply / 2;
        balanceOf[reserve] = totalSupply / 2;
        emit Transfer(address(0), owner, totalSupply / 2);
        emit Transfer(address(0), reserve, totalSupply / 2);
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], ""Insufficient balance"");
        require(_value <= allowance[_from][msg.sender], ""Allowance exceeded"");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""Invalid address"");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}",contract_216.sol
"Create a smart contract that represents a token, allowing users to transfer tokens between accounts. Implement functions for sending, approving, and burning tokens. Use a constructor to initialize the total token supply and distribute the initial tokens to the contract creator. Consider implementing reentrancy protection and ensuring accurate token balance updates.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Burn(address indexed from, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address to, uint256 value) external returns (bool) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        _transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) external returns (bool) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) external returns (bool) {
        require(balanceOf[from] >= value, ""Insufficient balance"");
        require(allowance[from][msg.sender] >= value, ""Allowance exceeded"");
        allowance[from][msg.sender] -= value;
        _transfer(from, to, value);
        return true;
    }

    function burn(uint256 value) external returns (bool) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        totalSupply -= value;
        emit Burn(msg.sender, value);
        emit Transfer(msg.sender, address(0), value);
        return true;
    }

    function _transfer(address from, address to, uint256 value) internal {
        balanceOf[from] -= value;
        balanceOf[to] += value;
        emit Transfer(from, to, value);
    }
}",contract_217.sol
"Create a smart contract that implements an ERC-20 token. The contract should have the ability to transfer tokens between addresses, allow for token approvals, and have events for token transfers and approvals. The contract should also have a total supply of 1,156,789,000 tokens and a fixed precision of 18 decimals.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply = 1156789000 * 10 ** uint256(decimals);

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        balanceOf[msg.sender] = totalSupply;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }
}",contract_218.sol
"Create a smart contract that resembles a standard token (ERC20) and has functions for transferring tokens, approving token spending, and getting the token balance. It should also have customizable name, symbol, and supply. Make sure to include logic for token allowance and return values.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract StandardToken {
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint256 _initialSupply) {
        name = _name;
        symbol = _symbol;
        totalSupply = _initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        _transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], ""Insufficient balance"");
        require(_value <= allowance[_from][msg.sender], ""Allowance exceeded"");
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    function _transfer(address _from, address _to, uint256 _value) internal {
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
    }
}",contract_219.sol
"Create a Solidity smart contract that allows users to query external APIs using the Oraclize API. The contract should include functions for querying data, managing network connections, and handling gas limits. The contract should support querying data using different timestamps, data sources, and query limits. Make sure to include error handling and customizable gas prices.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract OraclizeAPI {
    address public owner;
    uint256 public queryCount;

    struct Query {
        string dataSource;
        string query;
        uint256 timestamp;
        uint256 gasLimit;
        uint256 gasPrice;
    }

    mapping(uint256 => Query) public queries;

    event QueryResult(uint256 indexed queryId, string result);
    event QueryError(uint256 indexed queryId, string error);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function queryData(
        string memory _dataSource,
        string memory _query,
        uint256 _timestamp,
        uint256 _gasLimit,
        uint256 _gasPrice
    ) public payable onlyOwner returns (uint256) {
        require(msg.value >= _gasPrice * _gasLimit, ""Insufficient funds for gas"");

        queryCount++;
        queries[queryCount] = Query({
            dataSource: _dataSource,
            query: _query,
            timestamp: _timestamp,
            gasLimit: _gasLimit,
            gasPrice: _gasPrice
        });

        // Simulate querying external API
        string memory result = simulateQuery(_dataSource, _query, _timestamp);

        if (bytes(result).length > 0) {
            emit QueryResult(queryCount, result);
        } else {
            emit QueryError(queryCount, ""No result or error occurred"");
        }

        return queryCount;
    }

    function simulateQuery(
        string memory _dataSource,
        string memory _query,
        uint256 _timestamp
    ) internal pure returns (string memory) {
        // Simulate the result of an external API query
        return ""Sample API result"";
    }

    function withdraw() public onlyOwner {
        payable(owner).transfer(address(this).balance);
    }
}",contract_220.sol
"Design a smart contract for a custom token that can be minted, transferred, and burned. The contract should allow users to set a name and symbol for the token and implement basic token functionality, such as approval and allowance management. Include event logging for critical operations.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract CustomToken {
    string private _name;
    string private _symbol;
    uint8 private _decimals;
    uint256 private _totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Mint(address indexed to, uint256 value);
    event Burn(address indexed from, uint256 value);

    constructor(string memory name_, string memory symbol_, uint8 decimals_) {
        _name = name_;
        _symbol = symbol_;
        _decimals = decimals_;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);
        return true;
    }

    function mint(address account, uint256 amount) public {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _totalSupply += amount;
        _balances[account] += amount;
        emit Mint(account, amount);
        emit Transfer(address(0), account, amount);
    }

    function burn(uint256 amount) public {
        _burn(msg.sender, amount);
    }

    function burnFrom(address account, uint256 amount) public {
        _approve(account, msg.sender, _allowances[account][msg.sender] - amount);
        _burn(account, amount);
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _burn(address account, uint256 amount) internal {
        require(account != address(0), ""ERC20: burn from the zero address"");

        _balances[account] -= amount;
        _totalSupply -= amount;
        emit Burn(account, amount);
        emit Transfer(account, address(0), amount);
    }
}",contract_221.sol
"Create a smart contract that allows for the transfer of tokens between addresses, including the option to approve spending by other contracts. The contract should include functions to set the token name, symbol, and owner, as well as methods for transferring tokens, approving spending, and minting new tokens. Focus on the functional aspects of the contract, ensuring that tokens can be transferred and balances updated correctly.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    string private _name;
    string private _symbol;
    uint256 private _totalSupply;
    address private _owner;
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    modifier onlyOwner() {
        require(msg.sender == _owner, ""Not the contract owner"");
        _;
    }

    constructor() {
        _owner = msg.sender;
    }

    function setTokenDetails(string memory name_, string memory symbol_) public onlyOwner {
        _name = name_;
        _symbol = symbol_;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        require(_balances[msg.sender] >= amount, ""Insufficient balance"");
        _balances[msg.sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        require(_balances[sender] >= amount, ""Insufficient balance"");
        require(_allowances[sender][msg.sender] >= amount, ""Allowance exceeds amount"");
        _balances[sender] -= amount;
        _balances[recipient] += amount;
        _allowances[sender][msg.sender] -= amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }

    function mint(address account, uint256 amount) public onlyOwner {
        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }
}",contract_222.sol
"Develop a smart contract for a governance system that enables proposals, vote counting, and quorum checking. The contract should include functionality for proposal creation, voting, and state evaluation. Utilize OpenZeppelin's Governor and GovernorSettings modules. Implement basic functions for voting delay, voting period, proposal threshold, quorum calculation, and proposal state evaluation. ","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Governance {
    uint256 public proposalCount;
    uint256 public votingDelay;
    uint256 public votingPeriod;
    uint256 public proposalThreshold;
    uint256 public quorumVotes;

    enum ProposalState { Pending, Active, Defeated, Succeeded, Executed }

    struct Proposal {
        uint256 id;
        string description;
        uint256 startBlock;
        uint256 endBlock;
        uint256 forVotes;
        uint256 againstVotes;
        bool executed;
        mapping(address => bool) hasVoted;
    }

    mapping(uint256 => Proposal) public proposals;

    event ProposalCreated(uint256 id, string description);
    event VoteCast(uint256 proposalId, address voter, bool support, uint256 votes);
    event ProposalExecuted(uint256 id);

    constructor(uint256 _votingDelay, uint256 _votingPeriod, uint256 _proposalThreshold, uint256 _quorumVotes) {
        votingDelay = _votingDelay;
        votingPeriod = _votingPeriod;
        proposalThreshold = _proposalThreshold;
        quorumVotes = _quorumVotes;
    }

    function createProposal(string memory description) public {
        require(msg.sender == address(this), ""Only contract can create proposals"");
        proposalCount++;
        Proposal storage newProposal = proposals[proposalCount];
        newProposal.id = proposalCount;
        newProposal.description = description;
        newProposal.startBlock = block.number + votingDelay;
        newProposal.endBlock = newProposal.startBlock + votingPeriod;
        newProposal.executed = false;

        emit ProposalCreated(proposalCount, description);
    }

    function castVote(uint256 proposalId, bool support) public {
        Proposal storage proposal = proposals[proposalId];
        require(block.number >= proposal.startBlock && block.number <= proposal.endBlock, ""Voting is not active"");
        require(!proposal.hasVoted[msg.sender], ""Already voted"");

        if (support) {
            proposal.forVotes++;
        } else {
            proposal.againstVotes++;
        }

        proposal.hasVoted[msg.sender] = true;

        emit VoteCast(proposalId, msg.sender, support, 1);
    }

    function executeProposal(uint256 proposalId) public {
        Proposal storage proposal = proposals[proposalId];
        require(state(proposalId) == ProposalState.Succeeded, ""Proposal must be succeeded"");
        require(!proposal.executed, ""Proposal already executed"");

        proposal.executed = true;

        emit ProposalExecuted(proposalId);
    }

    function state(uint256 proposalId) public view returns (ProposalState) {
        Proposal storage proposal = proposals[proposalId];
        if (proposal.executed) {
            return ProposalState.Executed;
        } else if (block.number <= proposal.startBlock) {
            return ProposalState.Pending;
        } else if (block.number <= proposal.endBlock) {
            return ProposalState.Active;
        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes) {
            return ProposalState.Defeated;
        } else {
            return ProposalState.Succeeded;
        }
    }
}",contract_223.sol
"Create a smart contract that allows for the creation of a basic decentralized asset transfer system. Utilize the Owned contract to manage ownership and provide a way to transfer ownership. Implement a simple halt mechanism to pause or resume the contract's execution. The contract should also use the Proxy mechanism to enable efficient transactions. Include functions for depositing, withdrawing, and transferring assets. Make sure to include logging and monitoring functionality for auditing and tracking purposes.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Owned {
    address public owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""New owner is the zero address"");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}

contract Proxy {
    address public implementation;

    constructor(address _implementation) {
        implementation = _implementation;
    }

    fallback() external payable {
        address _impl = implementation;
        assembly {
            let ptr := mload(0x40)
            calldatacopy(ptr, 0, calldatasize())
            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)
            let size := returndatasize()
            returndatacopy(ptr, 0, size)

            switch result
            case 0 { revert(ptr, size) }
            default { return(ptr, size) }
        }
    }
}

contract AssetTransfer is Owned {
    bool public halted;
    mapping(address => uint256) public balances;

    event Deposit(address indexed user, uint256 amount);
    event Withdrawal(address indexed user, uint256 amount);
    event Transfer(address indexed from, address indexed to, uint256 amount);

    modifier whenNotHalted() {
        require(!halted, ""Contract is halted"");
        _;
    }

    function halt() public onlyOwner {
        halted = true;
    }

    function resume() public onlyOwner {
        halted = false;
    }

    function deposit() public payable whenNotHalted {
        balances[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }

    function withdraw(uint256 amount) public whenNotHalted {
        require(balances[msg.sender] >= amount, ""Insufficient balance"");
        balances[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);
        emit Withdrawal(msg.sender, amount);
    }

    function transfer(address to, uint256 amount) public whenNotHalted {
        require(balances[msg.sender] >= amount, ""Insufficient balance"");
        require(to != address(0), ""Transfer to the zero address"");
        balances[msg.sender] -= amount;
        balances[to] += amount;
        emit Transfer(msg.sender, to, amount);
    }
}",contract_224.sol
"Create a smart contract that enables the transfer of tokens, allowing users to approve and revoke spending limits for other accounts. The contract should support minting and burning tokens. Utilize the SafeMath library for arithmetic operations. Implement event emissions for notable actions.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Burn(address indexed from, uint256 value);
    event Mint(address indexed to, uint256 value);

    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value);
        balanceOf[_to] = safeAdd(balanceOf[_to], _value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], ""Insufficient balance"");
        require(_value <= allowance[_from][msg.sender], ""Allowance exceeded"");
        balanceOf[_from] = safeSub(balanceOf[_from], _value);
        balanceOf[_to] = safeAdd(balanceOf[_to], _value);
        allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender], _value);
        emit Transfer(_from, _to, _value);
        return true;
    }

    function mint(address _to, uint256 _value) public returns (bool success) {
        totalSupply = safeAdd(totalSupply, _value);
        balanceOf[_to] = safeAdd(balanceOf[_to], _value);
        emit Mint(_to, _value);
        emit Transfer(address(0), _to, _value);
        return true;
    }

    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value);
        totalSupply = safeSub(totalSupply, _value);
        emit Burn(msg.sender, _value);
        emit Transfer(msg.sender, address(0), _value);
        return true;
    }
}",contract_225.sol
"Create a smart contract that manages CryptoPuppies, allowing for gene mixing and gaming. Implement functions to mix genes, play games, and manage access control for CEO, CFO, and COO roles. The contract should also include events and logging mechanisms for auditing purposes. Reference the provided code fragment for implementation details, specifically the GeneScience, PuppySports, and PuppyAccessControl contracts.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract CryptoPuppies {
    struct Puppy {
        uint256 genes;
        uint256 birthTime;
    }

    Puppy[] public puppies;

    address public ceoAddress;
    address public cfoAddress;
    address public cooAddress;

    event PuppyCreated(uint256 indexed puppyId, uint256 genes, uint256 birthTime);
    event GenesMixed(uint256 indexed puppyId1, uint256 indexed puppyId2, uint256 newGenes);
    event GamePlayed(uint256 indexed puppyId, uint256 score);

    modifier onlyCEO() {
        require(msg.sender == ceoAddress, ""Only CEO can perform this action"");
        _;
    }

    modifier onlyCFO() {
        require(msg.sender == cfoAddress, ""Only CFO can perform this action"");
        _;
    }

    modifier onlyCOO() {
        require(msg.sender == cooAddress, ""Only COO can perform this action"");
        _;
    }

    constructor(address _ceo, address _cfo, address _coo) {
        ceoAddress = _ceo;
        cfoAddress = _cfo;
        cooAddress = _coo;
    }

    function createPuppy(uint256 _genes) public onlyCOO {
        uint256 puppyId = puppies.length;
        puppies.push(Puppy(_genes, block.timestamp));
        emit PuppyCreated(puppyId, _genes, block.timestamp);
    }

    function mixGenes(uint256 _puppyId1, uint256 _puppyId2) public onlyCOO returns (uint256) {
        Puppy storage puppy1 = puppies[_puppyId1];
        Puppy storage puppy2 = puppies[_puppyId2];
        uint256 newGenes = puppy1.genes ^ puppy2.genes;
        uint256 newPuppyId = puppies.length;
        puppies.push(Puppy(newGenes, block.timestamp));
        emit GenesMixed(_puppyId1, _puppyId2, newGenes);
        return newGenes;
    }

    function playGame(uint256 _puppyId, uint256 _score) public onlyCFO {
        emit GamePlayed(_puppyId, _score);
    }

    function setCEO(address _newCEO) public onlyCEO {
        ceoAddress = _newCEO;
    }

    function setCFO(address _newCFO) public onlyCEO {
        cfoAddress = _newCFO;
    }

    function setCOO(address _newCOO) public onlyCEO {
        cooAddress = _newCOO;
    }
}",contract_226.sol
"Create a smart contract that allows users to transfer and manage an ERC20 token. Include functions for transferring tokens, checking token balances, and approving and checking allowance. The contract should also emit events for token transfers and approvals. Consider implementing safety features to prevent common smart contract vulnerabilities.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }
}",contract_227.sol
Create a smart contract that utilizes the Compound Comptroller interface to provide functionality for claiming COMP and retrieving the COMPFee address. The contract should ensure that only valid addresses can initiate the claim process and include basic error handling for potential exceptions. The implementation should follow established best practices for Solidity development and utilize the provided SPDX-License-Identifier: GPL-3.0-or-later.,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity ^0.8.0;

interface ComptrollerInterface {
    function claimComp(address holder) external;
    function getCompAddress() external view returns (address);
}

contract CompClaim {
    ComptrollerInterface public comptroller;
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor(address _comptroller) {
        comptroller = ComptrollerInterface(_comptroller);
        owner = msg.sender;
    }

    function claimComp() external onlyOwner {
        comptroller.claimComp(owner);
    }

    function getCompAddress() external view returns (address) {
        return comptroller.getCompAddress();
    }
}",contract_228.sol
Create a solidity smart contract that allows users to register names in a locked system. The contract should have a boolean variable 'unlocked' that determines whether new name registrations are allowed. The contract should also store name registrations in a mapping structure and allow users to resolve hashes to addresses. Implement a function that allows users to register new names. Make sure the contract is secure and follows best practices.,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract NameRegistry {
    bool public unlocked;
    address public owner;

    struct Registration {
        address registrant;
        uint256 timestamp;
    }

    mapping(bytes32 => Registration) public registrations;
    mapping(address => bytes32) public addressesToNames;

    event NameRegistered(bytes32 indexed nameHash, address indexed registrant, uint256 timestamp);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier whenUnlocked() {
        require(unlocked, ""Contract is locked"");
        _;
    }

    constructor() {
        owner = msg.sender;
        unlocked = true;
    }

    function setUnlocked(bool _unlocked) external onlyOwner {
        unlocked = _unlocked;
    }

    function registerName(bytes32 nameHash) external whenUnlocked {
        require(registrations[nameHash].registrant == address(0), ""Name already registered"");
        require(addressesToNames[msg.sender] == bytes32(0), ""Address already registered a name"");

        registrations[nameHash] = Registration({
            registrant: msg.sender,
            timestamp: block.timestamp
        });
        addressesToNames[msg.sender] = nameHash;

        emit NameRegistered(nameHash, msg.sender, block.timestamp);
    }

    function resolveAddress(bytes32 nameHash) external view returns (address) {
        return registrations[nameHash].registrant;
    }
}",contract_229.sol
"Create a smart contract that manages a game with multiple stages, where players can participate and receive rewards. The contract should include functions for initializing game stages, tracking player progress, and distributing rewards. Implement a random number generator to determine game outcomes and ensure fairness. Consider incorporating data structures and algorithms to optimize performance.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GameManager {
    struct Stage {
        uint256 id;
        string name;
        uint256 reward;
        bool active;
    }

    struct Player {
        uint256 currentStage;
        uint256[] completedStages;
        uint256 totalRewards;
    }

    Stage[] public stages;
    mapping(address => Player) public players;
    uint256 private nonce = 0;

    event StageInitialized(uint256 id, string name, uint256 reward);
    event PlayerProgressed(address player, uint256 stageId);
    event RewardDistributed(address player, uint256 amount);

    function initializeStage(string memory name, uint256 reward) public {
        uint256 stageId = stages.length;
        stages.push(Stage({
            id: stageId,
            name: name,
            reward: reward,
            active: true
        }));
        emit StageInitialized(stageId, name, reward);
    }

    function participate() public {
        if (players[msg.sender].currentStage == 0) {
            players[msg.sender].currentStage = 1;
        }
    }

    function completeStage(uint256 stageId) public {
        require(stageId < stages.length, ""Invalid stage ID"");
        require(players[msg.sender].currentStage == stageId, ""Not eligible for this stage"");
        require(stages[stageId].active, ""Stage is not active"");

        players[msg.sender].completedStages.push(stageId);
        players[msg.sender].totalRewards += stages[stageId].reward;
        players[msg.sender].currentStage++;

        emit PlayerProgressed(msg.sender, stageId);
        emit RewardDistributed(msg.sender, stages[stageId].reward);
    }

    function getRandomNumber() private returns (uint256) {
        uint256 random = uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender, nonce))) % 100;
        nonce++;
        return random;
    }

    function determineOutcome(uint256 stageId) public view returns (bool) {
        require(stageId < stages.length, ""Invalid stage ID"");
        uint256 random = getRandomNumber();
        return random < 50; // 50% chance of success
    }

    function getPlayerInfo(address player) public view returns (uint256, uint256[] memory, uint256) {
        return (
            players[player].currentStage,
            players[player].completedStages,
            players[player].totalRewards
        );
    }
}",contract_230.sol
"Create a simple ERC20 token contract with basic functionality, including token transfers, approvals, and balance queries. Include a migration feature to allow tokens to be transferred to a new version of the contract. The contract should allow for token airdrops and support for older contract versions. The code should be easy to understand and follow best practices for Solidity smart contract development.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }

    function airdrop(address[] memory recipients, uint256[] memory amounts) public {
        require(recipients.length == amounts.length, ""Mismatched array lengths"");
        for (uint256 i = 0; i < recipients.length; i++) {
            require(transfer(recipients[i], amounts[i]), ""Transfer failed"");
        }
    }

    function migrate(address newContract, uint256 value) public {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        totalSupply -= value;
        emit Transfer(msg.sender, newContract, value);
    }
}",contract_231.sol
"Create a smart contract that enables the creation and trading of unique tokens. The contract should allow users to mint tokens, set prices, and manage token metadata. Consider incorporating features like token attributes, royalty payments, and dynamic presale and sale activation. Pay close attention to token supply management, fund allocation, and staking mechanics. Ensure the contract handles arithmetic operations securely by utilizing SafeMath.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract UniqueToken {
    using SafeMath for uint256;

    struct Token {
        uint256 id;
        address creator;
        string metadata;
        uint256 price;
        bool isForSale;
        uint256 royalty;
    }

    Token[] public tokens;
    mapping(uint256 => address) public tokenOwners;
    mapping(address => uint256[]) public ownerTokens;
    uint256 public tokenCounter;

    event TokenMinted(uint256 indexed tokenId, address indexed creator, string metadata);
    event TokenPriceSet(uint256 indexed tokenId, uint256 price);
    event TokenSold(uint256 indexed tokenId, address indexed buyer, uint256 price);

    modifier onlyTokenOwner(uint256 _tokenId) {
        require(tokenOwners[_tokenId] == msg.sender, ""Not the owner"");
        _;
    }

    function mintToken(string memory _metadata, uint256 _price, uint256 _royalty) public {
        require(_royalty <= 10000, ""Royalty too high"");
        uint256 tokenId = tokenCounter++;
        Token memory newToken = Token({
            id: tokenId,
            creator: msg.sender,
            metadata: _metadata,
            price: _price,
            isForSale: true,
            royalty: _royalty
        });
        tokens.push(newToken);
        tokenOwners[tokenId] = msg.sender;
        ownerTokens[msg.sender].push(tokenId);
        emit TokenMinted(tokenId, msg.sender, _metadata);
    }

    function setTokenPrice(uint256 _tokenId, uint256 _price) public onlyTokenOwner(_tokenId) {
        tokens[_tokenId].price = _price;
        emit TokenPriceSet(_tokenId, _price);
    }

    function buyToken(uint256 _tokenId) public payable {
        Token storage token = tokens[_tokenId];
        require(token.isForSale, ""Token not for sale"");
        require(msg.value >= token.price, ""Insufficient funds"");

        address oldOwner = tokenOwners[_tokenId];
        tokenOwners[_tokenId] = msg.sender;
        ownerTokens[msg.sender].push(_tokenId);

        uint256 royaltyAmount = msg.value.mul(token.royalty).div(10000);
        uint256 remainingAmount = msg.value.sub(royaltyAmount);

        payable(token.creator).transfer(royaltyAmount);
        payable(oldOwner).transfer(remainingAmount);

        emit TokenSold(_tokenId, msg.sender, token.price);
    }

    function getTokensByOwner(address _owner) public view returns (uint256[] memory) {
        return ownerTokens[_owner];
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }
}",contract_232.sol
"Create a Tron-based smart contract that manages user referrals and allows users to deposit and withdraw funds. The contract should include functions for setting up user referral networks, tracking user deposits and withdrawals, and managing the contract balance. The contract should also include event handling for tracking user activities.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ReferralSystem {
    address public owner;
    uint256 public totalDeposits;
    uint256 public totalWithdrawals;

    struct User {
        address referrer;
        uint256 balance;
        uint256 totalDeposits;
        uint256 totalWithdrawals;
    }

    mapping(address => User) public users;
    mapping(address => bool) public isRegistered;

    event Deposit(address indexed user, uint256 amount);
    event Withdrawal(address indexed user, uint256 amount);
    event ReferralSet(address indexed user, address indexed referrer);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier onlyRegistered() {
        require(isRegistered[msg.sender], ""User not registered"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function register(address referrer) public {
        require(!isRegistered[msg.sender], ""Already registered"");
        require(referrer != msg.sender, ""Cannot refer yourself"");

        users[msg.sender] = User({
            referrer: referrer,
            balance: 0,
            totalDeposits: 0,
            totalWithdrawals: 0
        });
        isRegistered[msg.sender] = true;

        emit ReferralSet(msg.sender, referrer);
    }

    function deposit() public payable onlyRegistered {
        require(msg.value > 0, ""Deposit amount must be greater than 0"");

        users[msg.sender].balance += msg.value;
        users[msg.sender].totalDeposits += msg.value;
        totalDeposits += msg.value;

        emit Deposit(msg.sender, msg.value);
    }

    function withdraw(uint256 amount) public onlyRegistered {
        require(amount > 0, ""Withdrawal amount must be greater than 0"");
        require(users[msg.sender].balance >= amount, ""Insufficient balance"");

        users[msg.sender].balance -= amount;
        users[msg.sender].totalWithdrawals += amount;
        totalWithdrawals += amount;

        payable(msg.sender).transfer(amount);

        emit Withdrawal(msg.sender, amount);
    }

    function getUserBalance(address user) public view returns (uint256) {
        return users[user].balance;
    }

    function getUserTotalDeposits(address user) public view returns (uint256) {
        return users[user].totalDeposits;
    }

    function getUserTotalWithdrawals(address user) public view returns (uint256) {
        return users[user].totalWithdrawals;
    }

    function getUserReferrer(address user) public view returns (address) {
        return users[user].referrer;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""Invalid address"");
        owner = newOwner;
    }
}",contract_233.sol
"Create a smart contract for the E4Token that allows for token transactions, including minting, transferring, and approving tokens. The contract should include a mapping to track token balances and allow holders to withdraw dividends. Implement functions for token transfers, approvals, and allowance tracking. Ensure the contract includes events for token transfers and approvals. Consider implementing modifiers and functions to govern token minting and burning. Develop a comprehensive and understandable smart contract that implements the E4Token functionality.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract E4Token {
    string public name = ""E4Token"";
    string public symbol = ""E4T"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    mapping(address => uint256) public dividends;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Mint(address indexed to, uint256 value);
    event Burn(address indexed from, uint256 value);
    event WithdrawDividends(address indexed to, uint256 value);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    address public owner;

    constructor() {
        owner = msg.sender;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], ""Insufficient balance"");
        require(_value <= allowance[_from][msg.sender], ""Allowance exceeded"");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    function mint(address _to, uint256 _value) public onlyOwner returns (bool success) {
        totalSupply += _value;
        balanceOf[_to] += _value;
        emit Mint(_to, _value);
        emit Transfer(address(0), _to, _value);
        return true;
    }

    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        totalSupply -= _value;
        balanceOf[msg.sender] -= _value;
        emit Burn(msg.sender, _value);
        emit Transfer(msg.sender, address(0), _value);
        return true;
    }

    function distributeDividends(uint256 _amount) public onlyOwner {
        require(totalSupply > 0, ""No tokens issued"");
        for (uint256 i = 0; i < totalSupply; i++) {
            address holder = address(uint160(i));
            if (balanceOf[holder] > 0) {
                dividends[holder] += (_amount * balanceOf[holder]) / totalSupply;
            }
        }
    }

    function withdrawDividends() public returns (bool success) {
        uint256 amount = dividends[msg.sender];
        require(amount > 0, ""No dividends to withdraw"");
        dividends[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit WithdrawDividends(msg.sender, amount);
        return true;
    }

    receive() external payable {}
}",contract_234.sol
"Design a smart contract that prevents delegate calls. The contract should have two key functions: observe and updateTickCum. Observe will allow for reading tick cumulative values and seconds per liquidity cumulative values, while updateTickCum will update these values. The contract should also have a constructor to initialize the contract owner, and include modifiers to restrict the owner's updates.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract PreventDelegateCall {
    address public owner;
    uint256 public tickCumulative;
    uint256 public secondsPerLiquidityCumulative;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function observe() external view returns (uint256, uint256) {
        return (tickCumulative, secondsPerLiquidityCumulative);
    }

    function updateTickCum(uint256 newTickCumulative, uint256 newSecondsPerLiquidityCumulative) external onlyOwner {
        tickCumulative = newTickCumulative;
        secondsPerLiquidityCumulative = newSecondsPerLiquidityCumulative;
    }

    fallback() external payable {
        revert(""Delegate call not allowed"");
    }

    receive() external payable {
        revert(""Delegate call not allowed"");
    }
}",contract_235.sol
"Create a smart contract that builds upon AccessControlUpgradeable, implementing a custom role, 'Admin', with defined functions for role management, including granting, revoking, and renouncing. Ensure proper access control using inherited functions and modifiers. Concentrate on the overall functionality and interaction with users.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract CustomAccessControl {
    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");

    mapping(bytes32 => mapping(address => bool)) private _roles;
    mapping(bytes32 => bytes32) private _roleAdmins;

    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);

    modifier onlyRole(bytes32 role) {
        require(hasRole(role, msg.sender), ""CustomAccessControl: sender must be an admin"");
        _;
    }

    constructor() {
        _setupRole(ADMIN_ROLE, msg.sender);
        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);
    }

    function hasRole(bytes32 role, address account) public view returns (bool) {
        return _roles[role][account];
    }

    function getRoleAdmin(bytes32 role) public view returns (bytes32) {
        return _roleAdmins[role];
    }

    function grantRole(bytes32 role, address account) public onlyRole(getRoleAdmin(role)) {
        _grantRole(role, account);
    }

    function revokeRole(bytes32 role, address account) public onlyRole(getRoleAdmin(role)) {
        _revokeRole(role, account);
    }

    function renounceRole(bytes32 role, address account) public {
        require(account == msg.sender, ""CustomAccessControl: can only renounce roles for self"");
        _revokeRole(role, account);
    }

    function _setupRole(bytes32 role, address account) internal {
        _grantRole(role, account);
    }

    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {
        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);
        _roleAdmins[role] = adminRole;
    }

    function _grantRole(bytes32 role, address account) private {
        if (!hasRole(role, account)) {
            _roles[role][account] = true;
            emit RoleGranted(role, account, msg.sender);
        }
    }

    function _revokeRole(bytes32 role, address account) private {
        if (hasRole(role, account)) {
            _roles[role][account] = false;
            emit RoleRevoked(role, account, msg.sender);
        }
    }
}",contract_236.sol
"Create a Solidity smart contract that manages a banana-based NFT system, featuring whitelist sales and public mints. The contract should include mechanisms for NFT ownership tracking, minting limits, and SuperBanana address management. Ensure that only the owner can pause and resume sales and withdraw funds. Implement functions for checking claimed bananas and burning NFTs","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract BananaNFT {
    address public owner;
    bool public paused;
    uint256 public totalSupply;
    uint256 public maxSupply;
    uint256 public whitelistPrice;
    uint256 public publicPrice;
    uint256 public maxMintPerAddress;
    address public superBananaAddress;

    mapping(address => bool) public whitelist;
    mapping(address => uint256) public mintedCount;
    mapping(uint256 => address) public tokenOwners;
    mapping(address => uint256) public ownedTokensCount;

    event Mint(address indexed to, uint256 tokenId);
    event Burn(uint256 tokenId);
    event Pause();
    event Unpause();
    event Withdraw(address indexed to, uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    constructor(
        uint256 _maxSupply,
        uint256 _whitelistPrice,
        uint256 _publicPrice,
        uint256 _maxMintPerAddress,
        address _superBananaAddress
    ) {
        owner = msg.sender;
        maxSupply = _maxSupply;
        whitelistPrice = _whitelistPrice;
        publicPrice = _publicPrice;
        maxMintPerAddress = _maxMintPerAddress;
        superBananaAddress = _superBananaAddress;
    }

    function addToWhitelist(address[] memory _addresses) external onlyOwner {
        for (uint256 i = 0; i < _addresses.length; i++) {
            whitelist[_addresses[i]] = true;
        }
    }

    function removeFromWhitelist(address[] memory _addresses) external onlyOwner {
        for (uint256 i = 0; i < _addresses.length; i++) {
            whitelist[_addresses[i]] = false;
        }
    }

    function mintWhitelist() external payable whenNotPaused {
        require(whitelist[msg.sender], ""Not whitelisted"");
        require(mintedCount[msg.sender] < maxMintPerAddress, ""Exceeded mint limit"");
        require(msg.value >= whitelistPrice, ""Insufficient funds"");
        require(totalSupply < maxSupply, ""Max supply reached"");

        _mint(msg.sender);
    }

    function mintPublic() external payable whenNotPaused {
        require(mintedCount[msg.sender] < maxMintPerAddress, ""Exceeded mint limit"");
        require(msg.value >= publicPrice, ""Insufficient funds"");
        require(totalSupply < maxSupply, ""Max supply reached"");

        _mint(msg.sender);
    }

    function _mint(address _to) internal {
        uint256 tokenId = totalSupply + 1;
        totalSupply++;
        mintedCount[_to]++;
        tokenOwners[tokenId] = _to;
        ownedTokensCount[_to]++;
        emit Mint(_to, tokenId);
    }

    function burn(uint256 _tokenId) external {
        require(tokenOwners[_tokenId] == msg.sender, ""Not the owner"");
        ownedTokensCount[msg.sender]--;
        delete tokenOwners[_tokenId];
        emit Burn(_tokenId);
    }

    function pause() external onlyOwner {
        paused = true;
        emit Pause();
    }

    function unpause() external onlyOwner {
        paused = false;
        emit Unpause();
    }

    function withdraw() external onlyOwner {
        uint256 balance = address(this).balance;
        payable(owner).transfer(balance);
        emit Withdraw(owner, balance);
    }

    function isClaimed(address _address) external view returns (bool) {
        return mintedCount[_address] > 0;
    }
}",contract_237.sol
"Develop a Solidity smart contract that includes two functions: uintToHex and uintToEther. uintToHex should convert a uint256 input into a hexadecimal string with leading zeros if necessary. uintToEther should convert a uint256 input into a human-readable string with appropriate units ('MIC') and formatting. Consider the value range and provide specific guidelines for values less than, equal to, and greater than 0.001 MIC.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Converter {
    function uintToHex(uint256 value) public pure returns (string memory) {
        bytes memory buffer = new bytes(64);
        for (uint256 i = 63; i < 64; --i) {
            uint8 byteValue = uint8(value & 0xff);
            buffer[i] = byteValue > 9 ? bytes1(uint8(byteValue + 87)) : bytes1(uint8(byteValue + 48));
            value >>= 8;
        }
        return string(buffer);
    }

    function uintToEther(uint256 value) public pure returns (string memory) {
        if (value == 0) {
            return ""0 MIC"";
        }
        if (value < 1e15) {
            return ""< 0.001 MIC"";
        }
        uint256 quotient = value / 1e15;
        uint256 remainder = value % 1e15;
        string memory result = uint2str(quotient);
        if (remainder > 0) {
            result = string(abi.encodePacked(result, ""."", uint2str(remainder)));
        }
        return string(abi.encodePacked(result, "" MIC""));
    }

    function uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {
        if (_i == 0) {
            return ""0"";
        }
        uint256 j = _i;
        uint256 len;
        while (j != 0) {
            len++;
            j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint256 k = len;
        while (_i != 0) {
            k = k - 1;
            uint8 temp = (48 + uint8(_i - _i / 10 * 10));
            bytes1 b1 = bytes1(temp);
            bstr[k] = b1;
            _i /= 10;
        }
        return string(bstr);
    }
}",contract_238.sol
"Create a Solidity smart contract that allows for governance and treasury management in the Nouns DAO, including logic for proposing, voting, and executing proposals, as well as managing the treasury and random number generation.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract NounsDAO {
    address public admin;
    uint public proposalCount;
    uint public voteTime = 7 days;
    uint public quorum = 50; // 50%

    struct Proposal {
        uint id;
        string description;
        uint createdAt;
        uint forVotes;
        uint againstVotes;
        bool executed;
        mapping(address => bool) voted;
    }

    mapping(uint => Proposal) public proposals;
    mapping(address => uint) public balances;

    event ProposalCreated(uint id, string description);
    event Voted(uint proposalId, address voter, bool vote);
    event ProposalExecuted(uint id);

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can perform this action"");
        _;
    }

    constructor() {
        admin = msg.sender;
    }

    function createProposal(string memory _description) public onlyAdmin {
        proposalCount++;
        Proposal storage p = proposals[proposalCount];
        p.id = proposalCount;
        p.description = _description;
        p.createdAt = block.timestamp;
        emit ProposalCreated(proposalCount, _description);
    }

    function vote(uint _proposalId, bool _vote) public {
        Proposal storage p = proposals[_proposalId];
        require(block.timestamp < p.createdAt + voteTime, ""Voting period is over"");
        require(!p.voted[msg.sender], ""Already voted"");
        p.voted[msg.sender] = true;
        if (_vote) {
            p.forVotes++;
        } else {
            p.againstVotes++;
        }
        emit Voted(_proposalId, msg.sender, _vote);
    }

    function executeProposal(uint _proposalId) public onlyAdmin {
        Proposal storage p = proposals[_proposalId];
        require(block.timestamp >= p.createdAt + voteTime, ""Voting period is not over"");
        require(!p.executed, ""Proposal already executed"");
        uint totalVotes = p.forVotes + p.againstVotes;
        require(totalVotes * 100 / quorum >= quorum, ""Quorum not met"");
        require(p.forVotes > p.againstVotes, ""Majority not in favor"");
        p.executed = true;
        emit ProposalExecuted(_proposalId);
    }

    function fundTreasury() public payable {
        balances[address(this)] += msg.value;
    }

    function withdrawFromTreasury(uint amount) public onlyAdmin {
        require(balances[address(this)] >= amount, ""Insufficient funds"");
        balances[address(this)] -= amount;
        payable(admin).transfer(amount);
    }

    function randomNumber() public view returns (uint) {
        return uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp)));
    }
}",contract_239.sol
"Design a smart contract that allows for permission-based access control and integrates with an EntryPoint. The contract should have functions for initializing the contract, setting operator permissions, and validating user operations. Include data structures for storing operator permissions, remaining fees, and remaining values. Consider implementing EIP712 and ECDSA signature verification. The contract should be compatible with OpenZeppelin contracts and EIP712 specifications.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract AccessControlEntryPoint {
    struct OperatorPermission {
        bool canSetPermissions;
        bool canValidateOperations;
    }

    struct UserOperation {
        address sender;
        uint256 nonce;
        bytes initCode;
        bytes callData;
        uint256 callGasLimit;
        uint256 verificationGasLimit;
        uint256 preVerificationGas;
        uint256 maxFeePerGas;
        uint256 maxPriorityFeePerGas;
        bytes paymasterAndData;
        bytes signature;
    }

    address public owner;
    mapping(address => OperatorPermission) public operatorPermissions;
    mapping(address => uint256) public remainingFees;
    mapping(address => uint256) public remainingValues;

    bytes32 private constant EIP712_DOMAIN_TYPEHASH = keccak256(""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"");
    bytes32 private constant USER_OPERATION_TYPEHASH = keccak256(""UserOperation(address sender,uint256 nonce,bytes initCode,bytes callData,uint256 callGasLimit,uint256 verificationGasLimit,uint256 preVerificationGas,uint256 maxFeePerGas,uint256 maxPriorityFeePerGas,bytes paymasterAndData)"");

    bytes32 public DOMAIN_SEPARATOR;

    constructor() {
        owner = msg.sender;
        uint256 chainId;
        assembly {
            chainId := chainid()
        }
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                EIP712_DOMAIN_TYPEHASH,
                keccak256(""AccessControlEntryPoint""),
                keccak256(""1""),
                chainId,
                address(this)
            )
        );
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the owner"");
        _;
    }

    function setOperatorPermission(address operator, bool canSetPermissions, bool canValidateOperations) external onlyOwner {
        operatorPermissions[operator] = OperatorPermission(canSetPermissions, canValidateOperations);
    }

    function validateUserOperation(UserOperation calldata userOp, bytes32 requestId, uint256 missingAccountFunds) external {
        require(operatorPermissions[msg.sender].canValidateOperations, ""No permission to validate operations"");
        _validateSignature(userOp, requestId);
        _payPrefund(missingAccountFunds);
    }

    function _validateSignature(UserOperation calldata userOp, bytes32 requestId) internal view {
        bytes32 digest = keccak256(
            abi.encodePacked(
                ""\x19\x01"",
                DOMAIN_SEPARATOR,
                keccak256(
                    abi.encode(
                        USER_OPERATION_TYPEHASH,
                        userOp.sender,
                        userOp.nonce,
                        keccak256(userOp.initCode),
                        keccak256(userOp.callData),
                        userOp.callGasLimit,
                        userOp.verificationGasLimit,
                        userOp.preVerificationGas,
                        userOp.maxFeePerGas,
                        userOp.maxPriorityFeePerGas,
                        keccak256(userOp.paymasterAndData)
                    )
                )
            )
        );
        require(ECDSA.recover(digest, userOp.signature) == userOp.sender, ""Invalid signature"");
    }

    function _payPrefund(uint256 missingAccountFunds) internal {
        if (missingAccountFunds != 0) {
            require(address(this).balance >= missingAccountFunds, ""Insufficient funds"");
            payable(msg.sender).transfer(missingAccountFunds);
        }
    }

    function deposit() external payable {
        remainingValues[msg.sender] += msg.value;
    }

    function withdraw(uint256 amount) external {
        require(remainingValues[msg.sender] >= amount, ""Insufficient balance"");
        remainingValues[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);
    }
}

library ECDSA {
    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
        if (signature.length != 65) {
            revert(""ECDSA: invalid signature length"");
        }

        bytes32 r;
        bytes32 s;
        uint8 v;

        assembly {
            r := mload(add(signature, 0x20))
            s := mload(add(signature, 0x40))
            v := byte(0, mload(add(signature, 0x60)))
        }

        if (v < 27) {
            v += 27;
        }

        if (v != 27 && v != 28) {
            revert(""ECDSA: invalid signature 'v' value"");
        }

        return ecrecover(hash, v, r, s);
    }
}",contract_240.sol
"Create a new smart contract that implements the IAnyswapV3ERC20 interface, allowing for token transfers, approvals, and permits. Focus on the functional requirements, ensuring the contract provides accurate token balances, allows for token transfers with optional data, and adheres to the ERC-20 standard. Consider the use of libraries, such as SafeERC20, to simplify common operations. Provide a high-level overview of the contract's variables, functions, and logic.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IAnyswapV3ERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
}

contract AnyswapV3ERC20 is IAnyswapV3ERC20 {
    string public name = ""AnyswapV3ERC20"";
    string public symbol = ""ANY"";
    uint8 public decimals = 18;
    uint256 private _totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    bytes32 public DOMAIN_SEPARATOR;
    // keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");
    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
    mapping(address => uint256) public nonces;

    constructor(uint256 initialSupply) {
        _totalSupply = initialSupply * 10 ** uint256(decimals);
        _balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);

        uint256 chainId;
        assembly {
            chainId := chainid()
        }
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),
                keccak256(bytes(name)),
                keccak256(bytes('1')),
                chainId,
                address(this)
            )
        );
    }

    function totalSupply() external view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) external view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) external override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) external view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) external override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external override {
        require(deadline >= block.timestamp, ""AnyswapV3ERC20: EXPIRED"");
        bytes32 digest = keccak256(
            abi.encodePacked(
                '\x19\x01',
                DOMAIN_SEPARATOR,
                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))
            )
        );
        address recoveredAddress = ecrecover(digest, v, r, s);
        require(recoveredAddress != address(0) && recoveredAddress == owner, ""AnyswapV3ERC20: INVALID_SIGNATURE"");
        _approve(owner, spender, value);
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""AnyswapV3ERC20: transfer from the zero address"");
        require(recipient != address(0), ""AnyswapV3ERC20: transfer to the zero address"");

        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""AnyswapV3ERC20: approve from the zero address"");
        require(spender != address(0), ""AnyswapV3ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}",contract_241.sol
"Create a smart contract that implements the IERC1822Proxiable interface. Use the Address library to interact with other contracts and the StorageSlot library to store and retrieve data. Design a data structure or mapping to manage data. Focus on functionality and simplicity, while ensuring gas efficiency and code organization.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC1822Proxiable {
    function proxiableUUID() external view returns (bytes32);
    function updateCodeAddress(address newAddress) external;
}

library Address {
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }
}

library StorageSlot {
    struct AddressSlot {
        address value;
    }

    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {
        assembly {
            r.slot := slot
        }
    }
}

contract ProxiableContract is IERC1822Proxiable {
    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

    function proxiableUUID() external pure override returns (bytes32) {
        return _IMPLEMENTATION_SLOT;
    }

    function updateCodeAddress(address newAddress) external override {
        require(Address.isContract(newAddress), ""New address is not a contract"");
        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newAddress;
    }

    function _delegate(address implementation) internal virtual {
        assembly {
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())
            switch result
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
        }
    }

    fallback() external payable {
        _delegate(StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value);
    }

    receive() external payable {}
}",contract_242.sol
"Write a smart contract that adheres to the IBEP20 standard. The contract should have a total supply of 100 trillion and the owner being the address that deploys the contract. Include functions to get the owner, decimals, symbol, and name of the token. Implement functionality for users to transfer tokens and approve or transfer tokens on behalf of others. Make sure to emit events when necessary.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract BEP20Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply = 100000000000000 * 10**uint256(decimals); // 100 trillion tokens
    address public owner;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        owner = msg.sender;
        balanceOf[msg.sender] = totalSupply;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], ""Insufficient balance"");
        require(_value <= allowance[_from][msg.sender], ""Allowance exceeded"");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }
}",contract_243.sol
"Create a Solidity smart contract that implements the ERC20 standard. The contract should allow token transfers, approve and track allowances for token transfers, mint and burn tokens, and retrieve token balances and allowances. The contract should also keep track of the token's name, symbol, and decimals. Structure the contract in a logical and readable manner.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20 {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    mapping(address => uint256) private balances;
    mapping(address => mapping(address => uint256)) private allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
    }

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        require(balances[msg.sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        balances[msg.sender] -= amount;
        balances[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        require(balances[sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        require(allowances[sender][msg.sender] >= amount, ""ERC20: transfer amount exceeds allowance"");
        balances[sender] -= amount;
        balances[recipient] += amount;
        allowances[sender][msg.sender] -= amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }

    function mint(address account, uint256 amount) public {
        require(account != address(0), ""ERC20: mint to the zero address"");
        totalSupply += amount;
        balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function burn(address account, uint256 amount) public {
        require(balances[account] >= amount, ""ERC20: burn amount exceeds balance"");
        totalSupply -= amount;
        balances[account] -= amount;
        emit Transfer(account, address(0), amount);
    }
}",contract_244.sol
"Create a simple smart contract that allows for ownership transfer, renunciation, and basic arithmetic operations. Use the SafeMath library for precision and implement ownership transfer and renunciation functions. Ensure the contract includes a modifier for the owner and provides basic functionality for setting and retrieving the owner's address.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    modifier onlyOwner() {
        require(isOwner(), ""Ownable: caller is not the owner"");
        _;
    }

    function owner() public view returns (address) {
        return _owner;
    }

    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, ""SafeMath: modulo by zero"");
        return a % b;
    }
}

contract SimpleContract is Ownable {
    using SafeMath for uint256;

    function add(uint256 a, uint256 b) public pure returns (uint256) {
        return a.add(b);
    }

    function sub(uint256 a, uint256 b) public pure returns (uint256) {
        return a.sub(b);
    }

    function mul(uint256 a, uint256 b) public pure returns (uint256) {
        return a.mul(b);
    }

    function div(uint256 a, uint256 b) public pure returns (uint256) {
        return a.div(b);
    }

    function mod(uint256 a, uint256 b) public pure returns (uint256) {
        return a.mod(b);
    }
}",contract_245.sol
"Write a smart contract that allows for the creation and management of NFT collections. Include functionality for setting new addresses for the NFT collection factories and launchpad fee wallet, as well as updates to the mint cap and launchpad fee percentage. The contract should also have methods for creating new NFT collections and setting the admin role. Consider using OpenZeppelin's AccessControl library for role-based access control.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""./AccessControl.sol"";
import ""./ERC721.sol"";
import ""./ERC721Enumerable.sol"";
import ""./ERC721URIStorage.sol"";

contract NFTCollectionManager is AccessControl {
    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    bytes32 public constant FACTORY_ROLE = keccak256(""FACTORY_ROLE"");

    address public nftCollectionFactory;
    address public launchpadFeeWallet;
    uint256 public mintCap;
    uint256 public launchpadFeePercentage;

    struct Collection {
        address collectionAddress;
        string name;
        string symbol;
    }

    Collection[] public collections;

    event CollectionCreated(address indexed collectionAddress, string name, string symbol);
    event FactoryAddressUpdated(address indexed newFactoryAddress);
    event FeeWalletUpdated(address indexed newFeeWallet);
    event MintCapUpdated(uint256 newMintCap);
    event FeePercentageUpdated(uint256 newFeePercentage);

    constructor(address _admin, address _nftCollectionFactory, address _launchpadFeeWallet, uint256 _mintCap, uint256 _launchpadFeePercentage) {
        _setupRole(DEFAULT_ADMIN_ROLE, _admin);
        _setupRole(ADMIN_ROLE, _admin);
        nftCollectionFactory = _nftCollectionFactory;
        launchpadFeeWallet = _launchpadFeeWallet;
        mintCap = _mintCap;
        launchpadFeePercentage = _launchpadFeePercentage;
    }

    modifier onlyAdmin() {
        require(hasRole(ADMIN_ROLE, msg.sender), ""NFTCollectionManager: caller is not an admin"");
        _;
    }

    modifier onlyFactory() {
        require(msg.sender == nftCollectionFactory, ""NFTCollectionManager: caller is not the factory"");
        _;
    }

    function setFactoryAddress(address _newFactoryAddress) external onlyAdmin {
        nftCollectionFactory = _newFactoryAddress;
        emit FactoryAddressUpdated(_newFactoryAddress);
    }

    function setFeeWallet(address _newFeeWallet) external onlyAdmin {
        launchpadFeeWallet = _newFeeWallet;
        emit FeeWalletUpdated(_newFeeWallet);
    }

    function setMintCap(uint256 _newMintCap) external onlyAdmin {
        mintCap = _newMintCap;
        emit MintCapUpdated(_newMintCap);
    }

    function setFeePercentage(uint256 _newFeePercentage) external onlyAdmin {
        launchpadFeePercentage = _newFeePercentage;
        emit FeePercentageUpdated(_newFeePercentage);
    }

    function createCollection(string memory _name, string memory _symbol) external onlyFactory returns (address) {
        NFTCollection newCollection = new NFTCollection(_name, _symbol, msg.sender, launchpadFeeWallet, mintCap, launchpadFeePercentage);
        collections.push(Collection({
            collectionAddress: address(newCollection),
            name: _name,
            symbol: _symbol
        }));
        emit CollectionCreated(address(newCollection), _name, _symbol);
        return address(newCollection);
    }
}

contract NFTCollection is ERC721, ERC721Enumerable, ERC721URIStorage {
    address public factory;
    address public feeWallet;
    uint256 public mintCap;
    uint256 public feePercentage;

    constructor(string memory _name, string memory _symbol, address _factory, address _feeWallet, uint256 _mintCap, uint256 _feePercentage) ERC721(_name, _symbol) {
        factory = _factory;
        feeWallet = _feeWallet;
        mintCap = _mintCap;
        feePercentage = _feePercentage;
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override(ERC721, ERC721Enumerable) {
        super._beforeTokenTransfer(from, to, tokenId);
    }

    function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {
        super._burn(tokenId);
    }

    function tokenURI(uint256 tokenId) public view override(ERC721, ERC721URIStorage) returns (string memory) {
        return super.tokenURI(tokenId);
    }

    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721Enumerable) returns (bool) {
        return super.supportsInterface(interfaceId);
    }

    function mintNFT(address to, uint256 tokenId, string memory uri) external {
        require(msg.sender == factory, ""NFTCollection: caller is not the factory"");
        _safeMint(to, tokenId);
        _setTokenURI(tokenId, uri);
    }
}",contract_246.sol
"Create a smart contract that manages a collection of unique digital assets, allowing users to buy, sell, and transfer ownership. Include functions for token enumeration, owner lookup, and balance retrieval. Make sure the contract adheres to the IERC721 standard and includes necessary event emitters for token transfer and approval.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC721 {
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function balanceOf(address owner) external view returns (uint256 balance);
    function ownerOf(uint256 tokenId) external view returns (address owner);
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    function transferFrom(address from, address to, uint256 tokenId) external;
    function approve(address to, uint256 tokenId) external;
    function getApproved(uint256 tokenId) external view returns (address operator);
    function setApprovalForAll(address operator, bool _approved) external;
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}

contract ERC721 is IERC721 {
    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    function balanceOf(address owner) public view override returns (uint256) {
        require(owner != address(0), ""ERC721: balance query for the zero address"");
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) public view override returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), ""ERC721: owner query for nonexistent token"");
        return owner;
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) public override {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _safeTransfer(from, to, tokenId, """");
    }

    function transferFrom(address from, address to, uint256 tokenId) public override {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _transfer(from, to, tokenId);
    }

    function approve(address to, uint256 tokenId) public override {
        address owner = ownerOf(tokenId);
        require(to != owner, ""ERC721: approval to current owner"");
        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), ""ERC721: approve caller is not owner nor approved for all"");
        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    function getApproved(uint256 tokenId) public view override returns (address) {
        require(_exists(tokenId), ""ERC721: approved query for nonexistent token"");
        return _tokenApprovals[tokenId];
    }

    function setApprovalForAll(address operator, bool approved) public override {
        require(operator != msg.sender, ""ERC721: approve to caller"");
        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function isApprovedForAll(address owner, address operator) public view override returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        require(ownerOf(tokenId) == from, ""ERC721: transfer of token that is not own"");
        require(to != address(0), ""ERC721: transfer to the zero address"");

        _beforeTokenTransfer(from, to, tokenId);

        _approve(address(0), tokenId);

        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(from, to, tokenId);
    }

    function _approve(address to, uint256 tokenId) internal {
        _tokenApprovals[tokenId] = to;
        emit Approval(ownerOf(tokenId), to, tokenId);
    }

    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) internal returns (bool) {
        if (isContract(to)) {
            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data) returns (bytes4 retval) {
                return retval == IERC721Receiver.onERC721Received.selector;
            } catch (bytes memory reason) {
                if (reason.length == 0) {
                    revert(""ERC721: transfer to non ERC721Receiver implementer"");
                } else {
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        } else {
            return true;
        }
    }

    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return _owners[tokenId] != address(0);
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal {
        // Optional hook for token transfer
    }
}

interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}",contract_247.sol
"Create a token-based smart contract that allows for token transfer, approval, and balance inquiry. Implement functions for token transfer, approval, and total supply. Utilize the SafeMath library for secure arithmetic operations. Incorporate event triggers for token transfer and approval. Consider the smart contract code provided and modify it to fit your requirements.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, ""Insufficient balance"");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(value <= balanceOf[from], ""Insufficient balance"");
        require(value <= allowance[from][msg.sender], ""Allowance exceeded"");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }
}",contract_248.sol
"Develop a smart contract that enables market positioning, funding rate management, and liquidator control. The contract should include functions to settle funding for traders, set default fee receivers, and update index price oracles. Implement pausability and reentrancy protection. Use upgradeable contracts from OpenZeppelin to ensure security and maintainability. Focus on providing a robust and secure foundation for managing market positions and funding rates.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";

contract MarketPositioning is Initializable, PausableUpgradeable, ReentrancyGuardUpgradeable, OwnableUpgradeable {
    struct Trader {
        uint256 position;
        uint256 lastFundingTime;
    }

    mapping(address => Trader) public traders;
    address public defaultFeeReceiver;
    uint256 public fundingRate;
    uint256 public indexPrice;

    event FundingSettled(address indexed trader, uint256 amount);
    event DefaultFeeReceiverUpdated(address indexed newReceiver);
    event IndexPriceUpdated(uint256 newPrice);

    function initialize(address _defaultFeeReceiver, uint256 _fundingRate, uint256 _indexPrice) public initializer {
        __Pausable_init();
        __ReentrancyGuard_init();
        __Ownable_init();
        defaultFeeReceiver = _defaultFeeReceiver;
        fundingRate = _fundingRate;
        indexPrice = _indexPrice;
    }

    function pause() public onlyOwner {
        _pause();
    }

    function unpause() public onlyOwner {
        _unpause();
    }

    function settleFunding(address trader) public whenNotPaused nonReentrant {
        Trader storage traderInfo = traders[trader];
        uint256 timeSinceLastFunding = block.timestamp - traderInfo.lastFundingTime;
        uint256 fundingAmount = traderInfo.position * fundingRate * timeSinceLastFunding;
        traderInfo.lastFundingTime = block.timestamp;
        emit FundingSettled(trader, fundingAmount);
    }

    function setDefaultFeeReceiver(address newReceiver) public onlyOwner {
        defaultFeeReceiver = newReceiver;
        emit DefaultFeeReceiverUpdated(newReceiver);
    }

    function updateIndexPrice(uint256 newPrice) public onlyOwner {
        indexPrice = newPrice;
        emit IndexPriceUpdated(newPrice);
    }

    function updateFundingRate(uint256 newRate) public onlyOwner {
        fundingRate = newRate;
    }
}",contract_249.sol
"Create a smart contract that follows the ERC20 token standard, allowing for token transfers, approvals, and allowance management. Use the SafeMath library for mathematical operations. Implement data structures to track token balances, ownership, and allowance details within the contract. Focus on ensuring the functionality and security of the contract.","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    mapping(address => uint256) private balances;
    mapping(address => mapping(address => uint256)) private allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(
        string memory _name,
        string memory _symbol,
        uint8 _decimals,
        uint256 _totalSupply
    ) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply;
        balances[msg.sender] = _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    function transfer(address to, uint256 value) public returns (bool) {
        require(balances[msg.sender] >= value, ""Insufficient balance"");
        balances[msg.sender] -= value;
        balances[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool) {
        allowances[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        require(balances[from] >= value, ""Insufficient balance"");
        require(allowances[from][msg.sender] >= value, ""Allowance too low"");
        balances[from] -= value;
        balances[to] += value;
        allowances[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return allowances[owner][spender];
    }
}",contract_250.sol
